1. Hello。 大家好。 欢迎观看SSTM32入门教程。 从本节开始。 我们将一起学习SSTM32。 那在本科视频之前呢。 我已经发布过一套五一单片机的入门教程。 SSTM32相比较无聊。 单片机还是有一定的难度的。 所以如果你是完全没有接触过这方面。 技术的同学。 那我推荐你先去看一下五一单片机的入门教程。 这样学习SSTM32会简单一些。 在本科视频里。 为了方便大家理解。 我可能经常会拿五牙单片机来举例比较。 所以如果你有五幺单片机的基础。 那就再好不过了。 好那我们就正式开始本课程的学习。 首先看一下课程简介。 第一条是程序成熟的手把手教学。 在本套视频中。 除了一些比较固定的代码。 比如延时函数。 显示屏函数等。 我会直接提供给大家。 其他的关键部分代码我都会亲自给大家敲出来。 一步步的演示过程是如何建立的。 程序是如何调试的。 根据我自己学习时候的体会了。 手打代码的教程和对着现成的代码讲的教程。 学习的感受差别会很大。 如果你只是对着线程代码讲的话。 那我听完后仍然不知道从哪里下手是吧。 但是如果是一步步演示的话。 那我至少可以把程序现象做出来。 最终对每一步的意义都会有着更加深刻的理解。 所以虽然SSTM32的代码会比较多。 我还是会坚持把它们都手打出来。 争取给大家提供一个最好的学习效果。 那第二条呢就是SSTM32。 最小系统板和面包板的硬件平台。 在本套视频中。 我们的硬件平台就像这个图片所示的一样。 我们将SSTM32最小系统板插在面包板上。 作为基本的硬件单元。 下面插上一块0.96寸的OLED。 作为调试和显示的屏幕。 那看过我五幺单片机教程的同学们应该都知道。 我对中枢显示屏还是情有独钟的。 在调试程序时。 我们可以把程序中的变量显示在这个屏幕上。 这样调试起来就会比较方便。 那针对这个显示屏呢。 我同样也会和五牙单片机的那个一样。 给大家提供一个现成的程序哈。 调用方法和参数。 定义和五元单片机的那个也是完全一致的。 这样可以方便大家快速入门这个显示屏。 那右边的st link是插在电脑上。 用于下载程序和供电的。 led按键呢插在最小系统板的两侧。 其他的一些模块。 比如这个是蜂鸣器模块。 则是用杜邦线来连接的。 带插针的模块则会跨接在面包板的中间。 然后再进行连线。 使用面包板能够完成任意电路的连接。 连线和修改都是非常方便的。 相比较成品的开发板方式呢。 使用面包板更有利于我们对硬件电路的学习。 而且也可以避免开发板的一些问题。 比如啊引脚冲突。 引脚无法更改的。 当然使用面包板也会带来一些问题。 比如你程序现象不出来。 不仅可能是你程序的问题。 也有可能是接线的问题啊。 这就需要我们在连线的时候要更加细心一些。 关注软件程序的同时。 也需要关注一下硬件电路啊。 但大家不要过于担心。 因为我们本次课程的硬件。 都会使用一些小模块来连线。 整体上来说硬件电路还是非常简单的。 接下来我们来看一下。 本套课程所需要的硬件设备。 首先是SSTM32面包板入门套件。 套件里的东西就是这个图片显示的这些哈。 这个套件里的东西不是很多。 但是作为SSTM32的入门套件。 是完全没有问题的。 这个套件的获取方式呢。 我会放在视频下方的简介里。 大家可以看一下哈。 第二个设备就是windows电脑。 这个相信大家学习SM32的话。 应该都是有的。 那这个电脑呢尽量选择windows系统的。 因为我们的编程软件。 还有一些小工具都是在windows平台的。 选择windows的电脑会方便一些。 最后呢就是再准备一些工具。 比如万用表。 示波器。 镊子剪刀等。 万用表可以很方便地检查电路的连接情况。 因为我们使用的是面包板搭建的电路。 可能会存在接错线或者接触不良的情况。 如果有个万用表。 就可以很方便的测试电路的连接情况。 示波器可以测出引脚的电压波形变化。 在PWM实践或者通信协议的时间能看到波形。 那对我们的调试程序将会有很大的帮助。 但是这个示波器还是比较贵的哈。 如果你财力有限的话。 也可以不准备示波器。 我们最终的现象都会在硬件电路上呈现。 没有示波器对最终的现象影响不大。 那下图这个是我目前正在使用的虚拟示波器。 这个可以插在电脑上。 在电脑屏幕上显示波形。 当然像实验室里的那种台式示波器。 或者逻辑分析仪也都是可以的。 能看波形就行了。 最后的镊子剪刀是方便我们面包板插线的。 也可以提前准备一下。 然后我们看一下软件设备。 本套教程学习SSTM32。 使用的是K5MDK这个软件。 K5MDK是用来给arm系列的单片机编程的。 之前学习五幺单片机用的软件是Q5C51。 Q5C51是用来给五幺系列的单片机编程的。 所以这两个软件是不一样的哈。 相当于KO软件的两个子系列。 所以如果你电脑上安装的是K5C51。 那这个是不能用来开发STM32的。 但是不用担心已经安装了C51的。 只需要再安装一个MDK即可。 如果你啥都没安装。 直接安装MDK也是没有问题的。 关于软件安装的部分。 我会在之后的课程再讲。 然后我们来大致的看一下。 我们这个套件的东西啊。 这一块呢就是我们的面包板。 其他的模块和导线。 都是插在面包板上完成连接的。 那这个面包板怎么用的。 我们到时候再讲。 然后左边这一盒是面包板专用的套件。 这种跳线比较短。 可以贴在面包板上插线。 比较适合长时间插线的情况。 那上面这一张呢是面包板的飞线。 这种线比较长。 也方便挪动。 比较适合经常挪动的接线情况。 下面这两排是杜邦线。 分别是公对母和母队母的。 可以用于插接一些电路模块。 那这个就是我们本次的主角。 SSTM32最小系统板了。 上面这个黑色的小芯片就是SSTM32。 我们主要就是学习这个小形态了。 然后右边这个是0.96寸的OLED显示屏模块。 用于显示参数和变量。 这个显示屏是一个四引脚版本的。 现在网上卖的有四引脚和七引脚的。 注意不要弄错了。 然后我们接着往下看。 这个蓝色的软件是定位器。 主要用来进行AD转换实验的。 下面这个是按键。 我选的这个按键是这种两引脚的小按键。 它可以正好跨接在面包板的。 引脚插孔和电源插孔之间连接。 非常方便简洁。 这边几个五颜六色的是led灯。 用来做点灯实验的。 那我争取让大家都成为点灯大师哈。 哈左边这个是s t link。 用来下载程序和供电的。 下面这个是USB转串口模块。 使用这个模块就可以使STM32。 和电脑进行串口通信了。 这个是有源蜂鸣器模块。 它是内置震荡圆的哈。 接上电就可以想。 相比较无源分频器模块。 需要不断翻转L口的操作方式。 那这个就方便多了。 基本和点灯一样简单。 那我们再看一下右边这四个模块。 这四个模块是一些传感器模块。 电路基本上是一致的。 那第一个是光敏电阻模块。 下面的四个引脚有两个是用来供电的。 还有两个是光敏电阻信号。 的模拟输出和数据输出。 这个可以用来进行IO读取实践或者AD实践。 第二个是热敏电阻模块。 也是有模拟输出和数据输出的。 第三个是对射式红外模块。 这个模块配合遮光片可以用来记次。 或者配合编码盘用来测速。 第四个是反射式红外模块。 这个做过从机车热应该清楚。 它可以向地面发射红外光。 然后再用红外接收管接收地面反射的红外光。 通过判断接收光的强度。 就可以大致的识别出地面的颜色变化了。 然后下面这个是W二五Q64flash存储模块。 它可以存储数据。 并且呢它是用SSPI总线进行通信的。 我们主要用它来学习SSPI通信。 这个是MPU6050陀螺仪和加速度计啊。 它可以测量芯片自身的姿态。 像四轴飞行器上。 一般都会配有陀螺仪和加速的机。 这个模块是IPHONEC总线通信的。 我们主要用它来学习IPHONEC通信。 右边这个是旋转编码器。 它可以输出两路正交的方波信号。 用于指示旋转的方向和速度。 SSTM32里面有专门的编码器。 电路可以很方便地识别这种信号。 那这个模块可以当做一个快速的按键来使用。 当然我的主要意图还是。 用它来模拟编码器的测速啊。 现在的编码电机一般都会配备。 霍尔传感器或者光电传感器。 这些传感器的输出和这种旋转编码器是一样的。 所以学习一下旋转编码器就可以了哈。 而且这种旋转编码器还比较方便的。 插在面包板上。 而且还比较便宜哈。 那下面这个是直流电机和tb6612电机。 驱动模块。 可以用来进行直流电机的PWM调速实验。 右边这个是SG90舵机。 它也是用PWM进行控制的。 它的输出端可以像船舵一样。 根据我们给定的PWM信号的占空比。 固定在某个角度上。 这个可以用来做一些机器人啊。 或者机械臂的关节。 那本节的课程简介就介绍到这里。 有关套件获取资料下载。 课程安排等其他信息呢。 请关注视频下方的简介。
2. 本小节我们来看一下htm 32的介绍。 第一条s t m324。 s t公司基于arm cortex杠m内核。 开发的32位微控制器。 那我们通过这个名字可以看出来。 s t的意思就是s t公司m就是微控制器。 mro control的首字母。 微控制器就是mcu。 就是我们常说的单片机。 所以sm 32也是一款单片机。 三二的意思是这是一款32位的单片机。 相比较八位的五一单片机。 s t m32 的性能还是非常强的。 当然s t也推出了有八位单片机。 叫s t m8。 这个大家也可以了解一下。 这个arm cortex杠m内核。 就是s t m32 内部的核心部分。 这个内核是arm公司设计的。 它在s t m32 中占据极为重要的地位。 比如我们程序指令的执行啊。 加减乘除的运算都是在内核里完成的。 它相当于整个芯片的cpu。 就像我们现在的电脑厂商一样。 可以拿着英特尔或者amd的cpu。 就可以推出自己品牌的电脑。 这个s t m32 也是一样。 s t公司拿着arm公司设计的内核。 整个封装起来就做成了s t m32。 当然也可以有其他的厂商。 拿着arm的内核来做他们自己的芯片。 那这些芯片都叫做基于arm内核的芯片。 那我们再看一下第二条。 sm 32常应用在嵌入式领域。 如智能车。 无人机。 机器人。 无线通信。 物联网。 工业控制娱乐产品带。 像这个智能车啊。 我们可以用s t m32 做一辆循迹小车。 读取光电传感器或者摄像头的数据。 然后驱动电机前进和转弯。 无人机呢。 我们可以用s t m32 读取陀螺仪。 然后根据控制算法去控制电机的速度。 从而保证飞机的稳定。 飞行机器人呢。 我们可以用s t m32 驱动舵机。 去控制机器人的关节。 然后让机器人运动无线通信。 这个我们可以给s t m32 连接上一些。 2.4g无线模块或者蓝牙wifi模块。 这样呀。 s t m32 就可以具备无线通信的能力。 物联网的话。 也可以借助这些无线模块来通信。 比如蓝牙wifi一个b这些。 再通过s t m32 驱动继电器。 来控制220伏电路的通断。 那工业控制的话。 我之前拆开过一个国产的p o c啊。 就发现它内部的主控就是一块s t m32。 那p l c这个东西。 一般都是工厂用来进行工业控制的对吧。 最后我们也可以用s t m32。 做一些娱乐电子产品。 像这个做个爱心流水灯啊。 那也是完全没问题的哈。 那第三点s t m32 功能强大。 性能优异。 片上资源丰富。 是一款经典的嵌入式微控制器啊。 像目前我们做一些需要单片机控制的东西。 一般都可以考虑一下htm 3 r。 接着我们再来看一下右边的这个s t m。 三二家族系列图。 这个标题写的就是s t m32 m c o m啊。 第二行就写了。 它是32位的arm cortex杠m内核的芯片。 目前s t m32 主要有四个系列。 分别是高性能系列。 主流系列。 超低功耗系列和无线系列。 对应的都有不同型号的产品。 比如高性能系列的就有s t m32。 f2 f4 f7 h7 这些。 下面有他们的性能介绍。 比如这个f2 系列就是398的call mark。 和120兆赫兹主频的cott杠m3 内核。 这个come mark就是一个内核。 跑分跑分越高。 性能越好。 cos杠m3 内核就是arm的其中一个内核芯片。 那我们可以看到右边这个s t m32。 h7 的芯片。 就是目前最强的s t m32 芯片。 拥有3224的内核跑分。 550兆赫兹的cortex杠m7 和。 240兆赫兹的cotx杠m4 的内核。 是一个双核微控制器啊。 那接着我们再来看一下主流系列。 那我们本次教程。 我们使用的就是s t m32。 f一的这个系列。 它是有177的内核跑分。 和72兆赫兹的cotx杠m3 内核。 那下面还有超低功耗系列。 比如l0 l1 l4 l5 等这些型号。 最后还有无线系列的s t m32。 像这个s t m32 w l和s t m32 wb。 大家可以了解一下。 那这些就是目前s t m。 三二家族中的所有系列了。 可以看出来这个系列还是比较全的。 如果你觉得性能不够。 如果你对功耗特别敏感呢。 如果你想做一个无线通信的产品。 可以了解一下无线的系列。 因为他们都是一个家族的。 也会比换别的芯片轻松很多啊。 接下来我们来看一下arm的介绍。 刚才我们说了。 s t m32 使用了arm cortex杠m内核。 那这个到底是怎样的内核呢。 arm公司还有哪些内核呢。 我们来看一下。 那首先这个arm是g值。 arm公司也指arm处理器内核。 arm公司是全球领先的半导体。 知识产权提供商。 知识产权提供商的意思就是。 这个arm公司是只涉及arm内核而不生产实物。 实际的内核是各大半导体厂商。 连同芯片一起制作出来的。 arm可以授权给各大厂商。 它的设计。 然后再收取授权费作为盈利方式。 这实际是一种开放合作。 利益共享。 风险共担的商业模式。 也正是这种方式。 使得arm公司获得了快速的发展。 那现在全球超过95%的智能手机。 和平板电脑都采用了arm的架构。 可以说arm的这种商业模式还是成功的。 当然我认为还有一个原因是。 这个arm设计的内核是真的不错。 那它设计的好。 大家才会和他合作对吧。 第三条是arm公司设计arm内核半导体厂商。 完善内核周边电路并生产芯片。 这个就比较好理解了对吧。 我们看到下面这个模块图就是这个意思。 这个蓝色部分是整个的s t m32 芯片。 内部处于cpu地位的。 就是arm公司设计的内核。 右边这些橙色的部分。 比如存储器。 还有一些片上的外设资源等。 如果s t觉得资源不够多。 这都是没问题的。 接着我们再来看一下arm的内核。 都有哪些型号。 从这个图里可以看出。 arm公司针对不同的应用场景。 也是生产了各种型号的内核。 那我们s t m32 使用的cott杠m内核。 也是其中一种。 先看一下这个蓝色的部分。 这些是arm公司以前生产的老版本内核了。 比如arm 7 arm 9 m 11。 我们把这些型号称为经典的arm处理器。 当然arm内核也是从arm 1 m2 等等。 这样发展过来的。 在arm 11之后。 arm可能觉得这样命名没意思了对吧。 当然实际应该是。 为了迎合时代的发展和市场的变化。 arm更改了命名方式。 推出了cortex系列的内核。 并且一下推出了三款子型号。 用于适用不同的场景。 它们分别是cotx杠a系列。 cott杠二系列和cott杠m系列。 你看这三个系列加起来。 正好构成了a arm 3个字母。 可见这个命名方式还是有讲究的哈。 那根据应用场景来看。 r系列和m系列适用于嵌入式领域。 而a系列则是适用于高端应用型的领域。 a系列就是application的意思。 a系列主要应用在手机领域。 像现在苹果的手机芯片。 高通的手机芯片。 联发科的手机芯片。 基本上都是采用arm内核架构的。 a系列。 也是arm内核中性能最高。 发展最快的系列。 现在a系列的型号推出的是非常多的。 远不止这个图片上的这几个型号。 大家有兴趣可以关注一下。 基于arm架构的m一芯片对吧。 就将这个arm架构推进到了电脑领域。 所以arm的发展趋势还是非常好的。 与a系列对比下来。 r系列和m系列的型号发展就比较慢了。 r系列就是real time的意思。 主要面向实时性很高的场景。 比如硬盘控制器这些东西。 这个r系列的应用场景应该还是比较小的。 r系列的内核型号也不是很多。 最后一个就是m系列的。 m系列就是micro control的意思。 主要应用在单片机领域。 像我们的s t m32。 使用的就是m系列的内核。 它的型号也有m0。 m1 m3。 m4 这些不同型号的内核性能也是不同的。 之前的这个图片就可以看到。 s t m32 f1。 使用的是cott跟m3 的内核。 还有s t m32 f0。 使用的是cortex跟m0 的内核。 s t m32 f3。 使用的是cortex杠m4 的内核。 还有这些使用了m3 m4 m7 的内核。 那看到这里。 这个基于arm cortex杠m内核的s t m32。 是什么意思。 相信大家应该都清楚了吧。 然后我们就来看一下。 我们本套课程使用的htm 32。 我们使用的是s t m32 f103。 c8 t6。 这个型号的s t m32。 就是右图的这个样子。 根据它的型号名称。 再对照前面的介绍。 我们就已经知道了。 它的系列是主流系列s t m32 f1。 它的内核是arm cortex杠m3。 主频是72兆赫兹。 它的ram大小是20k。 rom大小是64k。 这里的ram就是运行内存。 实际的存储介质是sram。 这里的room就是程序存储器啊。 实际的存储介质是flash闪存。 它的供电电压是二点到3.6伏。 标准是3.3伏供电。 这个需要注意一下。 我们以前学的五一单片机。 使用的是5伏供电。 还有usb输出的电压也是5伏。 5伏是不在这个供电电压范围内的。 不能直接给s tm 32供电。 如果是5伏电压。 那需要加一个稳压芯片。 把电压降到3.3伏。 再给sm 30供电。 它的分装是l q f p48。 也就是图片这种比较小的分装。 总共有48个音标。 这个如果你自己画板子的话。 需要了解一下它的分装啊。 接下来我们再来看一下。 这款芯片的片上资源。 这个片上资源又叫做外设。 英文是peripheral。 以后看到这个单词一般就指这些东西啊。 那下面这个表里就是s t m32 f。 一系列的外设资源。 通过程序配置外设来完成我们想要的功能。 在这个表中。 前两个深颜色的是位于cortex杠m3。 内核里面的外设。 剩下的都是内核y的外设。 接下来我们就来一一的看一下。 这些外设都是干啥的。 我接下来介绍的这些东西。 大家有个印象就可以了。 以后我们还会经常和这些东西打交道。 所以现在只是一个界面介绍。 里面可能会存在很多的专业名词。 那听不懂也没关系。 我们之后还会慢慢的来理解这些东西的。 首先是nvc嵌套向量中断控制器。 这个是内核里面用于管理中断的设备。 比如配置中断优先级这些东西。 接着是cs系统第一大电池系。 这个是内核里面的一个定时器。 主要用来给操作系统提供定时服务的。 这个s t m32 是可以加入操作系统的。 比如free rt o s u cos等。 如果用了这些操作系统。 就需要sixt。 提供定时来进行任务切换的功能。 当然我们本课程是不需要操作系统的。 我们可以用这个定时器。 来完成d类函数的功能。 下面的r c c是复位和时钟控制。 这个可以对系统的时钟进行配置。 还有就是使人各模块的时钟。 在s t m32 中。 其他的这些外设在上电的情况下。 默认是没有时钟的。 不给时钟的情况下操作外设是无效的。 外设也不会工作。 这样的目的是降低功耗。 所以在操作外设之前。 必须要先死人它的时钟。 这就需要我们用rc c来完成时钟的使人。 然后g p i o就是通用的l口。 我们可以用g p i o来点灯读取软件等。 这也是一个单片机最基本的功能了哈。 a f l o是复用io口。 它可以完成复用功能端口的重定义。 还有中断端口的配置。 ex t i s外部中断。 配置好外部中断后。 当银角有电瓶变化时。 就可以触发中断。 让cpu来处理任务。 t i m是定时器。 这也是整个s t m32 最常用。 功能最多的外设。 tm分为高级定时器。 通用定时器。 基本定时器三种类型。 其中高级定时器最为复杂。 常用的是通用定时器。 这个定时器不仅可以完成定时中断的任务。 还可以完成测频率。 生成pwm波形。 配置成专用的编码器接口等功能。 像pw波形就是我们电机驱动。 舵机驱动最基本的要求了。 adc是魔术转换器。 这个htm 3还内置了12位的ad转换器。 可以直接读取io口的模拟电压值。 无需外部连接ag芯片使用非常方便。 dma是直接内存访问。 这个可以帮助cpu完成搬运大量数据。 这样的繁杂任务。 u s a r t是同步或异步串口。 我们平时用的ua 2 t是异步串口的意思。 这里的u s a r t是既支持异步串口。 也支持同步串口。 当然我们实际还是用异步串口比较多哈。 下面的fc和spi。 是非常常用的两种通信协议。 s t m32 也内置了他们的控制器。 可以用硬件来输出时序波形。 使用起来更高效。 当然用通用l口来模拟时序模型。 也是没有问题的。 接下来看和usb也都是通讯协议。 看通信一般用于汽车领域。 usb我就不用多说了吧。 生活中到处都是usb设备。 利用这个s t m32 的usb外设。 可以做一个模拟鼠标。 模拟u盘等设备。 rtc是实时时钟。 在htm 3内部完成年月日时分秒的计时功能。 而且可以接外部备用电池。 即使掉电也能正常运行。 下面的cr c校验是一种数据的校验方式。 用于判断数据的正确性。 有了这个外设的支持。 进行cr c校验就会更加方便一些。 p w r电源控制。 可以让芯片进入睡眠模式等状态。 来达到省电的目的啊。 b k p备份寄存器。 这是一段存储器。 当系统掉电时。 仍可有备用电池保持数据。 这个根据需要可以完成一些特殊功能。 看门狗。 当单片机因为电池干扰死机。 或者程序设计不合理。 出现死循环时。 看门狗可以及时复位芯片。 保证系统的稳定。 d a c是数模转换器。 它可以在io口直接输出模拟电压。 是adc模数转换的逆过程。 s d l o是sd卡接口。 可以用来读取sd卡。 fs mc是可变静态存储控制器。 可以用于扩展内存啊。 或者配置成其他总线协议。 用于某些硬件的操作。 usb otg就是usb主机接口。 用otg功能。 可以让s t m32 作为usb主机。 去读取其他usb设备。 那以上就是s t m32 f一系列。 所有外设的大致介绍了。 我们之后的课程中。 经常会和这些字母缩写打交道。 所以大家提前要熟悉一下这些字母的意思。 至于具体的功能。 我们之后的课程会慢慢介绍。 另外还要注意一下。 这是s t m32 f一整个系列的所有外设。 并不是所有型号都拥。 有全部的wifi。 比如我们这款c8 t6 的芯片。 就没有后面这四个外设。 那具体有哪些外设。 每个外设有几个呢。 我们还要看一下对应的数据手册。 比如我们打开这个c8 t6 的数据手册。 翻一下这个外设资源表。 看到这个s t m32 f103 x。 这一点可以看到这个c8 t6。 是64g的闪存。 20k的sram有三个通用定时器。 一个高级定时器。 没有基本定时器啊。 两个sp i。 两个fc。 三个u s a r t。 一个usb。 一个can总线。 37个l口。 两个十通道的12位a d c。 那在这个表里没有出现的外设。 你就要确认一下它是不是存在。 要是操作了不存在的外设。 那他是不会工作的。 接着我们来看一下这个芯片的命名规则。 看一下这个型号的每一位字母和数字。 代表的意义啊。 在这里呢。 s t m32 代表的是基于arm核心的。 32位微控制器。 f代表的是通用类型。 103代表的是增强型。 当然也还有基本型。 usb型和互联型的一些型号。 c代表它的引脚数目是48。 其他的还有36角。 64角。 100角和144角的一些型号。 一般来说银角越多。 它的外设就会越多。 这个八代表它的flash闪存的容量是64k。 还有其他的一些容量。 大家可以看一下。 这个t代表它的封装类型是l q f p的。 六。 代表的是温度范围。 为-40~85摄氏度。 那这些就是这个s t m32 的命名规则。 现在还有一种比较常用的型号。 叫s t m32 f1032 c t6。 那对照这个表就可以知道。 这个r c t6 的芯片是64角。 256k的flash。 l q f p封装-40~85摄氏度。 这样的参数以后。 看到其他型号的s t m32。 也都可以对照这个命名规则。 了解它的大致参数啊。 然后我们来看一下这个芯片的系统结构。 这个结构看起来比较复杂。 现在这个阶段不需要每个部分都弄懂。 大致的了解一下即可了解这个系统结构。 有利于你加深对s t m32 的认识。 那我们来看一下。 我们可以把这个图分为四个部分。 像这样。 那左上角的这个就是cott和m3 的内核。 内核引出来了三条总线。 分别是echo的指令中线。 d扣的数据总线。 system系统总线。 这个eq的中线和d扣的总线。 主要是用来连接flash闪存的。 flash里面存储的就是我们编写的程序啊。 iq的指令总线就是用来加载程序指令的。 低扣的数据总线是用来加载数据的。 比如常量和调试参数。 这些除了echo的总线和dq的总线。 内核还引出了system系统总线。 system总线就连接到了这些其他的东西上面。 比如ram用于存储程序运行时的变量数据。 还有fmc这个本课程的芯片不会用的。 下面这个a h b系统总监。 就是用于挂载主要的外设的。 a h b的意思是先进高性能中线。 挂载的。 一般是最基本的或者性能比较高的外设。 比如复位和时钟控制这些最基本的电路。 还有sdl也是挂载在a e g b上的。 再后来就是两个桥接。 接到了a b2 和a b12 个外设总线上。 这个a p p的意思是先进外设中线。 用于连接一般的外设。 因为a b和a b的总线协议总线速度。 还有数据传送格式的差异。 所以中间需要加两个桥接。 来完成数据的转换和缓存啊。 a hb的整体性能比ap高一些。 其中这个a p p2 的性能又比a b1。 高一些。 a p p21 般是和a hb同频率的。 都是72兆赫兹。 a p b11 般是36兆赫兹。 所以a b2 连接的都是一些外设中。 稍微重要的部分。 比如gpl端口。 还有一些外设的1号选手的。 比如u s a t e s p i e t m e t m8。 这个tm 8和tm 11样。 也是高级定时器啊。 所以也是重要的。 外设。 还有a d c e x t i a f l o。 也是接在a p p2 上面的。 那其他的像这些2345号的外设。 还有d a c p w r b k b的。 这些是次要一点的。 外设都会分。 配到a p p e上去。 当然在使用的时候。 个人一般感觉不到a b2 和a1。 b一的形成差异啊。 只需要知道这个外设。 是挂载到哪个总线上的就可以了。 那右下角的这一大部分。 主要介绍的就是我们外设种类和分布啊。 剩下最后左下角的这一部分就是dma的。 这个dma可以把它当做内核cpu的小秘书啊。 比如有一些大量的数据搬运的活儿。 让cpu来干的话就太浪费时间了。 比如我有个外孙a d c魔术转换吧。 这个模式转换可以配置成连续模式。 比如1ms转换一次。 转换完的数据必须得转运出。 来。 否则数据就会被覆盖而丢失。 如果直接让cpu来干这活。 那cpu每过1ms就得来转运一下数据。 这样会费时费力。 影响cpu的正常工作。 而且这个活就是简单的数据搬运对吧。 也没必要cpu来干这活。 于是dma这个小秘书就出现了。 它主要就是干这些。 像数据搬运这样简单且反复要干的事情。 那dma通过dma总线连接到总线矩阵上。 它可以拥有和cpu一样的总线控制权。 用于访问这些外设小弟啊。 当需要dma搬运数据时。 外设小弟就会通过请求线发送dma请求。 然后dma就会获得总线控制权。 访问并转运数。 据整个过程不需要cpu的参与。 省下来cpu的时间来干其他的事情。 那这就是dm的用途。 到这里。 我们整个系统结构图就已经大概清楚了。 接着我们再来看一下这个芯片的引脚定义。 银角定义对于我们使用这个芯片而言。 还是非常重要的。 一般我们拿到一个新的芯片时。 需要着重的看一下它的引脚定义。 有的时候这个芯片的引脚定义看完了。 我们就可以大概知道。 这个芯片是怎么使用的了。 那这个就是我给大家做的s t m32。 f103 c8 t6 的引脚定义表。 经常用到这个表。 大家可以把这个图片存下来。 方便以后查看。 那我们来看一下。 这个芯片的引脚都是干啥用的。 这个就是c8 t6。 这个芯片的引脚序号和引脚名称的示意图。 在左上角有个小黑点。 代表它左边的引脚是1号引脚。 然后逆时针依次排列。 直到48号引脚。 下面这个表就是每个银角的名称和功能。 在这里我都做了颜色标记标。 红色的是电源相关的引脚标。 蓝色的是最小系统相关的引脚标。 绿色的是l口功能口。 这些引脚我们来依次看一下。 首先看一下表头。 前两列是引脚号和银角名称。 和上面的芯片引脚一一对应啊。 接着是类型还是代表电源。 i代表输入。 o代表输出。 io代表输入输出。 然后al口电瓶代表al口所能容忍的电压。 这里有f t的代表他能容忍5伏的电压。 没有f t的就只能容忍3.3伏的电压。 如果没有ft t需要接5伏的电瓶。 就需要加装电平转换电路了啊。 主功能就是上电后。 默认的功能一般和引脚名称相同。 如果不同的话。 银角的实际功能是主功能。 而不是引脚名称的功能哈。 默认复用功能。 就是l口上同时连接的外设功能引脚。 这个配置o口的时候。 可以选择是通用l口还是复用功能。 最后一个是从定义功能。 这个的作用是。 如果有两个功能同时复用在了一个l口上。 而你确实需要用到这两个功能。 那你可以把其中一个复用功能。 从映射的其他端口上。 当然前提是这个从定义功能的表里。 有对应的端口啊。 接着我们来依次看一下引脚定。 义第一个硬件是v b a t。 它是备用电池供电的硬件。 在这个鹰角可以接一个3伏的电池。 当系统电源断电时。 备用电池可以给内部的rtc。 时钟和备份计算器提供电源。 2号引脚是l口或者侵入检测。 或者rtc alle。 可以根据程序输出或读取高低电频哈。 是最基本也是最常用的功能的。 侵入检测可以用来做安全保障的功能。 比如你的产品安全性比较高。 可以在外壳加一些防拆的触点哈。 然后接上电路到这个引脚上。 若有人强行拆开设备。 那触点断开。 这个引脚的电平变化就会触发s t m32。 的侵入信号。 然后就会清空数据来保证安全。 rtc的引脚可以用来输出rtc校准时钟。 rtc闹钟脉冲或者秒脉冲哈。 34号引脚是l口。 或者接32点七六八千赫兹的rtc金证。 56号引脚接系统的主金正。 一般是八兆赫兹的。 然后芯片内有锁相环电路。 最终产生72兆赫兹的频率。 作为系统的主食。 中7号n i s t是系统复位引脚。 n代表它是地面平复位的。 vs s是负极。 接近d v dd是正极。 接3.3伏。 接着10号引脚到19号引脚都是l口哈。 其中p a0 还兼具了v k2 的功能。 这个可以用于唤醒处于待机模式的htm。 322 10号硬件是l口或者boot一硬件。 boot硬件是用来配置启动模式的。 这个我们等会儿再讲。 另外这个l口的引脚名称我没有加粗哈。 这个意思是。 没有加粗的口。 可能需要进行配置啊。 或者兼具其他功能。 使用的时候需要留意一下。 接着21 22号也都是l口。 23 24号的vs杠一和vd杠一。 是系统的主电源口。 同样。 的v s s是负极。 v dd是正极。 另外下面还有vs杠2v dd杠二。 vs杠3v dd杠三都是系统的主电源口。 这里s t m32。 内部采用了分区供电的方式。 所以供电口会比较多。 在使用时把vs s都接近d v dd。 都接3.3伏即可。 接着25~33号都是l口。 34号加上27号到40号。 这些是l口或者调试端口。 上面默认的主功能是调试端口啊。 调试端口就是用来调试程序和下载程序的。 这个s t m32。 支持s w d和g tag两种调试方式。 s w d需要两根线。 分别是s w d l o和s w c l k g tag。 需要五根线。 分别是g t m。 s g t c k。 g t d i g t d o n g t i s t。 我们教程使用的是s t link。 来下载调试程序的。 s t link用的是sw d的方式。 所以只需要占用p 13 p 14这两个io口。 在使用s w d的调试方式时。 剩下的pa 15 pb 3。 pb 4可以切换为普通的l口来使用。 但要在程序中进行配置。 不配置的话。 默认是不会用做l口的。 下面的41号到43号。 45~46号都是l口。 最后剩下的44号布特尼。 和刚才介绍的布特一一样。 也是用来做启动配置的。 那我这个表也是复制数据手册里面的。 在数据手册里也有引脚定义的表。 在这里哈。 下面还有一些注意事项。 大家可以看一下这个表。 把所有分钟的引脚定义都放在一起了。 看起来不太方便。 所以我就整理了这个标。 可以方便大家观看。 那有关io口的部分。 到这里就介绍完了。 然后我们来看一下s t m32 的启动配置。 也就是刚才我们看到的boot 0和boot 1。 两根引脚的功能。 这个启动配置的作用。 就是指定程序开始运行的位置哈。 一般情况下。 程序都是在flash程序存储器开始执行。 但是在某些情况下。 我们也可以让程序在别的地方开始执行。 用于完成特殊的功能。 那在这里我们。 看一下在s t m32 f10 叉叉叉里。 可以通过配置不t0 和boot 10件。 来选择三种不同的启动模式。 当布t0 引脚接零。 也就是接地的意思。 这个时候boot 1 gx就是无论接什么。 启动模式。 都是主闪存存储器的模式。 这时候主闪存存储器被选为启动区域。 也就是正常的执行flash闪存里面的程序。 这个模式是最常用的模式。 一般情况下都是这个配置哈。 那当bot一接零。 布特林接一阶一。 就是接到3.3伏电源正的意思。 那启动模式就是系统存储器。 说明是系统存储器被选为启动区域。 这个解释。 不太好理解啊。 其实这个模式就是用来做串口下载用的。 这个系统存储器。 存的就是s t m32 中一段bootloader程序。 bot loader程序的作用就是接收串口的数据。 然后刷新到主闪存中。 这样就可以使用串口下载程序了。 一般我们需要串口下载程序的时候。 会配置到这个模式上。 那什么时候我们需要用到串口下载呢。 我们可以看到这个菱角静音表。 刚才我们说了。 这五个是调试端口。 它们既可以用来下载程序。 也可以作为普通io口使用。 如果我们在程序中把这五个端口。 全部配置成了io口。 那这就坏了。 因为这个芯片没有调试端口了。 也就下载不了程序了。 所以在你配置这几个端口的时候。 要小心一点。 不要把它们全部都变成普通l口了。 那如果全部变成l口的。 下载不进去程序了。 这就需要用到串口的方式下载程序了。 如果想使用串口下的。 就需要配置boot一为零。 boot 0为一。 当然串口下载也不光是用来救急的哈。 如果你没有s t0 壳。 也没有机灵壳。 那就可以使用串口来进行下载程序。 这样就多了一种下载程序的方式。 那有关串口下载是如何操作的。 我之后会再讲。 然后就是boot一接一。 boot 0 j一的情况。 这时配置的是内置sram驱动。 这个模式主要是用来进行程序调试的。 现阶段用的比较少。 我们本套视频也不会用到最后。 下面还有一段话是在系统复位后。 system clock的第四个商城盐。 boot引脚的值将被锁定。 用户可以通过设置boot一和bot 0银角的状态。 来选择复位后的启动模式。 这个意思是。 boot引脚的值是在上电复位后的一瞬间有。 效的之后就随便了。 在这个引脚定义中。 我们可以看到这个bot一和pb 2。 是在同一个硬件上的。 也就是在上键的瞬间是boot一的功能。 当第四个时钟过之后。 就是p p2 的功能呢。 那这些就是有关部t引脚的部分。 看完了引脚定义和这个boot引脚的配置。 我们对这个芯片是怎么用的。 大概就有思路了。 那在这个表里。 如果我们想让sm 32正常工作。 那么首先就需要把电源部分。 和最小系统部分的电路连接好。 也就是这个表中标红色和蓝色的部分。 我刚才已经把这些引脚的功能和作用。 都介绍了。 那我们接下来就可以看一下s t m32。 最小系统电路了。 一般来说。 我们单片机只有一个芯片是无法工作的。 我们需要为它连接最基本的电路。 那这些最基本的电路就叫做最小系统电路。 我们来看一下这个电路。 右边这一部分。 就是s t m32 级供电的部分。 其中我们可以看到这三个分区供电的。 主电源和模拟部分电源都连接了供电引脚。 v s s都连接到基地。 v dd都连接了3v3。 也就是3.3伏啊。 在这个3.3伏和见地之间。 一般会连接一个滤波电容。 这个电容可以保证供电电压的稳定。 像我们在设计电路的时候。 一般只要遇到供电。 当然加这个滤波电容也是非常必要的哈。 大家自己设计电路的时候可以注意一下。 剩下还有一个vb at是接备用电池的。 如果需要接备用电池。 那就这样来接。 可以选择一个3伏的纽扣电池。 正极接vb a t。 负极接接d就行了。 备用电池是给rtc和备份计算器服务的。 如果不需要这些功能。 就不用接备用电池。 那这个v b a t直接接3.3伏即可。 或者悬空也是没有问题的。 这就是整个供电的部分。 可以说s t m32 的供电还是比较多的啊。 而且芯片四周都有供电引脚。 这个要是自己画板子的话。 就会深有体会啊。 这个供电实在是有点多。 走线还是很头疼的。 但是虽然头疼。 还是要把这些供电都接好啊。 接着我们再来看一下金正部分电路。 那这个就。 是一个典型的晶振电路。 在这里接了一个八兆赫兹的主时钟。 晶振还是tm 32的主金证。 一般都是八兆赫兹。 八兆赫兹。 经过内部锁相环倍频。 得到72兆赫兹的主频。 这个真正的两个引脚。 分别通过这两个网络标号。 连接到s t m32 的56号引脚。 另外还需要接两个20笔法的电容。 作为起征电容。 电容的另一端接地即可。 那这就是晶振电路。 如果你需要rtc功能的话。 还需要再接一个32.7。 六八千赫兹的晶振电路。 和这个一样。 接待34号引脚。 这个os c32 就是32.768。 千赫晶振的意思。 为什么要用32点七六八千赫兹呢。 因为32768是二的15次方。 内部rtc电路经过二的15次方分屏。 就可以生成一秒的时间信号了。 我们知道在计算机世界。 二的次方数是一个很神奇的数字。 还有很多数字都和二的次方有关。 接着我们再来看一下复位电路。 这个复位电路是一个10k的电阻。 和0.1微法的电容组成的。 它用来给单片机提供复位信号。 这中间的n i s t接在s t m。 三二的7号引脚。 n i s t是低电平复位的。 当这个复位电路在上电的瞬间。 电容是没有电的。 电源通过电阻开始向电容充电。 并且此时电容呈现的是短路状态。 那n i s t0 角就会产生低电平。 当电容逐渐充满电时。 电容就相当于断路。 此时n i s t就会被r一上拉为高电平。 那上电瞬间的波形就是先低电平。 然后逐渐高电平。 这个低电平就可以提供sm 32的上电。 复位信号。 当然电容充电还是非常快的。 所以在我们看来。 单片机就在上电的一瞬间复位的。 这就是复位电路的作用。 那电容左边还并联了一个按键。 这个可以提供一个手动复位的功能。 当我们按下按。 键时电容被放电。 并且n i s t引脚。 也通过按键被直接接地了。 这就相当于手动产生了低电平复位信号。 按键松手后。 n s t又回归高电平。 此时单片机就成复位状态。 转为工作状态。 平时我们也可以见到这种复位按键哈。 一般在设备上有个小孔。 当设备死机。 并且还不方便断电重启时。 我们就可以拿一个针。 戳一下这个小孔里的按键。 这样就会使设备复位了。 这就是手动复位的功能。 按下按键程序就从头开始运行的意思。 下面是这个启动配置。 这个h一相当于开关的作用波动。 这个开关就。 可以让boot引脚选择3.3伏还是接地了。 在我们这个最小系统板上。 使用的是这种跳线帽来充当开关的功能。 当跳线帽插在左边两个小时。 就相当于接地。 插在右边两个角色就相当于接3.3伏。 这样就可以配置boot的高低电平了。 当然你要自己设计电路的话。 接个拨码开关也是没问题的。 这样比插电线帽还方便一些。 那最后剩下的就是下载端口了。 如果你是用st link下载程序的话。 那需要把s w d l o和。 s w c l k这两个引脚引出来。 方便接线。 另外再把3.3符合接地引出来。 这个接力是必须引出来的。 3.3伏如果你板子自己有供电的话。 可以不硬。 不过建议还是都引出来。 这样方便一些。 那这些就是有关最小系统电路的内容了。 如果。 你自己画板子的话。 可以参考一下这个电路。 当然如果你是用s t m32。 最小系统板来设计电路的话。 就不需要这个最小系统了。 因为这个最小系统板。 那我们再看一下我提供的资料文件夹。 在这个资料模块。 第一个文件夹里面的这个核心板原理图。 就是我们这个最小系统板的原理图。 我们来看一下这个最小系统。 和我给的那个最小系统有哪些不同呢。 可以看到它这个最小系统的东西。 比我给的那个要多一些啊。 我们来依次看一下。 第一个是复位电路和我给。 的是一致的。 第二个是bot配置电路也是一样的。 第三个他在这里接了两个测试的l e d。 一个直接接到了v cc 3 v3 和gd。 这个是电源指示灯啊。 另一个接到了pc 13。 这是一个l口的测试灯。 接着第四个的下载电路也是一样的。 它在这个供电也加了一个电源滤波函。 这个作用也是稳定供电的。 然后这个是一个稳压芯片。 用于给5伏的电降到3.3伏。 给s t m32 供电。 它左边的输入是这个u s b的5伏电源。 右边输出的是3.3伏。 这个芯片没有给型号啊。 我根据它的外形和银角推。 测这个芯片的型号应该是xc 6204。 x c6204。 是一个3.3伏的稳压芯片。 另外还有xc 6206 m s1117 等。 这些都是常用的稳压芯片。 大家设计电路的时候可以参考一下。 那这两排就是银角的排针了。 这两个牌真把芯片的引脚都引出来。 方便我们接线的。 中间这个大的是s t f32 f103。 c8 t6 的芯片。 右上角和左下角是四个。 s t m32 供电的滤波电容。 左边这个是usb的接口。 它接的p一和p b a 12。 是s t m32 的usb硬件。 可以进行usb通信。 另外这个usb还可以。 提供5伏的供电。 这个电经过我们刚才介绍的这个稳压芯片。 降到3.3伏。 剩下的这些电路都是3.3伏的供电。 最后就是这两个晶振电路啊。 这个晶振电路和我给的基本是一样的。 上面这一部分是32.7。 六八千赫兹的晶振。 接到了s t m32 的pc 14和pc 15。 这俩硬件就是o s c32 的那两个硬件。 这里名字有点不一样。 但是是一个地方。 下面这一部分是八兆赫兹的主时钟。 晶振接的是s t m32 的osc这两个引脚。 那在这里多了一个一兆的电阻。 这个电阻也是有一些作用。 的哈。 不过也可以不解。 影响不大。 大家感兴趣的话可以了解一下。 最后我们再看一下。 这个最小系统板的实物图。 大概的认识一下板子上的软件。 那这个中间的黑色小芯片。 就是s t m32 f103 c8 t6。 左边这两个跳线帽是用来配置不同引脚的。 下面这个是负向键。 在左边是这个usb接口。 它可以进行usb通信。 也可以为板子供电。 右边这个金属外壳的。 是八兆赫兹的主时钟晶振。 这个黑色的是32.76。 8000Hz的rtc竞争。 然后在右边是两个led上面。 这个是p w2 电源指示灯。 下面这。 个是接在pc 13口的测试等。 最右边是s w d的调试接口。 用来下载程序的上下两排。 适用于接线的排针啊。 然后看一下背面这个五个角的小芯片。 就是3.3伏稳压芯片。 剩下的这些就是电容电阻这些小软件了啊。 那介绍到这里。 大家对这个最小系统板应该都了解了吧。 那有关s t m32 的介绍到这里就结束了。 本节我们把s t m32 的基本情况啊。 arm内核参数。 外设命名规则。 系统结构引脚定义。 启动配置。 最小系统都介绍了。 这些就是有关于s t m32 最基本的介绍。 如果想要继续。 深入了解htm 32。 可以看一下我提供资料里的这些文档啊。 这些文档是官方提供的最详细的介绍了。 想要学好s t m32。 看好这些文档也是必须的啊。 那本节的s t m32 介绍就到这里。 我们下节再见。
3. hello。 大家好。 欢迎继续观看s t m32 入门教程。 本小节我们主要的任务是软件安装二。 主要有以下几个步骤。 分别是安装k5 mdk软件。 安装器件知识包。 软件注册安装st link驱动和安装usb转串口驱动。 首先大家可以在视频下方的简介找到软件的下载链接。 下载之后就可以得到k5 mdk的安装包了。 在这里是一个压缩包。 我们先右键点击解压到k5 mdk这个选项。 那这里需要解压密码。 这个是我为了防止分享链接被网盘和谐设置的密码。 大家见到有密码的压缩包。 就在这个压缩包旁边找一下。 我会把写有密码的文档放在旁边的。 那这个密码是三二。 我们输入三二。 点击确定。 解压完成后得到了q5 mgk的文件夹。 我们点进去接着双击mdk 524这个ex e文件。 开始安装软件。 这里点next。 然后勾上同意许可协议的勾next。 在这里需要选择安装目录。 默认是c盘。 如果你觉得c盘没问题的话。 可以直接next的。 那我们也可以更改安装目录。 点击右边的浏览按钮。 选择d盘。 那在这里如果你之前已经安装了k5 c51 的话。 可以直接选择c51 的安装目录安装。 这样两个软件就可以共存了。 如果你之前没有安装过qq软件。 那在这里一定要新建一个目录啊。 最好在根目录下右键新建文件夹名字可以起q5。 这个名字和文件路径都不要带有特殊字符或者中文的名称啊。 因。 为这是国外的软件对中文的支持不好。 起中文名字可能会导致各种问题啊。 建好文件夹后。 选择这个文件夹即可。 那我这里因为之前安装过c51 的版本。 所以我就直接选择之前建的文件夹了。 选好文件夹之后。 下面的pc路径也会自动变化。 那我们直接next这个页面是一些个人信息。 大家随便填即可。 然后lex的接下来软件就开始安装了。 这个时间比较久。 大家耐心等待一会儿。 一般这里应该会弹出个窗口。 提示是否要安装unlink的驱动哈。 这个unlink是q公司开发的调制器。 我们点四就行了。 到这里软件安装就已经完成了。 这里有个显示发布说明文档的勾。 我们把它去掉。 就不看发布文档了。 然后点击非利息。 接下来就会自动弹出一个pack installer的窗口。 这个窗口就是用来安装器件支持包的。 我们先把它擦掉。 这个等会儿再讲啊。 然后我们就进入本视频的第二步了。 安装器件支持包。 首先我来介绍一下为什么需要安装器件支持包哈。 这个支持包是k5 才需要安装的。 像k4 和之前的老版本是不需要安装的。 这是因为现在的arm的芯片型号是非常多的。 升级换代的速度也快。 新型号的芯片也是不断的推出来。 那qq软件总不能出一款芯片就升级一下软件吧。 而且同时支持所有型号的芯片。 这个占用内存也是非常大的。 所以k5 之后芯片的器件支持包就被独立出来了。 我们开发哪种芯片就安装对应的支持包就行了。 如果你不安装支持包。 那在新建工程时是不会出现相应的器件型号的。 那我们来试一下。 我们打开qq软件。 然后新建一个工程。 随便起个名字哈。 可以看到在这里是只有arm一个器件列表的。 而且这里面没有s t m32 的型号。 这就是没有安装s t m327 件支持包的情况。 另外再说明一下。 我们现在安装的时候选的是c51 的安装目录。 现在这个软件就是c51 和mdk共存的情况。 如果你想切换为c51。 只需要在这个下拉列表选择legacy device这一项即可。 那这些就是五一单片机的型号。 如果你只按多了mdk。 那这个下拉列表是不能选择好。 介绍完了支持包的用途。 那我们就来安装一下s t m32 的支持包吧。 在这里有两种安装方式。 一种是离线安装。 一种是在线安装。 我们先介绍一下离线安装。 那我们打开k5 mdk的安装包文件夹。 打开知识包文件夹。 在这里我已经提前为大家准备了常见的知识包。 那我们本课程使用的是s t m32 f一系列。 我们就需要选择这个q.s t m32 f一叉叉杠df p的文件啊。 然后双击这里的目标路径。 会自动选择我们安装时的那个目录。 直接点击lex的即可。 等待一小会儿。 现在就安装完了。 然后我们点击finish。 接下来我们再打开k5。 新建一个工程看看。 在这里就出现了s t m32 f一的七点列表。 展开之后。 我们可以选择f103。 然后f103 c8。 这样就可以建工程了。 那到这里我们离线安装器件支持包的方式就介绍完了。 接着我再给大家拓展的讲一下在线安装的方式。 这个是拓展的部分哈。 主要是防止你们之后开发其他芯片。 找不到型号。 大家先了解一下。 现在先看我操作就行了。 因为在这个安装包里。 我只提供了部分的器件支持包。 所以如果你以后想开发其他芯片。 比如啊s t m32 f2 的系列或者其他公司的arm芯片。 那到时候找个器件支持包不就尴尬了吗。 那怎么办呢。 这时我们可以用到在线安装的方式了。 我们回到ko软件。 点击这个绿色的按钮。 弹出的就是我们之前擦掉的那个pack installer界面。 那这个就可以用来安装支持包。 并且所有可以用q软件来开发的芯片都可以找到。 使用还是非常方便的。 就是网速比较慢哈。 那进来这个页面之前需要给电脑连一下网。 然后进来之后它就会自动在q官网上获取最新的旗舰列表了。 下面这里提示的就是正在获取的东西。 右边有个进度条显示进度。 这个网速是挺慢的哈。 大家得多等一会儿。 如果你点进来没有自动获取的话。 可以点一下这个更新按钮。 这样就可以获取最新列表。 经过漫长的等待。 这个器件列表总算是加载完了哈。 可以看到这里有很多公司的名称里面包含了q支持的所有m芯片。 其中这个尴尬device的公司下就有目前做的还不错的。 国产兼容s t m32 的芯片。 叫gd 32。 里面有这个gd 32 f103 c8 的信号。 基本和s t m32 f103 c8 t6 的芯片一样哈。 还有下面这个mad motion公司里面有mm 32 f103 c8 t。 也是可以兼容s t m32 f103 c8 t6 的国产芯片哈。 现在s t m32 涨价比较厉害。 所以国产的这些芯片也取得了一定的发展。 大家以后可以了解一下哈。 接着往下滑。 下面这个s t mrc electronics里面就是sm 32的。 里面包含了现在s t m32 的所有型号。 其中就有我们刚才安装的s t m32 f一系列。 那比如我们以后想开发sm 32 f2 的系列。 我们就可以选择这个s t m3 f2。 然后在右边看到这个后缀是df p的文件。 然后点击install安装即可。 那接下来它就会自动在q的官网下载df并文件。 然后自动帮我们安装上。 当然你也可以用浏览器到这个网站上下载。 下载之后和离。 线安装的方式就是一样的了。 现在又是需要一段漫长的时间来下载哈。 那现在可以看到下面这里已经提示完成了。 我们拆掉这个窗口。 然后q会弹出个提示框。 说软件的知识包目录已经更改。 是否要重新加载支付包。 那我们点四。 然后在新建工程。 这时候我们就可以看到我们刚才选的s t m32 f2 的系列。 就出现在了列表中。 那这就是在线安装器件知识包的方法。 大家先有个印象。 以后需要用的时候可以再来看一下。 那接下来我们就开始进行第三步软件注册了。 这个q软件是一个付费软件。 如果不注册的话。 功能上会有很大的限制。 那我们个人用户学习的话。 用盗版问题也不大哈。 如果你是公司的话。 就要考虑一下这个软件的版权问题了。 那我们先关闭软件。 然后在k5 图标上右键选择以管理员身份运行。 这一步注意一下哈。 在这里必须要右键以管理员身份运行。 不能直接双击打开。 否则之后就会弹出窗口。 说你权限不够哈。 然后点击file nations management。 把这个cad复制下来。 接着打开安装包。 将这个k g的压缩包解压。 打开解压后的文件夹。 可以看到这个注册机啊。 如果你打开看不到这个文件。 可能是被杀毒软件杀掉了。 那你需要把杀毒软件关掉。 然后再重新解压。 得到这个注册机之后。 我们直接双击打开它。 然后把刚才复制的cad粘贴到这里。 右边的target要选择arm。 这个是用来注册mdk的。 如果你需要注册k c51。 就是选择c51。 最后点击generate生成序列码。 我们选中这个序列码复制下来。 然后就可以退出这个软件了哈。 接着把序列码粘贴到这个位置。 点击add l c下面提示lc添加成功。 并且上面mdk杠arm这一行的使用期限显示2032年。 那这就代表软件注册成功了。 我们可以使用到2032年。 如果你在点击add l c之后出现了这样的一个窗口。 那说明你没有以管理员身份运行。 然后我们关闭软件。 在注册完成后以后。 直接双击打开即可。 不需要再以管理员身份运行了。 接着我们再来安装一下ht link的驱动。 首先我们需要把x t link插到电脑上。 然后在此电脑上右键属性。 设备管理器。 打开这个设备管理器的窗口。 在这里可以看到这个s7 link是在其他设备的列表上。 并且图标带了个感叹号啊。 这就说明我们的电脑上目前是没有安装httk的驱动。 如果你插上httk。 在这个列表里找一下。 能找到s t link的设备。 并且没有感叹号。 那说明你电脑上已经装过s t link的驱动了。 就不需要再进行这一步了。 如果没安装的话。 我们需要安装一下驱动啊。 这个驱动程序q软件自带的就有。 我们可以打开k5 的安装目录。 在这个arm s link usb driver里面。 这个a m d64 点ex e就是64位的。 x86 就是32位的。 我这个电脑是64位的。 那我双击这个64即可。 然后点下一步。 点完成。 刚才我们就注意到这个设备管理器的列表刷新了一下。 在这里可以看到s t link已经没有感叹号了。 这就说明驱动已经安装成功了。 另外这个目录下还有jk的区段。 jk也是一种常用的调试器。 如果你想安装link驱动的话。 可以打开这里的sega文件夹。 那这里面就可以安装jdk的驱动了。 接着我们就可以进行最后一步安装usb转串口的驱动了。 同样我们先把usb转串口模块插到电脑上。 这个usb转串口的芯片是cg 340。 和之前五幺开发板上的一样。 所以如果你玩过五爻的话。 可能大概率已。 经装过了。 那我们看到设备管理器还是一样。 如果这也有感叹号。 就需要装一下驱动。 如果能正常识别。 就不需要装了。 cg 340的驱动在我提供的资料文件夹而已。 打开工具软件。 打开usb转串口c区340驱动。 双击这个exe的程序。 然后点击安装。 这里出现驱动安装成功就ok了。 同时我们也能看到这个设备管理器里面。 端口这个列表里出现了c区340这一项。 并且没有感叹号啊。 那这就说明这个驱动安装好了。 至此我们本小节的任务就全部完成了。 之后我们就可以用这些软件来开发htm 32。
4. 本小节我们来建立一个s t m32 的工程。 这个s t m32 的工程。 结构还是比较复杂的。 需要用到很多文件之后。 我们的代码也都是需要。 建立在工程结构上的。 所以在开始学习后续内容之前。 我们先来学习一下。 如何新建s t m32 的工程。 目前sm 32的开发方式主要有。 基于寄存器的方式。 基于标准库。 也就是库函数的方式。 和基于h a l库的方式。 基于寄存器的方式。 和我们五一单片机的开发方式一样。 是用程序直接配置寄存器。 来达到我们想要的功能。 这种方式最底层最直接效率会更高一些。 但是由于sm 12的结构复杂。 寄存器太多。 所以基于寄存器的方式目前是不推荐的。 基于库函数的方式是使用ht官方提供的。 封装好的函数。 通过调用这些函数来间接的配置计算器。 由于s t对寄存器分装的比较好。 所以这种方式既能满足对寄存器的配置。 对开发人员也比较友好啊。 有利于提高开发效率。 我们本课程使用的就是库函数的开发方式。 最后一个基于hl库的方式。 可以用图形化界面快速配置s t m32。 这个比较适合快速上手。 s t。 m32 的情况。 但是这种方式隐藏了底层逻辑。 如果你对s t m32 不熟悉。 基本只能停留在很浅的水平哈。 所以目前暂时不推荐hl库。 但是推荐你学过标准库之后。 去了解一下这个方式。 毕竟这个hl库还是非常方便的。 那使用库函数的方式。 我们需要准备一个s t m32。 库函数的压缩包。 大家可以在我提供的资料链接里。 找到固件库的文件。 然后可以看到s t m32 f10 x。 标准外设库。 这个压缩包我们先把它解压。 打开解压后的文件夹。 在这里就是库函数的文件夹目录了。 第一个文件夹里是两个图片。 这个没啥用啊。 第二个libraries里面就是库函数的文件了。 我们之后建工程时会用到。 第三个project是官方提供的工程示例和模板。 以后使用库函数的时候可以参考一下。 第四个utilities是htm。 三二官方评估版的相关例程。 这个评估板就是官方用s t m32 做的。 一个小电路板。 用来测评sm 32的这个文件夹。 里面存的就是这个小电路板的测评程序。 接下来后面两个文件。 一个是库函数的发布文档。 一个是使用手册发。 布文档里有一些版本的说明哈。 使用手册里有教怎么使用这个库函数的。 大家有时间可以看一下好。 那接下来我们就正式开始。 新建一个基于标准库的工程。 首先我们需要先建立一个。 存放工程的文件夹。 比如在d盘e盘等位置。 那我这里方便起见。 就在桌面新建了起个名字。 可以叫sm 32 project。 以后我们的工程都存在这个文件夹下。 这样比较方便管理。 接着我们打开q5 软件。 点击project new mvation project。 然后选择我们刚才新建的文件夹。 在这里要再新建一个文件夹。 用来存放本次的工程行。 起个名字叫二杠1s t m32 工程模板。 然后点进去。 接下来给工程文件起个名字。 在这里我们可以起一个通用一点的名字啊。 这个工程是干啥的。 我们可以在文件夹名称说明。 文件夹的名称是很方便改的。 这个工程名称以后不太方便改。 所以我们就起个project的名称。 然后点击保存。 接下来选择器件型号。 我们的芯片型号是s t m32 f。 103c8 t6。 所以这里选择s t m32 f103 c8。 这个点击ok。 这里弹出的是ko软件的一个。 新建工程小助手。 这个可以帮助我们快速新建工程。 那我们暂时不用这个小助手。 可以把它擦掉。 接下来工程就建好了。 但是这里的工程文件是空空如也哈。 现在这个工程还是不能直接用的。 我们需要给它添加一些工程的必要文件。 那我们打开固件库的文件夹。 打开libraries cm s s cm 3 device。 support s t s t m32 f10 x start up arm。 那这些就是s t m32 的启动文件。 s t m32 的程序。 就是从启动文件开始执行的。 我们把这些文件全部都复制下来。 然后回到工程模板文件夹里。 可以看到这些。 就是我们刚才新建工程自动生成的文件啊。 那如果直接把启动文件也放在这里。 就有点。 太乱了是吧。 所以我们需要新建一个文件夹。 可以叫做start。 然后把启动文件粘贴到这里面。 接着我们回到固件库的。 s t m32 f10 x文件夹。 可以看到s t m32 f10 x点去。 和两个system开头的文件。 这个s t m32 f10 x点距。 就是htm 32的外设寄存器描述文件。 它的作用就跟五一单片机的头文件。 i以及x52 点h一样。 是用来描述s t m32 有哪些寄存器。 和它对应的地址的。 这两个system文件主要是用来配置时钟的。 s t m32 主频72兆赫兹。 就是system文件里的函数配置的。 那我们把这三个文件复制下来。 也粘贴到start文件夹下。 接。 下来。 因为这个s t m32 是内核和内核。 外围的设备组成的。 而且这个内核的计算机描述。 和外围设备的描述文件不是在一起的。 所以我们还需要添加一个内核。 计算器的描述文件。 我们可以打开cm 3 cosport。 这两个cm 3文件就是内核的计算器描述。 当然他还带了一些内核的配置函数哈。 所以多了个点c文件。 我们把它俩一并复制下来。 也粘贴到data文件夹下。 到此为止。 我们工程的必要文件就复制完成了。 然后我们回到q软件。 把我们刚才复制的那些文件。 添加到工程里来。 我们可以点击选中这个source group。 然后再单击一下。 把这个图改一下。 名字也叫start。 接着右键选择。 添加已经存在的文件到组里来。 打开start文件夹。 把下面这个文件过滤器选择all files。 这样我们就能看到文件夹里的所有文件了。 我们首先添加一下启动文件。 这个启动文件有很多分类。 我们只能添加其中一个啊。 我们视频所用型号需要选择这个后缀为md。 点s的启动文件。 至于启动文件。 这个怎么选择。 我等会儿再讲哈。 我们选中它。 点击i的。 然后剩下的点c和点去文件都要添加进来。 我们可以按住ctrl键。 然后依次选择它们。 点击add。 然后close。 这样我们start文件夹里面的文件就添加好了。 这里的文件都是s t m32 里。 最基本的文件是不需要我们修改的。 我们添加进来即可。 那大家可以看到这个文件。 图标上带了个小钥匙哈。 这个意思是它是个只读文件。 我们可以打开试一下。 这些信息都是不让我们修改的哈。 最后我们还需要在工程选项里。 添加上这个文件夹的头文件路径。 要不然软件是找不到点去文件的。 我们点击这个魔术棒按钮。 打开工程选项。 在c c加加里找到这个include passage栏。 然后点击右边三个点的按钮。 在这里新建路径。 然后再点三个点的按钮。 把start的路径添加进来。 点击ok。 这样就把这个文件夹的头文件路径。 添加进来了。 接下来我们再新建一个main函数。 看看这个工程是不是可行啊。 我们打开工程文件夹。 然后新建一个文件夹。 叫做user。 我们的main函数就放在这个文件夹里。 然后kd在target这里右键点击添加组。 改个名字叫user。 然后在user上右键点击添加新文件。 选择c文件名字叫main下面的路径。 注意一下要选择优势文件夹。 要不然默认是放在文件夹外面的。 然后点击add。 这样我们就有了mdc文件了。 那在工程文件夹的user目录下。 也可以看到我们新建的main.c文件哈。 在这个m.c里。 我们先右键插入头文件。 选择s t m32 f教练x减h。 然后写一个幂函数。 按table键可以进行缩进啊。 里面写一个while一死循环。 这里注意main函数是一个int型。 返回值y的参数的函数。 还有文件的最后一行必须要是空行。 要不然会报警告哈。 然后我们点击这个按钮编译并建立工程。 可以看到下面提示的是零错误零警告哈。 那这就说明我们建立的工程是没问题的。 这个工程目前还没有添加。 s t m32 的库函数。 所以它还是一个基于寄存器开发的工程。 如果你想用寄存器开发s t m32。 那工程建到这里就可以了。 接下来我给大家演示一下。 如何通过配置寄存器来完成点人的操作哈。 当然直接操作寄存器的方式。 不是我们本课程的重点。 大家了解一下即可。 那我们先把这个界面的字体调大点哈。 现在的字体太小。 看着不舒服。 我们可以点击这个扳手工具选择颜色。 和字体选择c c加加编辑器的选项。 然后点击这个按钮。 把字号调成14。 这个a s m编辑器的字体。 我们也把它调成14哈。 然后ok这样字体就变大了。 另外我们再点一下这个扳手工具哈。 把这个编码格式选成u t f8 这一项。 这样可以防止一些中文乱码的问题。 当然你要打开我的工程。 也要把编码格式选为u t f8 哈。 否则中文显示就会出现问题。 如果你打开别人的工程。 看到中文是乱码的话。 可能还需要再改一下这个编码格式。 下面这个tab键的大小选择四哈。 这个锁定大小我比较。 习惯。 然后点击ok。 这样界面看起来就舒服一些。 接着我们需要拿出s t m。 三二的最小系统板。 s t link和四根母对母的杜邦线。 按照插针边上的标识符啊。 把3.3伏s w d l o。 s w c l k j n d对应连接好。 插好之后就是这个样子的。 然后把s tt给插在电脑上。 插上电之后。 这个板子上的电源灯应该会常亮啊。 另一个连接在pc 13口上的灯。 默认应该是闪烁的状态。 这是芯片里的一个测试程序啊。 然后我们再在q里面配置一下调试器。 点击魔术棒按钮选择debug。 这个调试器默认是unlink啊。 我们用的是s t link。 所以选择s t link debug。 然后再点击右边的设置按钮。 在flash下载这一项。 把这个reset and run这一项勾上。 勾上这一项之后。 我们下载程序后会立马复位并执行啊。 这样方便一些。 否则每次下载之后。 还需要按一下板子上的复位按键。 才能执行程序。 那配置好调试器之后点击确认。 ok然后重新编译一下。 没有错误哈。 再点击这个load按钮。 如果一切正常的话。 这个程序就会下载到sm 32里面了。 我们看一下板子。 可以看到这个灯已经不闪了啊。 因为我们目前的程序啥都没有。 那接下来我们就配置一下寄存器。 来点亮这个灯。 我们只需要配置三个计算器就可以。 点的呢。 我们可以打开s t m32 的参考手册。 首先是r c c的一个计算器。 来使能g p l c的时钟。 gpl o都是a p p2 的y s。 所以在这个a p p2 外设时钟死人寄存器。 r c c a b2 e n r里面配置。 可以看到这里有个i o p c e n。 这一位就是使人gp l c的始终的。 下面的解释是。 这一位写一就是打开g p l c的时钟。 那这一位写一其他的无关项。 我们先都给您哈。 那整个寄存器的二进制数据换成16进制。 就是四个一分组。 也就是00000010。 然后我们回到q在while死循环之前。 写上r c c的a b r e n i。 计算器等于0x00000010。 这样就可以打开g p l c的时钟了。 然后第二个计算器。 我们需要配置一下pc 13口的模式。 我们可以找到端口配置高计算器。 gpl x杠c r h啊。 这个x可以是a到g的任意一个字母。 然后右边的cnf 13和mod 13。 就是用来配置13 二口的。 下面的说明。 我们看一下这个cnf。 我们需要配置为通用推挽输出模式。 也就是这两位为零零mod要配置为输出模式。 最大速度可以给50兆赫兹。 也就是。 这两位为一一。 最后我们对照上面的寄存器。 这四位为0011。 其他的我们也都给它配置为零。 这样整个寄存器的值换算成16进制。 就是00300000。 然后我们回到q。 在这里写上g p l c的c r h等于零。 x00300000。 接下来我们就可以给pc 3 c输出数据了。 我们可以看到这个端口输出数据。 寄存器gp l o x杠o d r。 中间有一位o d r 13。 这一位写13 二口就是高电平。 写零就是低电平。 如果写一的话。 o dr的值就是00002000。 那在这里我们写上gpl c的ood 2等于零。 x00002000。 因为这个灯是低电平点亮的。 所以我们给o d r全为零。 就是量。 给o d r0 x00002000 就是灭。 那我们试一下。 先给odr全零编译。 下载。 这时可以看到这个pc 13的灯。 已经亮起来了。 如果我们给odr 2000的话。 编译下载。 再看一下灯就灭了。 那这就是配置寄存器的方式。 进行点灯的操作。 可以看出来。 这种方式需要不断的查手册。 来了解每个寄存器的每一位都是干啥的啊。 而且这个操作方式也有个弊端。 就是我们把除了pc 13之外的。 v都配置成了零。 这样会影响到其他端口的原有配置。 如果要做到只配置pc 13。 而不影响其他位。 那还需要余等于和或等于的操作。 这个在五一单片机的视频里。 我们也经常遇到。 那这样配置就会更加麻烦。 所以这种寄存器的操作方式虽然代码简洁。 但是还是不太方便。 那接下来我们就要为这个工程。 添加库函数了。 看看库函数和计算器的操作方式。 有哪些区别。 我们打开工程文件夹。 在这里新建一个文件夹叫library。 用来存放库函数。 接着打开固件库的文件夹。 打开libraries s t m32 标准外设驱动。 s r c。 这些就是库函数的源文件。 这个msc是内核的库函数啊。 其他的就是内核y的外设库函数了。 这个m i s c就是混杂的意思啊。 看来这个s t公司还是不厚道哈。 把内核的库函数都发挥到杂项里面去了。 开个玩笑。 那我们按ctrl a全选。 然后复制在library文件夹下粘贴。 然后再打开固件库的nc文件夹。 这些是库函数的头文件。 我们继续ctrl a全选。 然后复制在library文件夹下粘贴。 接着回到q软件。 同样在target处右键。 然后添加组。 改个名字叫library。 再右键添加已经存在的文件。 打开library。 ctrl a i。 这样就把所有的库函数文件都添加进来了。 但是对于这个库函数来说。 现在还不能直接使用。 我们需要再添加一个文件哈。 我们打开固件库文件夹。 打开project s t m32 template。 可以看到s t m32 f10 x c o n f。 点h和两个i t结尾的文件。 这个cnf文件是用来配置库函数头文件的。 包含关系的。 另外这里面还有一个用来参数检查的函数。 定义哈。 这是所有库函数都需要的。 两个i t文件是用来存放中断函数的。 我们把这三个文件复制下来。 然后粘贴到工程的user目录下。 接着回到qq软件。 在右侧组里把刚才那三个文件添加进来。 最后还需要一个宏定义啊。 我们可以在这个头文件右键打开文件。 然后划到最下面哈。 看到这个语句。 这是一个条件编译啊。 意思是。 如果你定义的使用标准外设驱动。 这个字符串。 下面这个include的cf点区域距才有效。 所以我们还需要复制一下这个字符串。 然后打开工程选项。 在c c加加的define栏目粘贴这个字符串。 这样才能包含标准外设库。 也就是库函数。 当然还有下面的头文件路径。 也不要忘了。 把这个优势和library目录的路径也都添加上。 然后ok。 这样我们基于库函数的工程就建好了。 我们可以看一下这个library。 里面的库函数也都带了钥匙。 不需要我们更改。 我们唯一需要更改的。 就是user组里面的这些文件。 那我们点一下这个三个箱子的案例啊。 把这个library往上挪一下。 把这些不用改的都放到最上面。 这样看着舒服一些。 那我们编译看一下。 这个第一次编译会比较慢。 以后就快一些了。 可以看到是零错误零警告哈。 这说明我们的工程建立是成功的。 然后我们再用库函数来实现点灯的操作。 我们先把这三句删了。 那库函数其实也是间接的配置计算器。 所以它们的步骤也是一样的。 首先是死人始终。 那库函数就有这样一个函数来开启时钟哈。 叫r c c a b2。 外设时钟控制。 然后这里提示有两个参数。 第一个是选择外设。 第二个是选择新的状态。 我们可以右键跳到函数定义。 这上面有函数的简介和参数说明。 简介说。 这个函数是用来省。 或者私人a b2 的外设时钟。 第一个参数可以是下面这些值。 那我们可以找到a p p2。 外设g p l c这一项。 然后复制直接作为第一个参数即可。 然后我们再回过去看第二个参数。 new state的值可以是enable或者disable。 那我们复制enable放在第二个参数的位置。 最后别忘了括号和分号。 这样gp l c的外设始终就配置好了。 我们可以看一下这个函数。 它的内部其实还是配置r c c a p p2。 n r这个计算机啊。 但是经过函数的包装。 我们不需要再去查手册。 来确认哪一位是干啥的了。 而且这里他已经帮我们用。 或等于和于等于来操作了。 所以这个库函数的配置。 是不会影响到寄存器的其他位的。 这就是库函数和寄存器的区别。 那我们看到这个代码虽然比计算器长啊。 但是语义更加明确。 也不需要我们在查表计算这个寄存器的值。 我们只需要调用。 库函数按照它的提示把参数填好就行了。 所以说从这点对比上来看。 库函数是比寄存器有更大优势的好。 那我们继续来配置。 第二步是配置端口模式。 我们需要用到gp i o lt这个函数。 然后有两个参数。 第一个是选择哪个g p i o。 第二个是参数的结构体哈。 这个比上一个函数要麻烦一些。 但也是一个套路。 我们根据提示来配置参数即可。 那我这里来操作一下。 这里使用了结构体来配置参数。 代码逻辑还是有些复杂的。 这个我们下节还会继续讲。 大家先跟着我操作就行了。 我们首先还是去。 到这个函数的定义。 可以看到这个函数的介绍。 是根据gpo一类的结构体的参数来配置。 gp i o第一个参数gpl x。 其中x可以是a到g来选择。 你要配置哪个gpl。 那我们是pc 13口的l e d。 所以第一个参数就写g p l c。 第二个参数是一个gp l e eletype。 define的结构体。 我们需要先定义一个结构体。 那在上面我们先把这个结构体的类型写上。 然后给结构体起个名字。 这个名字可以随便起哈。 但是根据官方的推荐。 我们最好起这样的名字。 叫g p i o e structure。 然后我们把结构体的每一个参数填上。 复制粘贴结构体的名字。 然后用点来引出结构体的参数。 可以看到这个结构体有三个参数。 分别是gpl模式。 gp端口。 gpu速度哈。 那我们先把这三个参数都罗列出来。 最后也还是一样。 右键转到mod的定义。 在右边的介绍说。 这个参数可以是gpl木质type define。 里面的一个值。 因为这是注释里面的东西啊。 所以没办法用右键跳转的。 那这里我们需要选中这个字符。 按一下ctrl f搜索一下这个定义的位置。 点击find next的。 可以看到这是个枚举哈。 gpl mod就是这里的其中一个值。 然后我们选择alt p p这一项复制。 这个就是通用推广输出。 然后在这里写上gpl mode aut p p。 这样这个参数就配置好了。 然后我们继续看一下下一个参数。 转到它的定义。 这里下面出现了一个框啊。 这个是。 说它的定义有很多个。 我们来看一下。 我们选择这个member这一项双击。 然后跳转的其实还是刚才那个位置。 然后看一下这个g p i o pin的说明。 他说这个参数在g p i o pin。 十defi里面定义了。 我们还是一样。 选中ctrl f find next。 可以看到这里有个宏定义的列表。 我们选择g p l o p 13复制。 然后填在第二个位置。 第三个参数也是一样。 右键跳到定义选中。 ctrl f find the next。 在这里选中50兆赫兹的速度。 复制在这里粘贴。 最后别忘了分号啊。 那结构体变量就有了。 我们就可以填这个gp一的第二个参数了。 那在这里有说明哈。 这个第二个参数是一个指向结构体的指针。 所以这里我们需要传递结构体的地址哈。 那我们复制结构体的名字粘贴到这个位置。 然后前面加上一个取地址符号。 最后打成右括号封号。 这个gpo模式配置就完成了。 这个配置的操作方式看上去比较难理解哈。 但是s t m32 的这种方式都是固定的。 大家多打几次就知道怎么用了。 最后我们。 设置端口的高低电平来进行点灯吧。 这里有个函数g p l sb次。 这个就可以把指定端口设置为高电平。 大家也可以右键去看一下参数的说明哈。 那这里我就直接填了。 第一个是g p o c。 第二个是g p o杠p杠13。 这一句就可以将pc 13号口置为高电平。 接下来自低电平。 也有函数叫gpl o g reset beats。 参数同样是g p l c g p l p 13。 这一句就可以将pc 13号口设为低电平。 那我们依次试一下。 我们先把高电平的注释掉。 编译。 下载。 可以看到灯已经亮了哈。 再把低电平的注释掉。 编译。 下载。 可以看到灯就灭了。 那这就是使用库函数的基本操作了。 这节把下节课也带着讲了哈。 至于s t m32 g p l口的结构。 结构体和库函数的操作。 这些我们下节再详细解释。 那本节我们先来用一下。 来测试一下我们的工程哈。 那有关新建工程的部分。 我们这节大概就介绍完了。 最后还要补充几点哈。 来看一下ppt。 首先是新建工程里的启动文件。 选择。 我们新建工程第一个加的就是启动文件。 这个启动文件有很多类型。 至于选择哪一个。 我们要根据芯片型号的选择。 那我们看到这个表。 这里是s t m32 f一系列中的型号分类。 其中根据flash的大小分为了小容量产品。 flash为16~32k简写为l d啊。 中低容量产品flash为16~128k。 减小为m d。 大容量产品。 flash为256~512k。 简写为h d。 加大容量产品flash大于512k。 简写为xl那sm 3 f100 的系列呢。 s t把它叫做超值系列。 简写为vl s t m32 f105 和107。 s t把它叫做互联型产品。 这个就没有根据flash大小在分类了。 所以就有了这个表。 如果你使用s t m32 f100 的型号。 就选择带vl的启动文件。 然后再根据flash的大小选择l dmd还是hd。 如果你使用s t m32 f100。 102103的型号。 就选择不带vl的。 然后根据flash的大小选择l d m d hd还是xl。 如果你使用sm 3 f105107 的型号。 直接选择cl的启动文件即可。 那在这里我们可以看一下哈。 这个启动文件后面带了字母。 和我这个表字母都是对应的。 这样我们就知道了。 我们这个s t m32 f103 的芯片。 就需要选择这四列。 又因为c8 t6 的flash是60。 4k所以选择md的启动文件。 这就是htm 32 f一系列的型号。 分类和启动文件的选取哈。 接下来我们再总结一下新建工程的步骤。 第一步建立工程文件夹。 q中新建工程选择型号。 这个不用说啊。 第二步。 工程文件夹里建立start library user的文件夹。 复制固件库里面的文件到工程文件夹。 这一步是为了添加工程文件准备的。 建文件夹是因为文件比较多。 需要分类管理一下哈。 这个文件夹的名称和数量没有限制。 大家也可以根据自己的理解来建。 这都是可以的。 另外需要用的文件一定要复制到工程。 文件夹里面来不要添加工程文件夹。 外面的文件。 要不然你外面的文件一旦挪位置。 工程里就找不到文件了。 所以我们要复制文件到工程里以来。 保持工程的独立性。 第三步是工程里对应建立start library。 user等同名称的分组。 然后将文件夹内的文件添加到工程分组里。 这一步的原因是在q里方便管理文件哈。 因为q没法直接添加文件夹。 所以还得重复一下。 在ko里建立分组。 然后添加文件。 这个添加文件。 我是把所有的点h文件和。 点c文件都添加进来了哈。 因为点h文件是不参与编译的。 所以其。 他很多工程都是不添加点h文件的。 但是我认为把点h文件加进来比较方便。 而且点h文件也是需要经常打开看的。 所以我比较习惯把所有的文件都添加进来。 第四步是工程选项c c加加include passage类。 声明所有包含头文件的文件夹。 这一步是因为你这个start library等文件夹。 是你自己建的q软件。 他并不知道。 所以你要用自己文件夹里面的dr h文件。 就必须声明一下这个路径。 那最好就是你自己建的所有文件夹。 都声明一下哈。 这样就不会出现点h文件找不到的问题了。 第五步是工程选项c c。 加加define类定义。 使用标准外设驱动这个字符串。 这是使用库函数的条件编译哈。 使用库函数就必须定义这个。 另外其他的工程。 在这个位置还声明了一个s t m。 32f10 x杠mt的字符串。 那根据我的调查。 k5 在新建功能后自动就帮我们声明好了。 这个不需要再额外声明了。 所以在这个位置只需要声明。 使用标准外设驱动的字符串即可。 第六步是工程选项。 debug下拉列表。 选择对应调试器。 tflash download。 你勾选reset and run。 这个就是选择调制器来进行下载的选项了。 我们用s t link就选择s t link的那一。 项即可。 那这就是新建工程的基本步骤。 新建工程也是很灵活的哈。 大家只要符合要求都可以编译。 通过每个人建工程的风格也不同。 大家学会了之后。 也可以建立一个属于自己风格的工程。 最后我再额外的讲一下这个工程的架构啊。 来看一下这个工程的每个文件都是干啥的。 为啥需要这些文件。 那我们看到这个图。 首先是start up启动文件。 这个是程序执行最基本的文件。 我们可以看到q中启动文件是用汇编写的。 启动文件内定义了中断向量表。 中断服务函数等。 那这个中断服务函数中有个复位中断。 这就是整个程序的入口哈。 当s t m32 上电复位。 或者按下复位按键之后。 程序就会进入复位中断函数。 执行复位中断函数主要就做了两件事情。 第一个是调用system init函数。 第二个是调用main函数对应启动文件。 在这里可以看到这是复位的中断函数。 然后调用system it。 再调用main。 然后程序就结束了。 当然实际上单片机的程序永远也不会结束。 所以在main函数的最后。 一定是一个死循环。 那system函数就是定义在这个system开头的点。 c文件里的。 那在qq里我们也可以看到这个函数的定义。 这里的简介写了这个函数的作用哈。 是设置微控制器的启动初始化。 嵌入式闪存接口锁。 相环更新系统内核的时钟变量。 下面的note写的是这个函数。 仅在复位后需要调用。 那下面这些就是用来配置这些东西的。 这个也不需要我们更改。 我们只需要知道在main函数之前。 单片机就已经执行了一堆东西了。 帮我们把这个闪存接口。 时钟等一系列杂碎的东西都配置好了。 另外在启动文件还定义了s t m32。 所有的其他中断哈。 这些中段达到触发条件后就会自动执行。 那在启动文件这下面。 这都是其他的中端调用了。 这个中断函数的定义。 就是在s t m32 f10 x杠i t里面的。 我们打开q可以看到。 这些就是中断函数的定义。 那最后s t还建议我们把自己的中段。 写在这个位置哈。 当然我们还是习惯在哪。 用中段就写在哪里啊。 写在别的地方也是可以的。 那这些就是中断部分的执行逻辑了。 另外你也可以自己定义一些用户文件。 来分装一些模块。 供主函数和中断调用。 这些也都是没问题的。 同时也有利于我们程序结构的模块化。 要不然所有的程序都堆在主函数里。 那主函数也太长了是吧。 到此为止。 这个工程结构主动执行的部分就介绍完了。 剩下右边的就是被动执行的东西了。 相当于s t m32 的资源。 我们在转数或者中断函数里。 就可以调用这些资源哈。 右上角这两个s t m3。 2f10 x.1h和k杠cm 3。 这些文件就是外设和内核。 外设的寄存器描述。 在q中我们可以看到。 这里面都是寄存器和寄存器。 每一位的名字。 还有地址信息等。 如果直接调用这些寄存器来使用。 s t m32。 那就是寄存器的开发方式。 我们已经试过了。 这种方式会有一些弊端。 也比较麻烦。 所以s t公司就提供了下面这两个文件。 这个就是库函数文件。 在qq中可以看到。 这每个外设都提供了一大堆的函数。 这些函数分装了计算器的操作。 给我们提供更加人性化的函数调用方式。 只要学会了操作套路。 那配置一个外设就是很简单的。 连手册都不需要看一眼哈。 这个c o n f文件就是用来配置头文件的。 包含关系的。 我们可以看到在这里。 c o n f文件。 include了所有的库函数头文件。 同时我们在s t m32 f。 10x.h的最后。 又包含了c o f。 所以在使用这些库函数时。 我们只需要包含s t m32 f10 x点去。 这一个头文件。 就相当于包含了所有的库函数头文件。 这样我们就可以任意的调用库函数了哈。 那这些就是整个工程的结构。 和每个文件的作用哈。 好以上就是我们本节课的所有内容了。 本节课我们建好了基于库函数的htm。 三个工程。 我们下一节就开始从这个工程上学习。 还是tm 32的第一个外设g p i o了哈。
5. hello。 大家好。 欢迎继续观看sm 32入门教程。 本节课将会分为两个部分。 总共四个小节。 另外在第二部分我也会给大家讲一些c语言的知识。 因为这个库函数里面用了大量的结构体。 指针枚举等知识。 这些知识应该都算是c语言中比较高级的部分了啊。 初学者可能比较难理解。 那我们会在这一节的第二部分介绍。 前半部分。 大家先跟着我来操作就行了。 好。 那我们先来看一下本节课程序的现象啊。 本节课第一部分总共有三个程序。 第一个是led闪烁。 第二个是led流水灯。 第三个是蜂鸣器啊。 我们先来看一下第一个程序编译下载。 这就是第一个程序的现象。 接下来再看一下第二个程序。 led流水灯。 编译下载。 这时可以看到这里的八个l e d正在以流水灯的方式不断循环点亮。 这就是第二个程序的现象。 接下来看一下第三个程序分明器啊。 编译下载。 这时候我们可以听到这个分离器正在滴滴明显哈。 这就是第三个程序的现象。 我们回到ppt先来看一下gpo的理论部分。 首先gpo这四个字母是general purpose。 input output的缩写。 译为通用输入输出口啊。 也就是我们俗称的l口。 这个gp i o根据使用场景可以配置为八种输入输出模式。 具体是哪八种模式。 我们等会再细说哈。 gpl的银角电瓶是0伏到3.3伏。 数据零就是低电平。 也就是零-2。 数据一就是高电平。 也就是3.3伏部分溢价可容忍5伏。 容忍5伏的意思是可以在这个端口输入5伏的电压。 也认为是高电平啊。 但是对于输出而言。 最大就只能输出3.3伏。 因为供电就只有。 3.3伏具体哪些端口能容忍5伏。 可以参考一下htm 32的引脚定义啊。 这里带f t的就是可以容忍五福的。 不带f t的就只能接入3.3伏的电压。 这个我们在第一节也讲过哈。 那gpo在输出模式下可控制端口输出高低电平。 用以驱动led控制分频器。 模拟通信协议输出时序的。 像我们刚才演示的l e d和分频器的程序现象。 就使用到了g p i o的输出模式。 另外在其他的应用场景。 只要是可以用高低电平来进行控制的地方。 都可以用gpo来完成。 如果控制的是功率比较大的设备。 只需。 要再加入驱动电路即可。 除此之外。 我们还可以用g p i o来模拟通信协议。 比如iphone c spi或者某个芯片特定的协议。 我们都可以用gpl的输出模式来模拟其中的输出时序部分。 那gpu在输入模式下可读取端口的高低电平或电压。 用于读取按键。 输入外接模块电平信号。 输入abc电压。 采集模拟通信协议接收数据等。 这个输入模式最常见的就是读取按键了。 用来捕获我们的按键。 按下事件。 另外也可以读取带有数字输出的一些模块。 比如我们套件里的光敏电阻模块。 热敏电阻模块的。 如果这个模。 块输出的是模拟量。 那gpo还可以配置成模拟输入的模式。 再配合内部的adc外设。 就能直接读取端口的模拟电压了。 除此之外。 模拟通信协议时接收通信线上的数据也是靠gp o的输入来完成的。 那看完介绍。 我们再来看一下s t m32 中gpu的基本结构。 下面这有一个框图。 这就是gpl的整体构造哈。 其中左边的是a b2 y c中心。 也就是这个s t m32 系统结构图的这个位置哈。 在s t m32 中。 所有的gp i o都是挂载在a b2 外设总线上的。 其中g p l o外设的名称是按照g p l a g。 p b g p l c等等这样来命名的哈。 每个gpl外设总共有16个引脚。 编号是从零到15。 那gpa的d0 号引脚。 我们一般把它称作pa 0。 接着第1号就是p a1。 然后p a21 次类推案一直到pa 15。 g p l b也是一样啊。 从p b01 直到p b 15。 这样来命名的。 寄存器就是一段特殊的存储器内核。 可以通过app b2 总线对寄存器进行读写。 这样就可以完成输出电平和读取电瓶的功能了。 这个寄存器的每一位对应一个引脚哈。 其中输。 出寄存器写一对应的引脚就会输出高电平。 显灵就是速低电平输入计算器读取为一。 就证明对应的端口目前是高电平。 读取为零。 就是低电平。 因为s t m32 是32位的单片机。 所以s t m32 内部的寄存器都是32位的。 但这个端口只有16位。 所以这个寄存器只有第16位。 对应的有端口。 高16位是没有用到的。 这个驱动器是用来增加信号的驱动能力的。 寄存器只负责存储数据。 如果要进行点灯这样的操作的话。 还是需要驱动器来负责增大驱动能力的。 那这些就是gpl的整。 体基本结构了。 接下来我们再来看一下这个gpo中每一位的具体电路结构。 那这个图就是sm 32参考手册中的gpl v结构的电路图了。 其中左边这三个就是寄存器。 中间这一部分是驱动器。 右边这个就是某一个l o的引脚了。 整体结构可以分为两个部分。 上面是输入部分。 下面是输出部分。 我们先来看一下输入部分。 首先是这个i o引脚。 这里接了两个保护二极管。 这个是对输入电压进行限幅的。 上面这个二极管接v dd 3.3伏。 下面接vs s0 伏啊。 如果输入电压比3.3伏还要高。 那上方。 这个二极管就会导通输入电压产生的电流就会直接流入v dd。 而不会流入内部电路。 这样就可以避免过高的电压对内部这些电路产生伤害。 如果输入电压比0伏还要低。 这个电压是相对于vs的电压哈。 所以是可以有负电压的。 那这时下方这个二极管就会导通。 电流会从vs直接流出去。 而不会从内部电路及去电流。 也是可以保护内部电路的哈。 如果输入电压在0~3点3伏之间。 那两个二极管均不会导通。 这是二极管对电路没有影响啊。 这就是保护二极管的用途。 接下来这根线就到了。 这个地方这里连接了一个上拉电阻和一个下拉电阻。 上拉电阻制v dd。 下拉电阻制vs s。 这个开关是可以通过程序进行配置的。 如果上面导从下面断开。 就是上拉输入模式。 如果下面导从上面断开。 就是下拉输入模式。 如果两个都断开。 那这个上拉和下拉有什么作用呢。 这个其实是未来给输入提供一个默认的输入电平的哈。 因为对于一个数字的端口。 输入不是高电平。 就是低电平。 那如果输入引脚啥都不接。 那到底是算高电平还是低电平呢。 这就不好说了。 实际情况是如。 果输入啥都不接。 这时输入就会处于一种浮空的状态。 引脚的输入电平极易受外界干扰而改变啊。 就像是一个物体悬浮在太空一样。 它的位置是不确定的。 受到一点扰动就会变化。 为了避免零件悬空导致的输入数据不确定。 我们就需要在这里加上上拉或者下拉电阻了。 如果接入上拉电阻。 当鹰角悬空时。 还有上拉电阻来保证银角的高电平啊。 所以上拉输入又可以称作是默认为高电平的输入模式。 下来也是同理。 就是默认为低电平的输入方式。 这就像是在太空的物体来到了地球上。 如果。 不施加外力。 由于重力的下拉作用。 默认还是回到地面的哈。 这个上拉电阻和下拉电阻的阻值都是比较大的。 是一种弱上来和弱下来。 目的是尽量不影响正常的输入操作啊。 接着我们继续往下看。 这里是一个肖特基触发器。 实际上这个应该是施密特触发器哈。 我查了英文的原文的。 这里写的就是施密特触发器的英文。 所以肖特基触发器应该是一个翻译错误。 这个施密特触发器的作用就是对输入电压进行整形的。 它的执行逻辑是。 如果输入电压大于某一阈值。 输出就会瞬间升为高电平。 如。 果输入电压小于某一阈值。 输出就会瞬间降为低电平。 那举个例子啊。 因为这个银角的波形是外界输入的。 虽然是数字信号。 实际情况下可能会产生各种失真哈。 比如有这样一个波形。 这是一个夹杂了波动的高低变化电平信号。 如果没有斯密特触发器。 那很有可能因为干扰而导致误判。 如果有了斯密特触发器。 那比如定一个这样的阈值。 上限和下限。 高于上限输出高。 低于下限输出低。 这样施密特触发器的输出就是首先是低于下限输出低。 然后在这个位置高于上限输出立即变为高。 虽然在这里信号由于波动再次低于上线了。 但是对于施密特触发器来说。 只有高于上限或者低于下限输出才会变化。 所以此时低于上限的情况。 输出并不会变化。 而是继续维持高电平。 然后直到下次低于下限时才会转为低电平。 这里信号即使在下线附近来回横跳。 因为没有跳到上限上面去。 所以输出仍然是稳定的。 直到下一次高于上限。 输出才会变为高。 那这就是施密特触发器的输出信号。 可以看到相比较输入信号经过整形的信号就很完美了。 在这里使用了两个比较预制来进行判断。 中间留有一定的变化范围。 这样可以有效地避免因信号波动造成的输出抖动现象啊。 接下来经过斯密特触发器整形的波形。 就可以直接写入输入数据计算器了。 我们再用程序读取输。 入数据进行器对应某一位的数据。 就可以知道端口的输入电平了。 最后上面这还有两路线路。 这些就是连接的片上外设的一些端口。 其中有模拟输入。 这个是连接到a d c上的。 因为a d c需要接收模拟量。 所以这根线是接到施密特触发器前面的哈。 另一个是复用功能输入。 这个是连接到其他需要读取端口的外设上的。 比如串口的输入引脚等。 这根线接收的是数字量。 所以在施密特触发器后面。 接着我们再来看一下输出的部分。 数字部分可以由输出数据寄存器或片上外设控制两种控。 制方式通过这个数据选择器接到了输出控制部分。 如果选择通过输出数据寄存器进行控制。 就是普通的l口输出。 写这个数据寄存器的某一位就可以操作对应的某个端口了。 那左边还有个叫做未设置清除寄存器。 这个可以用来单独操作输出数据寄存器的某一位。 而不影响其他位哈。 因为这个输出数据计算器同时控制16个端口。 并且这个寄存器只能整体读写哈。 所以如果想单独控制其中某一个端口。 而不影响其他端口的话。 就需要一些特殊的操作方式。 第一种方式是先读出这个。 计算器。 然后用按位与和按位或的方式更改某一位。 最后再将更改后的数据写回去。 在c语言中就是余等于和或等于的操作。 这种方法比较麻烦啊。 效率不高。 对于io口的操作而言不太合适。 第二种方式是通过设置这个未设置和未清除计算器。 如果我们要对某一位进行质疑的操作。 在未设置寄存器的对应位写一即可。 剩下不需要操作的位写零。 这样它内部就会有电路自动加输出数据。 寄存器对应位置为一。 而剩下显灵的位置保持不变啊。 这样就保证了只操作其中某一位。 而不影响其他。 位。 并且这是一步到位的操作。 如果想对某一位进行清零的操作。 就在未清除寄存器的对应位协议即可。 这样内部电路就会把这一位清零了。 这就是第二种方式。 也就是这个未设置和未清除寄存器的作用。 另外还有第三种操作方式。 就是读写sm 32中的未带区域。 这个未带的作用就跟五幺单片机的微型子作用差不多哈。 在s t m32 中专门分配的有一段地址区。 所有的v读写。 这段地址中的数据就相当于读写所映射位置的某一位。 这就是未来的操作。 方式这个方式我们本课程暂时不会用到。 我们的教程主要使用的是库函数来操作的。 库函数使用的就是读写未设置和未清除计算器的方法。 那我们继续看。 接下来输出控制之后就接到了两个mos管。 上面是p mos。 下面是n m这个mos管就是一种电子开关哈。 我们的信号来控制开关的导通和关闭。 开关。 负责将l口接到v dd或者vs。 在这里可以选择推广开路或关闭三种输出方式。 在推广输出模式下。 p mos和n mos均有效。 数据计算器为一时上管导通。 下管断开输出。 直接接到v dd就是输出高电。 平啊数据寄存器为零时。 上管断开。 下管导通输出直接接到vs就是输出低电平。 这种模式下高低电平均有较强的驱动能力。 所以推广输出模式也可以叫强推输出模式啊。 在推广输出模式下。 s t m32 对l口具有绝对的控制权。 高低电平都由sm 32说了算。 在开漏输出模式下。 这个p mos是无效的啊。 只有n mos在工作。 数据寄存器为一时下管断开。 这时输出相当于断开。 也就是高种模式。 数据计算器为零时。 下管导通输出直接接到vs s。 也就是输出低电平啊。 这种模式下只有低电平有驱动能。 力高电平是没有驱动能力的。 那这个模式有什么用呢。 这个开漏模式可以作为通信协议的驱动方式。 比如fc通信的引脚就是使用的co模式哈。 在多机通信的情况下。 这个模式可以避免各个设备的相互干扰。 另外开发模式还可以用于输出5伏的电频信号啊。 比如在alpha外接一个上拉电阻到5伏的电源。 当输出低电平时。 由内部的n mos直接接vs。 当输出高电平时。 由外部的上拉电阻拉高至5伏。 这样就可以输出5伏的电平信号。 用于兼容一些5伏电瓶的设备。 这就是开漏输出的主要用途。 剩。 下的一种状态就是关闭。 这个是当银角配置为输入模式的时候。 这两个牧师管都无效。 也就是输出关闭端口的电瓶由外部信号来控制。 那这些就是gpl未结构的全部介绍了。 接下来我们就来看一下gpo的八种工作模式。 那通过配置gp i o的端口。 配置寄存器。 上面这个未结构的电路就会根据我们的配置进行改变。 比如开关的通断amos和pm是否有效。 数据选择器的选择等。 那这个端口的电路就可以配置成以下八种模式。 上拉输入。 下拉输入。 模拟输入。 开漏输出。 推挽输出。 复用开。 漏输出和复用推挽输出。 我们依次来看一下。 上拉输入和下拉输入。 这三个模式的电路结构基本是一样的。 区别就是上拉电阻和下拉电阻的连接。 它们都属于数字的输入口。 那特征就是都可以读取端口的高低电平。 当鹰角悬空时。 上拉输入默认是高电平。 下拉输入默认是低电平。 端口一定要接上一个连续的驱动源。 不能出现悬空的状态。 那我们来看一下这三种模式的电路结构。 这里可以看到在输入模式下输。 出驱动寄存器是断开的。 端口只能输入而不能输出。 上面这两个电阻可以选择为上拉工作。 下拉工作或者都不工作。 对应的就是上拉输入。 然后输入通过施密特触发器进行波形。 整形后连接到输入数据计算器。 另外右边这个输入保护。 这里上面写的是v dd或者v dd杠f。 这就是3.3伏端口和容忍5伏端口的区别。 下面可以看到这里说v dd杠f t对五福荣的l角是特殊的。 它与v dd不同。 至于怎么个特殊法手册也没有说。 咱也不用管哈。 就知道一下这个容忍五福。 的引脚。 它的上边保护二极管要做一下处理。 要不然这里直接接vg d3.3伏的话。 外部再接入5伏电压。 就会导致上边二极管开启啊。 并且产生比较大的电流。 这个是不太妥当的。 接着我们再来看一下下面这一个模拟输入哈。 特征是gpl无效。 银角直接接入内部a d c。 这个模拟输入可以说是adc模数转换器的专属配置了哈。 我们看一下模拟书的结构。 这里输出是断开的。 输入的思密特触发器也是关闭的无效状态。 所以整个g p i o的这些都是没用的啊。 那就只剩下这一根线了。 也就是从。 零件直接接入片上外设也就是a d c。 所以当我们使用abc的时候。 将银角配置为模拟输入就行了。 其他时候一般用不到模拟输入。 接着我们再来看一下开漏输出和推广输出。 这两个电路结构也基本一样。 都是数字输出口。 可以用于输出高低电平。 区别就是开漏输出的高电平呈现的是高阻态。 没有驱动能力。 而推广输出的高低电平都是具有驱动能力的。 那这两种模式电路结构就是这样的。 这时候输出是由输出数据寄存器控制的。 这个p mos如果无效。 就是开漏输出。 如果p mos和n mos都有效。 就是推完输出。 另外我们还可以看到在输出模式下。 输入模式也是有效的。 但是我们刚才的电路图在输入模式下输出都是无效的。 这是因为一个端口只能有一个输出。 但可以有多个输入哈。 所以当配置成输出模式的时候。 内部也可以顺便输入一下。 这个也是没啥影响的。 最后我们再来看一下复用。 开了输出和复用推挽输出。 这俩模式跟普通的开漏输出和推广输出也差不多。 只不过是复用的输出引脚电瓶是由片上外设控制的。 那我们看一下这两个模式的结构。 可以看到通用的输出。 这里。 是没有连接的。 银角的控制权转移到了片上。 外设由片上外设来控制。 在输入部分。 片上外设也可以读取引脚的电瓶。 同时普通的输入也是有效的。 顺便接收一下电平信号。 其实在gpl的这八种模式中。 除了模拟输入。 这个模式会关闭数字的输入功能。 在其他的七个模式中。 所有的输入都是有效的啊。 那这些就是s t m32 g p i o的全部介绍了。 接着我们再打开这个s t m32 的参考手册。 大概的看一下这个手册。 我们打开这个g p i o和a f l o这一张。 我们本节只讲g p i o a f i。 o以后再讲啊。 那我们可以看到这个手册上来就说了g p i o的八种工作模式。 那下面就是介绍这些模式的哈。 我刚才也给大家讲过。 剩下的还有一些没讲到的点。 大家可以再看一下手册。 然后这里有外设的gpo配置。 当我们使用这些片上外设的银角时。 可以参考这个表里给的配置哈。 最后就是gpu的寄存器。 首先是g pro配置寄存器。 每一个端口的模式由四位进行配置啊。 16个端口就需要64位。 所以这里的配置计算器有两个。 一个是端口配置低计算器。 一个是端口配置高计算器。 具体怎么配置的。 可以参考一下下面这个介绍啊。 另外这里还多出来一项g p i o输出的速度哈。 这个在结构图里并没有说这个速度这个参数。 这个gpl的输出速度可以限制输出引脚的最大翻转速度。 这个设计出来是为了低功耗和稳定性的哈。 我们一般要求不高的时候。 直接配置成50。 兆赫兹就可以了哈。 然后是端口输入数据计算器。 这个就是ppt中的这个计算器里面的第16位对应16个硬件。 高16位没有使用。 然后是端口输出数据计器。 也就是这个计算器同样低16位。 对应16个引脚。 高16位没有使用。 接下来是端口未设置清除计算器。 也就是这个计算器啊。 这个寄存器的高16位是进行未清除的。 第16位是进行未设置的。 写一就是设置或者清除写零。 就是不产生影响啊。 下面这里还有一个端口未清除计算器。 这个计算器的第16位和上面这个计算器的。 高16位功能是一样的。 那为啥还要有这个计算器呢。 这个是为了方便操作设置的哈。 如果你只想单一的进行未设置或者未清除。 那未设置时用上面这个计算器。 未清除时用下面这个计算器。 因为在设置和清除时使用的都是第16位的数据。 这样就方便一些。 如果你想对多个端口同时进行未设置和未清除。 那就使用第一个计算器就行了。 这样可以保证未设置和未清除的同步性。 当然你要对信号的同步性要求不高的话。 先进行未设置。 再进行卫星除也是没问题的。 最后一个就是端口配。 置锁定计算器。 这个可以对端口的配置进行锁定。 防止意外更改哈。 使用方法看介绍。 这个我们暂时用的不多。 那有关s t m32 内部的gp l y设。 我们就讲完了。 接下来我们再来看一下s t m32 外部的设备和电路。 首先是l d和分频器。 介绍这些。 相信大家对这些东西应该已经比较熟悉了。 我就快速的过一下。 那led就是发光二极管。 正向通电点亮。 反向通电不亮。 下面这个就是l一的电路符号。 左边是正极。 右边是负极。 这个是l e d的实物图。 如果是银角没有剪过的l e d。 那其中长角是。 正极短角是负极。 通过l e d内部也可以看正负极啊。 这里较小的一半是正极。 较大的一半是负极。 这就是l e d。 接下来就是分频器。 分频器分为有源分频器和无源分配器。 有源分配器就是内部自带震荡源。 将正负极接上直流电压即可持续发生频率固定。 我们本视频用的就是下面这个图所示的有源分配器。 右边是它的内部电路。 这里用了一个三极管开关的进行驱动。 我们在vcc和gd分别接上正负极的供电。 然后中间这个引脚接低电平分频器就会响。 接高电平分频器就关闭。 那这里有文。 字说明写的是低电平触发哈。 这就是有缘分频器的用法。 另外还有无缘分明器。 它是内部不再增长源。 需要控制器提供震荡脉冲才可发生调整。 提供震荡脉冲的频率可发出不同频率的声音。 这个我们在五压单片机的教程已经使用过了。 本视频暂时不会涉及。 然后我们来看一下l d和分频器的硬件电路啊。 这边左边两个图是使用s t m32 的g p i o口驱动l一的电路。 其中上面这个是低电平驱动的电路。 led正极接3.3伏负极。 通过一个限流电阻接到p a0 上。 当pa 0输出低电平。 时led两端就会产生电压差。 就会形成正向导通电流。 这样led就会点亮了。 当pa 0输出高电平时。 因为l e d两端都是3.3伏的电压。 不会形成电流。 所以高电平l e d就是熄灭。 这里的限流电阻一般都是要接的哈。 一方面它可以防止led因为电流过大而烧毁。 另一方面它也可以调整l一的亮度。 如果你觉得l d碳量比较刺眼的话。 可以适当的增大限流电阻的阻值。 为了简化电路。 就省去了这个限流电阻。 大家自己设计电路的时候要注意加上。 啊下面这个图就是高电平驱动的电路。 l d负极接到真d正极。 通过一个限流电阻接到p a0 上。 这时就是高电平电量。 低电平熄灭了。 那这两种驱动方式应该如何选择呢。 我们刚才介绍这个g p i o在推广输出模式下。 高低电平均有比较强的驱动能力。 所以在这里这两种接法均可哈。 但是在单片机的电路里。 一般倾向使用第一种解法。 你有很多单片机或者芯片都使用了高电平弱驱动。 低电平强驱动的规则哈。 这样可以一定程度上避。 免高低电频打架。 所以如果高电平驱动能力弱。 那就不能使用第二种连接方法了。 接着看右边的分频器电路。 这里使用了三极管开关的驱动方案。 三极管开关是最简单的驱动电路啊。 对于功率稍微大一点的。 直接用l口驱动。 会导致s t m32 负担过重。 这时就可以用一个三极管驱动电路来完成驱动的任务。 上面这个图是p np 3极管的驱动电路。 三极管的左边是积极。 带箭头的是发射极。 剩下的是集电极。 它左边的积极给低电平三极管就会导通。 那通过3.3伏和gd就可以给分频器提。 供驱动电流了。 积极给高电平三极管截止分频器就没有电流。 下面这个图是np n3 极管的驱动电路。 同样左边是积极。 带箭头的是发射极。 剩下的是集电极。 它的驱动逻辑跟上面的是相反的。 积极给高电平导通。 低电平断开。 另外注意一下这个偏僻的三极管。 最好接在上边。 n p n的三极管就要接在下边哈。 这是因为三极管的通断是需要在发射极和积极之间。 产生一定的开启电压的。 如果你把负载接在发射器这边。 可能会导致三极管不能开启啊。 那这些就是s t m32 外部的设备和电路。 下面这个是把它背面的双面胶撕掉的样子。 右边这个图就是这个金属爪的示意图。 它内部的金属爪就会夹住银角。 再看一下背面的图。 我们可以发现金属爪的排列规律是中间的金属爪是竖着放的。 上下四排是连在一起的。 四个整体的金属爪。 就是在这里竖着的五个孔内部都是连接。 在一起的。 这样我们原件插在一纵排的不同孔位时。 内部的金属爪就实现了线路的连接。 而上下四排孔整体是连在一起的。 这四排是用于供电的。 这里也标的有。 第一排是正极。 第二排是负极。 第三排也是正极。 第四排也是负极哈。 如果我们需要供电。 就从上下的孔位中用跳线引出来即可。 另外再说明一下这个供电的引脚。 这中间这四个地方都是断开的哈。 如果是断开的。 就需要像这样在中间用跳线把两边连在一起。 当然我这次拆。 还挺意外的。 就可以这样连接。 首先把上面两排的供电引脚接上电源的正负极。 然后用跳线将正极引下。 来到这个孔里。 然后再纵向下面的孔横着插一个限流电阻到右边的这个孔。 接着再在右边纵向上面的孔横着插一个led到右边的这个孔。 然后再用跳线把右边引到负极。 这样整个电路的电流就是从电源正极出来。 通过金属爪到这里。 再通过跳线到这里。 再通过金属转下来。 然后通过电阻再通过金属爪上去。 然后通过l e d。 最后通过金属爪到跳线。 然后从这里接回负极。 好那我们本小节就到这里。 然后写程序实现我们想要的功能。
6. 本小节我们就来编写代码。 完成上一小节演示的三个示例程序啊。 首先我们需要先搭建一下面包板的电路。 我会把每个代码的接线图都放到工程文件夹的第一个文件夹里。 大家可以下载程序源码的文件查看。 我们打开经验图。 打开三个一led闪烁的图片。 这就是本节第一个程序的硬件电路。 那我们拿出面包板。 把正极的红线朝上啊。 注意别拉反了。 然后拿出sm 32最小系统版。 在这里按照图示位置。 上边和右边留两个孔。 下边留三个孔。 然后插到面包板上。 接着拿出跳线。 将最小系统板的正负极引到面包板的供电引脚上。 这样上下四排供电引脚就可以通过最小系统板获取电源了。 这里既引的负极。 3.3引的正极。 下面也是一样啊。 跳线连接完成后。 我们把s t link按照上面的银角标识符连接到最小系统上。 这里银角并不是按照顺序来的啊。 注意别插错线了。 我们这整个系统的供电是snk的。 3.3伏接到最小系统。 然后最小系统就通过跳线接到上下四排的供电孔的。 最后我们拿出一个l e d长角。 正极接到正极供电孔。 转角负极接到p a0 端口上。 这里使用的是低电平电量的操作方式。 为了方便就没有接限流电阻啊。 这样我们的硬件电路就搭建完成了。 我们把s link插到电脑上。 这里的电源灯亮起。 好那我们打开q5 软件。 然后新建一个工程。 这里新建工程比较麻烦。 我再给大家快速演示一遍以后。 我们就直接复制现有的工程了。 那我们点击project new project。 选择存放工程的文件夹。 在这里再新建一个文件夹。 我们可以按ctrl shift加n快捷键新建文件夹。 然后起个名字叫三杠一led闪烁。 点进去起个工程名叫project。 保存。 接着选择芯片s t m32 f103 c8。 ok这个窗口插件啊。 然后在文件管理里打开我们的工程文件夹。 在新建三个文件夹。 分别叫start library。 user打开固件库文件。 找到启动文件。 按ctrl a全选。 再按ctrl c复制。 然后把它们放到start文件夹下。 再找到sm 32 f10 x和system的两个文件。 ctrl c复制粘贴到大文件夹下。 再找到call根cm 3的两个文件。 复制粘贴到start文件夹下。 这样大文件夹的文件就复制完成了。 然后找到标准外设驱动的文件夹。 打开src全选复制。 粘贴到library文件夹下。 然后打开i n c全选复制。 也粘贴到library文件夹下。 这样library文件夹的文件也就复制完成了。 最后打开project文件夹。 然后打开后缀是template的文件夹。 按住ctrl键选择这里的main cf两个it文件复制粘贴到user文件夹下。 这里majc我们也直接复制过来啊。 这样就不用再新建文件了。 到此为止。 我们的工程文件就复制完成了。 然后回到q点击这个三个箱子的工程文件管理按钮。 把默认的这个数擦掉哈。 点这个按钮再新建三个组。 叫state library。 user。 然后选中start。 在右边点击添加文件。 打开start文件夹。 文件类型选所有文件。 首先添加后缀为md的启动文件。 然后按住ctrl把其他的点c和点h文件都选中pad。 这样start组里的文件就添加好了。 然后是library。 点添加文件。 打开library文件夹。 文件类型选所有文件。 ctrl a全选a。 这样library处理的文件就添加好了。 然后是user添加文件。 打开user文件类型。 选所有文件全选。 最后点击ok。 这样我们工程里的组合文件就都添加好了。 接着点击魔术棒按钮。 打开工程选项。 选择c c加加在include passes。 来把我们自己建的文件夹路径都添加进来。 start。 debris。 优势。 然后ok在defi里写上u s e使用下划线。 s t d标准p e l p h y设下划线。 d r i v e r驱动这个字符串。 最后是debug调试器。 选择st link。 然后设置flash下载。 勾上复位并执行这个勾。 最后确定。 ok这样工程选项就配置好了。 接着我们打开这个面点c。 把它这里面的原来的代码全都删掉了。 然后右键添加头文件。 写上主函数。 这样整个工程就建好了。 我们编译测试一下。 没有错。 没有警告啊。 然后下载测试也是没有问题的。 最后再给大家分享个小工具啊。 我把它放到了工程的第二个文件夹里。 这个东西是一个批处理文件。 它可以把工程编译产生的中间文件都删掉。 我们可以把它复制到工程文件夹里。 放在这里。 因为这个工程编译产生的文件比较大。 我们可以看一下这个led闪烁的工程就有20兆。 这里主要占空间的就是listing和objects这两个文件夹。 这些都是工程的中间文件。 如果你要把工程分享给别人的话。 可以先双击一下这个批处理文件。 这时他就会把这些中间文件都删掉啊。 我们再看一下。 这样就只要两兆左右的大小了。 然后你就可以把这个文件夹打包。 把工程分享给别人了。 好那我们回到q正式开始点亮一个led。 上节课我们也介绍过操作sm 32的g p i o总共需要三个步骤。 第一步使用r c c开启gpu的时钟。 第二步使用g p l e d t函数初始化gp l o。 第三步使用输出或。 者输入的函数控制gpl口。 在这里总共涉及了rc c和gp i o两个外设。 那我们先来看一下这两个外设都有哪些库函数吧。 我们可以在library中找到r c c d区这个文件双击打开。 然后拖到最下面。 在点h文件的最下面一般都是库函数。 所有函数的声明哈。 在这里我们可以看到r c c有很多的库函数。 但实际上这里的大部分函数我们都不会用到。 我们最常用的只有这三个函数。 r c c a h b外设使用控制。 r c c a p p l y是使用控制r c c a p b e外设使用控制。 我们可以右键跳到定。 义啊。 然后这里提示没有信息啊。 这是因为我们刚才把中间文件都删掉了。 那我们重新编译一下。 再跳转。 这时就来到了点c文件里的函数定义上面就有一个函数的介绍。 这个a h b外设时钟控制的函数就是死人或者私人。 a h b外设时钟的下面介绍。 第一个参数就是选择哪个外设。 这里说s t m32 互联型的设备。 可以在这个列表选择。 其他设备。 在下面这个列表选择。 接着第二个参数就是label或者disable。 然后下面的a b2 外设时钟控制和a p p e外设使用控制都是一样的。 操作方法。 第一个参数选择外侧。 第二个参数使人或私人。 如果你不清楚哪个外设是连接在哪个总线上的。 还。 可以在这个列表找一下哈。 列表中出现了。 就肯定是这个中线的外设对吧。 那r c c的扩展数就介绍完了。 最主要的就是这三个函数。 其他的函数基本都用不到。 接着我们再看一下gp i o的库函数。 我们打开g p i o.h的文件。 然后拖到最后。 这些就是gpl的全部库函数了。 我们目前需要了解的就是前面的这些函数。 第一个就是gp o d e d t参数。 可以写gpa gpb等等。 调用这个函数之后。 所指定的gpl外设就会被复位啊。 这就是这个函数的用途。 第二个a f l o d e里也是一样。 可以分为a f l y。 设这个a f l o我们后面再讲。 接着第三个gp l e t就是非常重要的函数了。 这个函数的作用是用结构体的参数来初始化gpu口。 我们需要先定义一个结构体变量。 然后再给结构体赋值。 最后调用这个函数。 这个函数内部就会自动读取结。 构体的值。 然后自动把外设的各个参数配置好。 这种elite函数在s t m32 中。 基本所有的外设都有啊。 一般我们初始化外设都是使用这个elt函数来完成的。 然后第四个是gpl struck it。 这个函数可以把结构体变量-1个默认值。 接下来这四个就是gpu的读取函数了。 然后下面跟着的四个就是gpu的写入函数。 这些函数就可以实现读写gpio口的功能。 然后剩下的这些函数呢我们暂时不会用到。 所以这里面重要的函数就是gpu 1 it和这八个读写函数好。 那我们就来试试用这些函数来操作gpu吧。 我们回。 到m.c文件首先调用的是r c c里面的a b2 y是始终控制函数。 我们复制粘贴到这里。 然后右键跳转到定义。 我们需要点亮pa 0口的l e d。 所以选择r c c a p p l y是g p l a这一项放到第一个参数。 然后继续第二个参数。 选择一label放到第二个参数。 这样始终就开启了。 接着调用gpl一例函数。 跳转定义第一个参数。 选择gpa。 第二个参数是一个结构体啊。 我们先把结构体类型复制下来。 在gpl上面粘贴。 起个名字叫gpl 1 ite structure。 这里这个结构体实际上也是一种局部变量哈。 在有些老的编译器。 他要求所有的局部变量定义必须放到函数的最前面哈。 如果你的编译器是这样的话。 就需要把这一行提到最前面去。 那我这个编译器是支持在函数中间定义变量的。 所以就放在这个位置。 接着我们复制结构体名字。 用点儿把结构体的成员都引出来。 然后还是一个套路。 右键跳转看一下说明。 复制粘贴一下参数。 这样看上去库函数还是很简单的是吧。 基本上都是复制粘贴。 复制粘贴。 这就印证了程序员的最高境界。 ctrl c ctrl v走天下对吧好。 那我们选择这个gp mode type defctrl f。 搜索一下。 然后这里就是gpl的八种工作模式。 ai是模拟输入。 in floating是浮空输入。 i p d是下拉输入。 ipo是上拉输入。 alt o d是开漏输出。 alt p p是推广输出。 a f o d是复用开楼。 a f p p是复用推广。 那我们点灯用的是推挽输出。 所以复制alt p p这一项粘贴到gpl mod这里呢。 接下来gp l p选择引脚。 我们继续右键跳转。 这里gpl ping有多个定义。 我们选择member这一项。 然后选中这个ctrl f。 这里因为我们用的是gp l a外设的0号引脚。 所以选择g p o p0 放到这里。 接着第三个还是一样的套路啊。 输出速度选择50兆赫兹就行了。 最后把g p i o初始化结构体的地址放到g p l e d的第二个参数。 这样初始化就完成了。 当这个gp l e d的函数执行完。 这个gpa外设的020件就自动被配置为推广输出50兆赫兹的速度了。 它内部的主要执行逻辑就是读取结构体的参数啊。 执行一堆判断和运算。 最后写入的g p l配置寄存器。 至于操作的细节我们就不用再关心了。 那到现在gpo初始化就已经完成了。 我们接下来就可以使用gpl的这些输入输出函数了。 本小节先介绍这四个gpu的输出函数。 第一个g p o c beats。 第一个参数是g p l o x。 第二个参数是g p p。 这个函数可以把指定的端口设置为高电平。 第二个gpl resbs参数和上面的一样啊。 这个可以把指定的端口设置为低电平。 第三个gpl rebe。 这个函数有三个参数。 前两个也是指定端口的。 第三个是b value。 这个是根据第三个参数的值来设置指定的端口。 第四个是gpl right。 第一个参数是gpx。 选择外设。 第二个参数是put value。 这个函数可以同时对16个端口进行写入操作啊。 那我们分别来用一下试试。 首先试一下reset bs。 可以看一下函数说明啊。 第一个是g pro x x可以是a到g。 第二个是要写入的gp l p x x可以是零到15。 那我们就写入gpa gpu p0。 这样就行了。 编译一下没有错误哈。 下载看一下。 可以看到这个led就已经点亮了。 这说明我们端口配置的没问题啊。 而且pa 0已经输出低电平。 那我们再换gpl sbs函数试试。 这个参数是一样的。 不用更改哈。 编译下载。 可以看到led就已经熄灭了。 然后我们再试一下第三个函数。 gpl rebeat。 这里前两个参数也是一样的。 第三个参数我们转到定义看一下第三个参数的介绍。 是指定写入的数据值。 这个参数可以是baction这个枚举中的一个字哈。 b reset是清除端口值。 也就是自低电平。 b set是设置端口值。 也就是至高电平。 我们先复制一下b reset放到这里编译下载。 可以看到led又亮起来了。 再把这个改成peter set编译下载。 可以看到led又熄灭了。 这就是这三个函数的用法。 那第四个函数我们下一个地层再介绍啊。 接下来我们先来完成led闪烁的任务。 为了实现lled闪烁。 我们就需要在主循环里写上点亮led延时一段时间熄灭。 而低延时一段时间。 这样的逻辑是吧。 点亮led。 我们可以用这一句。 改成bitter reset。 这样就是点亮led的。 然后复制一下。 改成beset。 这就是熄灭。 而d那中间呢需要加两个延时函数来进行一段延时。 这里我已经给大家提供了一个现成的延时函数代码啊。 在工程的第三个文件夹里。 这两个就是延时函数的模块。 我们先把它们添加到工程里面来。 那我们先复制打开led闪烁的工程。 这里再新建一个文件夹。 名称可以叫system存放系统的资源。 然后把delay粘贴到这里。 回到qq软件。 点击三个箱子的按钮。 添加主也叫system。 把它往上挪个位置。 然后右边添加文件。 打开system。 把d类的两个文件添加进来。 然后o这样d类文件就添加完成了。 最后别忘了点击魔术棒按钮。 添加这个新文件夹的头文件路径。 这样就完成了。 我们可以打开底力点去看一下。 这里就是三个延时函数。 分别是微秒延时。 毫秒延时和秒延时。 打开点c文件可以看到这些函数的定义啊。 这里是用sistatic定时器来实现的。 延时具体怎么实现的。 大家不用管的。 这个颜色函数一般都是直接拿来用就行了。 不需要修改什么。 那我们回到m.c使用这个延时函数模块。 需要先在上面写上井号。 include dele。 点下去。 然后复制毫秒延时函数。 放在这里参数给500。 这样就可以延时500ms了。 然后复制一下。 下面这里也给500ms的延时。 我们试一下编译。 没有错误下载。 我们来看一下。 这时led就开始闪烁了。 如果我们把这个延时改短点。 比如100ms编译下载。 这样led就散得更快了。 这就是第一个led闪烁的代码了。 这里先把100改回成500哈。 这里除了right beat函数外。 还可以用set beats和reset beats来实现。 那我把它们都写上哈。 给大家参考一下。 首先是gpl resbs。 点亮led参数是gpa gpp 0。 接着delay毫秒延时参数给500。 然后gp l sb词熄灭d参数也是gpa。 gpl p0。 接着还是延迟500ms。 这样也可以实现led闪烁编译下载我们看一下。 这样也是可以闪烁的哈。 最后大家可能觉得调用这些函数只能填他给的指定参数啊。 如果我们非要给个-1是高电平。 零是低电平。 这样该怎么办呢。 那我们可以复制一下这个right beat函数。 然后把bit reset改成零。 beset改成一。 但如果直接这样编译的话。 会有两个警告哈。 说的是枚举类型中混入了其他类型的变量。 所以如果想直接写一和零的话。 需要在这里加上强制类型转换。 把一和零类型转换为deteraction的枚举类型。 这样再编译就没有问题了。 然后下载这样也是没有问题的啊。 最后我们再研究一下推挽输出和开漏输出的驱动问题。 我们把这个r d拔掉。 然后把长角插到pa领口。 短角插到负极。 这样led就是高电平点亮的方式。 可以看到l d也是正常闪烁哈。 说明在推广模式下。 高低电平都是有驱动能力的。 那我们把这个端口的模式换成alt o d开漏输出模式啊。 编译下载。 可以看到lled就不亮了。 现在d还是高电平点亮的方式。 led不亮说明开漏输出的模式。 高电平是没有驱动能力的。 我们把id再改回低电平驱动的方式。 可以看到l d又亮起来了。 这说明开了模式的低电平是有驱动能力的哈。 这就印证了我们上一小节讲的推挽输出和开漏输出的特性。 推挽输出高低电平均有驱动能力。 开漏输出。 高电平相当于高阻态。 没有驱动能力。 低电平有驱动能力啊。 那我们把这个改回推完输出。 一般输出用推广模式就行了。 特殊的地方才会用到开发模式好。 这就是led闪。 烁代码的全部内容了。 我们关掉k来看一下第二个代码。 led流水灯。 先来看一下接线图啊。 这里需要拿出八个l led正极都插到正极的供电孔。 负极依次插到pa 0到pa 7的端口。 那我们来插一下电路。 这里可以先插两边的l d哈。 然后掰弯一下。 再插中间的l d。 这样方便一些。 插完电路后。 我们复制一下led闪烁的工程。 改个名字叫三杠二led流水灯。 这样直接复制现有工程。 就不用再费时间新建工程了。 那我们双击这个带有q图标的文件。 这样就可以打开工程了。 然后我们来修改一下这个代码。 实现l led流水灯的程序。 在这里第一句打开g p l a的始终。 因为我们连接的都是gp l a的端口。 所以第一句不用变的。 接着初始化端口的这一部分。 这里只初始化了gpu的0号端口。 我们流水灯用的是gp l a的0~7号端口。 所以这里要加一些端口。 那怎么加呢。 在这里我们可以直接在g p p0 后面加上或gpp 1。 再加上或gpp 2。 这样就可以一次性把三个端口都初始化了。 为什么可以这样来使用呢。 我们转到定义看一下。 这里可以看到p0 对应的数据是零。 x0001。 然后p1 p2 p3 依次为0x00020 x00040 x0008。 如果把这个16进制换成二进制的话。 就是0000000000000001。 然后是001001001000。 在这里每个端口对应一个位哈。 如果把它们进行按位或的操作。 比如p0 p一和p2 按位或。 那结果就是0111。 这样就相当于同时选中了三个端口。 这就是二位获得操作逻辑。 最后我们还可以看到这里有个g p i o po。 它对应的数据就是0x f f f f。 也就是所有位都为一。 这样就。 相当于选中了所有的引脚。 在这里除了这个gp l p可以用按位或者操作方式外。 这个时钟控制的这一项。 也是可以用按位或者操作方式来选择多个外设的。 你看它这里的定义也是一样的。 数据的规律是每一位对应一个y设。 还有这个g p i o c的beats。 这里也可以用按位或选择多个硬件。 这样就能同时设置多个硬件了。 所以这个函数名字也多了个s叫三的b次reset up bs也是一个意思。 在这个函数介绍里也写了这个参数可以是gp px的任意组合。 说的就是这个方式哈。 那介绍完安慰或者。 这种操作方式我们就可以在这里使用按位或把这八个引脚都选上哈。 当然这里我就直接写gpl拼好了。 这样就把16个端口全部配置。 为了推广输出模式。 然后是主循环里面。 我们先把这些删掉。 现在为了同时控制16个端口。 我们就可以使用gpl right这个函数了。 我们复制过来。 第一个参数是g pro x。 我们直接写g p l a。 第二个参数我们转到定义看一下。 这里写的是指定写的输出数据寄存器的值。 下面我们可以看到这。 第二个参数就是直接写到gpl的o d r寄存器里的。 所以我们可以写零。 x0001 对应二进制就是0000000000000001。 因为c语言不支持直接写二进制啊。 所以这里只能转化为16进制来写。 这16个二进制分别对应pa 0到pa 15。 总共16个端口。 玩最低位对应pa 0。 然后往上依次是pa 1 pa 21直到pa 15。 因为是低电平电量。 所以前面再加一个按位取反的符号。 这样就是第一个l d点亮。 其他都熄灭了。 就在d内500ms。 然后复制一下。 然后这里依次改为零二。 这里对应二进制就是001004010008100010。 这里是000100010400100801000。 这样就行了。 高八位我们暂时不用哈。 我们编译看一下。 没有错误下载。 可以看到led 14点亮。 如果想快一点的话。 这里可以改成100ms。 再试一下。 现在就快一些了。 如果你想换一种形式的流水灯。 这里的数据对应更改一下就行了。 或者定义一个数组。 一次取出数组中的数据来进行花式点灯。 这都是没问题的。 在这里我就不过多的演示了哈。 那我们第二个程序led流水灯到这里就完成了。 接下来是第三个程序分频器。 通过前两个程序的学习。 这个就应该简单多了吧。 我们先看一下接线图。 这个vcc正极接到正极供电孔基地。 负极接到负极供电后。 然后l控制集就随便选择一个l口接上就行了。 这里我选择的是pb 12号口。 那大家注意一下哈。 这个a 15 b3 b4 这三个口大家先别算。 我们从引脚定义图可以看到。 这三个口默认是g tag的调试端口。 如果要用作普通端口的话。 还需要再进行一些配置。 我之前在使用的时候就没注意到这一点啊。 我说我明明已经配置好了。 这三个端口怎么就不输出呢。 最后才发现这三个是调试端口啊。 好那我们就来连一下电路。 首先拿出分明器模块和三根公对母的杜邦线带孔的这一端。 插在蜂鸣器上。 另一端橙色的是vcc插在正极供电孔。 灰色的是基地插在负极供电孔。 红色的是控制角。 插在pb 12号口。 这样我们硬件电路就完成了。 我们给pb 12输出低电平分频器就会响。 输出高电平分频器就不响。 那我们复制一下led闪烁的程序。 改个名字叫三杠三分频器。 打开工程。 这里程序相信大家应该都已经会写了吧。 首先是时钟。 因为我们用的是pb口。 所以这里改为g p l b。 然后是端口p b 12号。 所以这里是ping 12端口模式。 仍然是推广输出速度50兆初始化。 这里也应该是对g p b的初始化。 到这里。 我们的pb 12号口就已经初始化好了。 然后是输出。 我们把这些先删掉啊。 这两个地方都改为b 12。 这就完成了。 我们看一下。 下载可以听到分频器已经在想了哈。 我们让他换个响的模式啊。 这里改成这样。 复制一下。 想100ms停100ms再响。 100ms再停700ms。 编译下载。 这样的声音就和我们最开始演示的一样了哈。 那最后再给大家介绍几种使用库函数的方法。 那第一种就是像我这样先打开点去文件的。 最后看一下都有哪些函数。 然后在右键转到定义。 查看一下函数和参数的用法。 这里全都是英文的。 如果看不懂的话。 借助一下翻译软件就行了。 比如我这里打开有道词典。 然后把这个画质的勾勾上。 再选中这个英文。 就可以出现中文司机的使用还是非常方便的。 第二种呢就是打开我提供资料文件夹里的这个库函数。 用户手册。 这里面有所有函数的介绍和使用方法。 这个文档是中文的。 看起来比较好理解。 而且这个函数下面都还给了例子。 要用的话直接复制过来就行了。 不过这个用户手册的版本并不对应我们现在用的这个库函数的版本哈。 我们看一下。 我们使用的库函数是v3.五点版本的。 这个用户手册是老版本库函数的。 所以有部分用法会有些出入。 但是整体上的差异都不大。 参考这个用户手册也是没有问题的。 那v3.五点的库函数有没有这样的用户测试呢。 我从网上了解的是。 目前还是没有的。 s t公司并没有发布v3.五点版本的库函数用户手册。 而是在这个固件库压缩包中给了这样的一个帮助文档。 我们可以打开看一下。 可以找到gpo这一节。 来看一下这种帮助文档。 可以像这样跳来跳去的。 如果你习惯这种方式的话。 也可以参考这个文档。 不过这个只有英文的版本。 那最后一种方式呢就是百度搜索。 参考一下别人的代码。 我们可以打开百度搜索s t m32 g p i o。 这里都有介绍哈。 我们搜索一下gpu初始化程序。 可以点开看看。 这里都有例子哈。 直接参考一下。 拿过来用就行了。 像我在学习啊s t m32 的时候。 也会经常去参考别人的程序哈。 要不然怎么知道该用哪些函数呢。 是吧好。 那我们本小节的任务到这里就全部完成了。 我们下一小节再来继续学习gpl的输入部分。
7. 欢迎回来啊。 那我们先看一下本节程序的现象。 本节课一共要写两个程序。 第一个是按键控制led。 第二个是光敏传感器控制分离器。 我们先来看一下第一个程序。 编译。 下载。 这里我已经连接了两个按键和两个l e d。 那我按下左边的按键。 左边的led点亮。 再按一下熄灭。 然后继续按这样子。 如果按右边的按键。 那右边的l d也会点亮熄灭。 点亮熄灭。 并且两个操作互不影响啊。 一个按键控制一个led的亮灭。 这就是第一个程序的现象。 接着再看一下第二个程序的现象。 下载。 这里我连接了分频器模块和光敏电阻传感器模块。 当我用手挡住光敏电阻光线变暗时。 分频器就会明显。 当我的手拿开光线变亮。 蜂鸣器就停止。 这就是第二个程序的现象好那我们回到ppt上。 两小节我们已经把gpu的结构和八种输入输出模式都讲完了哈。 所以本小节gpl输入的部分我们就直接从外部硬件设备开始讲了。 另外本小节还要再给大家介绍一下c语言的相关知识点。 宏定义。 tab defi结构体和枚举这些知识点。 这些知识点都是。 库函数里经常且反复出现的东西啊。 我再给大家详细的介绍一下。 了解了这些知识点。 你对库函数的执行逻辑就会理解的更加清晰明了。 至于c语言的if else啊。 加减乘除运算啊。 这些东西。 这是最基本的东西啊。 相信大家应该都已经会使用了。 在这里我就不再赘述了。 另外还有一个重要的知识点就是c语言的指针。 我之前已经录制过了一期指针的视频啊。 里面详细介绍了指针的含义和用法。 如果你对c语言的指针还不熟悉的话。 可以到我的视频主页里先看一下指针在哪一期视频好。 那。 我们先来看一下gpl输入模式下的硬件和电路吧。 首先是按键。 这个按键是最常见的输入设备了。 按下导通松手断开。 那下面这个图就是我们套件里的按键。 实物图。 上面白色的是按钮。 下面有两个银角。 当按钮按下去的时候。 下面两个引脚就是接通的。 松手后。 这两个零件就自动断开了。 这个执行逻辑太简单了是吧。 我就不过多介绍了。 接着看一下在单片机中应用按键时候的一个现象。 就是按键抖动现象。 所以在按下和。 松手的瞬间会伴随有一连串的抖动。 通过下面这个波形就可以看到。 假设按键没按下。 是高电平。 按下来就是低电平。 那在按下的瞬间信号由高电平变为低电平时就会来回抖动几下。 这个抖动会比较快哈。 通常在五到10ms之间。 人眼是分辨不出来的。 但是对于高速运行的单片机而言。 五到10ms的时间还是很漫长的。 所以我们要对这个抖动进行过滤。 否则就会出现按键按一下单片机却反映了多次的现象。 另外在按键松手的时候。 也会有一小段时间的抖动。 这个我们在程序中也要注意。 过滤一下啊。 最简单的过滤方法就是加一段延时。 把这个抖动时间耗过去。 这样就没问题了。 接着我们再来看一下传感器模块的介绍。 我们套件里提供了四种传感器模块。 分别是光敏电阻传感器。 热敏电阻传感器对射是红外传感器。 反射是红外传感器。 它们的电路结构和工作原理都差不多。 那这些传感器模块呢。 它们都是利用传感器元件。 比如光敏电阻。 热敏电阻。 红外接收管等。 这些软件的电阻会随外界的模拟量变化而变化。 比如光线越强。 光敏电阻的阻值就越小。 温度越高。 热敏电阻的阻。 值就越小。 红外光线越强。 红外接收管的组织就越小。 但是电阻的变化不容易直接被观察。 所以我们通常将传感器软件与定值电阻进行串联分压。 这样就可以得到模拟电压的输出了。 对电路来说。 检测电压就非常容易了。 另外这个模块还可以通过电压比较器来对这个模拟电压进行二值化。 这样就可以得到数字电压输出了。 那我们看一下下面这个电路图。 这个就是传感器模块的基本电路。 我们先看一下这个部分。 它的组织可以根据环境的光。 线温度等模拟量进行变化。 上面这个r一是和n一进行分压的定值电阻。 i一和n一串联。 一端接在vc c正极。 一端接在接地负极。 这就构成了基本的分压电路。 左边这个c2 是一个滤波电容。 它是为了给中间的电压输出进行滤波的。 用来滤除一些干扰。 保证输出电压波形的平滑。 一般我们在电路里遇到这种异端。 接在电路中。 另一端接地的电容都可以考虑一下这个是不是滤波电容的作用。 如果设滤波电容的作用。 那这个电容就是用来保证电路稳定的。 并不是电路的主要框架。 这时候我。 们在分析电路的时候。 就可以先把这个电容给抹掉。 这样就可以使我们的电路分析更加简单。 那我们把这个电容抹掉。 整个电路的主要框架就是定值电阻和传感器电阻的分压电路了。 在这里可以用分压定理来分析一下传感器电阻的阻值变化。 对输出电压的影响哈。 当然我们还可以用上下拉电阻的思维来分析。 当这个n一阻值变小时。 下来作用就会增强。 中间的a o端的电压就会拉低。 极端情况下n一组织为零。 ao输出被完全下拉。 输出零-2。 当一阻值变大。 下压作用就会减弱。 中间的。 引脚由于r一的上拉作用。 电压就会升高。 极端情况下n一阻值无穷大。 相当于断路输出电压被r一拉高至v cc。 这是用上下拉电阻来分析电路的。 我可以举个例子来说明上下拉电阻的工作逻辑哈。 ao这个输出端。 你可以把它想象成一个放在屋里的水平杆子。 r一上拉电阻相当于拴在屋顶的弹簧。 将杆子往上拉n一下拉电阻相当于拴在地面的弹簧。 将杆子往下拉。 这个电阻的阻值越小。 弹簧的拉力就越强啊。 这个杆子的高度就相当于电路中的电压。 如果只有上拉弹簧或者下拉弹簧。 那。 杆子肯定被拉到了屋顶或者地面。 在电路中就相当于中间点的电压为vc c或者jd。 那当两个弹簧相互拉扯的时候。 中间的输出端就会像拉力强的一端偏移。 至于偏移多少就取决于两个弹簧的弹力之差了。 如果上下拉弹簧的弹力一致。 则感知会处于居中的位置。 也就是电路输出二分之vcc的电压。 如果上面的阻值小拉一强。 那输出电压就会变高。 反之下面的阻值小。 输出电压就会变低。 如果组织为零。 在电路中就是短接的状态。 那就相当于拉力无穷大了。 如果上下拉电阻的阻值都为零。 就是。 两个无穷大的利益在对抗。 在电路中呈现的状态就是电源短路哈。 所以这种情况应该避免。 这个上拉电阻和下拉电阻在单片机电路中会经常出现哈。 比如弱上拉弱下来。 墙上拉强下拉等。 这里强和弱就指电阻阻值的大小。 也就是这个弹簧弹力的大小。 上拉和下拉就只是接到vcc还是jd。 也就是这个杆子是拉向屋顶还是拉向地面。 最终的输出电压就是在弹簧拉扯下最终感知的高低。 那大家以后再遇到上拉电阻和下拉电阻的分析。 就可以尝试一下。 用我这个感知和弹簧的模型来分析一下。 相信你会有更加深刻的理解了哈。 那我们回到这个电路继续来看。 在这两个电阻的分压下。 a o就是我们想要的模拟电压输出了。 这就是ao电压的由来。 仅需两个电阻分压即可得到。 那接下来这个模块还支持有数字输出。 这个数字输出就是对a o进行二值化的输出。 这里二值化是通过这个芯片lm 393来完成的。 这个lm 393是一个电压比较器。 然后剩下的是vcc和gt供电。 那我们。 vcc就接到电路的vcc接地。 也接到了电路的接地。 这里有个电容。 是一个电源供电的滤波电容。 这个电压比较器其实就是一个运算放大器哈。 有关运算放大器的知识。 我在五一单片机视频的a d d a那一集也有讲过哈。 大家不会的可以去看一下。 那我画一下这个运算放大器当做比较器的情况。 当这个同向输入端的电压大于反向输入端的电压时。 输出就会瞬间升为最大值。 也就是输出接vcc。 反之。 当同向输入端的电压小于反向输入端的电压时。 输出就会瞬间降为最小值。 也就是输出接近地。 这样就可以对一个模拟电压进行二值化了。 我们看一下实际的应用啊。 这里同样输入端音正接到了ao。 这里就是模拟电压端。 应付呢接了一个电位器。 这个电位器的接法也是分压电阻的原理哈。 理动电位器n负就会生成一个可调的阈值电压。 两个电压进行比较。 最终输出结果就是d数字电压输出。 d o最终就接到了引脚的输出端。 这就是数字电压的由来。 然后右边这里还有两个指示灯。 电路左边的是电源指示灯。 通电就亮哈。 右边的是d o输出指示灯。 它可以指示d o的输出电平。 低电。 平点亮高电平熄灭。 那右边d o这里还多了个i5 上来电阻哈。 这个是为了保证默认输出为高电平的。 然后就是p一的排针分别是vcc进d d o和ao。 那右上角这个图就是四个传感器模块了。 对于光敏电阻传感器来说。 这个n一就是光敏电阻。 对于热敏电阻传感器来说。 这个n一就是热敏电阻。 对于这个红外传感器来说。 这个n一就是一个红外接收管。 当然对应还会多一个点亮红外发射管的电路。 在这里。 发射管发射红外光。 接收管接收红外光模拟电压。 就表示的是接收光的强度。 那这个。 模块在这里啊。 电位器是直接换成了两个电阻进行分压哈。 这样数字输出就是固定阈值的二值化了。 这个模块通常用来检测通断哈。 所以阈值也不需要过多的调整。 那最后一个模块也是一个红外发射管和接收管啊。 只不过它是向下发射红外光。 然后检测反射光的。 这个可以用来做循迹小车。 接下来我们就来看一下按键和传感器模块的硬件电路吧。 首先案件这里我给了四种解法。 上面两个是下键按键的方式。 下面两个是上阶按键的方式。 一般来说我们的按键都是用上两种方式啊。 也就。 是下接的方式。 这个原因跟l led的接法类似啊。 那我们先来看一下第一个图。 这种解法是按键的最常用的解法了。 在这里随便选取一个g p l口。 比如p a0。 然后通过k一接到d。 当按键按下时。 pa 0被直接下达到gd。 此时读取pa 0口的电压就是低电平。 当案件凶手时。 pa 0被悬空。 悬空会出现什么情况呢。 就是引脚的电压不确定对吧。 所以在这种接法下。 必须要求pa 0是上拉输入的模式。 否则就会出现零点电压不确定的错误现象。 如果p10 是上拉输入的模式。 那我们之前讲了。 银角再悬空p10 就是高电平。 所以这种方式下按下按键引脚为低电平。 松手引脚为高电平。 接着再看一下第二个图。 相比较第一个图在这里外部接了一个上拉电阻。 这个意思大家就清楚了吧。 这个上来大家可以想象成一个弹簧。 把这个端口往屋顶上拿。 当按键松手时。 银角由于上拉作用自然保持为高电平。 当按键按下时。 银角直接接到基地。 也就是一股无穷大的力。 把这个银角往下拉。 那弹簧肯定对抗不了无穷大的力啊。 所以银角就为低电平。 这种状态下银角不会出现。 悬空状态。 如果是上拉输入。 那就是内外两个上拉电阻共同作用的啊。 这时高电平就会更强一些。 对应高电平就更加稳定啊。 当然这样的话。 当鹰角被强行拉到低时。 损耗也就会大一些哈。 那接着第三个图。 pa 0通过按键接到3.3伏。 这样也是可以的哈。 不过要求p0 必须要配置成下拉输入的模式。 当按键按下时。 引脚为高电平。 松手时银角回到默认值低键平。 再要求单片机的引脚可以配置为下拉输入的模式啊。 一般单片机可能不一。 定有下拉输入的模式。 所以最好还是用上面的解法。 下面的作为扩展部分啊。 大家了解一下即可。 那最后一种解法呢就是在刚才的这种解法下面。 再外接一个下拉电阻。 自己分析。 大家应该已经清楚了。 我就不再细讲了。 那总结一下。 就是上面这两种接法。 按键按下时银角是低电平。 松手是高电平。 下面这两种解法按键按下时是高电平。 松手是低电平。 左边两种解法必须要求引脚是上拉或者下拉输入的模式。 右边两种解法可以允许。 因为已经外置了上拉电阻和下拉电阻啊。 一般我们都用上面两种解法哈。 下面两种解法用的比较少。 那到这里按键的硬件电路就介绍完了。 再看一下右边的传感器模块的电路。 因为是使用模块的方案。 所以电路还是非常简单的。 这里vcc接3.3伏接地接接地用于供电d o数字输出。 随便接一个端口啊。 比如p a0 用于读取数字量a o模拟输出呢。 我们之后学a d c模数转换器的时候再讲。 现在还是不用接了哈。 好那我们本节课的主要内容到这里就差不多了。 首先是c语言数据类型。 这个c语言数据类型是个很基础的东西啊。 大家刚学c语言就应该接触到这些东西了吧。 那我把这个列出来。 主要是提几个注意事项。 我们看一下这个表。 左边这三列就是c语言数据类型的关键字所占位数和数的表示范围了。 比如恰似有符号字符型占八位。 可以表示-128~127的整数。 鞍山的char是无符号字符型占八位。 表示0~255。 然后下面就是sht和n3 的shot。 在16位表示的输入是这些int和i3 的。 int是占32位的。 表示的数就是右边这些。 这个需要注意一下哈。 在五一单片机中。 int是占16位的。 而在s t m32 中。 int是占32位的。 如果要用16位的数据。 要用笑来表示。 这是和五一单片机的不同之处哈。 不要混淆了。 然后下面还有这个now和sn占用的也是32位哈。 跟int是一样的。 所以别想着char short int这样排下来。 那应该是64位哈。 但其实none还是32位的。 如果想用64位的。 需要用到nn和鞍山的long long这个数据类型。 不过这个数实在是太大了哈。 我们用的比较少。 然后是。 float和double。 这些是用来存小数的。 float和double都是带符号的数。 没有无符号的float和double。 然后我们看一下右边在这里写的是c语言。 s t d n t点去文件和s t对这些变量的重命名啊。 因为左边这些名字比较长。 而且这个int的位数根据系统的不同。 还有可能不一样。 还有个就是这些名字有时候会名不对题哈。 比如这个恰本意是字符型数据的意思。 按名字来说。 它就应该存放字符的。 但是我们单片机通常用它来存放整数。 而不是字符。 所以综上各种原因吧。 c语言和sg就给这些变量换了个名字。 c语。 言提供的有s t d n t这个头文件使用了新的名字。 比如int 8杠t就是chat新名字表示的意思就是八位整型数据。 右边加个gt表示这是用tab defi重新命名的变量类型。 type define是用来给变量类型重命名的。 这个等会儿就讲啊。 然后这里ecchr的新名字就是uint 8杠t。 意思是无符号八位整型数据。 然后int 16杠t u int 16杠t int 32杠t u int 32杠t。 int 64杠t u int 64杠t这些通过名字就知道意思了。 就是16位整形。 32位整型。 64位整形的意思。 那我们以后在写程序的时候就会。 按照他的推荐哈。 使用这些新的名字。 那大家要知道他们代表的就是前面的这些数据类型。 就是换个名字而已。 我们打开这个程序来看一下。 这里先切回到分配器的程序哈。 然后在gpl点距离找下。 这其中就出现了这些unit 8杠t。 unit 16杠t。 这个uint 8杠t就相当于an schuint 16杠t就相当于an ssht。 这明白了吧。 另外这里我还列举出了这个st定义的名字。 像u8116 这些。 这是st库函数以前用的名字。 比如我打开库函数手册。 这个手册是老版本的。 所以还能看到这个u8 u16 这些。 那在新版。 库函数这里已经换成了uint 8杠t和unit 16杠七这样的了。 不过这个新版本库函数仍然支持u8 u16 这样的写法。 比如我写一个u8。 然后跳到定义。 在这里可以看到它就是把uint 8杠七又改了个名字叫u821。 然后uint 8杠七再转到定义。 可以看到这个uint 8杠t就是安生的char。 改个名字。 不过这个u8 定义这里上面有注释写了。 这是库函数。 老的类型是为了传统的目的而保留的。 说白了就是为了兼容老版本。 所以目前我推荐大家使用这一列的数据类型定义。 这是新版本固函数使用的方式。 也是c语言s t t i n t头文件里提供的官方定义哈。 接下来我们再来看一下c语言中的宏定义。 这个比较简单哈。 我们在五一单片机中都遇到过。 那我们看一下这个宏定义的关键字是井号def。 它的用途是用一个字符串代替一个数字。 便于理解。 防止出错。 比如我们在程序中经常用。 一代表高电平。 零代表低电平。 这个还算好理解啊。 但是如果说一代表上来输入。 二代表下拉输入三代表浮空数等等等等。 这时直接用数字来表示就非常麻烦了是吧。 那我们就可以用宏定义将数据参数映射到一个字符串上。 这样就比较好理解。 然后第二个用途是提取程序中经常出现的参数。 便于快速修改。 比如说我们写程序里面出现了十个g p l p0。 这个p0 是需要经常修改的。 那如果一个个修改就太不方便了是吧。 这时候我们就可以用一个字符串来代替gp l p0。 然后需要修改。 的时候只需要修改一下定义即可。 那这些就是宏定义通常的用途啊。 接着我们看一下定义宏定义哈。 这里写的是defi abc。 然后12345这个意思就是用a b c这个字符串替代。 12345这个参数。 我们引用这个宏定义是直接写int a等于a b c。 那它就等效于int a等于12345这个意思。 那我们打开程序可以看一下这个gp l p 12。 其实就是一个宏定义字符串。 我们跳转的定义可以看到gpl p 12替换的是0x1000。 这个数据左边这里是一个强制类型。 转换是为了严谨性考。 虑的我们暂时不用管的。 那在这里就是0x1000 表示12号口。 这个是不容易理解的啊。 所以我们用宏定义将12号口的数据改下。 名字叫g p l p 12。 这样就比较好理解了。 那在这里写gpp in 12。 就等效于在这里我们把这个复制下来。 然后粘贴到这里。 这是程序实际执行的内容。 但这样不便理解。 所以我们就使用了宏定义进行改名。 那剩下的还有这个r c c a b2。 外设g p b也是一个宏定义的替换。 还有这个g p b也是宏定义的替换。 那这些就是库函数中宏定义的用法。 当然。 宏定义还有其他的很多用法哈。 以后遇到再说。 在这里就不再细说了。 接下来是tap里放它的关键字就是tap。 敌方它的用途和宏定义的用途差不多哈。 它是将一个比较长的变量类型换一个名字。 便于使用。 说白了也是换名字的一个语句。 那定义tab敌方就这样写。 tab defi sa char。 然后you int 8杠t。 注意后面得加个分号啊。 这个type define和宏定义有哪些区别呢。 首先宏定义的新名字在左边啊。 tab defender新名字在右边。 然后是宏定义不需要分号。 tap里放后面必须加分号。 还有就是宏定义任何名字都可以换。 而菜谱。 里范只能专门给变量类型换名字。 所以宏定义的改名范围要更宽一些。 只不过对于变量类型重命名而言。 使用tab敌方更加安全。 因为宏定义只是无脑改名管理。 对不对。 而他不理发会对命名进行检查。 如果不是变量类型的名字。 那是不行的。 所以给变量类型从命名。 我们一般用tab defi。 比如tap里fan schuint 8杠t。 把scar重命名为uint 8杠t。 然后在程序中直接写uint 8杠t a那它就等效于i3 的恰a。 当然原来的名字and sa chair还是能用的。 这里的重命名只是增加了一个新名字。 原名字也是可以用的哈。 那。 在程序中我们这里的uint 8杠t u int 16杠七等等。 都是用tab离范重命名的数据类型。 接下来我们就来介绍一下c语言的结构体啊。 这个在库函数中出现的频率也是非常高的。 要理解库函数的运作逻辑。 理解结构体那是非常必要的。 那在c语言中。 结构体是用来干什么的呢。 其实结构体也是一种数据类型哈。 比如char short int等。 这些我们可以称作基本数据类型。 然后数组就是一大堆基本数据类型的集合。 比如定义恰a方括号十。 这就是十个恰行数据的集合对吧。 那数组我们就可以称作组合。 数据类型它是由许多基本数据类型组合而来的。 数组组合的只能是相同的数据。 比如这里就是十个下行数据的组合。 或者int b方括号20就是20个int型数据的组合。 数组只能组合相同类型的数据。 那如果我们想组合不同的数据类型。 该怎么办呢。 于是c语言的结构体就出现了。 结构体也是一种组合数据类型。 它的作用就是组合不同的数据类型。 我们看一下它的用途啊。 在一个复杂的程序里。 将有利于我们管理或者。 传递这些数据啊。 并且有利于程序员的理解。 那接下来我将使用d e v c加加这个软件。 来演示一下结构体的使用方法。 这里我已经写了一个最简单的hello world程序。 运行一下就输出helloworld哈。 那接着我们就在这个工程上研究一下结构体。 对于c语言的数据来说。 主要就是两个功能。 一个是定义数据啊。 一个是引用数据。 那既然结构体也是数据类型。 那它就应该和其他数据类型差不多。 也分为定义和使用。 首先定义数据。 比如int a。 这是定义一个int型的数据名字叫a对吧。 这个很简单。 然后是数组比。 如int b方括号五。 这是定义一个五个int型数据的数组名字叫b。 这个大家也很熟悉啊。 画个内存图。 编号依次为01234。 这就是数数啊。 那接下来就是结构体。 我们就可以写struct c。 这就是定义一个结构体。 数据名字叫c简单吧。 那当然是不可能这么简单的啦。 既然是不同类型数据的组合。 我们就得告诉他是哪些数据的组合对吧。 所以我们还得在这里加上一个附加说明。 告诉他是哪些数据。 我们要在struck的后面加上一。 对花括号。 比如恰行的x加分号。 int型的y封号。 float型的z分号。 这样才是结构体的完整定义。 这一句的意思就是定义一个结构体变量名字叫c。 画个内存图。 叫c里面放了三个变量。 第一个是恰型叫x第二个是int型叫y。 第三个是float型叫z。 这就是结构体的定义。 接着定义完了就要开始引用了对吧。 那int a引用就直接写。 比如a等于六六。 直接调用名字就可以应用了。 这个。 最简单。 然后就是数组的应用。 数组的引用是数组名b加上方括号取索引。 比如数组的第零个元素等于六六。 然后b方块21=77。 b方块2=88。 这就是数组的引用。 最后就是结构体的应用了。 结构体如何运用呢。 我们需要写结构体名字c然后用点运算符取索引。 这里的索引就不是01234这样的。 而是结构体指向的名字。 比如c.x它等于一个字符a。 然后c.y它等于一个数六六。 这就是结构体变量的引用格式。 就是结构体名称加上点。 然后结构体指向的名称来引用结构体的成员。 那我们编译一下。 可以看到这样是没问题的啊。 接着我们再打印一下。 看看数据到底对不对呢。 首先print f a等于2%d斜杠n。 然后a然后print f b方块零等于2%d斜杠n。 然后b方块二零复制粘贴一下哈。 改一下一。 然后是结构体print f c dx等于2%c。 因为这个变量是恰行的哈。 所以要用百万c。 然后斜杠n c.x复制粘贴。 改一下c.y c.z。 然后c.y是int型。 要用2%d c.z是float型。 要用2%f好运行一下。 这里可以看到abc这三个变量都是没问题的。 到这里类比基本变量和数组来理解结构体应该还算简单吧。 接下来我就来介绍结构体的特殊用法了。 我们先把这些删掉。 首先第一个问题就是这个结构体的名字太长了。 这里如果想再定义一个结构体d的话。 还得复制这一长串。 然后再定义d每次都写这么一大串。 太麻烦了是吧。 所以我们刚才讲的type define的作用就显现出来了。 那我们可以在这里写上开不敌范。 把这一大串名字拿过来。 然后起个新的名字。 比如struct name杠t。 最后别忘了分号。 当给出了这个新名字之后以后。 我们再定义这个结构体的时候。 就可以直接用struct name杠t来换掉原来的那一长串。 这样看上去就简单多了吧。 另外还有就是这个结构体成员可能会比较多。 我们一般会换个行来写。 比如这样。 这就是我们通常看到的格式哈。 所以你以后再看到这样的格式就应该知道了。 然后是type define。 将结构体换个名字叫struck杠t。 下面这里的这一个就是结构体的数据类型。 然后后面跟着的是结构体变量的名字。 那我们直接使用结构体变量的名字。 然后用点来引出结构体成员的数据。 这样就可以进行数据的写入和读取了。 学到这里。 我们再来看一下库函数中的用法。 这句是定义结构体类型的数据。 数据名称叫gpl elite structure。 左边是结构体类型名。 称我们转到定义这里。 是不是就明白了。 这里是结构体数据类型。 然后用tab define将这个类型换一个新名字。 叫g p i o1 it tab defi是不是和我们演示的这里基本一样。 然后引用结构体成员。 这里是不是也是结构体变量名加点。 然后结构体成员名这样的形式啊。 右边就是赋值的数据了。 那我们回到ppt来看一下。 这里定义结构体变量。 就是struct。 发括号恰x int y float z。 然后是struct name。 结构体变量的名字。 下面写了。 因为结构体变量类型较长。 所以通常用tab defi更改变量类型名。 这就是我们刚才。 演示的type define这样的形式。 然后引用结构体成员。 就是结构体变量名加点。 然后结构体成员名。 这也是好理解的哈。 但是最后这里又多了一种应用方式。 就是结构体的首例子。 也就是结构体指针加上杠大于号。 这个运算-2。 再加上结构体成员名。 这样也可以引用结构体成员。 所以说结构体成员的引用方式有两种。 一种是结构体变量名。 点结构体成员名。 另一种是结构体指针名更大于号。 结构体变量名。 为什么要加一种结构体指针的引用方式呢。 这是因为结构体是一种组合数据类型。 在函数之。 间的数据传递中通常用的是地址传递。 而不是直传递。 有关地址传递值传递。 还有指针的相关知识点啊。 可以看一下我的指针教程。 我在那个视频里把这两种传递方式的用法和利弊都讲了哈。 那我们回到这个问题来。 既然是使用指针传递指函数。 得到的就是结构体的首地址。 这时候我们就可以用更大于号这个运算符快速的引用结构体成员哈。 我们打开s t m32 程序。 这里可以看到这个结构体变量再传递给gp一类的函数时。 传递的是结构体的地址哈。 然后对应gpl一列的函数里。 这里。 就是用结构体指针来接收的。 然后里面再引用结构体成员时。 就可以直接使用杠杆大于号这个符号来引用。 当然这里你直接用星号引出指针变量的内容。 再用点儿来引用结构体成员也是可以的哈。 只不过用杠大于号这个运算符更加方便而已。 那回到主函数里面。 我们可以看出来啊。 首先将参数写的结构体的这三个变量里。 将结构体传递到函数里。 接在函数里面。 读取变量。 这就是使用结构体的整个过程。 你。 可能会想啊。 为什么要这样麻烦呢。 直接在这里多定义几个参数不就行了。 这个确实没问题。 但当这个函数需要十个八个参数时。 参数就太多了。 不方便管理。 所以这里就统一使用了结构体的传唱方式。 我们也只能按照他的安排来写了是吧。 那接下来最后一个就是c语言的枚举了。 首先枚举的关键词是这个alarm。 这个枚举跟结构体差不多。 也是一种数据类型啊。 下面可以看到枚举的用途是定义一个取值受限制的整形变量。 用于限制变量取值范围。 比如我们定义一个变量用来存储信息的值。 那理论上这个变量只能取1~7的值对吧。 但是如果你定义的是整形变量。 那这个变量随意存什么都行。 不会受到限制。 这时可能会出现数据不合法。 比如星期八的情况出现。 所以这个时候如果你想要程序更加安全一些。 就可以定义一个取值受限制的整形变量。 这个变量就是枚举。 另外这个枚举变量也可以当做一个宏定义的集合哈。 这个我们等会儿再看。 接下来我们到d e v c加加里来看一下。 首先枚举也是一种数据类型是吧。 那也是两个问题。 定义和引用。 定义和结构体差不多哈。 这。 里写animal。 然后是变量名字。 比如wake。 接着同样需要在alarm后面加上花括号。 来指定这个变量可以有哪些取值。 比如monday等于一逗号。 这里和结构体不一样哈。 需要用逗号隔开。 然后tuesday等于二逗号。 wednesday等于三。 然后等等我就不写了哈。 这样就可以限制wake这个变量的取值范围。 只能取代花括号里面的词。 另外这里面的定义啊。 如果数是按照顺序来加的。 那后面的赋值可以省略哈。 比如这个等于2=3。 因为是顺序的数可以去掉。 编译器会自动填上顺序值的。 同样这个变量类型名比较长哈。 我们可以用tab。 define改一下名。 那就这样写。 太普defi枚举类型。 然后枚举新名字。 比如叫wake杠t。 然后也换一下行哈。 下面这里就可以直接用wake杠t。 这样就定义好了枚举变量。 然后是引用。 当给它赋值时。 只能写wk等于monday。 这就等效于week等于一克等于tuesday。 等效于week等于二。 这个赋值只能按枚举中的定义了啊。 如果你写week等于八。 那编译器就会报警告说你枚举中混入了其他变量。 不过我这个编译器这样编译也没有提出金刚啊。 这个可能编译器比较宽容吧。 那在q5 软件中。 要是这样写的话。 就会报警告了。 比如我们试一下这个label就是一个枚举值。 我们转到定义。 可以看到它是一个这样的枚举哈。 我们复制一下枚举类型名。 试一下哈。 在这里定义一个枚举变量a。 然后赋值a等于elibel或者a等于disable。 我们编译一下。 这里有一个警告哈。 说的是变量a定义了。 但从来没有被使用。 这个不是负值的问题哈。 这说明我们这样赋值是被允许的。 那我们再随便赋值一个。 比如a等于100。 这样再编一下。 就是两个警告。 首先说的就是枚举中混入了其他类型。 这就是枚举的作用。 只能在他给定的参数列表里赋值。 不能负其他的值。 不过在这里我赋值a等于零。 看一下。 它也不行啊。 但是您确实是枚举中的值。 这个我感觉有点不人性化啊。 虽然零也是没居中的值。 但它只能赋值这个字符串。 不能直接给您哈。 如果想复制零。 还得进行一下类型强转。 把它转化为对应的枚举类型。 这样才没有问题。 那这就是枚举的用法了。 在这个工程里。 比如这个enable就是枚举变量。 还有下面的gpl mod看一下也是枚举变量。 这个gpu sweet也是枚举啊。 另外还有这个枚举值也不是必须赋值给枚举变量的。 我们可以随意定义一个变量。 把枚举值赋给他都行。 比如我这里写int a等于一label编译。 看一下。 这里只有个定义圈没使用的警告。 说明这也是没有问题的。 这样枚举中的定义就和宏定义差不多哈。 所以p p t在这里说枚举也是一个宏定义的集合啊。 就是这个意思。 那下面这些定义枚举和引用枚举。 大家看一下应该都没问题了哈。 好到此。 本小节的内容就已经全部讲完了。 我们讲了宏定义。 tab defi结构体枚举这些东西。 实际上这些东西都不是c语言最根本的语法哈。 没有这些东西。 c语言照样可以完成它的功能。 这些东西创造出来是为了我们编程人员更好地管理我们的工程。 虽然表。 面上这些操作感觉是多此一举哈。 但是当工程复杂起来之后。 使用这些新的知识将使我们的编程更加的便捷。 更容易理解。 更不容易出错啊。 在我们之后的s t m32 编程中。 也会不断地和他们打交道。 那本小节就到这里了。
8. 接下来我们来写一下gpl输入部分的代码。 先看一下第一个代码的接线图。 我们打开接线图的文件夹。 打开三杠四按键控制led的图片。 来看一下。 这里我接了两个按键和两个led。 其中两个按键分别接待了pb一和pb 11一两个口上。 按键一端接gpl口。 另一端接接地。 就是我们ppt中的第一种解法。 两个led分别接在了pa一和pa 22个口上。 l e d e端接gpl口。 另一端接vcc。 就是低电平减量的解法。 这个按键led的数量和连接的端口都是随意的哈。 具体接多少个。 接到哪些端口。 就看你的需求了。 然后我们。 把两个按键插在pb一和pb 11一两个端口上。 再把两个led插在pa一和pa 22个端口上。 这样就完成了这个代码的硬件电路。 接下来我们打开工程文件夹。 复制一下分频器工程的代码。 改个名字哈。 叫三杠四按键控制led。 然后点进去打开工程。 接下来我们就需要在这个工程上完成led和按键的驱动代码。 但是如果把这两部分驱动代码都混在主函数里面。 那代码就太乱了是吧。 不容易管理。 也不容易移植。 所以对于这种驱动代码而言。 我们一般都会把它分装起来。 单独放在另外的点c和点去文件里。 这就是模块化编程的方式啊。 我在五一单片机教程的模块化编程那节讲过。 不会的可以去看一下哈。 在这里我就直接操作了。 首先我们打开工程文件夹。 再建一个文件夹叫hardware。 用来存放硬件驱动。 然后回到q还是一样的步骤啊。 点击三个箱子的按钮。 打开工程管理。 新建一个组。 也叫hardwell。 挪个位置啊。 ok然后再点击魔术棒按钮。 打开工程选项。 选择c c加加。 点击这里三个点的按钮。 把刚才新建的hardware文件夹添加到头文件路径列表中。 ok这样我们就又添加了一个hardware文件夹。 然后在hardware这里右键添加新的文件。 选择c文件。 起个名字叫l e d。 这个文件就用来分装led的驱动程序。 然后路径也别忘了哈。 选择hardware文件夹存在这个文件夹里。 i的接着继续在hardware图右键添加新的文件。 选择h文件。 起个名字也叫d。 下面的路径也是一。 样选择hardware文件夹。 这里可以直接在这里写反斜杠hardware。 这样比较省事儿。 然后爱的这样我们就建好了。 led.c和d点去两个文件用来分装led的驱动程序。 led.c用来存放驱动程序的主体代码。 l d点去用来存放这个驱动可以对外提供的函数或变量的声明。 这两个文件建好之后。 还得添加一些必要的代码。 首先点c文件的第一行右键。 include的一个s t m32 f10 x的头文件。 这里格式都是固定的。 就是井号一副load f两个下划线。 下划线。 h如果没有定义led这个字符串。 那么井号def也是两个下划线下划线h那么就定义这个字符串。 最后再加上井号n的if。 这个是和井号以flow def组成的括号啊。 我们的函数和变量声明就放在这个括号里面。 最后注意这个文件要以空号结尾啊。 这样就完成了。 接着我们就来分装一下led的代码。 我们打开led.c文件。 首先写一个led初始化函数。 在这里写word的led下划线参数是word。 这个函数是用来初始化led的。 那里面写的就是打开时钟配置端口模式这些东西啊。 这就是我们之前学的代码。 也就是。 r c c a b2 外设始终控制我们的l d都是接在g p l a上的。 所以第一个参数是2c c a p p2 外设gpa。 然后第二个参数写enable。 开启时钟。 接着配置端口模式。 先定义一个结构体变量哈。 gpl 1 eletype体换。 这里如果不显示代码提示的话。 可以按一下快捷键ctrl alt加空格。 这样就可以弹出代码提示框了。 我们选择gpu elite type define。 变量名叫gpu structure。 然后把结构体的成员用点运算符都引出来。 先放在这儿。 最后调用gpu 1 it的函数。 第一个参数是gpa。 初始化gp i a外设。 第二个是结构体变量名啊。 前面加上取例。 子的符号。 这里使用的是地址传递。 接着填一下参数。 第一个gpl mode。 我们写gpo mode。 alt p p推广输出。 第二个gp l p我们写gpl ping一在货上。 gpl ping 2选中1号和2号口。 第三个gpl sb的。 我们写gpl sb的50兆赫兹。 选择50兆的速度。 这样led初始化的代码就写完了。 这个代码大家多打几遍。 再根据代码提示。 基本上就可以直接上手了哈。 还是比较好用的是吧。 那到这里我们只需要调用一个d1 d的函数。 led的两个gpl口就可以直接初始化完成了。 那我们先试一下。 因为这个函数是需要被外部引用的。 所以我们需要复制一下函数的第一行。 把这个函数的第一行放在点儿去。 文件的这里后面别忘了加上分号啊。 这样就是对模块外部声明这个函数是可以被外部调用的函数。 那我们回到m.c先把分离器的这些代码删掉哈。 在主函数里直接调用l d e d。 这样就完成了l d的初始化。 这里有提示一个警告哈。 这是因为我们新写的代码还没有更新。 软件。 还不知道有这个函数啊。 那我们编一下。 这个是零错误零警告啊。 有时候这个软件也会时不时报个警告或错误。 这个有可能是语法检查更新较慢。 直接编译一下。 没有问题就行了哈。 然后下载。 这里可以看到两个lled都亮起来了。 这说明我们的端口配置和模块化编程是没有问题的。 这里因为gpu配置好了之后。 默认就是低电平啊。 所以我们还没操作led。 led就亮起来了。 那我们可以在led it函数的最后写上gpl sbs gpa。 然后gpp一或者gpp 2。 这样初始化之后如果不操作l d l d就是熄灭的啦。 试一下编译没有错误下载。 这样初始化之后。 l d默认就是关闭的状态了。 接着我们就来快速完善一下led驱动程序模块。 除了初始化。 我们还需要点亮和熄灭d的函数。 这里可以写一个y的l e d e r y的点亮led一哈。 里面写gpl rec的bs。 gp l a g p l p1。 我们暂且把pa一的led叫de 1。 然后再来一个word l d e of void。 漆面。 l de里面写gpl sbs g p a g p p1。 然后把这两个函数复制粘贴一下啊。 把下面的改成l d2 gpl平二。 这里也是l d2 gpl平二啊。 这就是打开和关闭led 2的函数了。 当然我这里用了四个函数来实现两个灯的打开和关闭哈。 如果你觉得函数太多了。 那你也可以定义一个l d set函数。 然后定义两个参数。 一个参数选择操作哪个灯。 另一个参数选择开还是关哈。 这都是没问题的。 根据你的实际需求来。 我这里l d比较少啊。 就直接这样写了。 那我们把这四个函数都放在d点去文件里声明一下。 这样led的驱动函数模块就分装好了。 我们在主函数里调用函l d12 d类500ms。 d1 of da 500毫秒。 编译。 下载看一下led就在闪烁了。 我们再在这里加上led 2 of。 然后这里led 22编译下载。 可以看到两个led交替闪烁啊。 这说明我们的驱动代码是没问题的。 在主函数里。 我们的代码也变得更加简洁哈。 初始化就是初始化。 开灯就是开灯。 关灯就是关灯。 不需要再管那些底层的各种参数了。 这就是模块化编程的好处。 接着我们就来开始写按键部分的代码了。 同样我们也把按键分装在驱动函数模块里。 我们在hardware目录下右键添加新的文件。 选择c文件。 起个名字叫k下面的路径。 选择hardware文件夹。 直接写反。 斜杠hardware ad。 接着继续在hardware出右键添加新的文件。 选择h文件。 起个名字也叫k下面的路径也是写反斜杠它的y i。 然后k.c文件右键添加s t m32 f10 x头文件。 k.h写上井号flow def。 两个下划线。 k下划线h井号define。 两个下划线。 k下划线一去。 最后井号and if。 这样函数的基本框架就建好了。 我们到k.c文件里先写一个按键初始化函数。 boy的k1 it void。 在这里面我们将按键的两个端口都初始化为上拉输入的模式。 那第一步还是开启时钟啊。 r c c a b2 外设时钟控制。 我们的按键是接在gpb上的。 所以第一个参数是r c c a b2 外设gpb。 然后第二个参数写label。 开启时钟。 接着跟gpu输出也是一样啊。 定义一个结构体变量。 gpu 1 it tab defi变量名叫gpl的structure。 然后把结构体的成员用点运算符都引出来。 先放在这儿。 最后调用gpl 1 it的数。 第一个参数是g p b初始化gp b外设。 第二个参数是结构体变量名。 前面加上取地址的-2。 然后填一下参数。 第一个gp mode这里因为我们需要读取按键。 所以我们需要选择gpl mod i p u上来输入啊。 第二个gpp因为我们按键接在了pb一和pb 11口上。 所以写gp ping一或上gpp 11。 选中1号和11号口。 第三个gpl 10 b的这里的速度是gpl的输出速度。 还在输入模式下。 这个参数其实是没用的。 那我们还是填上gpl 10 b的50兆赫兹啊。 这个也没啥影响。 这样按键的初始化就完。 成了这里有个错误提示哈。 是这个名字打错了。 那我们改一下。 接着我们再来写一个读取按键值的函数。 我们在这下面写上uint 8杠t。 get a member void。 调用这个函数就可以返回按下按键的键码。 它的返回值是uint 8杠t我们之前讲过啊。 这就是ancient chat的意思。 接着我们在里面再定义一个变量啊。 your int 8杠t k number。 等于零。 最后return k蓝。 将这个变量作为返回值。 按键键码默认给您哈。 如果没有按键按下就返回零。 然后在中间这里我们就需要用到读取gpl端口的功能呢。 那先找一下gpu的库函数文件哈。 打开gpl点去这个文件放到最后来看一下这四个gpu的读取函数。 第一个是gpl read input data bit。 这个函数是用来读取输入数据进行器某一个端口的数值。 它的参数是gpx和gpp。 用来指定某一个端口返回值是unint。 八杠t代表这个端口的高低电平读取按键。 我们就需要用到这个函数。 我们再看一下第二个gpl read input data。 这个函数比上一个函数。 少了个b它是用来读取整个输入数据。 计数器的参数只有一个gpx用来指定外设。 返回值是unit 16杠七是一个16位的数据。 每一位代表个端口值。 第三个gpl read output data bit。 这个函数是用来读取输出数据进行器的某一个vr。 所以原则上来说。 它并不是用来读取端口的输入数据的。 这个函数一般用于输出模式下。 用来看一下自己输出的是什么。 具体有什么用啊。 我等会可以给大家演示一下。 那最后一个gpl read output data。 这个函数也是少了一个b。 意思也是一样。 是用来读取整个输出寄存器的。 我们打开。 ppt看一下这个图。 对照一下这个图应该就好理解了。 gpl read input data bit就是读取这里输入数据进入器的某一位gpl read input data。 就是读取这整个输入数据进器。 gpl read output data bit就是读取这里输出数据进行的某一位gpl read output data。 就是读取这整个输出数据进器。 所以说如果你想读取gpl口的话。 需要用read input的这两个函数。 如果在输出模式下。 想要看一下现在输出了什么。 才需要用到read output的这两个函数。 这就是这四个函数的用途。 那么回到k.c这里来。 在这里我们需要读取外部输入的一个端口值。 所以我们的。 gpl点距离复制一下gpu z的input data bit。 这个函数放到这里。 然后参数写gpb gpp一读取pb一端口的值。 这里的返回值就是输入数据进器某一位的值哈。 零代表低电平。 一代表高电平。 所以我们加上if判断。 把这个函数括起来啊。 然后如果读取pb一端口值等于等于零。 就代表按键按下。 我们进入if里操作。 这是按键刚按下会有个抖动。 所以需要delay一段时间。 那在这个文件里需要用到delay函数。 还需要在上面加上井号。 include da点去。 然后在这里dj 20毫秒消下抖。 接着我们还需要检测一下按键松手的情况。 因为我们的按键一般是松手之后才有动作的。 所以在这里加上一个while循环。 判断条件还是读取pb一等于等于零。 这个如果按键一直按下。 就卡在这里啊。 直到松手。 那下面松手之后再叠了20ms。 消一下按键松手的抖动啊。 接着我们赋值k number等于一。 用这个变量将键盘一传递出去。 这就是pb一按键的检测啊。 接着pb 11的按键也是一样。 我们复制粘贴一下这部分。 然后gpp一这里改成11pb 11的键盘。 我们定义为二。 最后是将cler这个变量返回回去。 这样就完成了按键的读取。 我们来试一下。 先把两个函数的第一行都复制到k点虚拟声明。 别忘了分号之后到m.c里面。 首先include k点去。 然后主循环之前初始化一下按键。 接着我们先定义一个全局变量k number。 用来存一下剑法的返回值。 这个注意一下。 虽然我们这个也叫k蓝宝。 但是这个k蓝宝和这里的k蓝宝不是一个变量。 这里是全局变量哈。 k函数里面的是局部变量。 两者的作用域不一样。 即使我在主函数这里再定义一个同名的k蓝波。 他们三个也都是不一样的。 在函数里面的是局部变量。 只能在本函数里使用。 在函数外面的是全局变量。 每个函数都可以使用啊。 在函数里优先使用自己的水库变量。 如果没有才会使用外部的全局变量。 那我就用这个全。 局变量来接反位置啊。 把这个删了。 当然这里用哪个变量都行。 编译一下。 现在还是没有问题的哈。 之后在主循环里先把这些删掉啊。 然后写k number等于k get number。 不断读取解码值。 放在k number变量里。 接着if k lo等于等于一。 这就是按键一按下了。 我们就可以执行对应的操作了。 比如d12 点亮led 1。 然后继续啊。 if k number等于等于二。 按键二按下l a d e of熄灭d1。 我们试一下编译。 下载。 按一下右边的按键1l d一点亮。 按一下左边的按键二lg一熄灭。 这些就是案件的基本操作了哈。 那我们演示的程序是按一下熄灭。 再按一下点亮。 也就是按键按一下l led的状态取反。 这个该怎么实现呢。 这就需要用到gpu z的output的函数了。 我们可以在lled的驱动里再加一个函数啊。 调用这个函数l v一的状态取反在里面。 我们可以写if复制一下gpl read output data bit。 这个函数放到这里哈。 然后gp l a g p p一等于等于零。 如果pa一的输出计算器为零。 那么就gp o sbs gpa gpp一把pa一至一。 否则也就是当前输出一。 那我们就是gpl reset壁纸g p l a g p p一把p a一至零。 这整个逻辑就是调用gpl v的output data tb的函数。 读取当前的端口输出状态。 如果当前输出零就给它置一。 否则就是零。 这样就实现了端口的电平翻转。 这也是gpl read output函数的用途。 一般用于输出模式下。 那接着我们复制一下这本书。 给l d2 也加上翻转的功能。 这里改成l d2。 g p p2。 最后把这两个函数的第一行放到头文件里。 声明一下。 这样我们就可以在主函数里使用这两个功能了。 比如按键一按下l d e turn。 按键二按下l第二层。 我们再试一下编译。 下载。 这时的现象就和我们演示的一样了哈。 最后注意一下这个驱动函数模块写好之后。 尽量在这些函数的上面加一些注释哈。 说明一下函数的用途。 参数的取值和返回值的意思。 这些东西这样别人在使用你的函数驱动时才知道咋用对吧。 就像s t m32 的库函数一样。 在每个函数上面写一下这样的注释。 那我这里时间关系就不在视频里写注释了哈。 我课下会写好提供给大家的。 大家自己写代码也尽量打打注释啊。 这样方便自己和别人理解好。 那第一个代码到这里就结束了。 接着我们来写一下第二个代码。 我们打开工程文件。 夹先看一下接线图。 在这里接了两个模块。 左边的分屏器和之前的接法还是一样哈。 vcc建立接电源控制脚。 接pb 12号口。 右边接的就是光敏传感器模块的vc c g d同样是接电源d数字输出端。 接pb 13号口。 先接一下蜂鸣器啊。 vcc接电源正接地接电源。 负控制角接pb 12。 然后是光敏传感器。 vcc接电源正接地接电源。 负dio输出角接pb 13。 闪电可以看到光敏传感器的灯亮了哈。 当我们遮住光线时。 输出指示灯灭代表输出高电平。 松手时输出指示灯亮代表输出低电平。 这个电位器可以调节高低电平的判断阈值哈。 大家可以试一下。 我就不演示了。 接着我们回到工程文件夹。 复制一下三杠四的代码。 改下名哈。 叫三杠五。 光敏传感器控制分频器。 然后打开工程。 这个程序应该还是比较简单的哈。 大家可能一看就会。 那我们的主要步骤还是驱动程序的分装。 我们先分装一下分频器啊。 在这个hardware目录出右键添加新的文件。 选择c文件名字起八折路径。 这里加上反斜杠hy add。 然后继续右键添加新的文件。 选择h文件名字起八热度径。 加上反斜杠号的y i。 然后同样啊c文件第一行添加上s t m32 头文件。 h文件加上以flow defbh define 8折h。 最后and if在c文件这里。 这个逻辑就跟l d差不多对吧。 那我们打开l d.c文件。 复制一下这些函数。 然后粘贴到蜂鸣器这里。 改一下函数名啊。 叫bug。 it but on the off。 but the turn里面的银角也改一下。 第一个开启gpb的时钟。 然后gp b g p p in 12。 这里set的beats也是gpb gpp in 12啊。 下面这些也都是机票b机票pin 12。 这样分配器的驱动程序就完成了。 我们把函数也都放到头文件里。 声明一下。 这样就好了。 先编译一下。 没有问题啊。 然后到mc里面把这些都删掉啊。 这里先include 8热点去。 然后在主函数这里写八折。 it初始化分频器。 下面测试一下8g2。 也得500ms。 复制粘贴一下。 这里八折of dele 500毫秒。 然后再粘贴两次哈。 改一下bug turn。 翻转两次。 来测试一下编译。 下载这时听到蜂鸣器不断明显啊。 说明驱动函数没有问题。 接着我们再来分装一下光敏传感器的模块。 在hardware目录出右键添加新的文件。 选择c文件名字。 起net sensor路径加上hardwi。 然后继续右键添加新的文件。 选择h文件名字起net cs镀金。 加上海的外add。 然后c文件第一行添加上sm 32头文件。 h文件加上以flow define net生成h。 define net正在h最后。 and if在letter sensor.c文件里写上word necser。 it word。 然后复制一下按键这里的初始化程序粘贴到这里。 修改一下时钟。 gpb不用改的gpu模式。 可以选择上拉鼠模式。 如果这个模块始终都接在端口上。 只要保证鹰角不会悬空即可。 那我们这里就选择上大输入模式吧。 然后银角这里因为光敏传感器连接的是pb 13三二口。 所以改成gpp 13。 下面初始化这里g p b也没问题啊。 这样初始化就完成了。 接下来写一个读取端口的函数。 这里我们的需求比较简单哈。 直接写个返回端口值的函数就行了。 比如uint 8杠t net sensor。 get wide。 然后直接return gpl。 read input data bit。 gpb gpp 13。 这就完成了。 接着再复制一下这些函数。 第一行啊。 放在头文件声明一下。 编译一下。 没有问题。 最后在主函数里测试哈。 上面include net sensor。 点进去。 下面这些先删掉啊。 首先necs 1 it初始化光敏传感器。 接着主循环里直接if necs get等于等于一。 这是光线比较暗的情况。 那么我们就8月二分别姓名叫el。 把这of。 这就实现了我们演示程序的现象哈。 我们测试一下编译。 下载。 然后遮住光明电阻。 分泌器响哈。 拿开分泌器不响。 这就完成了我们本节课的第二个代码。 本节课的内容到这里就差不多了哈。 最后我们来总结一下gpu的使用方法。 总体上来说还是比较简单的。 首先初始化时钟。 然后定义结构体赋值结构体。 gpl mod可以选择我们讲的那八种输入输出模式。 gp l p选择银角。 可以用按位或的方式同时选中多个硬件。 g p s b的选择输出速度。 这个不是很重要哈。 要求不高的话。 直接选50兆赫兹就行了。 最后使用gp l e d t函数。 将指定的gpl外设初始化好。 然后。 这里有八个读取和写入的函数。 我们读写gp口主要就用这些函数就行了。 具体用法我也都讲过啊。 一般我们自己做一个产品的话。 这时候就要尽量把每个硬件的驱动函数单独提取出来哈。 分装在点c和点去文件里。 这样有利于简化组函数的逻辑。 在主函数中我们还有更重要的任务要完成啊。 不要让这些驱动函数混在主函数里。 影响我们。 另外把硬件驱动提取出来。 也有利于我们移植程序啊。 还有利于我们进行分工合作。 比如让别人。 来写驱动函数。 你的主要精力就可以集中在主程序的逻辑上了。 最后既然要做分装。 那函数的注释就需要写清楚啊。 这样可以方便使用你这个模块的人快速上手这些函数好。 以上就是本节课的全部内容了。 我们下节再见啊。
9. hello。 大家好。 欢迎继续观看htm 32入门教程。 本节课我们来学习o l g调试工具。 本节课比较简单。 我会给大家提供一个。 oled显示屏的驱动函数模块。 大家先学会如何使用我提供的模块。 就可以了。 至于oled屏幕的原理和代码编写。 我之后会再讲的哈。 现在我们就是用o l d。 当一个调试的显示屏。 方便我们调试程序。 在以后的教程中。 我们会经常用到这个显示屏啊。 所以在这一节先提前介绍一下。 那我们先来看一下本节课程序的线下。 本节课只有一个程序啊。 o led显示屏。 我们下载看一下。 这时可以看到我们插在面包板上的oled。 显示了一些字符和数字啊。 第一个是显示一个字符a。 第二个是显示字符串。 hello world。 下面左边是显示一个数字12345。 然后右边是显示有符号的数字-66啊。 在下面是显示16进制数字a a55。 最后是显示二进制数字啊。 1010101001010101。 这个就是16进制a a55 的二进制数啊。 这些就是我提供的led驱动函数模块。 能显示的内容哈。 当然这个屏幕也能显示中文或者图像。 但是我暂时还没有加进来。 我们这个屏幕目。 前主要用于调试啊。 有这些显示内容就足够了。 那看过我五一单片机视频的同学。 应该对这些显示内容就比较熟悉了。 我提供的这个oled模块。 和五幺视频里的lcd模块。 它的驱动函数基本都是一模一样的。 所以上手这个oled屏幕应该还是比较容易的。 那么回到ppt。 首先我们先来看一下。 目前常用的程序调试方式啊。 对于我们的单片机编程而言。 经常会遇到一个很大的问题。 就是程序调试。 因为单片机不像电脑啊。 电脑有一个很大的屏幕啊。 想看什么变量参数。 直接打印到屏幕就可以了。 但是单片。 机不一样。 很多时候由于成本和电路结构的限制。 它并不会有一个像电脑屏幕。 那强大的显示屏啊。 这个对我们的调试造成的困难。 比如如果让你学习c语言。 但是不允许使用print f这个打印函数。 那你想一下c语言。 是不是就根本没法学对吧。 同样给你一个单片机。 但没有任何可以显示参数的东西。 那你也没法学单片机是吧。 所以我们本节先来学习一下程序调试方法。 我们来看一下。 这里我列举了三种常用的程序调试方法。 第一种就是串口调试。 它是通过串口通信呀。 将调试信息发送到电。 脑端电脑使用串口助手显示调试信息。 这种调试方式是非常常见的。 就是用串口将单片机连接到电脑。 相当于把电脑的屏幕挂在单片机上。 方便单片机显示调试信息。 一般我们设计pcb电路板的时候。 都会像这样。 在pcb边上留一个串口通信的硬件。 需要调试程序的时候。 把单片机连在电脑上。 然后就可以在电脑屏幕打印信息了。 调试好之后就断开串口程序。 就能正常工作了。 所以你看其他的教程啊。 如果是使用串口调试的话。 那一上来都应该会先学一下串口通信啊。 这样才好继续之后的课。 程。 但我一般比较喜欢用显示屏来调试程序啊。 我觉得显示屏调试会更加舒服。 所以我就先开了本节led调试工具的课。 串口通信的课我会放在后面再讲。 那接下来我们就来看一下显示屏调试。 它是直接将显示屏连接到单片机。 将调试信息打印在显示屏上。 这个方法就比较直接啊。 单片机没有显示参数的东西。 那我们就直接接个屏幕上去。 这里我们使用的是这种比较小小的。 0.96寸oled显示屏啊。 使用还是非常方便的。 当然串口调试和显示屏调试。 也是各有利弊的。 电脑的优势是可以借。 助强大的电脑来调试。 电脑端的软件不仅可以显示单独的参数啊。 而且可以显示曲线啊。 图形图像等。 还可以自己做一个软件啊。 来实现一个强大的用户交互界面。 那串口调试的弊端就是。 调试的时候需要拖着电脑哈。 而且通常的串口助手。 只能以信息流的方式呈现数据。 就是只能一行一行的打印哈。 如果有很多不断变化的数据要显示。 那就只能在电脑上刷屏显示。 这样用起来就不太方便。 接着显示屏调试的优势是。 对于不断变化的数据可以覆盖刷新显示。 而且显示屏可以始终接在单片。 机上显示方式很直接啊。 还有一般我们做一些稍微复杂的东西。 都会需要有一个人机交互的界面。 这样就可以直接把显示屏。 当做产品的一部分。 还是比较好用的。 那显示屏的弊端就是屏幕太小。 显示内容有限。 没有电脑软件那么强大的功能是吧。 所以这两种方法各有各的适用场景。 需要根据实际情况选择合适的方法。 那本套课程中。 基本上都是一些参数变量的形式。 所以我觉得用ord显示会更加方便。 最后我这里还列举了一种调试方式。 就是kill调试模式。 它是借助q软件的调试模式。 可使。 用单步运行设置断点。 查看计算器及变量等高级功能。 ko调试模式的功能还是非常强大的哈。 这个在下一小节可以给大家具体演示一下。 当然除了这三种方法之外。 还有很多种程序调试的方法哈。 比如点灯调试法。 如果你不清楚程序是不是执行到了。 某个位置。 就可以在那个位置放一个点灯的代码。 如果运行到了灯就亮。 没运行到灯就不亮。 还有注释调试法。 如果你的程序原来是好的。 但是加了某段程序就死了。 这时你可以把新加入的程序全部注释掉。 恢复到正常运行的状态。 然后依次一。 行一行的解除注释。 直到错误出现。 或者注释掉一部分来测试另一部分。 然后再注释掉另一部分。 测试这一部分。 减少程序运行的部分啊。 来定位出问题的程序在哪里。 另外还有对照法。 这就是你找到一个没问题的程序。 它的执行逻辑没问题。 你感觉你自己写的逻辑也没问题。 但是它的可以运行。 你的却不能运行。 这时就可以对照一下哈。 在它的程序逻辑上。 逐步替换成你的程序逻辑。 这样就比较容易发现错误在什么地方啊。 总之测试程序的基本思想就是缩小范围。 控制变量。 对比测试等测试。 的方法是多样的哈。 这个还得大家在实践中多想想了好。 介绍完这些调试方法。 我们来看一下oled显示屏的介绍哈。 首先o l d它是这一串英文的缩写。 意思是有机发光二极管。 o r g显示屏。 就是用这个有机发光二极管。 做出来的屏幕哈。 它是一种性能优异的新型显示屏啊。 具有功耗低。 这个是因为oled每一个像素都是一个单独的。 发光二极管。 每一个像素都是可以自发光的。 不像lcd那样需要有背光哈。 所以o r d屏幕会比较省电。 响应速度快。 这个特性可以使o l d有更高的刷新率啊。 总线。 时序快也可以避免阻塞我们的程序。 宽视角。 因为oled屏幕是自发光的。 所以在任何角度看显示内容都是清晰的哈。 对比lcd的话。 比如我现在录视频的这个电脑。 屏幕就是lcd屏。 如果我从上面或者下面斜着看这个屏幕。 那屏幕就会变黑哈。 很难看清上面的内容。 而我现在这个手机的屏幕是oled屏幕。 基本上各个视角都可以看清屏幕啊。 这就是可视视角的差别。 最后轻薄柔韧。 比如现在手机上的折叠屏。 柔性屏等用的就是oled显示屏。 接着来看一下本节用的0.96寸oled模块。 介绍是小巧玲珑。 占用。 接口少。 简单易用。 是电子设计中非常常见的显示屏模块。 这个显示屏也算是单片机领域的一个。 经典显示屏的。 当然它不会像我们手机电脑上的屏幕。 那么强大。 这个o r d一般都只有一种颜色。 分辨率也比较低哈。 驱动这个id只需要几根线和简单的通信协。 议。 占用资源比较少。 那下面这些图片。 就是这个o r d的外观和种类啊。 它有几种规格。 第一种就是我们视频使用的。 总共有四个证件。 像素是白色的。 右边这里还有一种七针脚版本的。 需要占用的l口就多一些哈。 对应这个像素颜色除。 了有白色像素的版本。 还有这种蓝色像素的版本。 和这种黄蓝双色的版本。 这个红蓝双色并不是真正的双色。 它是上面1/4的像素固定是黄色的。 下面3/4的像素固定是蓝色。 这种屏幕适合做一个需要显示标题。 行的界面。 还上面的黄色显示标题。 下面的蓝色显示内容了。 这样比较好看一些。 当然无论像素颜色是哪种。 它的驱动方式都是一样的。 最后看一下参数哈。 它的供电是3~5点5伏。 3.3伏和5伏的单片机都是兼容的哈。 通信协议是fc或sp i。 像下面这种四真假的屏幕。 一般用的是fc的通信协议。 这种七证件的屏幕。 一般用的是spi的中心协议。 这个fc通信和sbi通信。 我们之后的课程会讲哈。 现在了解一下即可。 最后它的分辨率是128x60。 四项数。 这个分辨率对于手机电脑而言。 那太低了是吧。 不过对于单片机而言还是非常够用的。 接着我们来看一下oled的竞价电路啊。 左边这个是四正教版本的o i d电路。 这里接地接接地。 vcc接3.3伏给o i d供电。 然后剩下的s scl和sda是fc的通信硬件。 需要接在单片机iphone c通信的硬件上。 当然我给的驱动。 函数模块用的是gpl口模拟的iphone c通信。 所以这两个端口就可以接在任意的。 g p l口上啊。 然后右边七正角版本的o led电路。 也是一样哈。 g d vcc接电源。 剩下的引脚是spi通信协议的引脚。 如果是gpl口模拟的通信协议。 那也是接在任意的gpl口上就行了。 这就是硬件电路。 最后来看一下我给的驱动函数模块。 都有哪些东西吧。 这个表里可以看到这些。 就是我提供的驱动函数啊。 上面这两个图是oled的实物图和屏幕坐标图。 我把这个o d分割成了四行。 16列的小区块。 从左上开始向下依次是第。 一行第二行。 第三行。 第四行向右依次是第一列。 第二列。 一直到第16列啊。 然后看一下下面的驱动函数啊。 第一个是o r d1 it。 这个是o led初始化函数。 在使用o r d之前。 需要调用一下这个函数啊。 对o l d进行初始化。 然后就可以正常使用了。 第二个是o i d可莉r这个是清屏函数。 调用这个函数。 屏幕就会清空啊。 然后下面的这些函数。 就都是o led的显示函数了。 首先oled修差显示一个字符。 第一个参数指定起始行。 第二个参数指定起始列。 第三个参数是要显示的字符啊。 比如一行一列。 显示字符a那在屏幕上一行一列的位置。 就会像这样显示一个a啊。 右边这里是它的实际效果。 接着d修十寸显示字符串。 比如在一行三列显示字符串。 hello world感叹号。 那就会从这里开始啊。 显示hello world感叹号。 右边是这样的。 然后o r d修number。 这个是显示无符号十进制数字。 前两个参数指定起始坐标。 第三个参数是要显示的数字啊。 第四个参数是数字的长度。 比如二行一列显示数字12345。 长度为五。 就会在屏幕的这个位置显示12345。 剩下的o r d修sa number。 就是显示有符号十进制数。 值在显示的时候会带一个正负号啊。 然后o l d修hax number。 显示16进制数。 o l d修b number。 显示二进制数。 这些我就不过多介绍了哈。 相信大家很容易就能看懂怎么用的。 我们下一小节写代码的时候。 再来具体演示啊。 这个屏幕还可以显示中文图像等内容。 我这里给的驱动函数。 并没有涉及这些东西哈。 这些东西我们调试的时候也暂时用不到。 如果大家需要的话。 我们之后单独学习o l d的时候。 再来演示这些功能好。 那本小节的内容就到这里了。 我们下一小节来学习一下如何使用这个驱。 动函数模块。
10. 首先我们还是看一下接线图。 我们打开四杠一oled显示屏的图片。 看一下。 我们就一直把这个屏幕插在这里哈。 需要用的时候随时可以使用。 而且放在右下角也不是很占地方。 那在这里我们使用的是四针角的o i d屏幕。 jd和vcc需要接电源的负极和正极啊。 我们可以在o l d的下面啊。 像这样先插上两根线。 把o l d的g d引到负极供电。 空o i d的vcc引的正极供电功。 另外这个供电孔也会同时接到sm 32的pb 6和pb 72个硬件。 不过这个也是没关系的。 我们直接不初始化这两个引脚就行了。 s t m32 的引脚上。 电后如果不初始化。 在这个模式下。 银角不会输出电平。 所以不会有什么影响啊。 当然你也可以不接这两根跳线。 直接给pb 6口输出低电平。 pb 7口输出高电平。 用gpl口直接给o i d供电。 这个也是没问题的。 因为这个led功率很小。 所以也是可以驱动的。 不过这种用gpu口供电不是很规范。 自己玩儿玩儿的时候用就行了。 要做实际项目的话。 最好还是用电源供电好。 那插好这两个供电跳线之后。 再把o d插到pb 6到pb 9这四个口。 这样o i d就接好了。 此时o i d的s。 c l接到pp 8。 s d a接到pp 9。 先用跳线引一下电源。 负极供电孔引到pb 6的位置。 征集姑娘口音了。 pp 7的位置。 然后拿出oled屏幕。 插到pp 6到p p9 的这四个空力。 这样就完成了。 然后我们回到工程文件夹。 复制一下按键控制led的工程文件夹。 改个名字叫四杠一oled显示屏。 打开工程。 这些原来的代码也都删掉。 把这些其他的选项卡都关掉哈。 现在这就是oled显示屏的工程了。 接着我们回到工程文件夹里。 我给大家准备的oled驱动函数模块就放到这个一杠四的文件夹里了。 大家可以下载程序源码查看哈。 那我们打开这个文件夹里面有两个版本。 一个是四针脚mc版本。 另一个是七针脚pi版本。 我们打开四针脚版本的文件夹里面有三个文件哈。 我们直接全部选中ctrl c复制。 然后到oled显示屏这个工程里来打开hardware文件夹。 把它们粘贴到这里来之后。 打开q在hardware处右键添加已经存在的文件。 打开hardware文件类型。 选择所有文件。 按住ctrl键选。 中这三个文件ad。 这样就把这个o d模块添加到工程里面来了。 我们打开分别看一下这三个文件都是什么东西啊。 初始化ifc通信的基本程序和oid用户调用的代码的。 这些函数我都已经写好了哈。 绝大部分都不需要更改。 我们需要更改的就只有上面的这两部分代码。 第一部分是银角配置。 这里选择的是你硬件电路上。 把s scl和sda这两个引脚接在了哪两个端口上。 比如我这里s scl接在了pb 8。 那这个地方就是gpb gpp 8。 如果你换个端口。 比如现在pa 6上。 那这个地方就要改成g p l a g p l p6。 下面这个sda的引脚配置也是一样哈。 sda接在了哪个位置。 就改成gpu啥gpp啥。 然后下面这个o l d f c1 d的函数里也得更改哈。 这里面就是把s scl和sda的两个引脚都初始化为开漏输出的模式。 这部分代码大家学了上一节gpu之后。 应该就已经非常熟悉了。 具体更改就是使用到的gpl外设都先用二cc开启一下时钟。 然后下面初始化gpb的pin 8。 在初始化gpb的ping 9。 这样就完成了。 所以对于这个模块来说。 我这里默认用的是s c l j p b8。 s d a j p b9。 如果你想修改。 那先把上面这两行引脚配置改一下。 剩下的都不需要修改啊。 就可以直接使用我这个oled驱动函数模块了。 这就是o i d.c里面的东西。 接下来o i d点区里面这里就是外部可调用函数的声明啊。 其他的也没啥了。 最后是d放的点h文件。 这里存的是oid的字库数据。 因为这个i d显示屏是不带字库的啊。 想要显示字符图形。 还得先定义字符的点阵数据。 那这里就是这些字符的点阵数据哈。 也就是字库o l e d.c文件的显示函数会用到这些数据。 我们需要把这个文件复制过来。 放到工程里。 当然字库也是不用我们修改的。 复制完成之后。 我们就来试用一下吧。 先编译一下哈。 没有问题。 然后卖点c上面先井号。 include o l d点进去。 最后main函数里主循环之前先调用oid。 一律初始化id。 然后试一下o d修恰显示一个字符。 先写行列坐标。 坐标的定义是这样的哈。 总共四行16列。 那我们写一行一列。 第三个参数写一个字符啊。 字符需要用单引号括起来。 然后a这样就完成了。 我们试一下啊。 编译。 下载。 可以看到oled的一行一列显示了一个字符a。 然后oled修string显示字符串。 一行三列显示字符串。 字符串需要用双引号括起来。 然后hello word感叹号再看一下。 这就在一行三列显示了hello world和感叹号。 这里注意计算一下坐标和字符串长度哈。 不要让它超出屏幕了。 这就是显示字符串。 然后o i d修number。 显示无法20进制数字啊。 在二行一列显示12345。 这个数字长度为五。 看一下。 就是这个效果。 如果你这个长度参数比数字长度长啊。 比如六。 那它就会在前面补零。 像这样。 如果这个长度参数比数字长度小啊。 那比如四它就会把高位的数据切掉。 像这样啊。 最高位的一就没有了。 这就是显示5号十进制数字。 这个只能显示5号数啊。 我们可以跳转一下定义啊。 这里每个函数我都写好了注释。 关于函数的作用和参数取值范围。 大家都可以看一下。 这就是这个函数的用法。 然后ord修三number。 这个是显示有符号十进制数字的函数。 比如二行七列显示12345。 长度为五啊。 编译一下。 下载那线下就是这样哈。 数字的前面会带一个正负号。 如果显示-66。 长度为二啊。 再看一下。 线下就是这样。 然后是d修hx number。 显示16进制数。 比如三行一列显示0x aa 55长度为四。 看一下。 现象就是这样的。 接下来是oled修冰蓝宝。 显示二进制数。 这里写四行一列。 显示0x a a55 这个数。 因为c语言不能直接写二进制的数啊。 所以这里我们只能用16进制来代替。 这个我还是比较奇怪的哈。 为什么c语言作为一个底层计算机编程语言。 却不支持直接写二进制的数。 况且c语言最终还是要翻译成汇编语言的。 汇编就支持直接写二进制。 c语言却不支持。 所以说二进制比较长。 一般都用16进制来表示啊。 但难免有的时候直接写二进制会更加方便。 c语言直接就不支持写二进制。 那咱也没办法。 这里就只能用16。 进制来写了这个16进制表示的二进制数是16位的哈。 所以这个长度给16编译下载看一下。 这里就显示了aa 55对应的二进制数据啊。 也就是1010101001010101。 最后还有一个函数o o r d可莉啊。 清屏啊。 我们在最后调用一下。 看一下。 这时候ord就不会显示任何东西。 因为在最后o d可莉把全屏都清屏了。 如果你只想清除部分字符。 在你想要清掉的地方显示空格字符就行了。 好这些就是我这个模块里所有的函数用法了。 这里先改回来哈。 接下来的时间我给大家演示一下q的调试模式啊。 这个调色模式我教程里可能用的比较少啊。 但是它确实是一个非常强大的工具。 在这里给大家介绍一下。 大家之后遇到一些复杂的问题。 可以考虑一下这个调试模式。 说不定就能很方便的解决你的问题了。 那。 我们换一个led闪烁的工程作为例子哈。 然后工程选项debug。 这里可以对调试选项进行配置。 这里默认是选择右边的这一项啊。 这个是在硬件上在线仿真。 需要我们把sd link和s t m32 都连接好。 如果你不想连接硬件。 也可以选择左边的使用仿真器这个选项。 这样就是电脑模拟s t m32 的运行了。 那我们就使用硬件的在线方程吧。 首先在进入调试模式之前。 需要先连接好sm 32之后编译一下。 确保工程没有问题。 现在这里编译是没有问题的哈。 然后点击这里的放大镜里面带一个d的图标。 进入调试模式。 在这个界面里。 主窗口就是我们的c语言程序。 上面这个窗口就是c语言翻译成的汇编程序。 这个你感兴趣的话。 可以对照这里看一下美剧c语言实际上都执行了哪些操作啊。 然后左边的这个窗口是寄存器组和状态标志位等信息。 这个是单片机硬件底层很重要的东西啊。 如果你用汇编编程的话。 这些东西都是必须要非常清楚的。 但如果你用的是c语言。 那这些东西就不用管了。 之后上面这一。 部分是程序运行控制的。 第一个是复位啊。 第二个是全速运行。 第三个是停止全速运行。 然后接着这四个是单步运行。 跳过当前行。 单步运行。 跳出当前函数。 单步运行。 跳到光标指定行单波运行。 那我们可以试一下哈。 这个黄色箭头指示的就是下一句将要执行的代码。 我们当前的程序就是从背函数开始的。 我们可以点一下单步运行。 那它就执行到了下一行。 然后再单步他就进到了二cc这个函数里面来了。 点击这个跳出函数。 它就可以跳到函数外面来了。 指定这一行。 然后点击运行到光标指令。 行那程序就运行到这个位置了。 我们可以点击程序左边这里深灰色的区域啊。 设置断点。 然后点击全速运行。 程序就会一直运行。 直到断点停下。 如果没有断点的话。 再选输运行程序就不会自动停下来了。 那我们就需要点击这里的停止按钮。 这样程序就会停下来了啊。 可以看到目前程序停在了delay函数里面。 然后我们点击rst负a程序就会回到最开始的地方。 这里我们可以看到现在程序是在启动文件的复位中断函数里。 说明复位后程序是从这里开始执行的。 我们单步运行可以看到。 首先程。 序会跳到system 1 d特函数里继续运行。 然后跳出函数继续运行。 应该就会执行内函数啊。 不过它突然停不下来了。 那没关系啊。 我们停止一下复位。 然后指定的main函数直接运行到当前行。 现在可以看到程序就执行到了这一行。 然后停下来了好了。 这就是调试模式下控制程序运行的方法。 这个方法可以精确追踪我们的程序是如何运行的。 如果你不清楚程序是如何一步步运行的。 那在这个调试模式里单步运行探索一下。 相信你对程序的运行逻辑就会有更深的理解。 当然这只是调试模式下的。 一小部分功能调试模式还有更强大的功能哈。 接着我们来看一下上面的这一堆功能哈。 第一个是命令窗口。 我们点击它可以打开和关闭命令窗口。 第二个是反汇编窗口。 也是可以打开和关闭的哈。 第三个是符号窗口。 在这里我们可以实时查看程序中所有变量的值哈。 我们试一下。 比如我想看一下这个gpl一定的structure结构体的值。 那就可以在这个窗口里找一下哈。 没点c里面。 然后main函数这里就可以看到这个变量了。 里面可以看到结构体的三个成员。 如果想看一下结构体值的变化。 可以在这。 里右键哈添加到watch一窗口。 在这里就能看到结构体的值了。 比如我们在这里单步运行。 这里就能看到这个变量值的变化还是非常方便的。 然后剩下的这里还有串口显示。 逻辑分析仪等等。 这些工具的功能也都是非常强大的哈。 大家可以自行了解一下。 我就不再演示了。 另外我们还可以点击这个外设菜单栏啊。 系统资源查看。 这里就可以看到所有的外设寄存器。 比如我们选择gpa右边的这里就会显示gpa外设的所有计算器。 那我们这个程序是翻转pa 0端口对吧。 我们就可以看一下o dr寄存器。 选择o加零。 这个就是pa。 零的输出数据计算器啊。 接下来我们运行。 可以看到这个o加零竟然是实时显示输出计算器的变化的。 可以看到sm 32也是在实时执行程序的。 我们点停止html 2的程序也停止运行啊。 再点运行还是tm 32程序也继续执行。 虽然说这个实时变化会有一些延迟啊。 但不得不说这个在线调试的功能还是非常强大的。 s t m32 实时执行程序。 q软件实时显示外设计算器状态。 还能随时控制程序的开始。 停止单步运行。 所以当你以后遇到一个比较难调的程序。 比如不清楚程序是如何执行的。 或者想要看一大堆变量却不方便显示的。 或者想看一下计算器是不是配置正确了。 都可以考虑一下使用这个q自带的调试模式。 最后再说明一。 下如果你想修改程序的话。 是不能直接在这个调试模式下修改的。 修改程序得先退出调试模式。 重新编译。 再进入调试模式啊。 这个注意一下。 那以上这些就是对q调试模式的简单介绍。 这个软件更多的功能还得需要大家自己慢慢探索了。 探索的方法可以是这些按钮菜单啊。 都随便点点看看有啥功能。 或者百度搜索一下各个功能是咋用的。 或者点这里的帮助啊。 第一项这里可以打开qq软件的官方帮助文档啊。 这个帮助文档里有对这整个软件最权威最细致的介绍。 如果你对某个功能不。 熟悉的话可以在这里找一找啊。 好以上就是本节的全部内容了。 我们下节再见。
11. hello。 大家好。 欢迎继续观看s t m32 入门教程。 中断和中断系统啊。 首先我们看一下本节课程序的现象。 本节课有两个程序。 第一个是对射。 是红外传感器计次。 第二个是旋转编码器计次。 我们先看一下第一个。 下载。 这里接了一个红外对管的传感器啊。 oled显示了一个数字。 现在是000。 我们用挡光片挡在这个红外对管中间。 此时这个模块的输出指示灯灭了。 代表现在输出高电平啊。 然后再打开挡光片。 此时输出指示灯亮了。 在灭到亮之间会产生一个下降。 沿这个下降沿触发单片机引脚的外部中断。 然后执行数字加一的中断程序啊。 所以现在屏幕就显示了001。 那我们再挡光几次。 屏幕上的数字。 就对我们挡光的次数进行了统计。 这就是第一个程序的现象。 接着看一下第二个旋转编码器记词。 在这里我接了一个旋转编码器啊。 屏幕上也是一个数字。 然后我旋转这个编码器。 可以看到数字也跟随变化。 这就是第二个程序的现象。 好那我们来看一下本节的知识点。 本节课要讲的是s t m32 的中断系统。 和外部中断。 中断系统是管理和执行中断的逻辑结构啊。 外部中断是众多能产生中断的外设之一。 中断系统。 在以后学其他外设的时候。 也是会经常和中断打交道的啊。 那我们先来了解一下中断的概念啊。 首先中断的定义是在主程序运行过程中。 出现了特定的中断触发条件。 这个中断触发条件就是中断源。 那使得cpu暂停当前正在运行的程序。 转二区域处理中断程序处。 理完成后又返回原来被暂停的位置。 继续运行。 这就是中段的定义。 可以看出来。 中断就是在正常组程序执行的某个时刻。 发生了中断触发条件。 比如对于外部终端来说。 可以是银角发生的电平跳变。 对于定时器来说。 可以是定时时间到了。 对于串口通信来说。 可以是接收到的数据。 当这些事件发生时。 情况会比较紧急啊。 比如外部中断来了。 你如果不来处理。 下一个跳变信号就跟着过来了。 比如串口接收终端来的。 如果你不来读取接收到的数据。 那下一个数据再过来。 就会把原来的数据覆盖掉。 所以我们希望当中断条件满足时。 cpu能够立即停下当前执行的程序。 转而去处理这些中断事件的程序。 比如外部中断来了。 我想要记次。 那就变量加加串口中断来了。 我就把接收到的数据转存起来。 当这些紧急事件处理完成后。 cpu还能回到原来停下的地方继续运行。 这就是中段的处理流程和用途啊。 使用中断系统能够极大的提高程序的效率。 比如如果没有中断系统。 为了防止外部中断被忽略。 或者串口数据被覆盖。 那主程序就只能不断的查询。 是否有这些事件发生。 不能再干其他事情呢。 比如如果没有定时器中断。 那主程序只有靠d类函数。 才能实现定时的功能。 但有了中断系统之后。 主程序就可以放心执行其他事情。 有中断的时候再去处理。 这就好像你早上定了个闹钟。 定好之后就可以放心睡觉了。 时间到了。 闹钟会提醒你。 就相当于产生了一个中断信号。 如果你没有闹钟。 那你就得不断的看时间。 生怕错过了起床点。 那这样你就没法安心睡觉了是吧。 接着我们来看一下中断优先级啊。 它是当有多个中断源同时申请中断时。 cpu会根据中断元的轻重。 缓急进行裁决。 优先响应更加紧急的中断源。 也就是说中断优先级就是中断的紧急程度。 这个中断优先级。 是我们根据程序设计的需求啊。 自己设置的哈。 中断优先级是为了在多个中段同时申请时。 判断一下应该先处理哪个。 如果事件非常紧急。 那你就把优先级设置高一些。 如果不是那么紧急。 那你就可以把优先级设置低一些。 这样可以更好地安排这些中断事件。 防止紧急的事件被别的中断耽误。 在s t m32 中。 中断优先级还有多种分类啊。 这个我们等会再详细讲哈。 然后我们再看一下。 下面一个概念中断嵌套。 它是当一个中断程序正在运行时。 又有新的更高优先级的中断申请中断。 cpu再次暂停当前中断程序。 转而去处理新的中断程序。 处理完成后依次进行返回。 这种把中断程序再次中断的现象。 就叫做中断嵌套。 中断嵌套也是为了照顾非常紧急的中断的。 如果现在cpu已经在执行某个中断程序了。 这时又发生了一个非常紧急的中转。 那这个中段就可以把当前的中断程序。 进行二次中断。 这样新的紧急中断就可以立即被执行了。 那能否进行中断嵌套也是由中断优先级。 来决定的。 这个等会儿再细说啊。 然后我们看一下。 这几个中段的执行流程图啊。 第一个是中段程序的执行流程。 左边是主程序。 当它执行到某个地方时。 外设的中断条件满足了。 那这时无论主程序在干什么事情。 比如加减乘除还没算完。 o i d显示程序才执行一半啊。 d类函数还正在等待啊。 中断来了。 主程序都得立即暂停。 程序由硬件电路自动跳转到中段程序中。 当中断程序执行完之后。 程序再返回被暂停的地方继续运行。 比如加减乘除没算完。 现在就可以继续算了。 o r d没显示完。 现在。 就继续显示delay没延时完。 现在就继续延时。 那这个被暂停的地方。 我们就称它为断点。 为了程序能在中断返回后继续原来的工作。 在中断执行前会对程序的现场进行保护啊。 中断执行后会在还原现场。 这样可以保证主程序即使被中断了。 回来之后也能继续运行啊。 当然我们用c语言编程。 保护现场和还原现场的工作。 并不需要我们来做。 编译器自动帮我们做好了。 所以这里了解一下即可。 接着中间这个图就是中断嵌套的执行流程。 比如这里就是正常的中断程序。 当这个中段正在执行时。 又。 有新的优先级更高的中断呢。 那这里就会再次大专。 然后执行新的中端。 新的中断结束。 再继续原来的中断。 原来的中断结束。 再继续主程序。 这就是中断嵌套的执行流程。 最后看一下右边的c语言程序啊。 带有中断的程序就是这个样子的。 上面是主函数y一死循环里就是主程序。 正常情况下。 程序就是在主程序里不断循环执行啊。 当中断条件满足时。 主程序就会暂停。 然后自动跳转到中断程序里。 运行中断程序。 顺序执行完之后再返回主程序继续执行。 一般中断程序都是在一个子函数里的。 这个函数不需要我们调用。 当中断来临时。 由硬件自动调用这个函数。 这就是在c语言程序中中断的执行流程。 了解完中断的概念。 我们就来看一下htm 32的终端。 第一条是68个可屏蔽中断通道。 这个中段通道就是中状元的意思啊。 68个中状元。 这个是f一系列最多的终端数量。 对于一个具体的型号可能没有这么多中端。 所以这个数量啊看看就行。 具体以对应型号的数据手册为准哈。 t i m定时器a d c魔术转换器。 usa art串口spi通信。 fc通信rtc实时时钟等多个west啊。 那通过这一句。 我们知道htm 3的中断是非常多的。 几乎所有的模块都能申请中断。 然后下面的使用nvc统一管理中断。 每个中段通道都拥有16个。 可编程的优先等级。 还可以对优先级进行分组。 进一步设置抢占优先级和响应优先级。 这个nvc就是s t m32 中用来管理中断。 分配优先级的。 nvc的中断优先级总共有16个等级。 还可以设置抢占优先级和响应优先级。 这个是非常灵活的。 接着右边这个图。 就是s t m32 里的中断资源。 这里看一下上面这些灰色。 的是内核的中端。 比如第一个复位中断。 当产生负a事件时。 程序就会自动执行复位中断函数。 也就是我们复位后程序开始执行的位置。 然后nmi不可屏蔽中端硬件失效。 存储管理总线错误错误应用等等。 这些都是内核里面的哈。 一般这些中段都比较高深。 我们看上去也挺难理解的。 但是这些中段我们一般用不到。 所以了解一下即可。 然后下面这些不是灰色的部分。 就是s t m32 外设的终端了。 比如第一个窗口看门狗。 这个是用来监测程序运行状态的终端。 那比如你程序卡死了没有及时。 喂狗窗口看门狗就会申请中断。 让你的程序跳到窗口看门狗的中断程序里。 那你在中断程序里。 就可以进行一些错误检查。 看看出现什么问题了。 然后pvd电源电压监测。 如果你供电电压不足。 pvd电路就会升起中断。 你在中段你就知道现在供电不足。 是不是电池没电了。 赶紧保存一下重要数据啊。 接着下面这些也都是类似的功能啊。 外设电路检测到有什么异常或者事件。 需要提示一下cpu的时候。 它就可以申请中断。 让程序跳到对应的中断函数里运行一次。 用来处理这个异常或事件。 那下面这。 个e x t i0 到e x t i4。 然后下面的ex ti 9杠五。 和最右边的ex ti 15杠十。 就是我们本节要学的外部中断。 对应的中断资源哈。 然后这个表右边这里还有一个中转的地址。 这个地址是干什么的呢。 这个是因为我们程序中的中断函数啊。 它的地址是由编译器来分配的。 是不固定的啊。 但是我们的中段跳转由于硬件的限制。 只能跳到固定的地址执行程序。 所以未来能让硬件跳转到一个。 不固定的中断函数里。 这里就需要在内存中定义一个地址列表啊。 这个列表地址是固定的。 中段发生。 后就跳到这个固定位置。 然后在这个固定位置。 由编译器。 再加上一条跳转到中段函数的代码。 这样中断跳转就可以跳到任意位置了。 这个中段地址列表就叫中断向量表。 相当于中段跳转的一个跳板哈。 不过我们用c语言编程的话。 是不需要管这个中断向量表的。 因为编译器都帮我们做好了。 所以我们还是很省心的。 然后接下来我们来看一下。 n v i c的基本结构。 这个nvc的名字叫做嵌套中断向量控制器。 在s t m32 中。 它是用来统一分配中断优先级。 和管理中断的。 n vs是一个内核外。 设是cpu的小助手啊。 我们刚才看到了s t m32 的中段非常多。 如果把这些中段全都接到cpu上。 那cpu还得引出很多。 现在进行适配设计上就很麻烦。 并且如果很多中断同时申请或者中断。 很多产生的拥堵。 cpu也会很难处理。 毕竟cpu主要是用来运算的。 中断分配的任务就放到别的地方吧。 所以nvc就出现了nvc有很多输入口。 你有多少个中断线路都可以接过来。 比如这里可以接到e x t i t m a d c u。 s a r t等等。 这里线上画了个斜杠。 上面写个n。 这个意思是一个外设可能会同时占用多。 个中转通道。 所以这里有n条线。 然后nvc只有一个输出口。 n vc根据每个中段的优先级。 分配中段的先后顺序。 之后通过右边这一个输出口告诉cpu。 你该处理哪个中转。 对于中断先后顺序分配的任务。 cpu不需要知道哈。 所以举个例子。 比如这个cpu是一个医生。 如果医院只有医生的话。 当看病的人很多时。 医生就得安排一下。 先看谁后看谁。 如果有紧急的病人。 那还得让紧急的病人最先来。 这个安排先后秩序的任务很繁琐。 会影响医生看病的效率啊。 所以医院就安排了一个叫号系统来病人呢。 统一。 取号。 并且根据病人的等级分配一个优先级。 然后j号系统看一下。 现在在排队的病人优先加号。 紧急的病人。 最后叫号系统给医生输出的。 就是一个一个排好队的病人。 医生就可以专心看病了。 这个记号系统在s t m3 里就是n v i c。 然后我们看一下中断的分组啊。 为了处理不同形式的优先级。 s t m32 的nvc可以对优先级进行分组。 分为抢占优先级和响应优先级。 那这两种形式的优先级有什么区别呢。 我们还来看一下病人借号的这个例子哈。 对于紧急的病人。 其实有两种形式的优。 先一种是上一个病人在看病。 外面排队了很多病人。 当上一个病人看完后。 紧急的病人。 即使是后来的也会最先进去看病。 这种相当于插队的优先级。 就叫响应优先级。 响应优先级高的可以插队提前看病。 另外如果这个病人更加紧急。 并且此时已经有人在看病了。 那他还可以不能上一个人。 看完。 直接冲到医生的屋里。 让上一个病人先靠边站。 先给他看病。 等他看完了。 上一个病人再继续。 然后上一个病人结束了记号系统。 再看看有没有人来这种形式的优先级。 就是我们之前讲的中断嵌套啊。 这种决定是不是可以中断。 嵌套的优先级就叫抢占优。 先级抢占优先级高的可以进行中断嵌套。 这些就是抢占优先级和响应优先级的解释。 那我们刚才说了。 每个中段有16个优先级。 为了把这个优先级再区分为。 抢占优先级和响应优先级。 就需要对这16个优先级进行分组了。 我们看一下ppt的第一句n。 vc的中断优先级。 由优先级寄存器的四位决定。 这里四位二进制可以表示零到15的数。 对应16个优先级啊。 这个优先级的数值越小。 优先级越高。 零就是最高优先级。 然后呢这四位可以进行切分。 分为高n位的抢占优先级和d4 到n位。 的响应优先级。 然后下面这一句。 抢占优先级高的可以中断嵌套响应。 优先级高的可以优先排队。 这个通过刚才的例子应该就好理解了吧。 然后还有抢占优先级和响应优先级。 均相同的。 按中断号排队。 这个中断号就是这里啊。 这个表里的这个数字。 当抢占优先级和响应n级均相同时。 就按照这里的这个数字来排队。 数值小的优先响应啊。 所以sm 32的中段。 不存在先来后到的排队方式。 在任何时候都是优先级高的现象。 应然后看一下下面的这个表。 因为优先级总共是四位。 所以就有041。 3223140这五种分组方式。 分组零就是零位的抢占等级。 取值只能为零啊。 四位的响应等级取值可以是零到15。 分组一是一味的抢占等级取值是0~1。 三位的响应等级取值是0~7啊。 然后分组234。 都是按照这个规律来分配的。 大家自己看一下这个分组方式。 在程序中是我们自己来选择的哈。 选好分组方式之后。 我们在配置优先级的时候。 就要注意。 抢占优先级和响应优先级的取值范围了。 不要超出这个表里规定的取值范围。 了解完nvc这个叫号系统和叫号的规则。 我们就。 来看一下第一个病人ex ti外部中断。 先看一下第一条e x t i。 它是x turn interrupt的缩写。 意思是外部中断。 然后第二条是ex ti。 可以监测指定gpl口的电平线二。 当其指定的gpl口产生电平变化时。 e x t i立即向n o c发出中断申请。 经过nvc裁决后即可中断cpu。 主程序是cpu执行e x t i对应的中断程序。 这就是ex t i的基本功能。 简单来说就是引脚电平变化。 申请中断。 然后看一下触发方式。 ex ti支持引脚电平的变化类型为上升沿。 就是电瓶从低电平变到高电平的瞬间。 触发中转。 下降沿就是高。 电平变到低电平的瞬间触发中断。 双边沿就是上升沿和下降沿。 都可以触发中断。 另外还支持软件。 除法就是银角啥事没有。 程序里执行一句代码就能触发终端。 接着再看一下外部中断支持的gpu口。 它支持所有的gpu口。 也就是任意的gpi口。 都可以当做外部中断的引脚。 但相同的ping不能同时触发终端。 这个意思就是。 比如pa 0和pb 0不能同时用。 或者pa 1 pb 1 pc一这样的端口。 g p l p一样的。 只能选一个作为终端硬件。 所以你如果有多个中断引脚。 要选择不同ping的硬件。 比如pa 6和p a7 p。 a9 和pb 15。 pb 0和pb 1。 这样的都可以啊。 然后再看一下外部中断占用的通道。 其中有16个g p l p。 这就对应g p p0 到g p p 15。 外加pvd输出。 rtc闹钟。 usb唤醒。 以太网唤醒。 这些加起来总共有20个中断线路。 这里的16个g p l p。 是外部中断的主要功能哈。 后面跟着的这四个东西其实是来蹭网的哈。 为啥这些东西要来外部中断蹭网呢。 因为这个外部中断有个功能。 就是从低功耗模式的停止模式下唤醒。 s t m32。 那对于pvd电源电压监测。 当电源从电压过低恢复时。 就需要pvd。 借助一下外部中断退出停止模式。 对于rtc闹钟来说。 有时候为了省电啊。 按tc定一个闹钟之后。 等到闹钟响的时候再唤醒。 这也需要借助外部终端。 还有usb唤醒。 以太网唤醒也都是类似的作用哈。 这四个蹭网的知道一下就行了。 最后外部中断的触发响应方式。 可以是中断响应和事件响应。 中断响应好理解啊。 就是申请中断。 让cpu执行中断函数。 那世界响应是什么意思呢。 这个其实是s t m32 对外部中断增加的。 一种额外。 的功能啊。 当外部中断检测到引脚电平变化时。 正常的流程是选择触发中断。 但在sdm 32中也可以选择触发一个事件。 如果选择触发事件。 那外部中断的信号就不会通向cpu了。 而是通向其他外设。 用来触发其他外设的操作。 比如触发a d c转化触发dma等。 所以总结一下就是中断响应是正常的流程。 引脚电平触发中断事件响应不会触发中断。 而是触发别的外设操作。 属于外设之间的联合工作。 那接下来我们就来看一下。 外部中断的基本结构吧。 这个图就是外部中断的整体结构图。 首先最左。 边是gpl口的外设。 比如g p l a g p b g p l c等等。 每个g p l外设有16个硬件。 所以进来16根线。 那我们刚才这里说了。 ex ti模块只有16个gpu的通道。 但这里每个gp l o s都有16个硬件。 如果每个硬件占用一个通道。 那e x t i的16个通道显然就不够用了。 所以在这里会有一个a f l o中断引脚。 选择的电路模块。 这个a fo就是一个数据选择器啊。 它可以在这前面三个gpy设的。 16个硬件里。 选择其中一个连接到后面的ex ti的通道里。 所以这前面说相同的ping不能同时触。 发中断。 因为对于pa 0。 pb 0。 pc 0。 这些通过a fo选择之后。 只有其中一个能接到ex ci的通道零上。 同理pa 1 pb 1 pc 1。 这些也只能有一个接到通道一上。 这就是所有gpl口都能触发中断。 但相同的ping不能同时触发中断的原因。 然后通过a fl选择之后的16个通道。 就接到了excel边缘检测及控制电路上。 同时下面这是个蹭网的外设。 也是并列进来的。 这些加起来就组成了e x c i的。 20个输入信号。 然后经过ex sci电路之后。 分为了两种输出。 其中上面的这些接到了nvc。 就是用来触发中断的。 这里。 注意一下。 本来20路输出应该有20路中段的输出。 但是可能st公司觉得这20个输出太多了。 比较占用nvc的通道资源。 所以就把其中外部中断的9~5和十。 五到十给分配到了一个通道里。 也就是说。 外部中断的9~5会触发同一个中断函数。 15到十也会触发同一个中断函数。 在编程的时候。 我们在这两个中断函数里。 需要再根据标志位来区分。 到底是哪个中段进来的。 这个注意一下。 然后下面这里有20条输出线路。 到了其他外设。 这就是用来触发其他外设操作的。 也就是我们刚。 才说的事件响应。 看完这个图。 相信你对中断的整体流程。 就应该熟悉一些了吧。 然后我们再具体的看一下。 这里a fl和ex ti的内部电路。 那先看一下a fl复用l口。 右边这个图。 就是a f l选择中转引脚的结构图。 这个结构图看上去就比较简单啊。 这里就是一系列的数据选择器。 第一个输入是pa 0。 pb 0。 p c0 等等。 一直到pg 0尾号都是零。 然后通过数据选择器。 最终选择一个接到ex t i0 上。 上面写的是配置这个寄存器的这些位。 可以决定选择哪一个输入。 然后下面的ex ti一等等。 一直到。 ex ti 5都是数据选择器。 这个好理解。 接着我们看一下左边的文字啊。 第一条是a f l o。 主要用于引脚复用功能的选择和从定义。 也就是数据选择器的中。 然后第二条在s t m32 中。 a f l o主要完成两个任务。 复用功能引脚重映射。 中断引脚选择。 其中复用功能引脚重映射。 就这里啊。 就是我们最开始提到的这个引脚定义表。 当我们想把这些默认复用功能的引脚。 换到从定义的这个位置来。 就是用a f i o来完成的。 这也是a f l的一大主要功能哈。 那另外一个功能就是我们刚才提。 到的中断引脚。 选择的这个也是用a f l o来完成的。 好a f l讲完了。 下面就是e x t i的内部框图了。 这里可以看到ex ci的右边。 就是20根输入线。 然后输入线首先进入边缘检测电路。 在上面的上升沿计算器和下降沿计算器。 可以选择是上升沿触发还是下降沿触发。 或者两个都触发。 接着触发信号。 就进入到这个或门的输入端了。 简单介绍一下哈。 这种弯弯的符号是或门。 它可以有多个输入。 但只能有一个输出啊。 执行的是货的逻辑。 在输入端只要有一个是高电平。 一输出就是高电平。 一只有全部输入低电平。 零输出才为零。 然后还有这种带点直边的符号。 是语文啊。 它同样也可以有多个输入。 但只能有一个输出。 执行的是雨的逻辑。 在输入端只要有一个是低电平。 零输出就是零。 只有全部输入一输出才为一。 另外还有一种三角号加个圈的啊。 是非门。 它只有一个输入。 一个输出。 输入一就输出零。 输入零就输出一执行的是非的逻辑啊。 最后还有一种哈。 就是刚才这里说的数据选择器。 它的符号是一个梯形。 有多个输入。 一个输出。 在侧面有选择控制端。 根据控制端的数据。 从输入选择一个接到输出。 这些就是常见的逻辑符号啊。 了解一下在s t m32 的模块。 框图里还是非常常见的。 那我们接着这里说。 在这里。 硬件触发和软件中断寄存器的值。 接到了这个后门上。 也就是任意一个为一破门就可以输出一。 所以在这里我们说支持的触发方式是。 上升沿下降。 沿双边沿和软件出发。 然后回到这里啊。 触发信号通过这个货门之后就兵分两路。 上一路是触发中断的。 下一路是触发事件的触发中断。 首先会制一个挂起寄存器。 这就相当于是一个中段的标志位了啊。 我们可以读取这个计算器。 判断是哪个通道触发的中端。 如果中断挂起计算器至一。 它就会。 继续向左走啊。 和中断屏蔽计算器共同进入一个与门。 然后是自novc中断控制器。 这里的语文实际上就是开关的作用。 因为对于语文来说。 x等于这个任意的输x0 以上。 任意的数x都等于零二。 这就相当于中断屏蔽寄存器给一。 那另一个输入就是直接输出。 也就是允许终端中断屏蔽寄存器给零。 那另一个输入无论是什么输出都是零。 相当于屏蔽了这个终端。 这就是这个与门的作用啊。 相当于一个开关控制。 接着看一下下一路事件的输出部分啊。 首先也是一个事件屏蔽。 寄存器进行开关控制啊。 最后通过一个脉冲发生器到其他外设。 这个脉冲发生器就是给一个电瓶脉冲啊。 用来触发其他外设的动作。 然后这个框图剩下的部分还有这些。 画一个斜杠。 写着20啊。 表示的就是这是20根线。 代表20个通道。 上面这些就是外设接口和app总线。 我们可以通过总线访问这些计算器。 那这些就是ex t i的内部结构了。 到这里有关中断系统。 nvc。 中断控制器和e x t i外部中断的内容。 我们就讲完了。 最后看一下本节课。 配合外部中断我们所使用的硬件模块啊。 对于。 外部中断来说。 那到底什么样的设备需要用到外部中断呢。 使用外部中断有什么好处呢。 在这里我大概总结了。 使用外部中断模块的特性。 就是对于htm 32来说。 想要获取的信号是外部驱动的。 很快的突发信号。 比如旋转编码器的输出信号啊。 我可能很久都不会拧它。 这时候不需要s t m32 做任何事。 但是我一拧它就会有很多脉冲波形。 需要s t m32 接收。 这个信号是突发的哈。 s t m32 不知道什么时候回来。 同时它是外部驱动的。 s t m32 只能被。 动读取。 最后这个信号非常快。 s t m32 稍微晚来一点录取。 就会错过很多波形。 所以对于这种情况来说。 就可以考虑使用s t m32 的外部中断了。 有脉冲过来。 s t m32 立即进入中断函数处理。 没有脉冲的时候。 sm 32就专心做其他事情。 另外还有啊。 比如红外遥控接收头的输出。 接收到遥控数据之后。 它会输出一段波形哈。 这个波形转瞬即逝。 并且不会等你。 所以就需要我们用外部中断来读取。 最后还有按键啊。 虽然他的动作也是外部驱动的突发事件。 但我并不推荐使用外部中断来。 读取按键。 因为外部中断不好处理。 按键抖动和松手检测的问题啊。 对于案件来说。 它的输出波形也不是转瞬即逝的啊。 所以要求不高的话。 可以在主程序中循环读取。 如果不想用主循环读取的话。 可以考虑一下定时器中断读取的方式。 这样既可以做到后台读取按键值。 不阻塞主程序。 也可以很好地处理。 按键抖动和松手检测的问题。 这个感兴趣的话可以了解一下。 那了解完外部中断的适用场景之后。 我们就来看一下这个编码器介绍啊。 本节程序还用到了对射式红外传感器。 这个模块。 我们。 之前就讲过。 用法也是比较简单的。 这里就不再讲了。 我们直接看一下旋转编码器。 首先旋转编码器。 它是用来测量位置速度或旋转方向的装置。 当其旋转轴旋转时。 其输出端可以输出。 与旋转速度和方向对应的方波信号。 读取方波信号的频率和相位信息。 即可得知旋转轴的速度和方向。 下面是旋转编码器的类型哈。 有机械触点式。 霍尔传感器是光栅式等类型。 那旋转编码器是怎么工作的呢。 首先看一下下面的第一个图啊。 它是一种最简单的编码器样式的。 这里使用的也是对射。 是红外传感。 器来测出的。 为了测速。 还需要配合一个这样的光栅编码盘。 当这个编码盘转动时。 红外传感器的红外光就会出现遮挡。 透过遮挡。 透过这样的现象。 对应模块输出的电平。 就是高低电平交替的方波。 这个方波的个数代表了转过的角度。 方波的频率代表转速。 那我们就可以用外部中断。 来捕获这个方波的边缘。 以此判断位置和速度。 不过这个模块只有一路输出啊。 正转反转输出波形没法区分。 所以这种测试方法只能测位置和速度。 不能测量旋转方向。 那为了进一步测量方向。 我们就可以用后面。 的几种编码器。 第二个图片就是我们套件里的旋转。 编码器的。 左边是它的外观。 右边是它的内部拆解结构。 可以看到啊。 它内部是用金属触点来进行通断的。 所以它是一种机械触点式编码器。 这里左右是两部分开关触点。 其中内侧的这两根细的触点。 都是和中间的这个引脚连接的。 像这样外侧的触点。 左边的接待这个硬件。 右边的接待这个硬件。 这就是这些触点的连接方式啊。 然后中间这个圆的金属片是一个按键。 我们这个旋转编码器的轴是可以按下去的。 这个按键的两根线就在上面引。 出来了按键的轴按下上面两根线短路。 松手。 上面两根线断开。 就是个普通按键啊。 然后再看一下编码盘。 它也是一系列像光栅一样的东西啊。 只不过这是金属触点。 在旋转时依次接通和断开两边的触点。 并且还有个关键的部分。 是这个金属盘的位置是经过设计的哈。 它能让两侧触点的通断。 产生一个90度的相位差。 最终配合一下外部电路。 这个编码器的两个输出。 就会输出这样的波形啊。 当正转时。 左边的引脚就是a项引脚。 输出一个方波信号。 同时右侧的硬件就是b向硬件输出一个。 和。 它相位相差90度的波形。 那比如正向旋转时。 b项输出是滞后90度的。 就是这样的。 反向旋转时a向还是方波线二。 那b项就会提前90度。 就这样的。 这样正转和反转就可以区分开了。 这种相位相差90度的波形就叫正交波形。 带正交波形信号输出的编码器。 是可以用来测方向的啊。 这就是单向输出和两项正交输出的区别。 当然还有的编码器不是输出正弦波信号。 而是一个引脚输出。 方波信号代表转速。 另一个输出高低电平代表旋转方向。 这种不是正加输出的编码器。 但也是可以测量方向的。 这个了解一下。 然后接着看一下第三个图。 这种是直接附在电机后面的编码器。 这种是霍尔传感器形式的编码器。 中间是一个圆形磁铁。 边上有。 两个位置错开的霍尔传感器。 当磁铁旋转时。 通过霍尔传感器就可以输出。 正交的风波信号。 它的输入轴转动时输出就会有波形。 这个也是可以测速和测方向的啊。 具体用法再看相应的手势。 当然第二个图里的这个编码器。 一般是用来进行调节的哈。 比如音响调节音量这样的用途。 因为它是触点接触的形式。 所以不适合电机这种高速旋转的地方。 另外几种都是非接触的形式啊。 可以用于电机测速。 电机测速在电机驱动的应用中。 还是非常常见的啊。 我。 们本节就用这种旋转编码器模块。 外部中断读取编码器计次数据的用法。 以后我们学了定时器。 还会再来看一下编码器测速的这种图的。 接下来我们看一下。 这个旋转编码器的硬件电路啊。 这里左边这个是模块的电路图。 这个图里。 中间这个就是旋转编码器。 上面按键的两根线。 这个模块并没有使用。 还是悬空的。 下面的这里就是编码器内部的两个触点。 旋转轴旋转时。 这两个触点以相位相差90度的方式。 交替导通。 因为这只是个开关信号。 所以要配。 看一下左边啊。 这里接了一个10k的上拉电阻。 默认没旋转的情况下。 通过r3 这个电阻输出到a端口的。 就也是高电平。 当旋转时。 内部这里触点导通。 那这个点儿就直接被拉低到基地了。 再通过二三输出a端口。 就是低电平的之后。 这个二三是一个输出限流电阻啊。 它是为了防止模块引脚电流过大的。 这个c一是输出滤波电容。 可以防止一些输出信号抖动。 这个滤波电容见了很多是吧。 然后右边的这一部分电路。 和左边的也是一模。 一样的哈。 它的输出接到了b端口上。 最后中间这里可以看到这个模块的c端口。 就直接接到了接地。 那这些就是这个模块的电路图啊。 然后右边我们在使用这个模块的时候。 接线就很简单了。 上面的vcc接d接电源。 下面的a项输出和b项输出。 接到sm 32的两个引脚上。 比如pb 0和pb 1。 然后中间的c硬件就是jd。 我们暂时不用好。 那ppt的内容到这里就结束了。 最后我们再来看一下手册啊。 大概的看一下每个外设在手册里的介绍哈。 首先是n v i c因。 为nvc是内核外设。 所以要在这个考tx杠m3 编程手册里。 找这个cott杠m3 编程手册里。 就是内核和内核外设的详细介绍。 如果你想研究一下内核的运转细节。 可以看一下这个手册。 不过这个手册。 我目前还没找到中文的版本哈。 大家如果有这个手册的中文版的话。 可以联系我一下。 我再更新一下资料链接。 那我们可以在目录里找到内核外设。 nova这一节。 这里就有n o c的一些说明啊。 大家感兴趣的话。 可以自己用翻译软件看一下。 然后是nvc的一些计算器。 使能寄存器。 中段清除势能计算器啊。 中段设置挂起计算器啊。 中段清除挂起计算器啊。 中断活动位计算器。 中断优先级计算器啊。 这个中断优先级计算器。 就是用来设置每个中段的优先级的。 这个如果直接配置计算器设置优先级的话。 那还是比较复杂的。 不过我们用库函数的话。 那就简单了。 直接给结构体赋值就行了。 所以这个计算器就大致看一下就行了啊。 不过你要知道我们的库函数。 最终还是要落实到这个计算器上来的。 接着下面还有一个软件触发终端计算器。 然后这后面还有一些中断执行。 细节的描述哈。 感兴趣的可以自己看一下。 那这些就是手册里对nvc的介绍了。 另外这些nv i c寄。 存器里还少了一个东西啊。 就是中断分组的配置。 中断分组的配置。 在这个s c b a r c r里。 这三位就是用来配置中断分组的。 然后下面有中断分组的描述啊。 和我p p t里也是一样哈。 大家可以看一下好n v i c的手势。 我就带大家看到这里。 然后我们再打开这个。 s t m32 的参考手册。 带大家快速过一下手册的内容哈。 我们可以在目录里找到中段和事件这一集。 这里就是中断系统和外部中断的介绍哈。 那首先是nvc的概述。 然后是中断向量表。 接着就是外部中断ex ti的介绍了。 然后是框图。 这个我也给大家讲过啊。 这里还有外部中断唤醒事件的说明。 最后是外部中断的功能说明。 然后是中断的线路印象。 也就是中断引脚选择。 这一部分实际上是在fl里的。 那最后就是外部中断的寄存器。 描述了。 这里有中断。 屏蔽寄存器事件。 屏蔽计算器上升沿触发选择计算器。 下降沿触发选择计算器。 软件触发计算器。 挂起寄存器。 这些计算器看上去应该不难理解吧。 在这个中断框图里也都有体现。 最后来看一下a f l o s哈。 在这个目录里找到gp和a f l o。 打开a f l o这一节。 这里对a f i o的描述啊。 就只有这一句话。 就是复用功能引脚重新式的意思啊。 然后下面这些全部都是重新设的表。 通过配置寄存器啊。 就可以在这些映射关系表里切换了。 最后就是寄存器描述了怎么切换。 配置这些寄存器就行了。 当然我们使用库函数。 那就更加方便了哈。 调用一个函数。 填两个参数就行了。 那最后几个计算器我们就可以看到哈。 这些就是用来选择外部中断引脚的。 好那本小节。 中断系统和外部中断的理论部分。 我们就学到这里哈。 下一小节。
12. 本小姐。 我们来写一下外部中断的代码。 那我们还是先看一下接线图。 我们打开经验图的文件夹。 打开五杠一对射。 是红外传感器机制的图片。 来看一下。 右上角这一部分和上一节oled显示屏的电路是一样的。 在这里把oled插好。 用于显示程序的现象。 然后左下角这里接了一个对射。 是红外传感器的模块。 接线也是比较简单的。 vcc键d分别接电源的正负极。 d数字输出端。 随便选一个gpl口接上就行。 在这里我接到了b 14的端口。 当我们的挡光片或者编码盘在这个对射是红外传感器中间经过时。 这个dio就会输出电平跳变的信号。 然后这个电平跳变的信号触发s t m32 pb 14号口的中段。 我们在中断函数里执行变量加加的程序。 然后主循环里调用o r d显示这个变量。 这样第一个程序就完成了。 那我们看一下实际电路。 目前这个面包板已经插好了。 o r d部分的电路接线图和o r d那截是一样的。 然后我们拿出这个对射是红外传感器模块。 用三根公对母的杜邦线把银角引出来。 然后vcc接电源正接地接电源负dog htm 32的pb 14。 这样就完成了。 我们可以随便找一个挡光片啊。 挡一下传感器中间这个槽可以看到这个输出指示灯也跟随尿灭啊。 这就说明高低电平输出是没问题的。 好那我们回到工程文件夹里复制一下oled显示屏的工程。 改一下名字啊。 叫五杠一对。 设置红外传感器g4。 打开工程。 把这些先删掉哈。 先留一个显示hello world的代码。 上面其他的文件也都关掉。 编译试一下。 没有问题啊。 下载看一下oid显示hello world也没问题。 那接下来我们就开始写第一个代码了。 我们还是把这个传感器的功能封装在一个模块里。 所以现在hardwell出右键添加新的文件。 选择c文件。 起个名字就叫counter sensor。 然后路径加上反斜杠号的y and。 接着还是在hardware出右键添加新文件。 选择h文件。 也叫counter or路径加上反斜杠号的y a在这里写上固定部分啊。 头文件是井号。 以flow def content center h。 井号defctrl cs h。 最后景和人的衣。 然后点c文件。 右键添加一下头文件。 这样模块的基本结构就写好了。 然后我们先写一个初始化函数啊。 一般模块我们要写的第一个函数都是初始化函数。 把这个模块要用的资源配置好。 那我们直接写void counter sensor elite void。 在这里面我们就要进行外部中断的配置了。 那如何配置外部中断呢。 我们可以看一下ppt的这个外部中断整体结构图。 看一下这个图使用外部中断要配置哪些东西就很清晰了。 简单来说。 我们只需要把这个外部中断。 从gpo到nvc这一路中出现的外设模块都配置好。 把这条信号电。 路给打通就行了。 具体步骤就是第一步配置二cc。 把我们这里涉及的外设的时钟都打开。 这个别忘了。 不打开时钟。 外设是没法工作的。 第二步配置gpio。 选择我们的端口为输入模式。 第三步配置a f i l。 选择我们用的这一路gp i o连接到后面的e x t i。 第四步配置e s t i。 选择边沿触发方式。 比如上升沿。 下降沿或者窗边沿。 还有选择触发响应方式。 可以选择中断响应和时间响应。 当然我们一般都是中断响应。 第五步配置nvc。 给我们这个中段选择一个合适的优先级。 最后通过nuc外部中断。 信号就能进入cpu了。 这样cpu才能收到中断信号。 才能跳转到中断函数里执行中断程序。 那这五步就是外部中断的配置流程。 这里涉及的外设比较多哈。 有r c c g p i o a f l o e x c i n v i c。 大家不要慌啊。 我们一个个来看。 那我们回到q。 首先第一步是r c c开启时钟。 这个我们之前讲过啊。 主要就是三个开启时钟的函数。 那我们在这里直接写r c c a b2 外设时钟控制。 首先是r c c a b2 外设。 开启g pb的时钟。 这个注意一下哈。 g p b是a b2 的外设。 这个参数是a b2 gpb的这个函数也要用app 2的这个开启始终函数。 你如果这里用了a b一或者a hb的函数。 然后填上app 2 gp b的参数。 这样程序也是不会报错的哈。 因为语法上没有错误。 后面这个参数只是一个宏定义啊。 只是一个数的替换而已。 所以编译器也不知道你写错了。 但实际运行的话。 你这个程序肯定是有问题的。 所以这里要细心一点啊。 注意函数和参数的这个a b2。 a b一和a区b要对应起来。 那我们继续。 接下来。 开启a f i o的始终a f l o也是a b b2 的外设。 那我们复制一下这个函数啊。 然后这里把gpo改成a f l o。 这样就行了。 你如果不确定哪个外设是接在哪个总线上的。 可以转到这个函数的定义啊。 看一下上面这个参数列表。 有的话就是这个总线上的外设。 那这里可以看到有这个r c c a p p2 外设a f i o。 所以这里就可以调用a p p2 开启时钟的函数。 然后填a f l o的这个参数。 开启时钟了。 接着还有ex ti和nvc两个s。 这两个外设的时钟是一直都打开着的。 不需要我们再开。 启时钟了。 ex ti作为一个独立外设。 按理说应该是需要开启时钟的。 但是寄存器里面却没有ext中的控制位。 这个原因手册里也没找到。 网上我也没得到确切的答案。 个人推测可能是和ex ti唤醒有关。 或者是其他的一些电路设计上的考虑哈。 那我们暂时就不用管了。 知道它不需要开启时钟就行了。 另外n vc也不需要开机时钟。 因为n vs是内核的外设。 内核的外设都是不需要开机时钟的。 人家跟cpu一起啊。 都是住在皇宫里的。 而rc c管的都是内核y的y4。 所以rc c管不着n v i c好拉到这。 里时钟就配置完了。 接着我们就来进行第二步配置。 gpo这一部分我们之前也学过哈。 也还是一样的流程。 首先定义结构体。 gpl elite type define。 gpl elite structure。 然后复制一下结构体名字。 把结构体成员都引出来。 最后gp 1 elegpb举例子。 gpl elist structure初始化gpl b y是接着填一下参数啊。 第一个gpu目的对于外部中断来说。 要选择浮空输入。 上拉输入或者下拉输入。 这其中的一个模式。 当然像这种其他外设使用g p i o的情况。 如果你不清楚该配置为什么模式。 可以看一下这个参考手册啊。 在gpo这一章找一下。 有一个外设的gpu配置表。 里面有写每个外设的各个零件都需要配置。 为什么模式这个我们之前也看过。 那在最后就有excel输入线。 它给的推荐配置就是浮空上拉或者下拉。 所以在这里我就给一个gpl目的。 ipo上来输入默认为高电平的输入方式。 然后gp l p我们用的pb 14号口。 所以就写gpl p 14 g p s speed。 这个不是很重要啊。 我们就还是gpl sb的50兆赫兹。 最后调用gpl 1 elete函数。 初始化一下gpl b外设。 这样gpl部分我们就配置好了。 然后我们就来进行第三步配置。 af这个a f l y s s t公司并没有给他分配专门的库函数文件啊。 它的库函数是和gpu在一个文件里的。 那我们找一下gpu的点去文件看一下最后的库函数。 我们之前学习gpu的时候讲了这上面的一些函数。 那还剩下一些函数没讲。 这些就是和a f i o有关的库函数。 我们来看一下。 首先上面这里有一个g p l a f l o d net。 这个函数是用来复位a f l y设的。 调用一下这个函数。 a f l y设的配置就会全部清除。 这好理解啊。 然后下面这个gpl plock configure。 这个函数是用来锁定gpl配置的。 调用这个函数参数指定某个银角。 那这个银角的配置就会被锁定。 防止意外更改。 这个也是gpl外设的函数啊。 之前没有讲。 这里再提一下。 用的不多。 大家了解一下即可。 然后是gpl event output configure和gpl event output command。 这两函数是用来配置a f i o的四件输出。 功能的用的也不多啊。 大家了解一下。 接下来gpl ping remap configure和gp e x ti nine configure。 这两个函数就比较重要了。 gpl拼remap configure可以用来进行引角重映射。 第一个参数可以选择你要重新设的方式。 第二个参数是新的状态。 使用还是非常简单的哈。 但是由于目前我们还没有学习到需要映射银角的外设。 所以实际调用的话。 我们之后再演示。 然后gp l e x c i n configure就是我们本节外部中断需要用的函数。 调用这个函数就可以配置a f l o的数据选择器。 来选择我们想要的中断引脚。 那最后一个g p l e t h。 made a interface configure。 这个是和以太网有关的哈。 我们这个芯片没有以太网外设。 所以也用不到好。 那这个文件的所有函数我们就都已经了解差不多了。 接着我们就回到这个主线任务来。 我们现在想要配置a f l o外部中断引脚选择。 那就直接复制这个gpl ex ti。 那configure函数放到这里来。 然后右键跳到进一看一下。 可以看到啊。 这个函数虽然是gpo开头。 但实际上里面操作的是a flo的寄存器。 所以这个函数实际上是a flo的函数。 这个知道一下。 那上面这里简介写的是选择gpp作为外部中断线。 第一个参数是。 gpl psource。 选择某个gpu外设作为外部中断源。 这个参数可以是gpl psource gpl x。 其中x可以是a到g。 那我们就复制一下这个参数放到这里。 我们用的是pb 14号硬件。 所以把x改成b就行了。 然后再看一下第二个参数。 第二个参数是gpl psource指定配置的外设中断线。 这个参数可以是gpl p sx。 其中x可以是零到15。 那我们再复制一下这个参数放到第二个参数这里。 然后x改成14。 代表连接pb 14号口的第14个中断线路到这里。 a f l y设中断引脚选择配置就完成了。 就这个函数就行了。 当执行完。 这个函数后a flo的第14个数据选择器就拨好了。 其中输入端被拨到了gpb外设上。 对应的就是pb 14号引脚。 输出端固定连接的是excel的第14个中转线路。 这样pb 14号引脚的电平信号就可以顺利通过a f i o。 进入后级e x c i电路了。 那接下来我们就可以进入第四步配置eti了。 我们先看一下ex ti的库函数文件。 看一下ex ti都有哪些库函数。 可以用我们找到eti dr h的文件打开。 拖到最后。 这些就是e x t i的所有库函数了。 库函数总共就只有这些啊。 看上去还是比较简单的。 我们。 来一一学习一下。 首先第一个e x t i d e d调用它就可以把ex ti的配置都清除。 恢复成上电默认的状态。 然后第二个e x c i e t调用这个函数。 就可以根据这个结构体里的参数配置。 ex t i y是我们初始化ex ti主要用的就是这个函数。 使用方法和gpu也是一样的。 这个应该也好理解。 接着第三个ex t struct 1 it调用这个函数。 可以把参数传递的结构体变量-1个默认值。 像在前面的三个函数啊。 基本所有的外设都有。 就像指库函数的模板函数一样。 基本每个外设都需要这些类型的函。 数这些模板函数使用方法和意识也都是一样的哈。 会使用一个之后再见到这种函数就能很容易的上手。 所以当你学gpu的时候。 你会觉得为啥要用结构体来初始化模块呢。 还得定义结构体。 结构体赋值。 然后再传递结构体的地址。 简直太麻烦了是吧。 但当你继续学习其他外设之后。 你就会发现外部中断也只使用结构体初始化的方式。 定时器也是a d c也是串口。 也是都是一个套路啊。 而且结构体可以看到参数的名字。 参数也都是复制粘贴来的。 根本不用查看计算器。 随便旋转参数就配置。 好了从这个角度看sm 32的库函数是不是比计算器方便多了哈。 这就是库函数的好处。 那接着下面继续看啊。 ei generate sw interrupt。 这个函数是用来软件触发外部中断的。 调用这个函数参数给一个指定的中断线。 就能软件触发一次这个外部中断。 这个如果你程序中需要用到这个功能的话。 可以使用这个函数啊。 如果你只需要外部引脚触发中断。 那就不需要用这个函数了。 然后剩下的这四个函数也是库函数的模板函数啊。 很多模块都有这四个函数。 因为在外设运行的过程中会产生一些状态标志。 位。 比如外部中断奶了。 是不是会有一个挂机计算器自带一个标志位啊。 对于其他外设。 比如串口设的数据啊。 会指标志位。 定时器时间到啊。 也会指标志位。 这些标志位都是放在状态寄存器的。 当成越想要看这些标志位时。 就可以用到这四个函数。 其中这前两个函数get flag status可以获取指定的标志位。 是否被质疑了。 可莉亚flag可以对z一的标志位进行清除。 那对于这些标志位啊。 有的比较紧急。 在治标志位后会触发中断。 在中断函数里。 如果你想查看标志位和清除标志位。 那就用下面两个函数get。 it status。 获取中断标志位是否被质疑了。 clear it pending beat。 清除中断挂起标志位。 所以总结一下就是如果你想在主程序里查看和清除标志位。 就用上面这两个函数。 如果你想在中断函数里查看和清除标志位。 就用下面这两个函数。 其实本质上这四个函数都是对状态寄存器的读写哈。 上面两个和下面两个都是类似的功能。 都是读写状态寄存器。 只不过是下面这两个函数只能读写与中段有关的标志位。 并且对中段是否允许作出的判断。 而上面的这两个函数只是一般的读写标志位。 没有额外的处理。 能不能触发中断的标志位都能读取。 所以建议在主程序里用上面两个。 中断程序里用下面两个。 当然你如果非要在中断里用上面两个。 那其实也是没问题的。 只不过是库函数针对这两种场景区分了这两类读取函数。 到这里这个ex ti的库函数就都看完了。 对于e x t i的初始化配置很明显啊。 用这个e x t r e d t函数就行了。 那我们回到这个初始化程序里来。 在这里直接先调一个eti net函数里面只有一个参数。 就是ex ti初始化的结构体。 因为e x ti只有一个。 所以不需要像gp那样先。 指定要配置哪个ex ti。 那我们右键跳转定义看一下说明啊。 函数简介写的是初始化ex t y s根据结构体里面指定的参数啊。 第一个参数是e x t r e d struct。 它是一个e t i t tab理范类型的结构体指针。 包含了对于ex ti外设的配置信息。 那我复制一下结构体类型的名字。 回到这里啊。 粘贴一下类型名。 然后起个变量名啊。 叫ex ti structure。 接着复制变量名在下面粘贴啊。 先把所有的结构体成员都用点儿引出来。 放在这里。 最后把结构体变量放在eti的参数里。 前面加上取粒子的符号。 接着我们来依次看一下参数啊。 第一个参数e x t r l。 这个是指定我们要配置的中转线。 那我们跳转到定义下面的这个选一下。 然后看一下右边的注释。 这个参数可以是e t i nx的任意组合。 我们选中e x t r nctrl f搜索一下。 这里可以看到啊。 这些就是这个参数的取值。 那我们需要用pb 14所在的第14个线路。 所以选择e l t i nine 14复制。 然后放到这里。 第一个参数就ok了。 接着第二个ex ti line command。 跳到定义看一下注释。 这里写的是指定选择的中断线的新状态。 这个参数可以是一label或disable。 那我们肯定要开启中断对吧。 所以复制一be放到这里。 第二个参数就ok了。 接着第三个ex tm的调到定义。 看一下注释。 这里写的是指定外部中断线的模式。 这个参数可以是ex tm的type defi里面的一个值。 但还是一样。 选中ctrl f搜索。 一下。 可以看到这是一个枚举。 第一个是中断模式。 第二个是事件模式。 那我们要用中断模式啊。 所以复制上面这个参数放到这里。 这样第三个参数也ok了。 接着看一下第四个参数啊。 e x c i trigger。 跳到定义。 看一下注释啊。 这里写的是指令触发信号的有效边缘。 这个参数可以是这个定义里的一个值。 那这个定义它这里写错了哈。 这里应该是e x t i tri格太不地方。 而不是ex tm的太不地方。 它现在搞得和上面这个一样了是吧。 这应该是个小疏忽啊。 那么往上稍微找一下。 可以找到这个ex ti催ger。 太不。 理犯的定义里面可以选择哈。 recent上升沿触发。 falling。 下降沿触发recent falling。 上升沿和下降沿都触发。 这个选择。 根据你的实际需求来啊。 我就选择falling下降沿触发了。 那放到这里。 这样我们的外部中断就配置完成了。 我们当前的配置是将ex ti的第14个线路配置为中转模式。 下降沿触发。 然后开启中断。 这样pb 14的电平信号就能通过e x t i通向下一级n v i c a了。 那最后我们就来执行第五步配置nvc。 我们还是先看一下库函数文件里的函数啊。 因为n o c是内核外设。 所以它的库函数是被s t发配到杂项这里来了。 我们打开m i s c点去拖。 到最后啊。 这里有nbc的四个函数和c的一个函数。 我们来看一下第一个n vc priority group configure。 这个函数是用来中断分组的。 参数是中断分组的方式。 然后第二个n v i c e d根据结构体里面指定的参数初始化n vc。 这个就不用多说了吧。 然后下面这个n vc set vector table。 设置中断向量表和nvc system lp configure系统低功耗配置。 这两个函数用的不多哈。 大家可以先不看这样这个n5 c的库函数就看完了。 只需要用上面的两个函数就行了哈。 在配置中断之前。 先指定一下中段的分组。 然后使用nyc 1 it初始化一下n vs就行了。 那我们复制一下nya priority group config。 这个函数回到配置这里来。 放在这里。 然后右键。 跳转到定义。 看一下上面啊。 这个简介是配置优先级。 分组先占优先级和重占优先级。 这里先占优先级就是抢占优先级。 重占优先级就是响应三级。 这个先站和从站的英文熟悉一下。 然后下面这个参数可以取这个列表里的一个词。 每个参数的解释。 这里可以看一下啊。 几位抢占。 几位响应和我上节讲的都是一样的哈。 这个具体要选哪个。 其实是根据我们的实际需求来的。 一般的话中段不多。 很难导致中断冲突。 对优先级分组来说就比较随意了哈。 哪个都行。 那这里我就选择第二个分组了。 两位。 抢占两位小樱。 这个比较平均一些。 我们复制一下这个参数。 然后放到这里来。 这样分组就完成了。 另外注意一下这个分组方式。 整个芯片只能用一种。 所以按理说这个分组的代码。 整个工程只需要执行一次就行了。 如果你把它放在模块里面进行分组。 那你要确保每个模块分组都选的是同一个哈。 要不你也可以把这个代码放在主函数的最开始。 这样模块你就不用再进行分组了。 那我这里就直接放在模块里进行分组了哈。 这样分组就完成了。 接下来直接调用nbs一类的函数。 右键跳转一下。 定。 义简介就不用看了。 直接复制nvc 1 d tab理范结构体放到这里。 然后结构体变量名叫nvc 1 d structure。 接着复制变量名啊。 把成员都引出来。 最后把结构体变量的地址放在nyc elete函数里。 然后依次看一下参数。 第一个aq channel跳转定义。 看一下解释啊。 指定中段通道来开启或关闭。 这个参数可以是iq n tap里面的一个值。 下面还有一个括号。 写的是对于完整的s t m32 中段通道列表。 请参考s t m32 f10 x.h文件。 这个意思是这个i r q n type的定义不在这个文件啊。 你要到s t m32 f10 x点区里面去找。 那我们还是选择这个iq n tab ctrl f搜索一下。 如果直接在这里搜索是搜索不到的。 那我们把下面的搜索范围由当前。 文件换成当前工程。 然后再搜索啊。 可以看到啊。 现在是跳到了s t m32 f10 x点去文件里。 这个定义就在这里哈。 我们可以在这上面的这个列表选择。 可以看到这里有非常多的中转通道。 因为这个库函数可以兼容所有的f一系列芯片。 但是不同的芯片中转通道列表是不一样的。 所以这里有很多条件编译哈。 用来选择你使用芯片的中转通道列表。 那我们可以点一下这左边的减号。 把所有的条件编译都折叠起来。 然后我们芯片用的是md中等密度的。 所以只需要展开这个md的条件编译即可。 其他的就不用看了。 那在这个表里。 我们就可以找到这个e x t 15。 杠10l q n s t m32 的ex t到e x t5 都是合并到了这个通道理啊。 所以我们复制这一个。 然后放到这里。 这样。 通道就制定好了。 接着i r q7 l command的跳转一下定义。 右边的解释是指定中段通道是死人还是势能参数。 可以是be或者disable。 我们选择be放在这里。 接着下面两个参数就是指定所选通道的抢占优先级和响应优先级了。 我们跳到定义看一下这两个参数的解释啊。 上面的是指定抢占优先级。 下面的是指定响应优先级。 这个值可以是零到15。 还具体的值可以参考这个表里的描述。 那我们选中这个表搜索一下。 可以看到啊。 这里给出了每个分组对应抢占优先级和响应优先级的取值范围。 这个表和我们ppt里的那个表是一样的。 我们选择了分组二。 那抢占优先级和响应优先级的取值范围就都是0~3。 那我们回到这里啊。 因为我们这个程序的中断只有一个。 所以中断优先级的配置也是非常随意的哈。 那我这里就给抢占优先级和响应优先级都设置为一。 优先级是在多个中状元同时申请产生拥挤时才有作用啊。 这只有一个中断优先级就随便了。 那到这里nyc就配置好了。 整个外部中断的配置也就结束了。 外部中断的信号从gpu到a f l o再到ex ti。 再到n v i c。 最终通向cpu啊。 这样才能让cpu有主程序跳到中断程序执行。 那中断程序应该放在哪里呢。 这就需要我们写一个中断函数了。 在s t m32 中。 中断函数的名字都是固定的。 每个中段通道都对应一个中断函数。 中断函数的名字。 我们可以参考一下启动文件哈。 那我们找到启动文件打开看一下。 在这里找一下。 可以看到这里定义的中断向量表。 这里面以iq handle结尾的字符串就是中断函数的名字。 我们可。 以找到这个ex c 15杠十iq handle这一项。 这就是e x t 15到十的中断函数。 我们复制一下。 回到这里啊。 再在下面写word。 粘贴一下中断函数的名字。 然后参数也是word。 这就是中断函数的格式。 中断函数都是无参无返回值的。 中断函数的名字不要写错了。 写错了就进不了中断了哈。 最好是直接从启动文件复制过来。 这样就不会有问题了。 然后在中断函数里一般都是先进行一个中断标志位的判断啊。 确保是我们想要的终端元触发的这个函数。 因为这个函数e x t到ex t5 都能进来。 所以要先。 判断一下是不是我们想要的e t 14进来的。 这时候我们就需要到e x t i点区里看一下。 复制一下这个e t i get it status放到这里来看一下参数啊。 第一个参数复制一下这个ex tnx放到这里。 然后x改成14。 看一下e x t 14的中断标志位是不是为一。 然后再看一下。 返回值是set或reset。 那我们就if把这函数括起来。 判断一下返回值是不是等于等于set。 如果是的话。 我们就可以执行中断程序了。 最后中断程序结束后。 一定要再调用一下清除中断标志位的函数。 因为只要中断标志位置一了。 程序就会跳到中断函数。 如果你不清除中断标志位。 那它就会一直升轻中断。 这样程序就会不断响应中断。 执行中断函数。 那程序就卡死在中断函数里了。 所以我们每次中断程序结束后。 都应该清除一下中断标志位。 我们复制一下e x t i可莉啊。 it pending beat。 放到这里。 参数也是ex tnine。 14将中。 断标志位清除。 这样中断的全部逻辑我们就写好了。 接下来我们就来测试一下能不能进入中断函数。 我们复制一下这个初始化函数的第一行啊。 放在头文件里。 声明一下。 这个中断函数就不用声明了。 因为中断函数不需要调用。 它是自动执行的。 那我们编译一下。 看一下没有问题。 我们写好模块之后。 最好编译一下。 要不然一会儿代码提示可能显示不出来。 我们新写的函数。 然后回到mac里面来。 在最上面include一下countertenor点。 然后在主循环前调用一下ctrance or 1。 这样就把外部中断配置好了。 然后就可以编译了哈。 没有问题。 我们使用一下这个调试模式。 看一下程序能不能跳转到中断函数。 那我们点击这个调试模式的按钮。 进入调试模式。 然后找一下中断函数啊。 在这里打一个断点。 然后全速运行。 看一下硬件。 我们用挡光片遮挡一下这个传感器。 这时我们看到程序成功跳转到中断函数里来了。 停在了这个断点处。 那我们继续传输运行。 再挡一下传感器。 可以看到程序又停到中段里来了。 这说明我们中断函数的配置和触发都是没问题的。 那接下来的事情就简单了。 我们退出角色模式啊。 我们想要一个数字来统计中断触发的次数。 那么就在这个模块上定义一个变量哈。 类型可以是uint 16档题。 名字可以是counter sensor。 ga count。 然后在中断函数里写counter sensor gcd加加。 这样就行了。 最后再在这个模块写一个get函数。 返回一下这个变量可以在这里写u int 16杠七。 counter sensor gget wor。 然后里面直接写return count。 生效杠杠的。 这样就行了。 然后我们把这个函数也放在头文件。 声明一下。 编译看一下。 没有问题。 然后在main函数里先改一下这个修四卷啊。 让它在一行一列显示一个count冒号。 在主循环里。 我们循环调用o l d c number。 在一行七列显示ctrl csgo get的返回值长度为五。 这样就是显示计算的数据了。 我们试一下哈。 这是oled显示的是count 00000。 然后我们挡一下传感器就加一啊。 再等一下就再加一。 再等一下就再加一。 这就是第一个程序的现象了。 我们现在用的是下降沿触发。 在移开挡光片的时候触发中断可以改一下。 这里。 变为上升沿触发再试一下。 现在就是遮挡的时候。 数字加一。 如果这里改成上升沿。 下降沿都触发。 再看一下。 就是遮挡和移开的时候都加一。 这就是各种触发方式的现象啊。 那到这里。 第一个程序就写完了。 接着我们再来看一下第二个程序。 先看一下经验图啊。 我们打开经验图的文件夹。 打开五杠二旋转编码器计次的图片。 来看一下这里右边还是o i d的电路。 左边这里插了一个旋转编码器模块。 上面vcc和歼d接正负极。 下面这两个ab向的输出硬件。 分别接到s t m32 的pb 0和pb 12个硬件。 这就是硬件电路。 我们在面包板上接一下哈。 首先把旋转编码器模块插到面包板上。 因为这个模块的引脚间距并不是标准的距离哈。 所以要稍微变一下银角才能插到面包板上。 然后用面包板跳线接一下电源。 vcc接电源正极。 接地接电源负极。 下面的两个零件用这个面包板飞线接一下啊。 a项输出接pb 0。 b项输出接pb 1。 这样硬件电路就完成了。 那我们找到工程文件夹。 也复制一下o led显示屏的工程。 改下名字啊。 叫五杠二旋转编码器。 计次打开工程。 把这些先删掉哈。 编译试一下。 没有问题。 下载看一下oled显示hello world有没有问题。 然后在q中我们还是先把旋转编码器建一个模块。 在hardware处右键添加新的文件。 选择c文件。 起个名字叫encoder路径。 加上反斜杠号的y。 i接着孩子在hardwell出右键添加新文件。 选择h文件。 也叫in code。 路径加上反斜杠。 hardw at头文件。 加上以flow defencoder h define include h。 最后仅和n的if。 然后c文件右键添加一下头文件。 接着还是写一个初始化函数啊。 void encode elite void。 在这里面我们初始化一下pb 0和pb 12个gpl口的外部中断。 当然这里只初始化一个外部中断。 其实也是可以完成功能的。 因为对于这个编码器而言。 正向旋转是ab向输出的是这样的波形。 反向旋转时输出的是这样的波形。 如果把一项的下降沿用作触发中断。 在中断时刻读取另一项的电瓶。 那你看正传就是高电平。 反转就是低电平。 这样就能区分旋转方向了。 只不过这样在操作上有一些小瑕疵啊。 比如你正转的时候。 由于a项先出现下降沿。 所以你刚开始动就进中断了。 而反转是a向后出现下降沿。 所以就是你转到位了才进入终端。 这样实际上也没问题哈。 就是有点不爽。 所以我准备的就是a b项都触发中断。 只有在b项下降沿和a项低电平时才判断为正转。 在a项下降沿和b向低电平时才判断为反转。 这样就能保证正转。 反转都是转到位了才执行数字加减的操作。 同时这样也可以给大家演示一下两个终端的初始化代码。 那我们开始写代码哈。 我们先把三个代码的初始化部分复制过来。 我们打开三个工程。 然后把这些初始化代码复制一下。 再回来啊。 粘贴放在这里。 然后改一下。 首先初始化时钟g p l b和a f l o这些不用改的。 接着初始化gp o我们用的是pb 0和pb 1。 所以这里改一下。 变成g p p0 或上gpp 1。 最后gp l e d g p b没问题。 然后是a f l中转引脚选择。 我们把这个14改成零。 将第零个线路拨到g p b上。 然后复制粘贴一下这个代码。 再将第一个线路拨到g p b上。 这样a f l o就完成了。 然后是e t i部分。 我们把这个指定的中段线改成e x t i纳零。 或者ex ti 1。 这样就能同时把第零条线路和第一条线路都初始化为中断模式。 下降沿触发了。 接着中断分组不用改的。 接着下面中断优先级。 这个要对两个通道分别设置优先级啊。 我们复制一下下面的这部分代码。 定义结构体变量的就不用复制了。 这个变量可以重复使用。 然后改一下上面的改成e x t i0 i q n。 优先级抢占和响应都还是一。 把下面的改成e x t i e l q n。 就把这个响应预算级改低一些。 设置为二吧。 好这样同时初始化e x t i0 和e x t i e的代码就改好了。 然后我们把这。 两个中断的中断函数都写一下。 我们打开启动文件。 看到这里有这两个中断的中断函数啊。 这里e x t i0 和ex t i e是分别独占一个函数的。 所以先复制一下这个ex t i0。 i q handler。 回到这里啊。 写上word e x t i0。 i q handler word。 在中断里我们也固定的检查一下中断标志位哈。 虽然这个函数只有ex t i0 可以触发。 但是作为固定模式的代码。 我们还是写一下吧。 在这里就写if e x t i get it status。 ex ti。 纳尼是不是等于等于set。 如果是的话。 执行中断程序。 最后ex ti可莉亚。 it pending beat e x t i n0。 清除中断标志位。 然后复制一下这个函数。 改一下函数名。 这里是e t i e l q handle里面判断标志位改成e x t r nine。 一清除标志位也是eti ne。 这样中断就完成了。 这里这两个中段是近的两个函数啊。 如果你使用的是9~5和15到十的这些中端。 那只能写一个中断函数。 这样就只需要把这两个if并列的放在一个函数里就行了。 那然后我们就可以写我们实现功能的代码了。 我们现在最上面定义一个变量。 因为这里需要正反转。 所以就定义一个带符号的变量吧。 int 16杠t起个名叫encoder count。 接着在中断函数里。 e x t i0 里。 我们先判断一下另一个引脚的电平。 if t p l o read input data。 bit。 gpb gpp 0。 是不是等于等于零。 如果是。 那就是反转就in扣着杠count减减。 当然这个是正转还是反转。 你可以自己定义啊。 正和反都是相对的。 然后在e r t i e里。 我们就e g p o reader。 input data bit gpb gpp 0。 是不是等于等于零。 如果是。 那就是正转。 就in code count加加。 这样中断对这个变量的加减就完成了。 我们先编译一下。 没有问题。 然后我们需要再定义一个函数。 把这个变量返回回去。 所以在这个位置写上int 16杠t include word。 在这里面我就不直接返回include count这个变量了。 我打算返回每次调用这个get函数之后。 返回count的变化值。 用于外部加减一个变量。 所以在这里我需要返回count。 然后把count清零。 那因为返回count之后函数就结束了。 没法清零了。 所以我先定义一个临时变量temp。 把count先赋值给tep。 再把count清零。 最后返回temp。 这样就完成了。 然后我们把这个函数放在头文件声明一下。 上面这个一it函数也声明一下。 编译看看。 没有问题啊。 那我们试一下。 在mdc里先include include点去。 然后include elite。 假设这里有一个变量number需要调用encoder模块对它进行加减。 那就可以在主循环里写number加等于encoder get。 因为这个get函数返回的是调用这个函数的间隔里。 旋转编码器产生的正负脉冲数。 所以这个返回值直接加等于给number。 就能对number进行加减操作了。 那最后我们加一下o i d显示在这里调用o led修sd number。 在一行五列显示lab长度为五。 上面的显示字符串也改一下哈。 一行一列显示number冒号。 这样代码就完成了编译。 下载看一下。 现在我们向右转编码器数字就增加。 但是现在有点不对劲啊。 向左转编码器数字减小是正常的。 那这个问题应该是中断里判断搞错了是吧。 我们看一下代码。 这里e x t i0 里面应该判断另一个引脚的。 所以这里应该是g p p1。 我们再看一下。 现在就没问题了。 向右转数字增加。 向左转数字减小好。 这就是第二个代码的全部内容了。 那最后再给大家提几个中断编程的建议哈。 第一个就是在这个中断函数里。 最好不要执行耗时过长的代码。 中断函数要简短快速。 别刚进中段就执行一个delay多少毫秒这样的代码。 因为中断是处理突发的事情。 如果你为了处理一个突发的事情。 待在中断里不出来了。 那主程序就会受到严重的阻塞。 另外就是最好不要在中断函数和主函数调用相同的函数。 或者操作同一个硬件。 尤其是硬件相关的函数。 比如oled显示函数。 如果你记在主函数里调用o l d。 又在中断里调用o l d o l d就会显示错误。 为什么呢。 因为你想在主程序里o o d刚显示一半。 他进中断了。 结果中断。 你还是d显示函数。 那oled就挪到其他地方显示了。 这时还没有问题啊。 但当中断结束之后。 需要继续原来的显示。 这时候就出问题了。 因为硬件的显示位置被挪到其他地方来。 所以再回来的时候继续显示的内容就会跟着跑到其他地方去。 这就会造成问题。 虽然在中段进入和退出的时候会有保护现场和恢复现场。 但这只。 能保证cpu程序能正常返回。 不出问题。 对于外部硬件的话。 并没有在进入中断时进行现场保护。 所以中断返回后就出问题了。 那为了避免这样的问题。 就最好不要在主程序和中断程序里操作。 可能产生冲突的硬件。 在实现功能的时候。 可以像我这样在中断里操作变量或者标志位。 当中断返回时。 我在对这个变量进行显示和操作。 这样既能保证中断函数的简短快速。 又能保证不产生冲突的硬件操作。 这就是中断程序设计的注意事项哈。 那在其他地方大家也都可以多用用变量或者标志位哈。 来减少代码之间的耦合性。 让各部分代码相互独立。 仅使用变量标志位或者函数作为接口。 这样能让程序更加清晰啊。 代码更加强健好。 那本节外部中断的部分到这里就结束了。 我们下节再见。
13. hello。 大家好。 欢迎继续观看sm 32入门教程。 结构最复杂的一个设定时器。 因为定时器的内容很多。 所以本大节总共分为四个部分。 八个小节。 在第一部分我们主要讲的是定时器基本定时的功能啊。 也就是定一个时间。 然后让定时器每隔这个时间产生一个中断。 来实现每隔一个固定时间执行一段程序的目的。 比如你要做个时钟秒表。 或者使用一些程序算法的时候。 都需要用到定时中断的这个功能。 在第二部分我们主要讲的是定时器输出比较的功能。 输出比较这个模块最常见的用途就是产生pwm波形。 用于驱动电机等设备啊。 来驱动舵机和直流电机的例子。 在第三部分我们主要讲的是定时器输入捕获的功能。 来实现测量方波频率的例子啊。 使用这个编码器接口能够更加方便地读取正交编码器的输出波形。 在编码电机测速中应用也是非常广泛的好。 那我们先来看一下第一部分的程序现象。 第一部分总共有两个程序。 第一个是定时器定时中断。 第二个是定时器外部时钟啊。 我们先看一下第一个下载。 这时候可以看到oled上显示了一个数字number。 并且每秒自动加一。 这个就是用了定时中断的功能啊。 定时器使用内部时钟定了一个一秒的时间。 每隔一秒申请一下中断。 然后在中断函数里执行number加加。 最后在o l d上显示number。 这就是第一个程序。 然后看一下第二个程序。 定时器外部时钟。 下载看一下这个程序使用了外部时钟来驱动定时器啊。 我们可以在定时器指定的外部硬件上输入一个方波信号。 来提供定时器计数的时钟。 现在这里我暂时用这个对射是红外传感器来手动模拟一个外部时钟啊。 我们用挡光片依次遮挡移开。 遮挡移开提供一个方波。 可以看到这个o r d上下面这个cnt就是定时器中计数器的值。 每遮挡一看一次。 计数器加一。 然后计数器寄到九后自动清零。 同时申请中断。 执行number加加。 这就是第二个程序的现象。 使用定时器的外部时钟可以提供一个更加精确的时钟来计时啊。 或者也可以把外部时钟当做一个计数器。 毕竟定时器本质上就是一个计数器对吧。 那接下来我们来看一下ppt。 首先tm它是英文timer的缩写。 意思是定时器。 然后定时器的基本功能就是定时器可以对输入的时钟进行计数。 并在计数值达到设定值时触发中断。 这就是定时器最基本的功能啊。 就是定时触发中断。 同时也可以看出来定时器就是一个计数器啊。 当这个计数器的输入是一个准确可靠的基准时钟的时候。 那他在对这个基准时钟进行计数的过程。 实际上就是计时的过程啊。 比如在sm 32中。 定时器的基准时钟一般都是主频72兆赫兹。 比如我对72兆赫兹即72个数。 那就是一兆赫兹。 也就是1微秒的时间。 如果记72000个数。 那就是1000Hz啊。 也就是1ms的时间。 然后看一下下一条s t m32 的定时器。 拥有16位计数器。 预分频器自动重装寄存器的时机单元在72兆赫兹技术时钟下。 可以实现最大59.65秒的定时。 这里计数器就是用来执行计数定时的一个计算器啊。 每来一个时钟。 计数器加一预分频器。 让这个技术更加灵活啊。 自动重装寄存器就是技术的目标值。 就是我想要记多少个时钟申请中断。 这些寄存器构成了定时器最核心的部分。 我们把这一块电路称为时机单元。 这个等会儿分析定时器结构的时候再详细点啊。 那这个实际单元里面的计数器。 预分频器自动重装器都是16位的。 二的16次方是65536。 也就是如果预分频器设置最大。 自动重装也设置最大。 那定时器的最大定时时间就是59.65秒。 接近一分钟啊。 这个怎么算的呢。 就是72兆除以65536。 再除以65536。 得到的是中断频率。 然后取倒数就是59.65秒多啊。 大家可以自己算一下。 这就是最大的定时时间。 应该说还是挺长的了。 如果你嫌这个还不够长。 s t m32 的定时器还支持几年的模式。 也就是一个。 定时器的输出当做另一个定时器的输入。 这样加一起最大的定时时间就是59.65秒。 再乘两次6536。 这个时间大概是8000多年。 这下够长了吧。 如果还嫌短。 那就再积累一个定时器。 定时时间还会再延长6536x6536倍。 这个可见指数爆炸的威力哈。 小小的s t m323 个定时器几年就能实现丈量宇宙年龄的能力。 你用s tm 3定个时就能从宇宙诞生。 一直记到宇宙灭亡。 这个还是非常厉害的哈。 那我们接着看ppt下面这一条htm 12的。 定时器不仅具备基本的定时中断功能。 输入捕获。 输出比较。 编码器接口。 主从触发模式等多种功能。 由于定时器的这个基本结构是非常通用的哈。 很多模块电路都能用到。 所以htm 3的定时器上扩展了非常多的功能。 我们第一部分讲的就是这个定时中断和内外时钟源选择的功能。 第二部分讲输出比较。 第三部分讲输入捕获和主从触发模式。 第四部分讲编码器接口。 这就是课程的安排啊。 当然除了这些。 还是有很多的功能没讲到。 不过最常用最基本的功能都会给大家讲到的。 然后看一下最后一条htm 32的定时器。 根据复杂度和应用场景分为了高级定时器。 通用定时器。 基本定时器三种类型。 其中高级定时器最为复杂。 通用定时器中等复杂哈。 最常用基本定时器最简单。 我们课程主要讲的就是通用定时器。 学会了通用定时器。 再学高级定时器和基本定时器。 那都应该没问题的啊。 接下来我们就来看一下这三种定时器的一个介绍表啊。 首先是第一列类型。 分为了高级定时器。 通用定时器和基本定时器。 然后第二点编。 号这个熟悉一下。 因为同一个芯片一般有很多个定时器。 所以tm后面会跟一个数字编号和定时器类型的对应关系。 就是tm一和tim 8是高级定时器。 tm 2345是通用定时器。 tm 6和tm 7是基本定时器。 当然除了tm一到八。 在库函数中还出现了tm 9010 11等等啊。 这些一般都用不到啊。 只需要知道一下t i m一到八每个都是什么定时器就好了。 然后看一下第三列这些不同类型的定时器啊。 它所连的总线也是不一样的。 其中高级定时器连接的是性能更高的a p p2 中线。 通用定时器和。 基本定时器连接的是a b一中线。 这个在rcc开启时钟的时候要注意一下。 最后看一下功能。 先看基本定时器。 它的功能最少只有基本的定时中断功能和一个主模式触发dc的功能。 所以基本定时器还可以和dc联合使用。 这就是基本定时器还是比较简单的。 然后是通用定时器。 这就复杂起来了。 它拥有基本定时器全部功能。 也就是下面的这个定时中断和触发dc的功能。 同时它还额外具有内外时钟源。 选择输入捕获输出比较编码器接口储存触发模式等功能。 那这些功能呢就是我们本课程。 在后面也都会给大家讲的。 最后就是高级定时器了。 这就更复杂了。 它拥有通用定时器全部功能。 也就是下面这些功能它全都有。 同时它还具有重复计数器死去生成互补输出。 刹车输入等功能。 这些功能主要是为了三相无刷电机的驱动设计的哈。 我们本课程暂时不会涉及到好。 那这些就是这三种定时器的大概介绍了。 可以看出来这三种定时器是由高级到低级向下兼容的。 高级定时器。 拥有通用定时器的全部功能。 通用定时器又有基本定时器的全部功能。 最后这里是对。 于s t m32 f103 c8 t6。 这款芯片它内部拥有的定时器资源是tm一到tm 4。 也就是一个高级定时器和三个通用定时器。 没有基本定时器啊。 这个注意一下。 不同的型号定时器的数量是不同的。 你在操作这个外设之前。 一定要查一下它是不是有这个外设。 别操作到了不存在的外设。 那样是不会起作用的啊。 接下来我们就依次来看一下高级定时器。 通用定时器和基本定时器的结构图啊。 看一下这三种定时器是怎么样来工作的。 设计这些结构都能完成哪些任务。 那我们先从简单的。 基本定时器开始看哈。 前面我们比里列出来了。 基本定时器可以完成定时中断和主模式触发dc的功能。 那我们就来看一下这个定时器设计的结构是怎么来完成这些功能的。 首先这一部分有三个最重要的寄存器啊。 分别是预分频器。 计数器和自动重装计算器。 它们构成了最基本的计数计时电路。 所以这一块电路就叫做实际单元预分频器。 之前连接的就是基准计数时钟的输入啊。 最终来到了这个位置。 由于基本定时器只能选择内部时钟。 所以你可以直接认为这根线直接连到了输入端的这里。 也就是内部时钟c k i n t内部时钟的来源是r c c t mx clk。 这里的频率值一般都是系统的主频72兆赫兹。 所以通向实际单元的技术基准频率就是72兆。 再来看实际单元。 首先是预分频器。 它可以对这个72兆赫兹的技术时钟进行预分频。 比如这个计算器写零。 那就是不分屏。 或者说是一分屏。 这时候输出频率等于输入频率等于72兆赫兹。 如果预分频器写一。 那就是二分频。 输出频率等于输入频率除以二。 等于36兆赫兹。 如果写二就是三分频。 输出等于输入除以三。 以此类推。 所以预分频器的值和实际的分频系数相差的一。 即实际分频系数等于预分频器的值加一。 这个预分频器是16位的啊。 所以最大值可以写65535。 也就。 是65536分屏。 这就是预分频器。 就是对输入的基准频率提前进行一个分屏的操作。 然后是计数器。 这个计数器可以对预分屏后的技术始终进行计数。 计数时钟每来一个上升。 沿计数器的值就加一。 这个计数器也是16位的。 所以里面的值可以从零一直加到6535。 如果再加的话。 计数器就会回到零。 重新开始。 所以计数器的值在计时过程中会不断的自增运行。 当自身运行的目标值时产生中断。 那就完成了定时的任务。 所以现在还需要一个存储目标值的计算器。 那就是自动重装寄。 存器了。 自动重装寄存器也是16位的。 它存在就是我们写入的技术目标。 在运行的过程中。 计数值不断自增。 自动重装值是固定的目标。 当计数值等于自动重装值时。 就是计时时间到了。 那它就会产生一个中断信号。 并且清零计数器。 计数器自动开始下一次的计数计时。 在这里图上画的一个向上的折线箭头啊。 就代表这里会产生中断信号。 像这种计数值等于自动重装值产生的中断呢。 我们一般把它叫做更新中断。 这个更新中断之后就会通往nvc。 我们在配置好nvc的定时器通道。 那定时期的。 更新中断就能够得到cpu的响应。 这里向下的箭头代表的是会产生一个事件。 这里对应的事件就叫做更新事件。 更新事件不会触发中断。 但可以触发内部其他电路的工作。 以上这些就是定时器定时中断的全部流程的。 从基准时钟到预分频器。 再到计数器。 计数器计数至尊。 同时不断地与自动重装计算器进行比较。 他俩值相等时。 即计时时间到这时会产生一个更新中断和更新事件。 cpu响应更新中断就完成了我们定时中断的任务了。 好到这里。 定时中断和时机单元的工作流程。 我们就已经讲。 完了哈之后我们简单的介绍一下这个主模式触发dc的功能。 sdm 32定时器的一大特色就是这个主从触发模式。 它能让内部的硬件在不受程序的控制下实现自动运行。 如果能把这个主从触发模式掌握好。 那在某些情景下将会极大的减轻cpu的负担哈。 这个模式我们后面的课程还会再详细讲的。 这里简单了解一下。 那我们来看一下这个主模式触发dc有啥用呢。 这个用途就是在我们使用dac的时候。 可能会用dac输出一段波形。 那就需要每隔一段时间来触发一次dc。 让它输出下一个电压点。 如果用正常的思路来实现的话。 就是先设置一个定时器产生中断。 每隔一段时间在中断程序中调用代码。 手动触发一次dac转换。 然后dc输出。 这样也是没问题的哈。 但是这样会使主程序处于频繁被中断的状态。 这会影响主程序的运行和其他中断的响应哈。 所以定时器就设计了一个主模式。 使用这个主模式可以把这个定时器的更新事件啊。 映射的这个触发输出tr g o的位置。 然后t r g o直接接到dc的触发转换引脚上。 这样定时器的更新就不需要再通过中断来触发dc转换了。 仅需要。 把更新事件通过主模式映射的tr g o。 然后t r g o就会直接去触发dc的整个过程。 不需要软件的参与。 实现了硬件的自动化。 这就是主模式的作用。 当然除了这个主模式外。 还有更多的硬件自动化的设计。 这些我们后续再继续讲哈。 那有关基本定时器的部分我们就讲完了。 接下来我们再看一下通用定时器。 到通用定时器这里来。 结构就瞬间复杂了很多啊。 我们来看一下。 首先中间最核心的这一部分还是实际单元。 这部分结构和基本定时器是一样的啊。 由预分频器计数器自动重装计数。 器构成每部分的工作流程和基本定时器也是一样的。 预分频器对时钟进行预分频。 计数器自增技术。 当计数值达到自动重装值时。 计数值清零。 同时产生更新中断和更新事件。 不过对于通用定时器而言。 这个计数器的计数模式就不止向上计数这一种呢。 我之前解释的时候都是用的向上技术的模式。 也就是计数器从零开始向上自增g的重装值清零。 同时申请中断。 然后开始下一轮依次循环。 这是线上技术。 除了这种向上技术的模式外。 通用定时器和高级定时器还支持向下技术模式和中。 央对齐模式。 向下技术模式就是从从庄子开始向下至减减到零之后回到童装值。 同时申请中断。 然后继续下一轮依次循环。 这就是向下技术。 就是从零开始先向上自增寄到重装值。 申请中断。 然后再向下自减减到零。 再申请中断。 然后继续下一轮依次循环。 总结一下就是基本定时器仅支持向上技术这一种模式。 通用定时器和高级定时器支持向上技术。 向下技术。 这个模式的比较多哈。 不过我们最常用的还是向上计数模。 式啊。 所以其他两种模式大家就了解一下。 主要掌握向上技术的模式就行了。 然后我们再来看一下上面的这部分结构啊。 这些就是内外时钟源选择和主从触发模式的结构了。 我们先看一下内外时钟源选择。 对于基本定时器而言。 定时器只能选择内部时钟。 也就是系统频率72兆赫兹。 到了通用定时器这里。 时钟源不仅可以选择内部的72兆赫兹时钟。 还可以选择外部时钟。 具体都有哪些呢。 第一个外部时钟就是来自tm x e t r引脚上的外部时钟。 这个e t r引脚的位置可以参考。 一下引脚定义表。 可以看到这里有tm 2 c h e e t r。 意思就是这个tm 2的c h一和e t r都是复用在了这个位置。 也就是pa 0引脚下面还有c h2。 c h3。 c h4 和其他定时器的一些硬件哈。 也都可以在这里找到。 那这里我们可以在这个tm 2的e t r银角。 也就是pa 0上接一个外部方波始终。 然后配置一下内部的极性。 选择边缘检测和预分频器电路。 再配置一下输入滤波电路。 这些电路可以对外部时钟进行一定的整形啊。 因为是外部硬件的时钟。 所以难免会有些毛刺。 那这些电路就可以对输入的波形进行滤波啊。 同时也可以选择一下急性和预分频器。 最后滤波后的信号兵分两路。 上面引入e t i f进入触发控制器。 紧跟着就可以选择作为实际单元的时钟了。 如果你想在e t r外部引脚提供时钟。 或者想对e t r时钟进行计数。 把这个定时器当做计数器来用的话。 那就可以配置这一路的电路啊。 在s t m32 中。 这一路也叫做外部时钟模式二。 除了外部e t r引脚可以提供时钟外。 下面这里还有一路可以提供时钟。 就是t r g i这一路从名字上来看的话。 它主要是用作触发输入来使用的哈。 这个触发输入可以触发定时器的重模式。 关于触发输入和重模式啊。 我们后续的课程在讲。 本小节我们讲的是这个触发输入作为外部时钟来使用的情况。 你暂且可以把这个tr gi当做外部时钟的输入来看。 当这个t r gi当做外部时钟来使用的时候。 这一步就叫做外部时钟模式一。 那通过这一路的外部时钟都有哪些呢。 往左看。 第一个就是e t r引脚的信号。 这里e t r引脚既可以通过上面这一路来当做时钟。 又可以通过下面这一路来当做时钟。 两种情况对于时钟输入而言是等价的哈。 只不过是下面这一路输入会占用触发输入的通道而已。 然后第二个就是i t r信号。 这一部分的时钟信号是来自其他电子器的。 从右边可以看出来。 这个主模式的输出t r g o可以通向其他定时器。 那通向其他定时器的时候。 就接到了其他定时器的i t r引脚上来了。 这个i t20 到t r3 分别来自其他四个定时器的t r g o输出。 至于具体的连接方式是怎么样的。 手册的这个位置有一张表哈。 这里可以看到tm 2的i t r0 是接在了tm一的tr机上的。 i t r一接在tm 8。 i t r2 接在tm 3。 i t r3 接在了tm 4。 其他定时器也都可以参照一下这个表啊。 这就是i t r和定时器的连接关系。 通过这一路我们就可以实现定时器直连的功能。 比如我们可以先初始化tm 3。 然后使用主模式把它的更新事件映射到tr g o上。 接着再数字化tm 2。 这里选择t r2 对应的就是tm 3的tr 9。 然后后面再选择时钟为外部时钟模式一。 这样tm 3的更新事件就可以驱动tm 2的实际单元。 也就实现了定时器的吉连。 那我们继续看这里还可以选择t i e f杠e d。 这里连接的是这里输入捕获单元的c h10 件。 也就是从c区一引脚获得时钟。 这里后缀加一个d就是边缘的意思啊。 也就是通过这一路输入的时钟上升沿和下降沿均有效。 最后这个始终还能通过ti 1 f p一和ti 2 fp 2获得。 其中t i e f p一是连接到了这里啊。 就是c h e眼角的时钟啊。 t i2 f p2 连接到了这里。 就是c h2 in加的时钟到这里。 外部时钟模式一的输入就介绍完了。 总结一下就是外部时钟模式一的输入可以是e t r引脚。 其他定时器c区一硬件的边缘。 c h e音阶和c区二零件。 这还是比较复杂的哈。 一般情况下外部始终通过e t r引脚就可以了。 下面设置这么复杂的输入。 不仅仅是为了扩大时钟书的范围哈。 更多的还是为了某些特殊应用场景而设计的哈。 比如未来定时器的吉连而设计的这一部分。 下面这一部分我们之后讲输入捕获和测评。 律师还会继续讲的哈。 到时候你就会明白他为什么要这样设计的。 现在这些电路你大概了解一下就行了哈。 对于时钟输入而言。 最常用的还是内部的72兆赫兹的时钟。 如果要使用外部时钟。 首选e t r引脚。 外部时钟模式二的输入。 这一路最简单最直接哈。 那有关时钟输入的部分到这里就讲完了。 最后这里还有一块没有讲到啊。 这个是定时器的一个编码器接口。 可以读取正交编码器的输出波形。 这个我们后续课程也会再讲啊。 然后接下来右边这里这个就是定时器的主模式输出了。 这部分电路可以把内部的一些事件映射的这个t r g o引脚上。 比如我们刚才讲基本定时器分析的啊。 将更新事件映射的t r g o用于触发d a c。 这里也是一样哈。 我们可以把定时器内部的一些事件映射到这里来。 用于触发其他定时器d a c或者a d c。 可见这个触发输出的范围是比基本定时器更广一些的哈。 那上面的这一部分就差不多了哈。 我们再看一下下面这部分。 右边这一块是输出比较电路。 总共有四个通道。 分别对应c h e到c h4 的硬件。 可以用于输出pwm波形驱动电机啊。 左边这一块是输入捕获电路。 也是有四个通道。 对应的也是c一到c h4 的硬件。 可以用于测量输入方波的频率等。 来中间这个计算器是捕获比较计算器是输入捕获和输出比较。 电路共用的。 因为输入捕获和输出比较不能同时使用。 所以这里的计算器是共用的哈。 银角也是共用的。 那有关输入捕获和输出比较。 这部分电路我们留到之后的视频再具体分析哈。 我们本节主要讲的是定时中断和内外时钟源选择。 也用不到这部分电路啊。 好有关通用定时器的内容。 我们暂时就讲到这里。 最后我们简单的看一下高级定时器。 到高级定时器这里呢结构就更加复杂了。 对比通用定时器的结构啊。 高级定时器这里左上的这一大部分都没有变化。 主要改动的就是右边这几个。 部分我们来看一下。 第一个是这里申请中断的地方。 增加了一个重复次数计数器。 有了这个计数器之后。 就可以实现每隔几个计数周期才发生一次更新事件和更新中断啊。 原来的结构是每个技术周期完成后都会发生更新。 现在有个计数器在这里可以实现每隔几个周期再更新一次。 这就相当于对输出的更新信号又做了一次分屏哈。 那对于高级定时器的话。 我们之前计算的最大定时时间59秒多。 在这里就还需要再乘一个6536。 这就又提升了很多的定时时间了是吧。 这就是这个重复计数器的工作流程。 然后下面这里的这些就是高级定时器对输出比较模块的升级了。 这些内容简单说一下。 大家有个印象就行了。 现在还不必深入了解。 我们看一下这个dt g是死需生成电路。 右边这里的输出引脚由原来的一个变为了两个互补的输出。 可以输出一对互补的p wm波。 这些电路是为了驱动三下五刷电机的哈。 三下五刷电机还是比较常用的。 比如四轴飞行器啊。 电动车的后轮啊。 电钻等里面都可能是这个三相无刷电机。 因为三下五刷电机的驱动电路一般需要三个墙壁。 每个桥壁两个大功率开关管来控制。 总共需要六个大功率开关管的控制。 所以这里的输出pwm引脚的前三路就变为了互补的输出。 而第四路却没什么变化啊。 因为三项电机只需要三路就行了。 为了防止互补输出的p dm驱动墙壁时。 在开关切换的瞬间。 由于器件的不理想哈。 造成短暂的直通现象。 所以前面这里就加上了死去生成电路。 在开关切换的瞬间产生一定时长的死去。 让墙壁的上下管全都关断。 防止直通现象啊。 那最后一部分就是刹车输入的功能呢。 这个是为了给电机驱动提供安全保障的。 如果外部引脚bk i n产生了刹车信号或者内部时钟失效产生了故障。 那么控制电路就会自动切断电机的输出。 防止意外的发生。 这就是刹车输入的功能。 那到这里我们这个表里的每个功能都大概介绍了哈。 还有一些没详细介绍。 我们后续课程再说。 然后这些高级定时器。 通用定时器。 基本定时器的框图也都介绍完了。 接下来我们来看一下这个图。 这是我画的一个定时中断基本结构图啊。 在这个图里我把其他无关的东西都去掉了。 另外还加了一些定时器框。 图里没体现出来的东西。 我们来着重看一下本小节的两个任务啊。 定时中断和内外时钟源。 选择这些所设计的结构。 那首先中间最重要的还是psc预分频器。 c n t计数器。 a r r自动重装计算器。 这三个计算器构成的实际单元。 下面这里是运行控制。 就是控制金属器的一些vr。 比如启动停止啊。 向上或向下计数等等。 我们操作这些计算器就能控制实际单元的运行了。 左边是为实际单元提供时钟的部分。 这里可以选择rcc提供的内部时钟。 也可以选择etr银角提供的外部时钟模式二。 在本小节示例程序里。 第一个定时器定时中断就是用的内部时钟这一路。 第二个定时器外部时钟就是用的外部时钟模式二。 这一路当然还可以选择这里的触发输入。 当做外部时钟啊。 即外部时钟模式一对应的有e t r y b时钟。 这些就是定时器的所有可选的时钟源了。 最后这里还有个编码器模式。 这一般是编码器独用的模式啊。 普通的始终用不到这个。 接下来右边这里就是计时时间到产生更新。 中断后的信号趋向。 在这里。 如果是高级定时器的话。 还会多一个重复计数器。 这个注意一下哈。 不过我们暂时就不考虑了。 那这里中断信号会先在状态寄存器里自一个中断标志位。 这个标志位会通过中断输出控制到nvc申请中断。 为什么会有一个中段输出控制呢。 因为这个定时器模块有很多地方都要升级终端。 比如前面这个图里。 不仅更新要申请中断。 这里触发信号也会申请中断。 还有下面的输入捕获和输出比较匹配时也会申请。 所以这些中段都要经过中断输出控制。 如果需要这个中段。 那就允许。 如果不需要。 那就禁止。 简单来说这个中段输出控制就是一个中段输出的允许位。 如果需要某个中段。 就记得允许一下好。 接下来我们再来看几个时序图啊。 研究一下实际单元运行的一些细节问题。 第一个是预分明细时序。 这个图是当预分频器的参数从一变到20计数器的时序图。 第一行是c k p s c预分频器的输入时钟。 就是这个图里的这个位置啊。 选内部时钟的话。 一般是72兆赫兹。 然后这个时钟在不断地运行。 下面这个cnt e n计数器使能高电平计数器正常运行。 低电平计数器停止啊。 在下面是c k c n t计数器。 时钟就是这个位置。 它既是预分频器的时钟输出。 也是计数器的时钟输入啊。 这里可以看到开始时计数器未使能。 计数器始终不运行。 然后死人后前半段预分频器系数为一。 计数器的时钟等于预分频器前的始终。 后半段预分频器系数变为二的。 计数器的时钟就也变为预分频器前十中的一半。 在计数器时钟的驱动下。 下面计数器寄存器也跟随始终的上层岩不断自增。 在中间的这个位置。 fc之后计数值变为零了。 这里虽然没写哈。 但是可以推断出a r r自动重装值就是fc当计数值记得和重装值相等。 并且下一个时钟来临时。 计数值才清零。 同时下面这里产生一个更新事件。 这就是一个技术周期的工作流程啊。 然后下面还有三行时序。 这三行时序是什么意思呢。 这里描述的其实是这个预分屏计算器的一种缓冲机制啊。 也就是这个预分屏计算器实际上是有两个。 一个是这个供我们读写用的。 它并不直接决定分频系数。 另外还有个缓冲寄存器。 或者说是影子寄存器。 缓冲寄存器和影子寄存器啊。 这两个说法其实是一个意思啊。 这个缓冲寄存器才是真正起作用的计算器啊。 比如我们在某个时刻把预分屏计算器由零改成了一。 如果在此时立刻改变时钟的分频系数啊。 那么就会导致这里在一个技术周期内。 前半部分和后半部分的频率不一样。 这里计数计到一半。 计数频率突然就会改变了。 这虽然一般并不会有什么问题啊。 但是s t m32 的定时器比较严谨。 设计了这个缓冲寄存器。 这样当我在计数记到一半的时候。 改变了分明值。 这个变化并不会立刻生效。 而是会等到本次技术周期结束时产生的更新事件。 预分频计数器的值才会被传递到缓冲寄存器里面去。 才会生效啊。 所以在这里看到。 即使我在技术中途改变了预分频值。 技术频率仍然会保持为原来的频率。 直到本轮技术完成。 在下一轮技术时改变后的分频值才会起作用。 最后这里也是啊。 预分频器内部实际上也是靠技术来分屏的。 当预分屏值为零时。 计数器就一直为零。 直接输出将频率当预分频值为一时。 计数器就01010101。 这样记住。 再回到零的时候输出一个脉冲。 这样输出频率就是输入频率的二分频。 预分频器的值和时间的分频系数之间有一个数的偏移哈。 那最下面就有这样一个公式。 就是计数器计数频率c k c n g等于c k p s c除以p sc加一。 这个好理解吧。 然后继续下一页看一下计数器时序。 这个图是计数器时序图。 内部时钟分频因子为二。 就是分频系数为二哈。 第一行是内部始终70兆赫兹。 第二行是时钟使能高电平启动。 第三行是计数器时钟。 因为分频系数为二。 所以这个频率是上面这个除二啊。 然后计数器在这个时钟每个上升沿至增。 当增到0036的时候发生溢出。 那g到三六之后再来一个上升沿计数器清零。 计数器溢出啊。 产生一个更新事件脉冲。 另外还会自一个更新中断标志位。 u y f这个标志位只要质疑了就会去申请中断。 然后中断响应后需要在中断程序中手动清零。 这就是计数器的工作流程。 下面有个市值啊。 计数器溢出频率c k c n t o a等于c k c n t除以a r r加一。 这个a r的值也是要加一的哈。 把上面这个式子带进去。 就是等于c k p s c除以p s c加一。 再除a r2 加一。 这就是我们在计算定时时间的一个式子啊。 用72兆赫兹除以p sc加一。 再除a r2 加一。 就能得到溢出频率。 如果想算溢出时间。 那就只需要再取个倒数就行了。 那刚才说了。 预分频器为了防止技术中途更改数值造成错误啊。 设计了缓冲寄存器。 这个计数器那肯定也少不了这样的设计了。 我们可以看一下这个结构图啊。 这里面像这样带一个黑色阴影的计算器。 都是有影子寄存器这样的缓冲机制的哈。 所以计数器的这个ai自动重装计算器也是有一个缓冲寄存器的。 并且这个缓冲计算器是用还是不用。 是可以自己设置的哈。 下面这两个图。 第一个计数器无预装时序。 就是没有缓冲计算器的情况。 第二个有预装时序就是有缓冲寄存器的情况。 通过设置这个a r p e位就可以选择是否使用预装功能。 我们先看一下无预装的情况。 在这里计数器正在进行自侦技术。 我突然更改了自动加载计算器。 就是自动重装计算器啊。 由f f改成了三六。 那计数值的目标值就有f f变成了三六。 所以这里记到三六之后就直接更新。 开始下载技术。 再看一下下面这个图。 有预兆的情况。 在技术的中途。 我突然把技术目标由f5 改成了三六。 可以看到下面有个影子寄存器啊。 这个影子寄存器才是真正起作用的。 它还是f5。 所以现在技术的目标还是g到f5 产生更新事件。 同时要更改的三六才被传递的影子计算器。 在下一个技术周期。 这个更改的三六才有效。 所以可以看出啊。 引入这个影子计算器的目的实际上是为了同步。 就是让值的变化和更新事件同步发生。 防止在运行途中更改造成错误啊。 在这个例子也可以看出。 如果这里不使用硬质计算器的话。 f5 改到三六立刻生效。 但此时计数值已经到了。 f一已经超过三六了。 f一只能增加。 但他的目标却是三六比他还小。 这样f一就只能一直加一直加。 一直加到f f f f再回到零。 再加到三六才能产生更新。 这就会造成一些小问题哈。 当然如果你不介意这样的问题的话。 那就不用管这些细节了。 毕竟s t m32 设计出来要考虑到各种各样的情况。 所以做的比较严谨哈。 接下来我们再看一下最后一个ppt。 在这里给出了一个2c c时钟树的结构图。 这个时钟数就是s t m32 中用来产生和配置时钟。 并且把配置好的时钟发送到各个外设的系统啊。 时钟是所有外设运行的基础。 所以时钟也是最先需要配置的东西。 我们之前说过程序中主函数之前还会执行一个system 1 d的函数。 这个函数就是用来配置这个时钟数的。 这个结构看上去挺复杂的哈。 配置起来还是比较麻烦的。 不过好在ht公司已经帮我们写好了配置这个时钟数的system init函数啊。 那这里我们就来看一下这个时钟数。 在这个时钟数里啊。 从这里画一个界限。 左边的都是时钟的产生电路。 右边的都是时钟的分配电路啊。 中间的这个system clock就是系统始终72兆赫兹在时钟产生电路啊。 有四个震荡源。 分别是内部的八兆赫兹高速rc振荡器。 外部的四到16Hz高速石英晶体振荡器。 也就是金正啊。 一般都是接八兆赫兹。 外部的32点七六八千赫兹低速竞争。 这个一般是给rtc提供时钟的。 最后是内部的40 千赫低速rc振荡器。 这个可以给看门狗提供时钟上面这两个高速竞争啊。 是用来提供系统时钟的。 我们a h b a b2 a b一的时钟都是来源于这两个高速竞争哈。 这里内部和外部都有一个八兆赫兹的竞争。 都是可以用的。 只不过是外部的石英振荡器比内部的rc振荡器更加稳定。 所以一般我们都用外部竞争。 但是如果你系统很简单。 而且不需要那么精确的时钟。 那也是可以使用内部rc振荡器的。 这样就可以省下外部晶振的电路了。 那在c1 d函数里。 s t是这样的。 配置适中的哈。 首先它会启动内部时钟。 选择内部八兆赫兹为系统时钟。 暂时以内部八兆赫兹的时钟运行啊。 然后再启动外部时钟。 配置外部时钟走这一路进入p l l锁相环进行倍频八兆赫兹。 倍频九倍。 得到72兆赫兹。 等到锁相环输出稳定后。 选择锁相环输出为系统适中。 这样就把系统时钟由八兆赫兹切化为了72兆赫兹。 这是s t配置的流程哈。 大家可以自己分析一下system 1 d的函数时间关系。 我就不带着大家一步步分析了。 这样分析之后可以解决实际应用的一个问题哈。 那就是如果你的外部基站出问题了。 可能会导致一个现象哈。 就是你会发现你程序的时钟慢了大概十倍。 比如你用定时器定一个一秒的时间。 结果过了大概十秒才进终端。 这个问题就出在这里哈。 如果外部晶振出问题了。 系统始终就无法切换到72兆赫兹。 那它就会以内部的八兆赫兹运行。 八兆相比于72兆大概就慢了十倍。 我之前画了个板子就遇到了这个问题哈。 我发现时钟好像慢了十倍。 检查一下。 发现我芯片焊接的时候啊。 把外部晶振的两个引脚焊短路了。 最后把这两个引脚分开。 始终就变为正常的72兆了。 另外这里还有一个cs s。 这个是时钟安全系统啊。 他也是负责切换时钟的。 它可以监测外部时钟的运行状态哈。 一旦外部时钟失效。 它就会自动把外部时钟切换回内部时钟。 保证系统时钟的运行哈。 防止程序卡死造成事故。 另外在这个高级定时器这里哈。 也有这个css的声音。 在这个刹车输入这里。 一旦cs检测到外部时钟失效。 这里通过后门就会立刻反应到输出比较这里。 让这个输出控制电机立刻停止啊。 防止意外。 这就是这个s t m32 里面的一些安全保障措施。 那回到这里啊。 接下来我们再看一下这右边的时钟分配电路。 首先系统时钟72兆赫兹。 进入hb中线。 hb中线有个预分频器。 在system init里配置的分明系数为一。 那hb的时钟就是72兆赫兹。 然后进入app一中线。 这里配置的分配系数是二。 所以a b一总线的时钟为72兆赫兹。 除以2=36兆赫兹。 现在大家可能会有个问题哈。 就是我们刚才说通用定时器和基本定时器是接在a p p一上的。 而a p p一的时钟是36兆赫兹。 按理说他们的时钟应该是36兆赫兹啊。 但是我在讲定时器的时候。 一直都说的是。 所有的定时器的时钟都是72兆赫兹。 这是为啥呢。 原因就在这里。 这下面还有一条支路。 上面写的是。 如果a b一预分频系数等于一。 则频率不变。 否则频率乘二。 然后再看右边发现这一路是单独为定时器2~7开通的。 那因为这里预分频系数我们给的是二。 所以这里频率要再乘二。 所以通过定时器2~7的时钟就又回到了72兆赫兹。 所以这里就可以有个结论啊。 无论是高级定时器还是通用电子器。 还是基本电子器。 它们的内部基准时钟都是72兆赫兹。 这个就给我们的使用带来的方便哈。 不用再考虑不同定时器的时钟不一样的问题了。 当然前提是你不乱改他。 c storm init里面的默认配置。 要是改了这里的时钟还得再另行分析哈。 然后我们再看一下下面a b2 的时钟。 这里给的分明系数为一。 所以a b2 的时钟和hb一样。 都是72兆赫兹。 这里接待app 2上的高级粒子器也单开了。 一路上面写的也是。 如果a b2 预分频系数等于一。 则频率不变。 否则频率乘二。 但是这里a b2 的预分频系数就是一。 所以频率不变。 定时器一和八的时钟就是72兆赫兹啊。 那在这些时钟输出这里啊。 都有一个与门进行输出控制。 控制位写的是外部始终使人。 这就是我们在程序中写r c c a b2 或者a b1。 外设时钟控制作用的地方。 打开时钟就是在这个位置写一。 让左边的时钟能够通过与门输出给外设好。 那就有关于时钟数的内容。 我就讲到这里哈。 剩下的还有一些给a d c啊。 s d l o等等这些提供时钟的电路啊。 大家就自己看看了。 最后我们还是再简单的看一下手册。 看看手册上关于定时器的介绍。 在手册里关于定时器的介绍。 有三张。 高级定时器。 通用定时器和基本定时器各占一章。 内容还是非常多的哈。 我们打开通用定时器看一下哈。 首先是简介。 这里有它的一些基本描述哈。 然后下面是结构图。 这个还是很重要的哈。 再下面就是功能描述啊。 有实际单元。 这里面有一些时序图哈。 演示了预分频器的工作流程。 下面这里计数器的时域图啊。 这就比较多了。 不仅有这个向上计数的模式啊。 还有向下计数模式的。 一般向上技术用的最多哈。 其他的想了解的话。 可以再看看这个手册。 接着下一节就是始终选择了这里。 想深入研究的话。 也可以再看看手册。 在下面就是捕获比较通道的介绍。 这个我们后续课程在讲哈。 好那到这里本小节的内容就全部完成了。 我们下一小节来开始写定时中断和内外时钟源选择的代码。
14. 定时中断和内外时钟源选择的代码部分哈。 那首先我们还是来看一下经验图。 我们打开程序源码第一个文件夹的接线图。 打开六杠一定时器定时中断的图片。 这个代码的接线图比较简单啊。 就只需要差一个o l d屏幕就行了。 和之前o l d显示屏的接线图是一样的。 因为定时器和中断系统的电路。 都在s t m32 内部。 定时中断。 也是为我们的程序设计提供服务的。 所以芯片外面这里就只差一个o r d。 显示数据就行了。 这就是经验图。 这里。 我已经插好o r d显示屏了哈。 其他的就没有了。 硬件电路就是这样好。 那我们回到工程文件夹。 开始写定时中断的代码哈。 我们复制一下o i d显示屏的代码。 改个名字啊。 叫六杠一定时器定时中断。 打开工程啊。 把这些先删掉。 编译一下。 下载看一下哈。 没有问题。 那回到工程。 我们还是先给定时器建一个模块哈。 在system目录出右键添加新文件。 那因为这个定时器不涉及外部的硬件啊。 所以我就把它放到system文件夹里面了。 当然你也可以放在其他文件夹里。 这个都没问题。 毕竟这个文件夹都是自己建的哈。 想咋建想咋放都可以。 按照你的喜好来。 不。 这样便于查找和管理。 那我们继续这里选择c文件。 起个名字就叫time存储路径。 加上反斜杠。 system放到system文件夹里。 然后add。 接着继续右键添加新文件。 选择h文件也叫time存储路径。 加上反斜杠system ad。 然后固定部分写一下哈。 头文件里以flow def camera。 而去最后n的if c文件里。 右键添加一个头文件。 这样模块就建好了。 那在这里啊。 老规矩上来还是先写个初始化函数啊。 void timer elite wi。 在这里面我们来初始化定时器。 那怎么来初始化定时器呢。 我们可以看一下p p t的这个图。 这个是定时中断的整个框架结构哈。 我们只需要把这里面的每个模块都打通。 就可以让定时器工作了。 那大体上的步骤就是第一步。 r c c开启时钟啊。 这个基本上每个代码都是第一步。 不用多想。 在这里打开时钟后。 定时器的基准时钟。 和整个外设的工作时钟就都会同时打开了。 第二步呢选择实际单元的时钟元。 对于定时中断。 我们就选择内部时钟源啊。 第三步配置实际单元。 技术模式等等。 这些参数用一个结构体就可以配置好了。 第四步配置输出中断控制。 允许跟新中段输出到n vs。 第五波呢配置nvc。 在nvc中打开定时器中断的通道。 并分配一个优先级。 这部分在上节我们也用过。 流程基本是一样的。 第六步就是运行控制啊。 整个模块配置完成后。 我们还需要死能一下计数器啊。 要不然计数器是不会运行的。 当定时器使能后。 计数器就会开始计数了。 当计数器更新时触发中断。 最后我们再写一个定时器的中断函数。 这样这个中断。 函数每隔一段时间就能自动执行一次了。 好。 那这些。 就是我们初始化定时器的大体思路了。 接下来我们回到k。 先看一下定时器的库函数都有哪些哈。 那我们找一下定时器t i m的库函数。 在这里哈。 先打开点去文件。 拖。 到最后。 可以看到这些库函数的数量是非常的多哈。 大家不要害怕。 我们本小节先把我们需要用的函数跳出来。 讲一下。 其他的之后再慢慢学哈。 这个不用多说。 第二个tm time base elite。 实际单元初始化。 这函数比较重要哈。 它就是用来配置。 这个图里这里的实际单元的。 这里面有两个参数。 第一个tmx选择某个定时器。 第二个是结构体。 这个我们等会儿配置的时候再详细说哈。 然后下面这几个函数我们暂时用不到啊。 之后再说。 那我们在这里。 先把我们讲过的函数都做个标记哈。 这样等会儿方便查找。 我们可以把光标放在我们想做标记的行。 然后点这个按钮。 这样就可以在这行代码左边。 添加一个书签啊。 如果再点一下。 那就会清除数线。 再点一下就又添加这个书签。 只是在这里做个标记哈。 方便我们查找代码用的。 对代码的运行没有任何影响。 那我们在下面再随便加几个书签。 这样的话我们就可以点这里的第二个按钮。 这是跳到上一个书签的位置。 然后第三个按钮呢。 这是跳到下一个书签的位置。 最后这个按钮是清除所有书签。 点一下当前文件的所有书签就都清楚了。 这就是这个书签的小工具。 简单介绍一下。 如果你有做标记的需要。 可以用一下这个。 那回到这里哈。 我们把讲过的这两个函数做一下标记。 接下来我们往下看啊。 这个函数t i m ten base struck it。 这个函数可以把结。 构体变量赋一个默认值。 这个之前我们也都见过。 没啥说的哈。 我们也做个标记。 然后是tm cmd。 这个是用来使能计数器的哈。 对应的就是我们这个图里的这个位置。 运行控制。 它有两个参数。 第一个gm x选择定时器。 第二个new state。 新的状态也就是死人还是私人。 死人计数器就可以运行。 私人计数器就不运行。 我们也标记一下哈。 然后下一个是tm it configure。 这个是用来使能中断输出信号的。 对应的就是这个位置中断输出控制。 它的参数看一下哈。 第一个tmx选择定时器。 第二个t i m i t选择要配置哪个。 终端输出第三个new state。 新的状态只能还是势能。 这种it configure函数之后还会经常遇到。 就是死人外设的中段输出。 这个应该好理解吧。 那我们继续。 接下来看一下这下面的六个函数。 先打上标记哈。 那这六个函数对应的就是这里哈。 实际单元的时钟选择部分。 可以选择r c c内部式中。 e t r y b式中i t r x其他定时器。 t i x捕获通道。 这些我们来看一下。 第一个tm internal clock configure。 选择内部始终参数只有一个tmx调用一下。 这里的连接就是这样的了。 第二个t i m i t r x x。 ternal clock configure。 选择i t r x。 其他定时器的时钟参数是tm x。 选择要配置的定时器和input trigger source。 选择要接入哪个其他的定时器。 调用一下。 这里的连接就是这样的了。 接着第三个t i m t i x x o。 clock和飞哥选择ti x捕获通。 道的时钟参数。 第一个tmx不用说了。 第二个ti x x ternal clock sauce。 选择tx具体的某个银件。 接着还有两个参数。 a power ity和ea filter。 输的集训和滤波器。 对外部硬件的波形。 一般都会有即兴选择和滤波器。 这样更灵活一些哈。 调用一下这个函数。 这个图里就是这样连接的。 那在下面t i m e t r克拉克。 目的一confire。 选择e t r通过外部时钟模式。 一输入的时钟。 也就是这一路哈。 从下面这里走的。 那它的参数ex t t r g posca。 外部触发预分频器。 这里可以对etr的外部时钟。 再提前做一个分屏。 然后接下来polity和filter也。 是一样。 即兴和滤波器。 那下面这个tm e t r clock mode 2 config。 选择e t r。 通过外部时钟模式二输入的时钟。 对应的就是这一路从上面这里走的。 它的参数和上面这个一模一样哈。 我就不再介绍了。 对于e t r输入的外部时钟而言。 这两个函数是等效的。 它们的参数也是一样的。 如果不需要触发输入的功能。 那两个函数可以互换啊。 然后最后一个函数t i m e t r configure。 这个不是用来选择时钟的。 就是单独用来配置e t r引脚的。 预分频器啊。 即兴啊。 滤波器这些参数的好。 到这里。 这个图里关键部分。 的函数基本就讲完了啊。 时钟源选择用这里的六个函数。 实际单元用time base一定的函数中断输出控制。 用it configure函数。 nva用上节讲过的n vs lt函数运行控制。 用tm cmd函数。 这样初始化基本上就ok了。 接下来我们再看几个函数。 因为在初始化结构体里有很多关键的参数。 比如自动重装值和预分频值等等。 这些参数可能会在初始化之后还需要更改。 如果未来改某个参数。 还要再调用一次初始化函数。 那太麻烦了是吧。 所以这里有一些单独的函数。 可以方便的更改这些关键参数。 比如这里的t i m。 procal configure就是用来单独写预分频值的。 看一下参数啊。 progre就是要写入的预分名值。 后面还有一个参数。 p s c reload mode。 写入的模式哈。 我们上一小节说了。 预分频器有个缓冲器。 写入的值是在更新事件发生后才有效的。 所以这里有个写入的模式。 可以选择是听从安排在更新事件生效。 或者是在写入后手动产生一个更新事件。 让这个值立刻生效。 不过这些都是细节问题啊。 影响不大。 你就知道这个是写预分分值的函数就行了。 然后下一个t i m counter mod configure。 用来改变计数器的计算模式。 参数count mode选择新的。 技术性模式。 然后再往下t i m a r pro的config。 自动重装器预装功能配置啊。 我们之前ppt的后面还介绍了。 这个计数器的预装功能。 有预装还是无预装。 是可以自己选择的。 怎么选择。 调用一下这个函数。 给个参数。 使人还是私人就行了。 这就是这个函数的用途。 然后再往下。 tm set counter给计数器写入一个值。 如果你想手动给一个计数值。 就可以用这个函数。 下面这个t i m set out reload。 给自动重装器写个值。 如果你想手动给个自动重装值。 就可以用这个函数接在后面。 tm get counter获取当前计数器的值。 如果你想看当前计数器记到哪里的。 就可以调用一下这个函数。 返回值就是当前的计数器的值。 下面tm get percular获取当前的预分频器的值。 如果想看预分频值。 就调一下这个函数。 最后再看一下后面的这四个函数啊。 这四个函数熟悉吧。 上节我们也见过这些。 就是用来获取标志位。 和清除标志位的。 这里就不再多讲了哈。 好到这里终于介绍完了。 这个定时器的库函数真是海量啊。 那本小节我们就暂时介绍这么多。 接下来我们就来使用我们刚才介绍的函数。 来配置一下定时器吧。 我们回到这里。 按照我们之前说的步骤来初始化定时器。 在这里我准备初始化的是tm 2啊。 也就是通用定时器。 首先第一步是开启时钟。 r c c a b一外设时钟控制。 这里注意哈要使用a b一的开启时终函数。 因为tm 2是a b一总线的外设。 那参数的第一个就是r c c a b e。 外设tm 2。 然后。 enable。 这样时钟就开启了。 接下来第二步选择实际单元的时钟。 我们到这个tm点去。 文件里来复制一下这个函数啊。 我们想选择为内部时钟。 然后放到这里。 参数只有一个tmx。 那我们写tm 2。 这样tm 2的实际单元。 就由内部时钟来去弄的。 不过这个选择时钟的函数啊。 我看其他很多人的代码都没有写。 因为定时器上电后。 默认就是使用内部时钟。 如果不调用这个函数。 那也是使用的内部适中。 所以不写这一行也行哈。 不过我们未来步骤的完整。 还是写上这一行吧。 那接下来我们就到了第三步。 配置实。 际单元我们到tm点距离找一下哈。 在这里我们要使用的是这个t i m tam base。 一it函数来初始化实际单元。 那我们复制一下放到这里。 参数第一个tmx我们写tm 2。 第二个是结构体。 我们转到函数定义看一下哈。 在上面这个注释找一下结构体的类型名。 复制一下。 放到这里。 然后起个变量名啊。 叫tm time base it structure。 然后先把结构体成员都引出来。 先放在这里。 最后把这个结构体的地址放到it函数里。 这样就行了。 接下来我们来一一的看一下参数哈。 第一个clock devision。 我们跳转一下定义。 然后看一下这个参数的注释啊。 这里写的是指定时钟分频。 这个参数可以是这里面的一个字哈。 这个时钟分频的参数之前在讲原理的时候。 一直都没出现过哈。 那它是用来干啥的呢。 我们可以看一下ppt里的这个图。 我们之前说了。 在这个定时器的外部信号输入引脚。 一般都会有一个滤波器啊。 比如这里还有下面这里。 这个滤波器可以滤掉信号的抖动干扰。 那它是怎么工作的呢。 其实也是非常简单的哈。 就是在一个固定的时钟频率f下进行采样。 如果连续n个采样点都为相同的电瓶。 那就代表输入信号稳定了。 就把这个采样值输出出去。 如果这n个采样值不全都相同。 那就说明信号有抖动。 这时就保持上一次的输出。 或者直接输出低电平也行啊。 这样就能保证输出信号。 在一定程度上的滤波。 这里的采样频率。 f和采样点数n都是滤波器的参数。 频率越低。 采样点数越多。 那滤波效果就越好。 不过相应的信号延迟就越大啊。 这就是这个滤波器的工作原理。 现在关键的地方来了。 这个采样频率f从哪来。 那手册里写的是。 它可以是由内部时钟直接二的。 也可以是由内部时钟加一个时钟分频二代。 那分屏多少。 就是由我们这个参数可clock devin决定的。 可见这个参数其实跟实际单元。 关系并不大哈。 在这里我们随便配一个就行了哈。 那我们ctrl f搜索一下。 可以看到这个参数可以取这三个值哈。 第一个是一分屏。 也就是不分屏。 第二个是二分屏。 第三个是四分屏。 那我们选个一分平板复制放到这里。 这样第一个参数就完成了。 接着第二个count mo计数器模式。 我们跳转一下。 这里没有跳过去让我们选哈。 那我们就直接手动找一下吧。 在这个tm点区的最上面。 就是这个地方可以看到这个counter mod参数。 要不要注释。 看一下这个参数可以是这里的一个值。 搜索一下哈。 这里可以看到有这种模式。 分别是向上技术。 那我们选择向上技术放到这里。 这样第二个参数就完成了。 接着下面三个参数。 period周期就是a arr自动重装器的值哈。 poker就是psc预分频器的值。 reputation counter就是重复计数器的值。 这些参数就是实际单元里面。 每个关键计数器的参数。 不过这里并没有cnt计数器的参数。 这个如果我们都需要的话。 可以用之前说的set counter和get counter。 这两个函数来操作计数器。 那这里这个reputation counter是重复计数器。 还是高级定时器才有的。 这里不需要用。 我们直接给零就好了。 接下来决定定时时间的参数就是这两个了。 如果我们想定一个一秒的时间。 那就可以参考一下ppt的这个公司。 定时频率等于72兆除以psc加一。 再除a22。 加一定时一秒。 也就是定时频率为1Hz。 那我们就可以p sc给一个7200哈。 arr给个1万。 然后两个参数都再减一个一。 这样就完成了。 因为预分频器和计数器都有一个数的偏差。 所以这里要再减个一哈。 然后注意这个psc和a r r的取值。 都要在0~65535之间。 不要超范围了。 这个p sc。 和a r r的取值不是唯一的。 你可以预分屏给少点。 自动重装给多点。 这样就是以一个比较高的频率。 即比较多的数。 也可以预分屏给多点。 自动重装给少点。 这样就是以一个比较低的频率。 即比较少的数。 两种方法都可以达到目标的定时时间哈。 在这里。 我们预分屏是对72兆。 进行7200分屏。 得到的就是10k的技术频率。 在10k的频率下记1万个数。 那不就是一秒的时间吗。 这样理解也是没问题的。 关于定时时间的计算。 要么记公式。 要么理解工作流程哈。 这都是可以的。 好到这里实际。 单元就配置好了。 接下来我们就需要使人更新中断了。 我们可以找一下。 这个t i m i t configure。 就是用来使能中断的。 我们复制一下。 放到这里。 参数第一个写tm 2。 第二个选择中段哈。 我们跳转一下函数定义。 看一下。 这个参数可以是下面这些值的任意组合。 其中第一个就是update更新中断。 我们复制这个参数。 然后放到这里。 最后第三个参数new state。 直接以内部就行了。 这样就开启了更新中断到nvc的通路。 那下一步自然就是n v i c大主吧。 这个我们上节讲过。 这里就直接写了。 首先n v c优先级分组。 n v i c priority group configure。 分组写nyc priority group 2。 选择分组二。 接着nyc 1。 it tab def。 n vs editor structure。 复制粘贴一下。 把参数列出来。 最后n y c1 d取地址粘贴结构体。 这样就好了。 参数第一个中段通道。 我们跳转一下定义。 右边看一下哈。 选中这个i r q n tap。 搜索一下下面这个换为当前工程啊。 搜索。 然后在这个列表里找到tm 2 l q n。 这就是定时器二在n vc里的通道。 我们复制放到这里。 然后第二个参数直接一。 下面是抢占优先级和响应优先级。 我们就给个二和一吧。 这样中断通道就打通了。 然后还需要最后一步。 启动定时器就完事儿了。 我们到tm点距离找一下。 复制这个tm c m d函数放到这里。 然后里面的参数第一个给tm 2。 第二个给liable。 这样定时器就可以开始工作了。 当产生更新时就可以触发中断到这里。 整个定时中断的初始化代码就完成了。 接下来我们就可以写中断函数了。 我们找一下启动文件打开。 这里可以找到这个tm 2 a q handler。 这个就是定时器二的终端函数了。 我们复制一下。 回到这里哈。 写word粘贴怪的。 当定时器产生更新中断时。 这个函数就会自动被执行。 在定义函数之后。 我们还是按照规矩哈。 检查一下中断标志位。 if t i m get it status。 获取中断标志为参数。 第一个是tm 2。 第二个是想看哪个中段的标志位。 我们跳转一下定义。 那这里就选择tmt update更新路段放到这里。 如果更新中断标志位等于等于set。 那我们就可以执行相应的用户代码了。 最后别忘了清除标志位啊。 tm clear i t pending beat tm 2。 第二个参数也是这个哈好了。 这样我们的代码就已经基本完事了。 接下来我们进行测试。 我们把这个初始化函数的第一行。 放在头文件里声明一下。 然后先编译。 看一下有没有错误啊。 目前还是没有错误的。 那我们就到主函数这里来进行测试。 然后在主函数这里调用timer it。 初始化定时器。 这样定时器就能开始工作了。 那我们想让定时器每秒自动。 帮我们加一下number这个变量。 所以我先定义一个变量哈。 在这里用int 16杠t number。 定义一个16位的全局变量number。 然后这个number要在中断函数里执行加加。 但是这个中断函数是在timer模块里的。 如果直接在这里写number加加。 那number就是跨越不同点c文件的变量了。 这样编译试一下。 他就会报错啊。 那解决方法有两种。 第一种是如果你想跨文件使用变量。 那可以在使用变量的那个文件的上面。 用extern声明一下要用的变量。 比如在这里写extern int 16杠七蓝。 这样就行了。 声明变量就是告诉编译器。 我现在有lab这个变量。 它在别的文件里定义了。 至于在哪里。 你自己去找吧。 然后编译器就会勤勤恳恳的去找哈。 最终他发现在没点c里确实有这个变量。 那编译器就知道了。 他就会把这个extern声明的变量。 当做m.c变量的一个引用。 注意这个过程并没有定义新的变量哈。 他操作的还是没点cd的。 这个number。 其实我们淘文件里的函数声明。 也是用extern实现的。 在这个函数的前面还是有一个extern的。 只不过这个extern可以省略。 所以我们一般不写。 那回到这里啊。 当我们用extern声明了主函数的number变量时。 就可以在这里直接使用主函数的number变量了。 这样变异就不会有问题的。 这是第一种解决方案。 就是使用跨文件的变量。 用extern声明即可。 那第二种方案呢。 就是直接把这个中断函数复制一下。 放到主函数后面。 这样他们就在一个文件里了。 这里extern声明就不需要了。 下面这个中断函数我们就注释掉。 这里也删掉哈。 对于定时中断而言。 这个中断函数就是为别的文件服务的。 所以中断函数可以放在使用它的地方。 这样更方便一些。 在这里我们把这个函数注释掉。 当成一个中断函数的模板。 如果哪个文件想用的话。 就复制过去就行了。 那这里我们就暂时采用第二种解决方案呢。 在m.c里中断函数每秒自动把蓝宝加加。 然后组循环里我们显示一下就行了。 这里显示字符串改一下啊。 在一行一列显示number冒号。 然后组循环里调用o l d修number。 一行五列显示蓝宝长度为五。 这样循环刷新number的。 值就行了。 我们编译看一下。 没有问题哈。 下载看一下现象。 可以看到。 此时number的值就正在执行每秒加一的操作了。 不过在这里会有个问题哈。 就是我们复位一下。 可以看到这个number是从一开始计数的。 多复位几次啊。 可以看到每次程序刚一开始。 number就立刻变成一了。 按理说number的初始值是零。 应该从零开始计数的。 但是number一上电就立刻变为一了。 这说明中断函数在初始化之后。 就立刻进入了一次。 这是怎么回事呢。 那我之前研究了一下哈。 这个问题就出在这里。 我们打开这个time base一例函数。 在最后可以看到这一句哈。 上面的注释写的是生成一个更新事件。 来重新装载预分频器和重复计数器的值。 立刻为什么要加这一句呢。 我们知道这个预分频器。 是有一个缓冲寄存器的。 我们写的。 只只有在更新事件时才会真正起作用。 所以这里未来让子立刻起作用。 就在这最后手动生成了一个更新事件。 这样预分频器的值就有效了。 但同时它的副作用就是。 更新事件和更新中断是同时发生的。 更新中断会自更新。 中断标志位到我们之后。 一旦初始化完了。 更新中段就会立刻进入。 这就是我们刚一上电就立刻进中断的原因。 那解决方案也非常简单哈。 就是在time base it后面。 开启中段的前面可以在这里哈。 在手动调用一下t i m clear flag tm。 二转到第一行。 复制一下这个tm flag update放到这里。 这样再手动把更新中断标志位清除一下。 就能避免刚初始化完就进中断的问题了。 那我们再看一下。 这样就没问题了。 上电后数字从零开始增加。 那在这里我们还可以看一下。 cn t计数器值的变化情况。 我们在这里直接写o l e d修number。 二行五列显示tm get counter。 tm 2长度为五啊。 编译看一下。 这时可以看到下面这个计数器的值。 在飞速变化。 变化范围应该就是从零一直到自动重装值。 我们的自动重装值写的是10000-1。 所以这个值就是从零一直自增到9999。 总共是1万个数。 记1万次就是一秒对吧。 如果我们把自动重装值改成1000。 那就是由原来记1万个数。 变成了g1000 个数了。 再看一下。 这时这个值就是从零加到了999了。 对应的就是0.1秒。 可以看到上面这个数字加加的速度。 也是比原来快了十倍哈。 如果我们把这里改回1万。 把下面预分频值去掉一个零。 那就是以原来十倍的基数频率记1万个数。 编译看一下。 这时number加加的速度也是原来的十倍。 和刚才是一样的哈。 这就是预分频值和自动重装值。 对中断频率的影响。 大家可以多玩一玩这部分哈。 我们之后还会经常和他们打交道的好。 这就是第一个代码到这里就完成了。 这里我们先改回来哈。 这里显示也删掉。 编译一下。 那接下来我们就来开始写第二个代码。 首先还是看一下经验图。 我们打开经验图文件夹。 打开六杠二定时器外部时钟。 看一下。 这里经验图也比较简单。 右下角是一个oled显示屏。 上面接来一个对射式红外传感器。 d数字输出。 接到pa 0硬件。 这个p a0 引脚就是tm 2的e t r引脚哈。 我们就在这个引脚输入一个外部时钟。 我们拿出对射式红外传感器接三根杜邦线。 然后vcc接正极接地接负极。 dojpa 0硬件。 这样就ok了。 那回到代码的文件夹。 我们复制一下六杠一的工程。 改个名字啊。 叫六杠二定时器。 外部时钟。 打开工程。 我们在这个工程的基础上更改一下啊。 现在我们的基本任务仍然是定时中断。 但是这个时钟部分呢。 我们就不使用内部时钟了。 我们把这一行删掉。 然后到tm点区里找一下。 选择时钟的几个函数。 在这里我们复制一下这个tm e t r clock mode。 二config。 这个就是我们想要的。 通过e t r引脚的外部时钟模式二配置。 然后放到这里看一下参数。 第一个给tm 2。 然后剩下的参数我们转到定义看一下。 第二个参数是外部触发预分频器。 可以是下面的这些值。 那我们不需要分屏哈。 就选择第一个复制放到这里就要继续。 第三个参数是外部触发的急性。 第一个是反向。 就是低电平或下降沿有效。 第二个是不反向。 就是高电平或上升沿有效。 这个根据需求来哈。 我就选择不反向了。 放到这里继续。 第四个参数是外部触发滤波器。 这个值必须是0x0。 0~0x0 f之间的一个值。 这个滤波器我刚才介绍过了哈。 就是以一个采样频率f采样n个点。 如果n个点都一样才会有效输出。 那这个值就是来决定f和n的。 具体是怎样的对应关系呢。 手册里有说明哈。 在这个位置大家可以自己看一下哈。 那我们这里就暂时不用滤波器了。 所以这个位置写0x00 就行了。 好这样。 通过etr的外部时钟模式二就配置好了。 那银角要用到g p i o。 所以还是别忘了哈。 在这之前还要先配置gp i o。 我们快速写一下。 先r c c a b2。 外设时钟控制cc a p2。 外设gpa一类。 不开启gpa的时钟。 接着gpl 1 it tab def。 gpo 1 ite structure。 然后列一下结构体成员。 最后gpl 1 it gpa取地址。 gpl一地址是抓墙。 那这个gpl mode。 这个可以看一下手册的配置表哈。 我们找一下在这里啊。 因为一旦悬空电瓶就会跳个没完。 所以我准备给上拉输入哈。 这是可以的。 就是如果你外部的输入信号功率很小。 内部的这个上拉电阻。 可能会影响到这个输入信号。 防止影响外部输入的电瓶。 那这里我就还用上拉输入吧。 gpl目的ip up。 然后这里gpp给gpp 0。 最后一个g p l speed。 给gp l o s speed 50兆赫兹。 这样就完事儿了。 当然下面这个预分屏和自动重装值。 也改小点哈。 我们手动模拟的没那么快。 这里预分频就给一。 不需要分屏哈。 自动重装值给十。 从零积到九就行了。 最后我们想实时看一下cnt计数器的值。 我们把它的函数也分装一下吧。 这样规范一些。 我们在下面写joint 16杠七。 timer get counter void。 然后里面直接写return tm。 get counter tm 2。 这样就行了。 然后这个函数也放在头文件里。 声明一下。 编一下。 没有问题啊。 那在主函数里我们先复制一下这个哈。 在二行一列显示个c n t冒号。 然后下面复制一下。 在二行五列显示tab get counter。 长度为五。 这样就完成了。 我们编译下载试一下。 看一下哈。 这时上面这里是number。 下面是c n t计数器的值。 我们用打滑片挡一下c nt加一。 因为现在实际单元没有预分平衡。 所以每次遮挡身体都会加一。 如果有预分频呢。 就是遮挡几次才能加一次。 然后加到九后自动清零。 同时申请中断蓝宝加加。 这就是第二个程序的现象了。 然后代码这里这些预分频器急性等参数啊。 大家都可以自己换一换看看现象。 然后tm点去这里其他的一些时钟输入啊。 大家也都可以自己试一试。 这里我就不再一一演示了哈。 好那本小节的代码部分到这里就结束了。 我们下一小节再见。
15. 大家好。 欢迎回来啊。 本小姐。 这个输出比较功能还是非常重要的。 它主要是用来输出pwm波形的。 pwm波形又是驱动电机的必要条件。 所以你如果想用s t m32 做一些有电机的项目。 比如智能车机器人等吧。 那这个输出比较功能就要好好学学了哈。 好。 那我们先来看一下本小节程序的现象。 本小节共有三个程序。 第一个是pwm驱动led呼吸灯。 第二个是pwm驱动舵机。 第三个是pwm驱动直流电机。 我们先来看一下第一个程序的现象。 下载看一。 我接了个l e d啊。 可以看到这个d正在不断的变换亮度。 实现了一个呼吸灯的效果。 那大家知道我们这个gpl口是一个数字输出的端口。 输出电平不是高电平。 就是低电平。 按理说led只有完全量和完全灭两种状态啊。 怎么能实现led连续的调控亮度。 那这就是pwm的功劳了。 这就是第一个程序的现象。 接下来看一下第二个程序。 pwm驱动舵机。 下载看一下。 我们拿一下这个舵机哈。 然后按下这个按键。 可以看到舵机输出轴的角度在不断的变换哈。 另外ord上也显示了当前的角度。 每按一下角度变量就变一次。 舵机也会随即跟随变化到指定的角度固定下来。 当然这个角度你可以任意设置哈。 在这里演示的例子。 我就只用按键进行简单的修改了哈。 这就是第二个程序的现象。 接下来看一下第三个程序。 pwm驱动直流电机。 下载看一下。 按一下按键可以看出电机已经转起来哈。 o i d上显示的是当前的速度值。 目前是正20。 然后再按一下速度就更快了。 速度值变为正40。 然后再按一下。 再按一下。 升80。 再按一下乘100。 现在就是正向满速旋转来。 再按一下速度由正100变为-100。 电机立刻变为反向慢速旋转。 然后进圈就是-80。 -60。 -40。 -20。 然后回到零电机停止。 这就是第三个程序的现象。 我们可以任意地设置电机旋转的方向和速度哈。 这里的速度值也是可以根据程序任意更改的。 不过在这里演示。 我。 就写的比较简单了哈。 好接下来我们就来看一下ppt。 看一下这个输出比较模块是如何来控制这些设备的。 首先看一下简介。 输出比较它的英文是oc。 全称是output compare。 直译就是输出比较的意思。 在这个库函数中经常会出现这些英文缩写哈。 所以要了解一下。 要不然他写个oc你不知道是啥意思。 那不就尴尬了吗。 另外还有c全称是input capture。 意为输入捕获。 还有cc全称是capture compare。 一般表示的是输入捕获和输出比较的单元。 这就是这些英文缩写哈。 了解一下。 然后看一下下一条输出比较电路可以通过比较。 cnt计数器与ccr捕获比较寄存器值的关系。 来对输出电瓶进行自一自零或翻转的操作。 用于输出一定频率和占空比的pwm波形。 这就是输出比较模块的最主要的功能。 就是输出一定频率和占空比的pwm波形。 这个cnt和ccr是在哪里呢。 我们可以看一下这个图。 这一块就是输出比较的电路。 cnt在这里哈。 就是实际单元里面的计数器。 ccr是这里就是捕获比较计算机。 刚才我们说了。 cc就是捕获比较的意思。 r是register寄存器的意思。 所以c c r就是捕获比较寄存器。 这个捕获比较计算器是输入捕获和输。 出比较共用的。 当使用输入捕获时。 它就是捕获寄存器。 当使用输出比较时。 他就是比较寄存器。 那在输出比较这里这块电路会比较cnt和csr的值。 c n t计数至尊c c r是我们给定的一个值。 当c n t大于c c r小于c c r或者等于c c r时。 这里输出就会对应的字一至零至一至零。 这样就可以输出一个电瓶不断跳变的pwm波形了。 这就是输出比较的基本功能。 然后回到这里继续来看。 后面两条是每个高级定时器和通用定时器都拥有四个输出比较通道。 并且高级定时器的前三个通道。 额外拥有死需生成和互补输出的功能。 这两条内容也可以通过这个结构图看出来哈。 在这里看到基本定制器是最简单的。 并没有输入捕获和输出比较的功能哈。 所以我们本小节的功能不能在基本定时器上使用。 然后通用定时器和高级定时器。 这里都有四个输出比较的通道。 可以同时输出四路pwm波形。 这四个通道有各自的cci计算器。 但是他们是共用一个cn t计数器的。 然后高级定时器这里前三个输出比较通道。 还额外具有死需生成和互补输出的功能。 这个是用于驱动三相无刷电机。 的哈我们本课程暂时不作为重点内容。 那么回到这里。 现在我们对这个输出比较的用途就应该大概清楚了啊。 就是用来输出pwm波形的。 那什么是pwm波形呢。 我们来看一下下一页ppt。 在这里简单的介绍一下pwm波形。 那首先pwm它的英文全称是pose west modulation。 意思是脉冲宽度调制。 这个pwm波形是一个数字输出信号哈。 也是由高低电平组成的。 像这个图里一样哈。 低电平高电平。 低电平。 高电平低电平这样的一个连续变化电平信号。 那叫这个型号。 有。 什么用呢。 接着看下一条。 在具有惯性的系统中。 可以通过对一系列脉冲的宽度进行调制。 来等效地获得所需要的模拟产量。 常应用于电机控诉等领域。 也就是说使用这个pwm波形是用来等效地实现一个模拟信号的输出。 也就是我们最开始提的问题。 数字输出端口控制led。 按理说l e d只能有完全量和完全灭两种状态。 怎么能实现控制亮度大小呢。 那通过这个pwm波形就可以实现。 我们让l e d不断点亮熄灭。 点亮熄灭。 当这个点亮熄灭的频率足够大时。 l d就不会闪烁了。 而是呈现出一个。 中等亮度。 当我们调控这个点亮和熄灭的时间比例时。 就能让led呈现出不同的亮度级别。 对于电机调速也是一样哈。 我们以一个很快的频率给电机通电断电。 通电断电。 那么电机的速度就能维持在一个中等速度。 这就是pwm的基本思想。 看起来也是一个挺简单的方法是吧。 pwm的秘诀就是天下武功唯快不破。 只要我闪的足够快。 你就发现不了我到底是闪着亮的。 还是一个正常的平稳的亮度。 当然pwm的应用场景必须要是一个惯性系统。 就是说led在熄灭的时候。 由于余晖和人眼视觉暂留现象。 lled。 不会立马熄灭。 而是有一定的惯性。 过一小段时间才会熄灭。 电机也是啊。 当电机断电时。 电机的转动不会立马停止。 而是有一定的惯性。 过一会儿才停。 这样具有惯性的系统才能使用pwm。 那在这个图里也可以看出来。 这种高低电平跳变的数字信号。 它是可以等效为中间这个虚线所表示的模拟量的。 当这个上面电瓶时间长一点。 下面电瓶时间短一点的时候。 那等效的模拟量就偏向于上面。 当下面电瓶时间长一点。 上面电瓶时间短一点的时候。 等效的模拟量就偏向于下面。 那在使用pwm时会有几。 个比较重要的参数啊。 我们来看一下第一个参数就是频率。 它等于t分之一。 ts就是下图的这里哈代表一个高低电平变换周期的时间。 周期的倒数就是频率对吧。 pwm的频率越快。 那它等效模拟的信号就越平稳。 不过同时性能开销就越大哈。 一般来说pwm的频率都在几千到几十千赫。 这个频率就已经足够快了。 然后第二个参数就是占空比。 它等于t2 比上t s t2 是这里高电平的时间哈。 ts是一个周期的时间。 那t2 比上t就是高电平时间相对于整个周期时间的比例啊。 一般用百分比。 来表示。 比如占空比为50%。 那就是高低电平时间相等的方波啊。 占空比为20%。 那就是高电平占20%。 低电平占80%。 占空比为百分之百。 那就直接是高电平不带变的哈。 占空比0%。 那就直接是低电平。 这就是占空比。 占空比决定了pwm等效出来的模拟电压的大小。 占空比越大。 占空比越小。 这个等效关系一般来说是线性的哈。 比如高电平是5伏。 低电平是0伏。 那50%占空比。 就等效于中间电压就是2.5伏。 20%。 占空比就等效于1/5处的电压就是1伏。 这就是占空比哈。 那最后一个参数就是分辨率。 它等于占空比变化布局。 比如有的占空比只能是1%。 2%。 3%等等。 这样以1%的布局跳变。 那它的分辨率就是1%。 如果可以1.1%。 1.2%。 1.3%等等。 这样以0.1%的布局调变。 那它的分辨率就是0.1%。 所以这个分辨率就是占空比变化的细腻程度啊。 这个分辨率需要多高。 得看你实。 际项目的需求哈。 如果你既要高频率。 又要高分辨率。 只有对硬件电路要求比较高了哈。 不过一般要求不高的话。 1%的分辨率就业已经足够使用了。 那这些就是pwm的知识点。 使用pwm波形就可以在数字系统等效输出模拟量。 就能实现led控制亮度。 电机控速等功能了。 那接下来我们就来具体的分析一下哈。 定时器的输出比较模块是怎么来输出pwm波形的。 这里这个图是高级定制器前三个通道的输出比较部分电路。 下面这个图是通用定时器的输出比较部分电路。 个通道啊和这个结构也基本是一样的。 我们先看一下通用定时器的这个结构。 这个图对应的就是这个图里的这部分电路。 左边是cnt和ccr比较的结果。 右边就是输出比较电路。 最后通过tm h一输出的gpu引脚上。 然后下面还有三个同样的单元。 分别输出到c区2c h3。 c区四哈。 那我们回到这里。 来看一下。 在这个图里。 左边就是cnt计数器和ccr一第一路的捕获比较计算器。 他俩进行比较。 当sn t大于c加r1。 或者cnt等于c加r一时。 就会给这个输出模式控制器传一个信号。 然后输出模式控制器就会改变它输出o c e r e f的高低电平。 ief信号实际上就是指这里信号的高低电平哈。 这个r e f是reference的缩写。 意思是参考信号。 这个稍微记一下哈。 之后还会见到。 然后上面这里还有个etf输入。 这是定时器的一个小功能哈。 一般不用不需要了解。 接着这个r e f信号可以前往主模式控制器。 你可以把这个ief映射的主模式的t i g o输出上去。 不过ie f的主要去向还是下面这一路啊。 通过下面这一路到达这里。 这是一个极限选择啊。 给这个寄存器写零信号就会往上走。 就是信号电平不翻转进来。 啥样出去还是啥样。 写一的话信号就会往下走。 就是信号通过一个非门取反。 那输出的信号就是输入信号高低电平反转的信号。 这就是极限选择。 就是选择是不是要把高低电平反转一下。 那接着就是输出使能电路了。 选择要不要输出最。 后就是oc一硬件。 这个硬件就是c h e通道的硬件哈。 那现在输出的通道我们就知道了。 接下来我们还需要看一下这个输出模式控制器。 它具体是怎么工作的。 什么时候给ie f高电平。 什么时候给ie f低电平。 我们看一下下面的这个表哈。 这就是输出比较的八种模式。 也就是这个输出模式控制器里面的执行逻辑。 这个模式控制器的输入是cnt和ccr的大小关系。 输出是r e f的。 高低电平里面可以选择多种模式来更加灵活地控制ief输出。 这。 个模式可以通过寄存器来进行配置。 你需要哪个模式就可以选那个模式。 那具体都是怎么操作的呢。 我们来看一下这个表。 第一个模式是冻结。 描述是sn t等于ccr时。 r e f保持为原状态。 c n t等于c c r时维持原状态。 那其实这个c n t和c c r就根本没有用是吧。 所以你也可以把它理解成3t和c c r无效。 r e f保持为原状态。 这都是一样的效果。 那这个模式也比较简单哈。 他根本就不管c nt谁大谁小。 直接按e f保持不变。 维持上一个状态就行了。 这有什么用呢。 比如你正在输。 出pwm波突然想暂停一会儿输出就可以设置成这个模式。 一旦切换为冻结模式后。 输出就暂停了。 并且高低电平也维持为暂停时刻的状态保持不变。 这就是冻结模式的作用。 然后接着看下面这三个模式。 匹配时至有效电平。 匹配。 时至无效电瓶和匹配时电平翻转。 这个有效电瓶和无效电瓶啊。 一般是高级定时器里面的一个说法是和关断刹车这些功能配合表述的。 他说的比较严谨哈。 所以叫有效点评和无效点评。 在这里为了理解方便。 你可以直接认为自有效电平就是至高电平啊。 至无效电。 平就是自低电平。 这样就行了。 那这三个模式都是当snt与cci值相等时执行操作。 第一个是c n t等于c加s r e f至有效电平。 也就是高电平。 第二个是相等时至无效电瓶。 也就是低电平。 第三个是相等时电平翻转。 这些模式就可以用作波形输出了哈。 这个可以方便地输出一个频率可调。 占空比始终为50%的p w分量波形。 比如你设置c c r为零。 那cg每次更新清零时就会产生一次sn t等于ccr的事件。 这就会导致输出电平翻转一次。 每更新两次输。 出为一个周期。 并且高电平和低电平的时间是始终相等的。 也就是占空比始终为50%。 当你改变定时器更新频率时。 输出波形的频率也会随之改变。 他俩的关系是输出波形的频率等于更新频率除以二。 因为更新两次输出才为一个周期对吧。 那上面这两个相等。 时至高电平和低电平。 感觉用途并不是很大哈。 因为他们都只是一次性的。 这玩高或低电平后就不管事了。 所以这俩模式不适合输出连续变化的波形。 如果你想定时输出一个一次性。 的信号。 那可以考虑一下这两个模式。 然后继续看一下下面这里的两个模式。 强制为无效电平和强制为有效电平。 这两个模式是c n t与c c r无效。 ief强制为无效点评或者强制为有效点评。 这里这两个模式和冻结模式也差不多啊。 如果你想暂停波形输出。 并且在暂停期间保持低电平或者高电平。 那你就可以设置这两个强制输出模式啊。 接下来看一下最后两个模式。 pwm模式一和pwm模式二。 这两模式就非常重要了哈。 它们可以用于输出频率和占空比都可调的pwm波形。 也是我们主要使用。 的模式来看一下描述。 在pwm模式一。 并且计数器为向上计数的情况下。 它是c n t小于ccr时。 r e f至有效点评。 cnt大于等于c c时。 r e f至无效点评。 在向下计数的情况下。 是cnt大于ccr 10 r e f至无效电平。 c n t小于等于c c20 r e f至有效点评。 这个情况比较多哈。 一般我们都只使用向上技术。 所以这里向下计数的描述我们就暂时不看了。 它们之间也只有大小关系。 急性啊。 这些东西不同。 基本思想都是一样的哈。 我们着重分析一个向上技术的就可以了。 然后再对比看一下pwm模式。 二在向上基础的情况下。 cnt小于csx r e f至无效电平。 c n t大于等于ccs r ef至有效电平。 经过观察可以发现哈。 它的大小比较关系和上面这儿是一样的。 区别就是输出的高低电频反过来了。 所以pwm模式二实际上就是pwm模式一输出的取反改变。 pwm模式一和p w模式二就只是改变了r e f电瓶的极限而已哈。 从上面这个图里可以看到r e f输出之后还有一个极限的配置。 所以使用pwm模式一的正极性和p w模式二的反击性。 最终的输出是一样的。 这里设计的比较灵活啊。 输出模式里。 可以设置机芯。 最终输出之前也可以设置机芯。 那这就是两个模式的区别。 所以使用的话我们可以只使用p w模式一。 并且是向上技术这一种模式就行了。 那这种模式是怎么输出频率和占空比都可调的p w r m波形呢。 我们再看一下下面这个ppt。 在这里我给出了输出pwm的基本结构。 这也是我们本节课的重点内容哈。 我们来看一下。 首先左上角这里是时机单元和运行控制部分。 在左边是时钟源选择哈。 这里省略了这些都是上一小节的内容。 在这里还需要继续使用。 只不过是这里更新事。 件的中断申请我们不需要了哈。 输出p wm暂时还不需要中断。 这就是实际单元的部分配置好了。 实际单元这里的cnt就可以开始不断的自增运行了。 然后下面这里就是输出比较单元了。 总共有四路输出比较单元的最开始是cc 2捕获比较计算器。 c c r是我们自己设置的哈。 c t不断自证运行。 同时他俩还在不断进行比较。 后面这个就是输出模式控制器啊。 在这里我就以pwm模式一为例子来讲解了。 这里面是pwm模式一的执行逻辑哈。 c n t小于c加20r e复制有效点评。 c n t大于等。 于c加20r e f g无效点评。 那它是怎么输出pwm波形的呢。 我们看一下右上角的这个图。 这里蓝色线是cnt的值。 黄色线是a arr的值。 蓝色线从零开始自增。 一直震到a2。 在这个过程中。 我们再设置一条红色线。 这条红色线就是ccr。 比如我们设置c c r为30之后。 再执行这里的这个逻辑。 下面这里绿色线就是输出。 可以看到在这一块sn t小于ccr。 所以是高电平之后。 这里cnt就大于等于c起来了。 所以就变为低电平。 当c nt溢出清零后。 cnt又小于c3 r。 所以。 自高电平再之后就又是c n t大于等于c加是低电平。 这样一直持续下去。 r e f的电瓶就会不断变化。 并且它的占空比是受ccr值的调控的。 如果cci设置高一些。 输出的占空比就变大。 cci是指低一些输出的占比就变小。 这就是pwm模式的工作流程。 这里reef就是一个频率可调。 占空比也可调的pw模型。 最终在经过急性选择输出使能最终通向gpl口。 这样就能完成pwm波形的输出了。 那接下来我们就再来看一下pwm的参数是如何计算的吧。 第一个pwm频率看一下上面这个图。 从这里到这里为pwm的一。 个周期可以看出它始终对应着计数器的一个溢出更新周期。 所以pwm的频率就等于计数器的更新频率。 下面这个式子c k p sc除以p sc加一再除2+1。 就是计数器的更新频率公式。 然后接着是占空比参数。 我们再看一下上面这个图。 从这里到这里。 sn t是从零一直加到a r。 比如a r是99。 那c n t总共就是记了100个数。 再看高电平的时间。 就是从这里到这里。 c n t是从零一直加到c c r。 比如ccr是30。 注意这里在等于30的瞬间哈。 就已经跳变为低电平了。 所以c nt从零到。 29是高电平。 总共是30个数的时间。 所以这里占空比就是30÷100=30%。 总结一下公式。 就是占空比等于c c r除以a r加一。 那最后还有一个参数啊。 就是分辨率。 也就是占空比变化的布局。 从上面这个图可以看出哈。 ccr的值应该设置在零到a r加一这个范围里。 c c r等于a r加一时。 占空比就正好是半分之百。 如果ccr再大一些。 那占空比就始终是百分之百没有意义的。 所以csr的变化范围取决于ai的值。 a r越大。 c c r的范围就越大。 对应的分辨率就越大。 所以。 总结一下公式就是分辨率等于i加1/1。 注意我这里定义的分辨率是占空比最小的变化布局。 所以这个值是越小越好。 你也可以把c c r的范围定义成分辨率。 那就是值越大越好。 总之就是占空比变化的越细腻越好好。 这就是这些参数的计算公式哈。 如果我要求你输出一个频率为1000Hz。 占空比可任意调节。 且分辨率为1%的p w m波形。 那你会不会用这里的公式来确定合适的参数呢。 大家可以先想一想哈。 我们下一小节就会来实际操作一下的。 那到这里有关pwm输出的。 内容就讲完了。 最后我们再回过来简单的看一下高级定时器的输出比较电路。 这个电路大家仅做了解即可哈。 不需要掌握。 那我们来简单的看一下。 我们可以这样啊。 从这里画一个圈。 把这个圈里面的东西去掉哈。 那它就跟通用电子器的电路是一样的了。 那这个圈里的电路到底有什么用呢。 这就需要和外部电路来一起理解了。 在它外面通常要接一个这样的电路哈。 上面是正极。 接着是一个大功率开关管。 一般都是墨水怪哈。 就是一种大功率电子开关。 然后再来一个mos管。 最后大坚地目视管。 左边是控制机。 比如说给高电平。 右边两根线就导通。 低电平就断开。 下面也是一样哈。 有一个控制极。 高电平导通低电平断开。 中间是输出啊。 如果上管导通下管断开。 那输出就是高电平。 如果下管导通上管断开。 那输出就是低电平。 如果上下管都到通。 那就是电源短路哈。 这样是不允许的。 如果上下管都断开。 那输出就是高阻态。 那就构成了h桥电路。 就可以控制直流电机正反转了。 如果有三个这样的推广。 电路那就可以用于驱动三相无刷电机了。 这就是这个电路的用途啊。 那对于这个电路来说。 如果直接用单片机来控制的话。 那就需要两个控制器。 并且这两个控制集电瓶是相反的。 也就是互补。 因为上管导通下管就必须断开。 下管导通上管就必须断开。 再来理解内部电路结构。 那自然就好理解了。 首先这个oc一和c1 n就是两个互补的输出端口。 分别控制上管和下管的导通和关闭。 然后是在切换上下管导通状态时。 如果在上管关断的瞬间。 下管立刻就打开。 那可。 能会因为气垫的不理想哈。 上管还没有完全关断。 下管就已经导通了。 出现了短暂的上下管同时导通的现象。 这会导致功率损耗啊。 引起气件发热。 所以在这里为了避免这个问题。 就有了死去生成电路。 它会在上管关闭的时候延迟一小段时间再导通下管。 下管关闭的时候延迟一小段时间再导通上管。 这样就可以避免上下管同时导致的现象了。 好这就是死穴生成和互补输出的用途。 我就讲这么多哈。 大家了解一下即可。 那到这里s t m32 内部是如何产生pwm波形的。 我就说完了。 接下来我。 们就来看一下s t m32 的外部设备。 在这里有舵机。 可以用pwm信号来控制舵机输出轴的角度。 还有直流链接。 可以用pwm控制电机的速度。 那先看一下舵机哈。 第一条舵机是一种根据输入pwm信号占空比来控制输出角度的装置。 下面这个图就是我们套间里的舵机哈。 型号是sg 90。 它有三根输入线。 两根是电源线。 一根是信号线。 我们的pwm就是输入的这个信号线来控制舵机的。 在这边有一个白色的输出轴。 它的轴会固定在一个指定的角度不动哈。 至于固定在哪个位置。 是由信号线的pwm信号。 来决定的。 这是舵机的工作方式。 然后中间这个是舵机的一个拆解图哈。 在这里可以看到里面的结构有舵机上盖输出轴。 减速齿轮组。 下面这里是直流电机。 舵机控制板电位器。 可以看出舵机其实并不是一种单独的电机哈。 它的内部是由直流电机驱动的。 它里面还有个控制电路板。 是一个电机的控制系统哈。 大概的执行逻辑是pwm信号输入的控制板。 给控制板一个指定的目标角度。 然后这个电位器检测输出轴的当前角度。 如果大于目标角度。 电机就会反转。 如果小于目标角度。 电机就会正转。 最终使输出轴固定在指定角度。 这就是舵机的内部工作流程啊。 但不管怎么样。 我们就只需要知道输入一个pwm波形。 输出轴固定在一个角度就行了。 那接着我们来看一下输入pwm信号的要求。 就是pwm的周期为20ms。 对应的就是50Hz哈。 高电频宽度为0.5ms到2.5ms。 就是占空比是这个范围。 这个范围对应的输出角度啊。 看一下右边的这个图。 我们这是一个180度的舵机哈。 输出轴的角度是-90度到正90度。 或者你规定是0~180度。 这都是没问题的哈。 然后输入信号脉冲宽度周期是20ms。 也就是这个上升沿到下一个上升沿。 这之间的时间是20ms。 然后高电平的时间如果是0.5ms。 对应的。 角度就是-90度。 如果是1ms对应的角度就是-45度。 如果是1.5ms。 对应的角度就是0度。 如果是2ms。 对应的角度就是正45度。 如果是2.5ms。 对应的角度就是正90度。 也就是说0.5ms对应-90度。 2.5mm对应正90度。 中间的对应关系都是线性分配的哈。 按比例来。 你给个pwm输出轴就会固定在一个角度。 那实际应用的话。 比如机器人机械臂可以用舵机来控制关节。 遥控车遥控船可以用舵机来控制方向。 还有一些其他的机械结构啊。 都可以考虑用。 一下这个舵机。 那这些就是舵机的大概介绍了。 这里pw波形它其实是当做一个通信协议来使用的哈。 跟我之前说的用pwm等效一个模拟输出关系不大。 把p w m当成一个通信协议。 也是一个比较常见的应用行。 因为很多控制器都有pwm输出的功能。 而且pwm只需要一根信号线就行了。 这也是一种应用形式哈。 那然后我们就来看一下舵机的硬件电路板。 在这里硬件电路也是比较简单的。 我们先看一下上面这个引脚定义图哈。 在这个舵机上有三根线。 分别是黑红黄对应的。 黑色是电源负极接地。 红色是电源正极。 这里5伏舵机就接正5伏哈。 黄色是信号线。 接p w b m信号。 我们上面这个舵机哈。 现在颜色不太一样。 这里是钟红尘。 对应的棕色是电源负。 红色是电源正。 橙色是信号线。 引脚顺序是一样的哈。 然后右边这个是黑红白。 那就是黑户红阵白信号。 如果你不确定啊。 就到你的商品页面去看一下哈。 一般都会有个银角。 说明。 然后继续看这个电路。 实际应用的话。 接地就接接地电源正的5伏。 这个是电机的驱动电源哈。 一般电机都是大功率设备。 它的驱动电源也必须是一个大功率的输出设备哈。 如果能像这样单独提供供电。 那就再好不过了。 如果不能。 那也要注意电源的功率是不是能达标。 如果单独供电的话。 供电的负极要和s t m32 共地。 然后正极接在5伏供电引脚上。 对于我们套件的话。 可以直接从s7 link的5伏输出角哈。 零一根线接到这里。 这样就是使用usb的5伏供电。 也是可以带得动的哈。 这就是供。 电那最后就是信号线p w m就直接接到s t m32 引脚上就行了。 比如p a0。 因为这个舵机内部是有驱动电路的。 所以我们单片机的引脚就可以直接接到这里的。 我们这个pwm只是一个通信线。 是不需要大功率的。 好多集到这里就差不多了。 然后我们再看一下直流电机。 这个是直流电机和驱动的简介哈。 因为这个直流电机是一个单独的电机。 里面没有驱动电路。 所以我们就要外挂一个驱动电路来控制了。 那我们看一下第一条。 直流电机是一种将电能转化为机械能的装置。 就是通电就。 转对吧。 他有两个电极。 当电极正接时电机正转。 当电极反接时电极反转。 比如下面这个图片。 就是我们套件里的电机哈。 型号是130直流电机。 这里有两个硬件大门。 一边接正。 一边接负电机。 就朝一个方向转哈。 如果我们把正负极对调。 那电机就会朝另一个方向转。 这个操作起来也是比较简单的哈。 然后继续看一下第二条。 直流电机属于大功率器件。 gpl口无法直接驱动。 需要配合电机驱动电路来操作。 这个注意一下。 电机这类器件基本上都属于大功率设备的。 必须要加驱动电路才能控制电。 机驱动电路也是一个研究课题哈。 现在市面上也有很多驱动电路可以选择。 比如tb 6612 d r v8833 l9110 l298 等等。 这些都是比较常见的电机驱动芯片哈。 这个功率可以做得更大一些。 当然你也可以自己用mos管的设计电路。 这都是没问题的。 感兴趣的话可以研究一下。 那我们本课程就直接使用tb 6612这款电机驱动芯片来驱动电机的。 使用现成的芯片还是挺方便的哈。 别人都把电路设计好集成在芯片里了。 我们直接。 拿来用就行了。 那我们来看一下gb 6612是一款双路h桥形的直流电机驱动芯片。 可以驱动两个直流电机。 并控制其转速和方向。 这个芯片里面是有两路驱动电路的。 又因为它是h桥形的驱动电路。 里面一路有四个开关管。 所以就可以控制正反转。 像有些芯片。 比如u l n2003。 它里面一路就只有一个开关管。 所以他就只能控制电机在一个方向转。 那下面这个图就是这个电机驱动板的样子。 上面的芯片就是tb 6612。 就行了。 可见这个芯片的集成度还是非常高的哈。 基本上不需要我们在加什么东西。 然后右边这个就是h桥电路的基本结构。 这个我们刚才也分析过哈。 比如左边这个上管导通。 下管断开。 那左边输出就是接在vm的电机电源正极下拐角从上拐断开。 那就是接在p gd的电源负极。 这里接一个电机。 左上和右下导通。 那电流就是这样的。 从左流向右边。 右上和左下导通。 那电流就反过来了。 从右边流向左边。 h小可以控制电流流过的方向。 所。 以它能控制电机正反转。 这就是这个电机驱动芯片内部的部分电路啊。 我们大概了解一下。 即可应用的话也不用管这么多。 那我们接下来就来看一下怎么用这个驱动芯片吧。 我们看一下硬件电路。 站在左边就是这个电机驱动模块的进阶电路了。 我们来看一下这里左下角vm就是电机电源的正极了。 这个和刚才舵机的电源要求是一样的哈。 要接一个可以输出大电流的电源。 右边引脚定义看一下这个vm是驱动电压。 输入端范围是4.5~10伏。 这个电压一般合理。 电机额定电压保持一致。 哈比如如果你是5伏的电机。 这里就接5伏。 如果你是7.2伏的电机。 这里就接7.2伏。 这个是vm。 然后下一个引脚是vcc。 这个是逻辑电平输入端哈。 范围是2.7~5.5伏。 这个要和我们控制器的电源保持一致。 比如你使用s t m32 是3.3伏的旗舰。 那就接3.3伏。 如果是五一单片机是5伏的期间。 那就接5伏。 这个硬件并不需要大功率哈。 所以可以和控制器共用一个电源。 然后第三个引脚是接地。 这个就接系统的负极就行了。 然后板子在右边还有两个间d。 这个都是一样的。 硬件哈在板子内部都是连通的。 随便选一个间d用就可以哈。 然后继续看这里。 a o e a o2 bo 1 bo 2就是两路电机的输出了。 可以像这样分别接两个电机。 a o一和ao 2。 就是a路的两个输出。 它的控制端就是上面的这三个p w m a a e2 和a11 这三个引脚。 控制下面a路的一个电极。 这里对应关系我也用灰色填充给大家标出来了哈。 方便大家观看。 那这三个硬件就直接接到单片机的gpl口就行了。 其中p w m a硬件要接pwm信号输出端。 其他两个硬件可以任意接两个普通的gpl口。 那这三个银角给一个低功率的控制信号驱动电路。 就会从vm汲取电流来输出到电机。 这样就能完成低功率的控制信号。 控制大功率设备的目的了。 那然后右边这一路也是一样。 bo一和bo 2是b入的两个输出。 它的控制端是上面右边的b in 1 bin 2和p w m b这三个引脚。 两路的功能和操作方法是完全一样的哈。 最后还剩一个s t b y硬件。 这个是待机控制键。 如果接t n d芯片就不工作。 处于待机状态。 如果接逻辑电源。 vcc芯片就正常工作。 这个硬件如果不需要待机模式的话。 可以直接。 接vcc 3.3伏。 如果需要的话。 可以任意接一个gpo。 给高低电平就可以控制了。 好这就是这个电机驱动板的硬件电路。 那这三个角是如何控制电机正反转和速度的呢。 我们看一下右下角这个表。 这里输入是in 1 in 2 p w m和s t b y s t b y低电平就待机。 高电平就正常工作。 这个不用看了啊。 然后右边是输出o1 o2 和模式状态。 我们来看一下。 在这里。 如果in一和in 2全都接高电平。 两个输出就都为低电平。 这样两个输出没有电压差。 电机是不会转的。 如果in一和in 2全都接低电平输。 出直接关闭。 这样电机也是不会转的。 全高货。 全低电机都不能赚。 那剩下的就只有一高一低了是吧。 这里如果印一给低电平。 in 2给高电平。 电机就是处于反转状态。 那转还是不转呢。 要取决于pwm。 如果p w m给高电平。 那输出就是一滴高。 有电压差了。 电机可以转。 这时候定义的是反转。 太转了哈。 如果p w m给低电平。 那输出两个低电平电机还是不转。 这就是反转的逻辑。 印一给低in 2给高pwm。 高转低不赚。 如果pwm是一个不断翻转的电平信号。 那电机不就是快速的反转停止反转停止了吗。 如果pwm。 频率足够快。 那电机就可以连续稳定的反转了。 并且速度取决于pwm信号的占空比。 这就是反转的工作流程。 在这里的pwm就是我们之前讲的使用pwm来等效一个模拟量的功能。 然后看下面正装也是差不多哈。 这里给in一高电平。 in 2低电平。 这样电机就是正转状态。 那是转还是不转呢。 要取决于pwm信号。 pwm高正转d停止。 如果pwm频率足够快。 那电机就是连续稳定的正转了。 并且速度取决于pwm信号的占空比。 好赖。 有关这个电机驱动模块的介绍到这里就讲完了哈。 本节课的内容到这里也差不多结。 束了那最后还是大概的看一下手册哈。 本小姐设计的章节有这个捕获比较通道。 这里面有这个捕获比较单元的一些电路图哈。 我们奔向节讲的是输出比较的部分。 输入捕获这部分之后再讲哈。 然后就是这三单元有强制输出模式。 就是cnt和ccr无效r e f强制为高和低的那两种模式啊。 输出比较模式就是c n t等于c c s r e f。 是冻结至高至低还是翻转的那四种模式。 最后是pwm是这个比较重要哈。 就是c n t大于或小于csr s r e f至高或至低的那两种模式。 这些就是本小节涉及。 的知识点哈。 更多细节问题大家可以再详细研究一下手册。 基本上内容我都讲过了哈。 在这里就不再带大家细看手册了。 另外看这个手册的时候。 可能他的语言会比较晦涩难懂哈。 而且它这里面经常会像这样引用一大堆寄存器的名字。 所以看的时候还要多对照寄存器介绍来理解这些寄存器的解释啊。 也都是很重要的内容。 把功能描述和寄存器描述都对照看看。 这样才好懂一些哈。 好那本小节到这里就结束了。
16. 好接下来我们来学习一下输出比较的代码部分啊。 我们先看一下经验图。 看一下这个六杠3p wm驱动led呼吸灯的图片。 在这里我们在pa 0引脚上插了一个led。 我们准备在这个pa 01件输出一个pwm波。 用于驱动这个led。 并且呈现出不同的亮度。 注意一下哈。 这个l d我们用的是正极接在pa 00件。 负极接在监d的驱动方法。 这样就是高电平电量。 低电平熄灭。 这是正极性的驱动方法。 这样接的话观察更直观一些哈。 就是占空比越大。 l e d越亮。 占空比越小。 d就越暗。 那然后我们看一下面包。 板在这里我们只需要拿出一个led正极接待pa。 零负极接在gd这样就行了。 接下来我们回到工程文件夹。 复制一下oled的工程粘贴。 改个名字叫六杠3p wm驱动led呼吸灯。 打开工程。 把这些先删掉哈。 我们这个工程暂时用不到oled。 但我还是保留了o i d这个模块哈。 如果你想看一些变量。 可以随时显示在这个o r d上。 这样方便调试一下。 我们先编译一下哈。 没问题。 那接下来我们给pwm建一个模块。 在这个hardware文件夹右键添加新文件。 选择c文件叫pwm存放路径。 加上反斜杠hardw add。 然后继续添加新文件。 选择h文件叫pwm存放路径。 加上反斜杠hy。 接下来头文件的固定部分快速写一下。 c文件这里也加一个sm 32的头文件。 这样就行了。 然后在这里我们写一个pwm的初始化函数。 word pwm y的。 在这里进行pwm的初始化。 那怎么初始化呢。 我们可以看一下p p t的这个图啊。 这个小节我们已经把pwm的这整个通路都讲完了。 现在我们只需要把这些模块都打通。 那就可以输出pwm了是吧。 具体的步骤就是第一步r c c开启时钟。 把我们要用的t i m y s i和gpl外设的时钟打开。 第二步配置实际单元。 包括这前面的时钟源选择和这里的实际单元哈。 都配置好这个代码。 我们之前也写过哈。 第三步配置输出比较单元里面包括这个ccr的值。 输出比较模式。 即兴选择输出齿轮。 这些参数在库函数里也是用结构体统一来配置的。 第四步配置gp i o。 把pwm对应的gpu口啊初始化为复用推挽输出的配置。 这个p w m和g p i o的对应关系是怎样的呢。 可以参考一下引脚定义表哈。 这个我们等会儿再细说。 那最后第五步就是运行控制了。 启动计数器。 这样就能输出pwm了。 好现在思路我们就已经清楚了。 接下来我们来看一下库函数里对应的函数吧。 我们回到q展开这。 个library目录。 找一下tm的库函数。 我们打开这个tm.h的文件。 拖到最后。 这就是tm外设对应的库函数。 我们之前已经介绍一部分了哈。 现在继续来看一下。 首先看一下这里四个函数。 t m o c11 d o c21 利特o c31 it和oc 41例。 这四个函数就是用来配置输出比较模块的。 oc就是output compact。 输出比较。 所以这一看就知道它是用来配置我们这个结构图的这一块的对吧。 这里输出比较单元有四个。 那对应也有四个函数哈。 o c e o c2 oc 3 oc 4。 一个函数配置一个单元。 那它的参数呢第一个tm x选择定时器。 第二个结构体啊。 就是输出比较的那些参数了。 这个就清楚了。 然后继续看下面tm oc struck的it。 这个是用来给输出比较结构体赋一个默认值的。 那到这里输出比较的配置啊。 其实就已经可以完成了。 接下来就是一些小功能和运行时更改参数的函数了。 我们来看一下哈。 这里有四个函数。 tm force的oc 1234 configure。 这个是用来配置强制输出模式的哈。 如果你在运行中想要暂停输出波形。 并且强制输出高或低电平。 可以用一下这个函数。 不过一般用的不多哈。 因为强制输出高电平和设置百分之百占空比是一样的。 强制输出低电平和设置百分之。 零占空比也是一样的。 所以这四个函数了解一下就行啊。 不需要掌握。 然后下面tm oc 1234 pro的configure。 这四个函数是用来配置ccr寄存器的预装功能的。 这个预装功能就是影子寄存器哈。 之前也介绍过。 就是你写入的值不会立即生效。 而是在更新事件才会生效。 这样可以避免一些小问题。 这个一般可以不用。 还也了解下即可。 不需要掌握。 然后是t i m o c1234 fast的configure。 这四个函数是用来配置快速使人的这个功能手册里单脉冲模式来解。 由小段介绍哈。 用的也不多。 不需要掌握。 接着是tm。 可莉r o c123421 f这个功能在手册里。 外部事件时清除ief信号那一节有介绍。 这个也不需要掌握函。 那刚才看的这些函数都是s t m32 的一些小功能配置的。 用的都不多。 感兴趣的话可以看看手册哈。 然后继续看这里。 tm o c e polarity configure。 oc e n polarity configure。 然后oc 2 oc 2 n o c3 oc 3 n o c4。 这些就是用来单独设置输出比较的急性的。 这里带个n的。 就是高级定时器里互补通道的配置哈。 oc 4没有互补通道。 所以就没有oc 4 n的函数。 那这里有函数可以设置极限哈。 在结构体初始化。 的那个函数里也可以设置极限。 这两个地方设置极限的作用是一样的哈。 只不过是用结构体是一起初始化的。 在这里是一个单独的函数进行修改的。 一般来说结构体里的参数啊都会有一个单独的函数可以进行更改。 这里的函数就是用来单独更改输出即兴的啊。 然后下面这里tm ccx command和cc x n command。 是用来单独修改输出使能参数的。 在下面tm select oc x m选择输出比较模式啊。 这个是用来单独更改输出比较模式的函数。 然后再往下看这里tm set compare 1234。 这四个是用来单独更改ccr寄存器。 值的函数。 这四个函数比较重要哈。 我们在运行的时候更改占空比就需要用到这四个函数。 好来到这里有关输出比较的函数就介绍完了哈。 总结一下这个oc 1 d的函数是用结构体来初始化输出比较单元的。 这个很重要哈。 需要掌握。 然后中间这里有一些函数啊。 是定时器的一些小功能。 这个了解一下即可。 不需要掌握。 最后是这些运行时候更改参数的函数。 其中这四个set compare函数重要需要掌握其他的了解一下即可。 那函数看完了。 我们来开始写代码哈。 我们回到pwm.c文件。 在这里按照我们之前说的步骤来初始化。 首先实际单元的这部分代码我们之前写过。 那我们就直接找一下之前定时中断的代码复制一下哈。 我们打开定时器。 定时中断的工程。 把这些初始化代码都复制一下。 然后在这个pwm的初始化函数里粘贴。 看一下。 打开时钟。 选择内部时钟。 初始化实际单元我们还继续使用tm 2这个定时器哈。 所以这些都不用改。 下面这里打开中断和配置nvc的部分。 我们就不需要了。 最后启动定时器。 这个也留着。 接着在这个实际单元初始化下面。 我们来初始化一下输出比较单元哈。 我们在这个tm点距离找一下函数。 在这里有四个初始化函数。 对应四个输出比较单元。 或者说输出比较通道哈。 这都是一个意思。 你需要初始化那个通道就调用哪个函数。 不同的通道对应的gpl口也是不一样的哈。 所以这里要按照你gpl口的需求来。 这里我使用的pa 0口对应的就是第一个输出比较通道。 所以这里我就要使用这个tm oc 11列特函数。 这个通道和gpl的对应关系。 等会再详细说哈。 先别急。 那我们先复制一下这个oc 11例特函数。 然后放在这里看一下参数哈。 第一个是tm x。 我们给tm 2。 第二个是用来配置输入比较的结构体。 我们转到定义。 复制一下这个结构体类型名。 接着回来哈。 在这上面粘贴几个变量名。 叫tm oc 1 ite structure。 然后复制变量名。 在下面列一下结构体成员啊。 那这里结构体的成员比较多啊。 而且里面有很多参数是高级定时器才用到的。 比如这种带个n的参数。 还有这个idol state参数啊。 都是高级定时器才需要用啊。 所以这里一般我们就只把我们需要用的参数列出来就行了。 那第一个需要用的就是这个oc mode设置输出比较的模式。 然后是oc polarity设置输出比较的急性。 output state。 设置输出齿轮。 最后是pulse。 这个是用来设置cc 2的。 最后把结构体的地址放在一定的函数里。 这样就行了。 在这里我们这个结构体现在并没有给所有的成员赋值对吧。 那对于这个结构体变量来说。 它现在是一个局部变量。 如果不给它的成员赋初始值。 它成员的值就是不确定的。 这可能会导致一些问题啊。 比如当你想把高级定时器当做通用定时器输出pwm时。 那你自然就会把这里的tm 2改成tm一对吧。 这样的话这个结构体原来用不到的成员现在就需要用了。 而这些成员你又没给复制。 那就会导致高级定。 时器输出pwm出现一些奇怪的问题。 至于怎么奇怪的呢。 比如我之前写了一个代码哈。 这样高级定时器输出四路pwm。 如果我把初始化函数放在程序的第一行。 那就没问题。 如果出转函数之前出现了其他的代码。 那四路pwm就会有三路不能输出。 这个问题就很奇怪是吧。 能不能输出p wm竟然和初始化函数再打一行有关。 那最终找到的原因呢就是这里我的结构体成员没有配置完整。 而且我也没给结构体赋初始值。 所以为了避免程序中出现不确定的因素啊。 我们要么就像上面这个一样。 把结构。 体所有的成员都配置完整。 有没有用。 我都给配置一下。 要么就先给结构体成员都附一个初始值。 再修改部分的结构体成员。 这里先改回来啊。 那怎么给结构体赋初始值呢。 我们就要用到这里的struct一定的函数了。 这个struct一定的函数就是用来给结构体赋初始值的。 那我们复制一下这个tm oc struck it。 放到这个定义结构体的下面一行哈。 然后把结构体变量的地址传进去。 这样就能给结构体赋初始值。 我们可以转到这个函数的定义看一下哈。 这个给结构体赋初始值的方法也非常简单。 就是一个一。 个手动的给个值哈。 右边这里就是它默认给的初始值好。 这是这个结构体赋值的一个注意事项哈。 也是这个struck的一定的函数的用途。 就是如果你不想把所有成员都列变赋值。 那就可以先用struct it-1个初始值。 再更改你想改的值就行了。 接着我们就来看一下这个结构体里的几个参数啊。 第一个oc目的输出比较模式转到定义看一下哈。 它没有跳过去。 我们从这里跳试一下。 在这里可以看到这个oc mod的参数。 右边是这个参数。 可以是这里的一个值。 搜索一下。 这里可以看到哈。 这些就是我们上一小节介绍过的那几种输出比较模式。 第一个timing就是冻结模式。 第二个五相等。 时至有效电平。 第三个int 5相等。 时至无效点评。 第四个togo相等时电平翻转。 下面这两个就是pwm模式一和pwm模式二的。 然后下面这里还有force action active和inactive。 这就是强制输出的两种模式啊。 不过这两个参数它不让我们初始化的时候使用。 那我们也不用它。 我们主要用的就是这个tm oc mod pwm 1。 我们复制一下。 放到这里。 这样输出比较模式就配置好了。 接下来oc polarity输出比较即兴。 我们也转下。 定义在这里啊。 它可以是这里的一个字。 我们还是搜索一下哈。 这里参数第一个是high高级性。 就是急性不翻转哈。 r e f波形直接输出。 或者说是有效电平是高电平。 r e f有效时输出高电平。 这都是一个意思哈。 第二个是low低级性。 就是r e f电瓶取反。 或者说是有效电平为低电平。 这个可以根据你的电路需求来哈。 那这里我就选择高级性。 这个复制放到这里。 这样即兴选择就完成了。 接下来是output state。 输出状态就是输出死人哈。 跳转一下。 在这里哈。 然后选择这个搜索一下。 这里就是disable势能和label。 死人了。 这个不用说。 肯定得死人了。 复制。 放在这里。 这样输出死人就完成了。 那最后一个pose。 这个名字比较奇怪哈。 pass直译是脉冲的意思。 它实际上就是用来设置ccr寄存器值。 我们可以跳转第一看一下哈。 这里注释写的就是指定pass的值会被加载到capture compare register。 这个就是ccr捕获比较计算器啊。 然后这个参数可以是零到f f f f之间的一个值。 就是16位的范围哈。 回到这里。 这个pass就是ccr的值。 前面这里呢预分频器是p c。 这里周期是ai哈。 这三个值共同决定输出pwm的周期和占空比。 计算公式就在ppt的这里哈。 那这个值我们等会儿再算哈。 现在我们初始化还没有结束。 我们还有一个gpo没有初始化。 现在我们已经把通道初始化好了。 在tm 2的oc一通道上就可以输出pwm波形了。 但最终这个波形肯定是要借用一下gpl口才能输出。 对吧。 那这个tm 2的oc一通道是借了哪个gpl口呢。 我们可以打开这个引脚定义表。 这边这一列默认复用功能就是片上外设的端口和gpu的连接关系。 在这里可以看到有tm 2 c h e e t r。 它是在这个pa 0这一行的。 这就说明tm 2的e t r引脚和通道一的引脚。 都是进入了p a0 这个引脚的位置的。 换句话说就是tm 2的引脚复用在了pa 0引脚上。 所以说如果我们要使用tm 2的oc 1。 也就是c区一通的输出p wm。 那他就只能在pa 0的引脚上输出。 而不能任意选择引脚输出。 同样如果使用tm 2的c h2。 那就只能在pa一端口输出。 tm 2的cg 3。 就只能是pa 2 z h4。 就只。 能是pa 3这些其他的外设也是同厉害啊。 比如我们要使用s p i e的m i s o硬件。 那就是p a6。 如果要使用fc 2的sc l引脚。 那就是pb 10。 这个关系是定死的哈。 不能任意更改。 不过虽然它是定时的s t m32 还是给了我们一次更改的机会的。 这就是从定义哈或者叫重映射。 比如如果你既要用u s a r t的tx硬件。 又要用tm 2的c区三通道。 他俩冲突了。 没办法同时用。 那我们就可以在这个重映射的列表里找一下。 比如这里我们找到了tm 2的c h3。 那tm 2的cg 3就可以从原来的。 引脚换到这里的银角。 这样就避免了两个外设银角的冲突。 如果这个重新设的列表里找不到。 那外设复用的gpu就不能挪位置。 这就是重新设的功能哈。 配置重映色就是用a flo来完成的。 这个我们等会儿可以试一下。 这些就是外设银角和gpo引脚的复用关系和重新设的介绍。 我们在使用外设的银角时。 需要多参考一下这个引脚定义表哈。 那我们现在要使用tm 2的c区一通道输出pwm。 通过这个表就知道它只能在p a0 引脚输出。 或者找一下重新设哈。 可以看到这里有重映射的位置。 所以如。 果使用重映射。 它可以从pa 0挪到这个pa 15的硬件上。 在其他的硬件就没有机会作为这个通道的输出硬件了。 好这样的话我们就知道该配置哪个gpu口的。 我们回到代码在这上面的位置。 初始化一下pa 01角。 当然这个初始化的位置随意哈。 你可以放在上面。 也可以放在下面。 只不过我们习惯把gpu放在上面哈。 那在这里我们打开这个d.c的文件。 复制一下这个初始化代码放在这里。 这个开启时钟的也不要忘了哈。 然后改一下这个gpp改成gpp 0。 下面gp l a初始化没问题啊。 另外这个g。 p l模式也要更改啊。 看一下参数。 这里我们需要选择为gpl目的af p p复用推挽输出。 为什么选择这个模式呢。 这个我们可以看一下ppt的这里啊。 对于普通的开路推广输出。 银件的控制权是来自于输出数据寄存器的。 那如果想让定时器来控制硬件。 那就需要使用复用开漏推广输出的模式。 在这里输出数据寄存器将被断开。 输出控制权将转移给片上外设。 那通过刚才看到引脚定义表哈。 我们就知道了。 这里偏上外设硬件连接的就是tm 2的社区一通的。 所以只有把gpu设置成复用图源输出引脚的控制权才能交给片上外设。 p w m的波形才能通过引脚输出。 回到这里。 为什么选择复用推挽输出。 应该就知道了吧。 那我们复制这个参数放到这里。 这样输出pwm的gpu就配置好了。 最后一步tm cm d一内部启动电阻器啊。 p wm波形就能通过pa 0输出了。 现在我们来看一下这里a r p s c和c c r这三个参数吧。 看一下公式哈。 通过公式我们知道pwm频率等于计数器的更新频率。 pwm占空比等于cr除以a r加1p w m分辨率等于a r加1/1。 如果我现在要产生一个频率为1000Hz。 占空比为50%。 分辨率为1%的p w波形。 那代入公式就是啊。 72兆除以p sc加一除以a2 加1=1000。 c c r除以a2 加一等于50%。 a r加1/1=1%。 那减下来就很容易得到哈。 分辨率1%。 a2 加一就是100。 上面这里也就是100哈。 占空比50%。 c加就是50。 频率1000p sc加一算一下就是720。 那在程序里r给100-1。 psc给720-1。 cr给50。 现在就是频率为1000Hz。 占空比为50%的pw波形了是吧。 我们来试一下看看那把这个函数的第一行放在头文件里。 声明一下。 编译看看。 暂时没问题啊。 没点c里面首先include pwm点去。 然后主函数里调用pwm e d。 现在就完成了编译看一下。 没有错误哈。 下载看一下。 此时l e d已经点亮了哈。 它现在其实是在以1000Hz的频率闪烁。 我们看不出来。 那怎么看呢。 我们可以用一下示波器哈。 这个示波器是一个很强大的工具。 大家如果有条件的话。 可以准备一个。 但是示波器可能比较贵哈。 如果没条件的话。 可以看我这个现象哈。 也不影响大家理解。 那我这里用的虚拟示波器哈。 这里可以接探头采集电路波形。 然后电脑上有个软件可以显示波形。 我们来看一下。 这里我把探头的g d与s t m32 共地哈。 然后探头接在led的正极。 就是pa领口。 这样就可以采集pwm的波形了。 我们在电脑端打开探头的通道。 可以看到现在就已经出现波形了哈。 我们看一下。 可以看出来这里到这里是一个周期。 时间是1ms哈。 那频率就是1000Hz。 没问题。 然后占空比高电平和低电平时间相等。 占空比就是50%也没问题啊。 这样就说明我们的参数设置是没问题的。 那我们回到代码。 改下这个c加r来调节一下占空比吧。 我们可以把它改成十。 那再同比就是十除以a2 加一等于10%啊。 看一下。 这是占空比是十。 led的亮度就变暗了一些哈。 看一下示波器。 可以看到这个高电平的时间就变短了。 只占整个周期的10%。 频率仍然不变。 还是1000Hz。 那我们再改一下哈。 c c r改成90。 那占空比就是90%。 看一下。 现在led就变亮了。 看一下示波器高电平的时间占整个周期的90%。 这就是pwm的波形和驱动led的效果。 那回到代码。 我们来完成一下这个工程的最终效果吧。 我们想让led呈现呼吸灯的效果。 那就是不断更改cci的值就行了对吧。 在运行过程更改cci。 看一下。 那我们就需要用一下这个函数啊。 tm set compare 1。 这个函数是用来单独更改通道一的ccr值的。 我们复制一下哈。 回到这里。 在下面写一个函数。 分装一下吧。 wp wm set compare 1。 参数是uint 16杠t compare。 然后里面调用一下这个tm set compare一函数。 第一个参数给tm 2。 第二个给compare。 这样就分割完了。 之前这个初始化设置ccr的值啊。 我们就不需要了。 暂时给零。 那我们把这个函数放在头文件声明一下啊。 然后到主函数这里来。 我们只需要在这个while一组循环里不断调用pwm set compare一函数。 更改cci的值。 这样就能完成led呼吸灯照效果了。 那我们先定义一个变量unit 8杠t i打组循环里。 for a等于零。 a小于等于100。 哎佳佳。 现在这个i就是从0~100不断循环自增。 然后pwm set compare一参数给i。 这里没有函数提示哈。 还有个警告是因为没有编译哈。 软件还不知道我有这函数。 所以写完函数之后尽量编译一下哈。 这样有提示会方便一些。 那现在就不用管了哈。 这里这样占空比就是从0~100。 led逐渐变亮。 最后别忘了d j 10毫秒哈。 延时一段时间。 要不然太快了。 那从零变到100之后。 我们再复制一下这个for循环。 把这里的i改成100-2。 那占空比就是从100~0。 led逐渐变暗。 这样就完成了。 再往外说明一下哈。 这个set compare一函数是设置ccr寄存器的值。 它并不直接是占空比。 占空比是ccr和a r加一共同决定的。 现在我ar加1=100。 ccr的值才直接等于占空比。 一般情况下都是要和ai共同计算的哈。 这个注意一下。 那接下来继续我们看一下现象哈。 没有错误下载。 现在d就是在不断的变量变暗哈。 呈现了呼吸灯的效果。 再看一下示波器。 可以看到占空比在不断变化哈。 两个放在一起对照一下啊。 这个现象就非常直观了是吧。 大家感受一下这个。 那这个led呼吸灯的程序我们就写完了。 最后我们再看一下之前说的银角重映射。 这个是怎么玩的吧。 我们从引脚定义表里看到了这个tm 2的c区一。 可以从p a0 挪到pa 15引脚上。 怎么操作呢。 我们就需要用到a f i o了。 那首先要使用a f i o。 就要开启a f i o的始终。 我们复制一下这一行。 这里改成a fa fo是a b2 的设备。 没有问题。 然后我们到这个gpo点去里来。 现在我们需要用到这个gp l p remap configure。 零角重新设配置。 然后放到这里转到定义看一下哈。 这里第一个参数选项非常多。 里面都是重映射的方式哈。 每个方式对应的重映射关系是啥呢。 这个可以看一下手册。 在fo这一节有讲银角从一色的功能哈。 这里面有很多表。 就是从映射方式和银角更改的关系。 那我们可以找到t i m2 复用功能重新向的这个表。 从一项就是重新设哈。 里面有四种重新设的方式。 第一种没有重新设银角就是pa 0123。 第二种部分重新设方式。 一零件就是pa 15。 pb 3。 前两个变了哈。 后面两个pa 2 pa 3没有改变。 第三种部分重新设方式。 二银角就是后面两个换成pb 10 pb 11。 前两个没有改变。 第四种完全从一测就是四个银角都更改位置。 这就是重映射方式和银角对应关系哈。 其他的表也都是这个意思。 大家有需要的话。 可以看一下这个表。 那如果我们想把pa 0改到pa 15。 就可以选择这个部分重新设方式一或者完全重新设。 这都可以回到代码这里。 我们就找一下。 可以看到这里t i m2 有部分重新设。 一部分重新设二和完全重新设。 如果都不适用。 那就是没有重新设对应表里的四种方式哈。 那我们这里选择部分重新设一的参数。 然后放到这里。 第二个参数label。 这样就能把pa 0换到pa 15了。 但是现在还要注意一个问题。 我们回到这个引脚定义表里啊。 看一下在引脚定义表里。 这个pa 15我是没给加粗的。 因为它上电后已经默认复用。 为了调试端口gt di。 所以如果想让他作为普通的gpu或者复用定时器的通道。 那还需要先关闭调试端口的服用哈。 怎么关闭呢。 也是用这个g p l p remap configure函数看一下参数啊。 这里有三个参数就是用来解除调试端口的服用的。 sw g就是s w d和g tag这两种调试方式哈。 第一个low gt r s t就是解除gt r s t引脚的附庸。 在引脚定义里看一下。 就是这个n g t i s t。 也就是p b4。 如果使用这个参数。 那么这个pb 4就变为正常的gpl口了。 其他的四个端口仍然是调试端口。 不能当做g p i o来使用。 然后看第二个参数。 g tag disable。 这个就是解除jtag调试端口的复用。 在引脚定义里就是pa 15。 pb 3。 pb 4。 这三个端口变回g p i o上面的pa 13和pa 14人为s w d的。 调试端口。 最后看第三个参数。 s w g disable。 这个参数就是把s w d和g tag的调试端口全部解除在引脚定义里。 就是这五个引脚全部变成普通的gpo。 没有调试功能的。 所以这个参数千万不要随便调用哈。 一旦你调用这个参数并且下载程序之后。 那么你的调试端口就没有了。 这之后再使用st link就下载不进去程序了。 这时就只能使用串口下载。 下载一个新的没有解除调试端口的程序。 这样才能把调试端口弄回来。 所以使用这个参数要小心一点哈。 那这些参数和gpo能不能使用的情况啊。 在手册。 里也有写。 在这里有个表哈。 l口能用还是不能用。 大家可以看一下。 和我刚才描述的内容是一样的。 回到这个引脚定义表啊。 在这里如果我们需要用pa 15。 pb 3。 pb 4这三个硬件。 那通常就是解除g tag的附庸。 保留s w d的复用。 所以这里参数我们就选sw g g tag disable复制放在这里。 然后第二个参数you be。 这样就可以正常使用pa 15这个引脚的。 总结一下。 就是如果你想让pa 15。 pb 3。 pb 4这三个银角当做gp i o来使用的话。 那就加一下这里的第一句和第三句。 先打开a f l o。 始终再用a f l o将jtag。 复用解除掉。 这样就行了。 如果你想重新设定时器或者其他外设的复用硬件。 那就加一下这里的第一句和第二句。 先打开af时钟。 再用fl重新设外设复用的硬件。 这样就行了。 如果你重新式的引脚又正好是调试端口。 那这三句就都得加上。 打开a f l o时钟。 重新设银角。 解除调试端口。 这样才行好。 那有关重映射和解除调试端口的内容我就讲完了。 然后回到代码。 现在有了这三句。 我们定时器的通道一就从pa 0挪到pa 15来。 所以下面gpl初始化这里gp l p0 也得改成gp l p 15。 因为已经。 挪到pa 15了。 所以就要初始化pa 15的gpo。 而不是p a0 呢。 那现在重新设的代码就写好了。 我们来试一下哈。 编译。 下载看一下。 现在pa 0的呼吸灯就不亮了。 我们再插一个l e d在pa 15上试试。 正极接pa 15。 负极接接地。 可以看到现在定时器的通道一就已经成功地挪到pa 15来了。 这就是重新设的功能。 可以更改复用的引脚。 那到这里我们第一个代码就算完成了哈。 这里重新设的部分我先注释掉啊。 放在这里。 这里也改回p a0。 如果你需要重新设的话。 就再解除这里的注释。 看看好。 那我们接下来开始写第二个代码。 我们还是先看一下经验图哈。 打开六杠四pwm驱动舵机的图片。 看一下。 这里是我们套间里的sg 90舵机。 它有三根线哈。 第一个间d就是棕色线接待面包板的接地。 第二个五福正极就是红色线啊。 这里要接5伏的电机电源。 大家不要把它接到面包板的正极了哈。 这个震级只有3.3伏的电压。 而且输出功率不大。 带不动电机的。 所以我们需要把它接在st link的5伏输出引脚。 从鹰角编号看。 这最下面的两个音节都是5伏输出角哈。 接哪个都行。 那我们这里就接待右下角的这个硬件了。 这里输出的直接是usb的5伏电源哈。 这个功率足够驱动电机的。 然后看第三个引脚pwm信号就是橙色线接在p a一引脚上。 这里我换了个通道哈。 上个代码用的是pa 0的通道一。 这里用的是pa一的通道二。 这都是可以的哈。 你想选哪个就选哪个。 那最后再在pb一接一个按键。 用来控制舵机。 这样这个电路就完成了。 然后看一下面包板。 先把之前的拔掉哈。 我们拿出这个舵机接一下线。 因为这个舵机的接口也是母口哈。 所以我们用一下这个跳线和杜邦线转一下。 这里棕色线用跳线转一下。 接着面包板gd红色线。 用一根公对母的杜邦线转一下。 接着s t link的五福音件。 橙色线也转一下哈。 接在p a10 件。 最后再在pb一接一个按键。 这样就完成了。 接着我们看一下代码。 打开工程文件夹。 复制一下上一个工程改个名字啊。 叫六杠四pwm驱动舵机。 打开工程。 在这里我们就要来驱动舵机了。 那我们看一下ppt。 在这里驱动舵机的关键就是输出一个这样的pwm波形是吧。 只要你的波形能按照这个规定准确的输出。 那驱动舵机就非常简单了。 所以我们回到代码。 在pwm初始化这里改一下。 首先我们改下通道。 我们现在用的是p a一口的通道二。 所以这里g p l o初始化就改成g p l p1。 上面这个也不需要了哈。 先删掉。 然后后面这里t i m o c11 d是通道一的初始化。 所以我们要改成oc 2里头。 这样这个结构体的参数就会配置到通道二的。 当然如果你通道一和通道二都想要用的话。 那就直接在这里加两行代码。 把通道一和通道二都初始化了。 这样就能同时使用两个通道来输出两个pwm了。 同理通道三和通道四也是可以使用的。 那对于同一个定时器的不同通道输出的pwm。 它们的频率啊。 因为不同通道是共用一个计数器的。 所以它们的频率必须是一样的。 他们的占空比呢由各自的ccr决定。 所以占空比可以各自设定。 还有就是它们的相位。 由于计数器更新啊。 所有p w m同时跳变。 所以它们的相位是同步的。 这就是同一个定时器不同通道输出pwm的特点。 如果驱动多个舵机或者直流电机。 那使用一个定时器不同通道的pwm就完全可以了。 然后继续看代码。 这里就只调用oc 21例函数就行了哈。 最后这里set compare一改成compact。 二头文件里也改一下哈。 这样就能使用通道二了。 编译一下。 这里有个问题哈。 看一下是主函数里的函数没有找到。 这个我们刚改哈。 就不用管了。 然后我们看一下参数。 这里a r p s c和c c r就是我们要设定的参数。 还是看一下p p t的这里哈。 第一个频率是72兆除以p s c加一。 再除a2 加一。 它要等于舵机要求的频率。 舵机要求的周期是20ms。 那频率就是1÷20毫秒。 等于50Hz哈。 占空比这里舵机要求高电平时间是0.5ms到2.5ms。 要计算占空比的话也是可以算的哈。 这个等会再说。 那在这里psc和a r r的参数并不是固定的。 这个可以自己多尝试几次。 找一个比较方便计算的值。 那经过我的尝试呢。 我设置p sc加一为72。 a r加一为20k。 这样的话满足第一个等式。 所以最终频率是50Hz。 同时呢20k对应20ms。 那ccr设置成500就是0.5ms。 ccr设置成2500就是2.5ms。 这样的话参数也是非常直观哈。 所以回答程序这里a r的值就给20k减一。 p sc就给72-1。 下面ccr的取值范围是500~2500。 对应的就是0.5ms到2.5ms。 那这里的初始值就给零吧。 我们使用下面这个函数在运行过程中设置c加。 现在pwm就初始化好了。 我们来看一下现象。 在主函数这里先把这些删掉哈。 我们调用一下pwm。 set compact 2。 给个500。 那现在舵机用0~180度来表示的话。 就应该是0度的位置。 我们编译试一下哈。 没有错误。 下载看一下。 现在舵机就移动到0度的位置。 我们稍微掰一下这个输出轴哈。 可以感觉有一股力在维持它现在的位置。 然后我们用示波器来验证一下波形。 看看把这个示波器探头接在pa一引脚。 看一下。 现在这个频率是50Hz。 这里到这里是20ms。 没有问题啊。 然后看一下高电平时间。 从这里到这里是500微秒。 就是0.5ms哈。 都符合要求。 那接着我们改一下参数。 改为2500。 对应180度试一下哈。 现在可以看到舵机就转到180度的位置。 看一下示波器哈。 频率还是50Hz。 高电平时间为2.5ms。 再改一下。 1500。 对应90度试一下哈。 现在就是在90度的位置。 示波器这边呢。 是1.5ms都符合预期哈。 这就是舵机的操作方式。 那回到代码我们来完成一下最终功能哈。 首先我们先给舵机建一个模块。 我们想要的函数是舵机设置角度。 参数是0~180度哈。 调用一下就能变为对应的角度。 这样才直观方便对吧。 而不是这里的pwm设置c c r参数是500~2500。 这参数谁知道是啥意思呢。 不直观不方便对吧。 所以我们再建一个舵机的模块。 分装一下这个函数。 那这里我快速建一个模块哈。 在hard way处添加文件。 c文件名字叫server。 再来一个h文件server。 固定部分也快速写一下。 这样模块就建好了。 然后在舵机模块的c文件。 我们要继承p w m的功能。 所以这里include。 p w m点下去。 然后写个舵机初始化的函数。 word server it void。 你们要干些啥呢。 就是p w m e d把他的p w m底层初始化一下。 然后再来个函数。 word server sangle。 舵机设置角度参数。 我们给一个float。 angle。 这个定义成float之后。 方便计算一些在里面。 那就是调用pwm set compact 2参数。 这里就要稍微计算一下了哈。 我们来看一下这里0度对应500。 180度对应2500。 那如果给一个角度。 怎么得到ccr的值呢。 这里首先我们要对angle进行缩放。 0~180度是180的范围。 500~2500是2000的范围。 所以这里angle除以180x2000就得到目标比例了。 再加一个偏移哈。 加500。 这样就完成了0~180~500~2500的映射。 验证一下啊。 ango等于零。 0÷180。 再乘2000=0。 再加500得到的是500对0度哈。 angle等于180。 180÷180。 再乘2000=2000。 再加500得到的是2500。 对应180度。 由于映射是线性的啊。 所以里面的值肯定都是一对应的。 没问题。 所以我们就把舵机的代码封装好了。 我们把这两个函数放在头文件里。 声明一下。 编译。 没有问题。 然后主函数里我们就不再直接调用pwm模块的。 这样不直观哈。 我们把它改成server模块。 首先include就不用pwm点去了。 用server点去初始化。 改一下sol edit设置角度。 这里就可以直接用solo sangle给个角度就行了。 这样就直观一些了。 是吧好。 那我们来完成一下最终现象。 在上面加一下按键的头文件。 然后定义两个变量哈。 uint 8杠t k number按键键码。 float angle。 角度变量。 主函数里k1 it按键初始化。 然后组循环里k number等于该number。 if k蓝等于等于一angle加等于30。 if angle大于180。 angle等于零。 最后把这个舵机设置角度的代码拖过来。 把angle变量给它。 这样就行了。 最后我们再加一下o l d显示显示一下角度值。 那在上面先o l d e d t初始化o l d。 在这里。 oled show string。 一行一列显示angle。 冒号先显示个字符串啊。 最后在这里o d修number。 一行七列显示安卓长度为三。 这样就完成了。 我们试一下。 这时按下按键可以看到舵机的角度。 每按一下加30度哈。 然后示波器这里也对照看一下。 大家对照着感受一下这个过程。 高电平时间也就是占空比哈。 再按照他的要求不断变化。 好到这里。 第二个程序就写完了。 最后我们再来写一下第三个程序哈。 pwm驱动直流电机。 先看一下经验图。 我们打开六杠5p wm驱动直流电机。 看一下。 这里红色的是tb 6612电机驱动模块哈。 它的第一个引脚vm电机电源同样的也是接在s t link的5伏硬件。 第二个vcc逻辑电源接在面包板3.3伏正极哈。 第三个基地电源负极接在面包板的负极之后。 a o e a o2 电机输出端接电机的两根线。 这个接线不分正反哈。 如果你对掉这两根线。 那电机旋转的方向就会反过来。 然后右边这里是力度的驱动。 如果你需要接两个电机。 那就在右边再接一个电机。 如果只需要一个电机。 那就随便选一路。 另一路空格就行。 那接着继续看上面这里的界线。 s t b y待机控制角不需要待机哈。 直接接逻辑电源键。 3.3伏。 剩下的三个是控制硬件。 a in一和a in 2是方向控制。 任意接两个g p o就行了。 这里我接的是p b4 和p b52 个角。 最后一个pwm a是速度控制。 需要接pwm的输出角。 这里我接的是pa 2这个硬件。 这里我又换了个通道哈。 pa 2对应的是tm 2的通道三。 到时候初始化通道三就行了。 另外这里还是接一个按键哈。 在pb一口用于控制。 这就是这个经验图了。 那我们看一下面包板。 来接一下电路哈。 之前呢先拔掉。 拿出这个电机驱动模块。 这个背面有引脚标号哈。 把vm放在左下角。 插在面包板的中间位置。 这个千万别插反了哈。 尿板容易烧坏驱动。 然后我们从第二个角开始接。 第二个是vcc接面包板电源正。 第三个是gd接面包板电源负之后的两个哈。 我们拿出电机。 把这两根线插在这里。 这个电机的螺旋桨转的还是比较快的哈。 可以先不踩。 要不然调试的时候可能比较危险。 然后是上面的零件。 按照接线图左边第一个p w m a。 我们接着p a2。 第二个a12 接在pa 5。 第三个a印一接待pa 4。 第四个s b y。 接待面包板电源正。 最后我们再用一个公对母的杜邦线把vm接在s tnc的五幅银角。 然后p p一的按键这里已经建好了哈。 现在接线就完成了。 这个线路还是比较复杂的哈。 大家要细心一点。 不要插错了。 好那我们回到工程文件夹。 复制一下pwm驱动led呼吸灯。 这个代码改个名字哈。 叫六个25p wm驱动直流电机。 打开工程。 目前这个代码是在通道一输出一个1000Hz的pwm。 我们电机接待了通道山上。 所以这里先改一下g p l p0 改成p2。 下面o c e一律改成oc 31例。 然后下面set compare一改成compare 3。 最后头文件这里一改成三。 也别忘了哈。 这样就行了。 那接下来对于直流电机。 我们也给它建立一个模块。 在hy处添加模块。 这里快速加一下。 名字叫motor。 然后h文件。 add固定部分快速写一下哈。 在电竞这个模块里。 我们同样是include pwm点去继承p wm的模块。 然后写一个初始化。 wide moor。 elite。 wide。 在这里调用它底层的pwm。 一it初始化一下pwm。 同时在这个电机的模块里还多了一些东西哈。 就是电机方向控制的那两个角。 所以在这里我们要再额外初始化方向控制的两个角。 那我们还是打开l e d.c复制一下这里的初始化代码。 然后。 放在这里改一下哈。 这里开启gpa时钟没问题。 下面gp ping改成g p p4 或者g p p5 之后初始化gp l a。 这样就把电机方向控制角初始化好了。 那初始化结束。 我们接下来就要写设置速度的函数了。 在这里word motor set speed参数要给一个带符号的速度变量哈。 负数用来表示反转。 这个速度值我们定为-100~100哈。 所以这里参数类型就给int 8杠t名字。 给十币的。 然后在函数里面针对正转和反转。 我们用if来分别处理哈。 if是b的。 大于等于零。 这里就是正转的逻辑在里面。 我们首先把方向控制角设置为一个高电平。 一个低电平。 哪个位高。 哪个位低。 不重要哈。 就是急性不一样而已。 所以我们就设置gpl set的beats gpa。 gpp 4。 gpl reset beats。 g p l a g p l p5。 这样方向就设置好了。 最后是速度p w m set compare 3。 这里应该是三哈。 我们还没编译。 所以提示有点问题。 把sb的变量传进去。 这样速度就也设置完成了。 电机就能转起来了。 接着我们把反转的逻辑也完成一下。 else这里是b的。 就是负数代表反转。 那在这里面把上面这三行复制下来。 改一下哈。 首先正反转。 那就set和reset反过来就能反转了。 然后还要设置pwm这里因为这时10b的为负数。 set compare必须全正数。 所以10b的前面要加一个负号。 这样就行了。 那我们来测试一下。 把这两个函数放在头文件里。 声明一下。 编一下。 这里还是这个错误哈。 没问题。 不用管了。 最后回到m.c。 现在就可以开始测试电机了。 先把之前的代码删掉。 首先头文件这里不需要pwm的。 改成moto dh。 然后主函数里调用moto it初始化电机。 再调用一个motor set speed。 参数给个50。 设置速度为正转的50。 测试一下。 看看编译。 没问题啊。 下载看一下。 这时电机就已经转起来了哈。 我们可以用手试一下现在的旋转方向。 然后我们再改一下参数变为-50。 再试一下。 然后电竞现在就是反转。 我们可以用手再试一下方向。 现在的确是反转哈。 然后再改一改。 测试一下。 改成100。 现在速度就是正传最大。 再改一下。 20。 现在速度就更慢一些了。 同时现在可以发现一个问题哈。 就是这个电机会发出蜂鸣器的响声。 在堵转的时候很明显哈。 转起来的话。 由于电机的声音听不太清。 因为电机里面也是线圈和磁铁。 所以在pwm的驱动下会发出分频器的声音。 这是正常现象哈。 如果你不介意的话。 可以不管。 如果介意的话。 那怎么避免这个问题呢。 答案就是加大pwm频率。 当pwm频率足够大时。 超出人耳的范围。 人耳就听不到了。 经过查询呢。 然而听到声音的频率范围是20Hz到20 千赫。 我们目前给的是1000Hz。 然而。 是能听到的。 所以在这里我们可以加大频率。 加大频率呢我们可以通过减小预分频器来完成。 这样不会影响占空比哈。 所以我们给这个预分频器去掉一个零。 现在就是十千赫了。 当然还不够。 我们再把72改成36。 变为一半。 现在就是20 千赫。 我们再试一下看看。 下载。 现在堵转试一下就听不到声音了哈。 那现在电机驱动模块就测试完成了。 我们最后来完成一下这个代码的全部功能哈。 回到主函数上面。 include的k dh定义两个变量。 unit t8 杠t k number。 按键键盘int 8杠t sb的有符号的速度变量。 在主函数里先k1 it初始化按键。 主循环里哈。 和上一个代码类似。 k number等于k。 get number。 if k number等于等于一。 speed加等于20。 if speed的大于100。 sb的等于-100。 现在speed就是从-100~100变化。 最后把side speed函数挪到这里。 把10b的变量传进去。 这样就能实现按键控制速度了。 最后o i d显示下速度在前面。 o i d show string。 一行一列显示10b的冒号。 后面oid修sa number。 一行七列显示10b的长度为三。 这样代码就全部完成了。 试一下看看。 按下按键o i d上速度变量变化。 同时电机也站起来了哈。 啊。 把螺旋桨安上。 现在就得到了最终的效果。 在这里如果你电机的正反转方向和你想要的方向不一样哈。 就是急性反了。 这个有很多地方可以调换过来。 比如最简单的电机两根线反过来接。 或者输入的in一和in 2反过来。 在程序里也可以哈。 把这里的set和reset翻过来。 这都可以改变极性。 另外这里引叫哈。 你也可以用宏定义给它统一改一下名字。 这样如果你换银角的话。 比较方便修改。 那这里我就不再演示了哈。 好到这里。 本小节的内容就全部完成了哈。 我们下一小节再见。
17. 大家好。 欢迎回来。 就是定时器的输入捕获功能。 那还是先看一下最终程序的线下输入捕获部分总共有两个程序。 第一个是输入捕获模式测频率。 第二个是pwm模式测频率和占空比。 先看一下第一个程序啊。 输入捕获模式测频率下载看一下。 在这里。 为了测量外部信号的频率。 我们现在有个信号源产生一个频率和占空比可调的波形啊。 但是考虑到大家可能没有信号发生器。 所以我这里就借用了一下上一小节的代码。 先用pwm模块在pa 0端口输出一。 个频率和占空比可调的波形。 然后我们本节的代码测量波形的输入口是pa 6。 所以我们直接用一根线把pa 0和pa 6连在一起。 这样就能测量自己p w模块产生波形的频率了。 另外如果你有示波器的话。 可以把探头也接在这根线上验证。 看一下频率值到底对不对啊。 如果你还有信号发生器的话。 那就不需要p a0 自己输出波形了。 直接用信号发生器产生可调的测试信号。 接在pa 6端口。 这样就行了。 那现在看一下当前代码的现象。 目前我们o r d上显示的频率是1000Hz。 这说明通过。 p a6 的测试。 pa 0输出的是一个1000Hz的信号。 然后返回程序来看一下这两行是pa 0输出频率和占空比的参数。 调节部分。 目前预分频系数是720。 代入右边的公式啊。 简单计算一下频率就是1000Hz。 我们加大预分屏。 比如扩大十倍。 现在输出频率应该是100Hz啊。 再试一下。 下载。 看到目前测试的频率为100Hz。 再改一下。 比如3600。 现在频率应该是200Hz。 试一下。 下载。 没问题啊。 这就是第一个程序输入捕获模式测频率。 目前这个程序只能测频率哈。 还不能测量占空比。 如果想同时测量频率和占空比。 s t m32 的输入捕获还设计了一个pwm模式。 即p wm输入模式啊。 那我们就来看一下第二个程序。 pwm是测频率。 占空比。 下载看一下o i d第一行显示频率当前是1000Hz。 第二行显示占空比当前是50%。 对应程序这里的pwm参数配置。 当前频率是72兆除以分频系数。 720÷100等于千赫。 占空比是ccr 50÷100=50%。 我们修改一下。 比如分频系数给个3600频率就是200Hz。 c3 r给个20。 占空比就是24%下。 下载。 目前看到测量得到的频率200Hz。 占空比20%。 没问题啊。 大家可以自行更改参数尝试哈。 或者用信号发生器进行测试都是可以的。 那本节程序的现象我就演示到这里啊。 接下来我们回到ppt看一下输入捕获的理论部分。 首先第一条输入捕获它的英文缩写是ac。 全称是input capture。 直译就是输捕获的意思啊。 对应前面我们这个定时器的整体结构图啊。 输入捕获就是这左边一部分电路。 那右边就是我们之前讲过的输出比较部分。 四个输入捕获和输出比较通道。 共用四个cci计算器。 另外他。 们的c一到c44 个通道的银角也是共用的。 所以对于同一个定时器输入捕获和速度比较。 只能使用其中一个不能同时使用啊。 然后我们回过来看一下书捕或者描述。 这一句话就是对整个输捕获的一个概括描述哈。 先看一下之前输出比较的部分。 我们也有一句话的概括描述。 就是输出比较可以通过比较c nt与ccr寄存器值得关系。 来对输出电平进行至一至零或翻转的操作。 用于输出一定频率和占空比的pw波形。 也就是这里啊。 c n t和csr是作为比较电路的输入。 根据cnt和ccr的大小关系。 从通道引脚输出高低电平。 这是输出比较的执行逻辑。 然后来到输入捕获的部分。 我们看一下输入捕获模式下。 当通道输入引脚出现指定电平跳变时。 这个指定的电平跳变就是上升沿或者下降沿哈。 可以通过程序配置发生电平跳变的瞬间。 输捕或电路会干些啥呢。 会让当前cnt的值所存到csr中。 所存到c加r的意思就是把当前cnt的值读出来。 写入到c加r中去。 这就是功能描述。 就是输入引脚电平跳变的瞬间。 把cnt的值所存到c加r中。 对应这个定时器的结构图案。 就是这四个是边沿信号。 输入零件。 一旦有边沿。 比如说上升沿。 那这一块输入滤波和边缘检测电路就会检测到这个上升沿。 让输入捕获电路产生动作。 所以这一块的作用和外部中断差不多哈。 都是检测电平跳变。 然后执行动作。 只不过外部中断执行的动作是向cpu申请中断。 而这里电路执行的动作就是控制后续电路。 让当前cnt的值所存到csi计算器中。 对比一下输出比较哈。 就是输出比较。 银角是输出端口。 输入捕获。 银角是输入端口。 输出比较是根据cnt和csr的大小关系来执行输出动作。 输入捕获是接收到输入信号。 执行cnt所存到csr的动作。 这就是输入捕获的执行流程和与输出比较的区别哈。 那设计这样一个书补或电路有什么用呢。 就是测量pwm波形的频率。 占空比。 脉冲间隔。 电平持续时间等参数。 这个脉冲间隔啊实际上和频率是差不多的意思。 电瓶持续时间和占空比差不多啊。 这些参数通过这个输入捕获电路都可以很方便地进行测量。 如何配置数组合电路来测量这些参数。 这就是本小节接下来的任务啊。 好我们。 先接着看下一条。 每个高级定时器和通用定时器都拥有四个数捕获通道。 我们看一下啊。 这里通用定时器总共有四个通道。 上面高级电子器也有四个通道哈。 输入捕获电路。 通用定时器和高级定时器没有区别。 都是一样的。 然后基本定时器这里没有输入捕获的功能哈。 这就是输入捕获电路的资源分布情况。 了解一下。 然后是下面一条可配置为pwm模式。 同时测量频率和占空比。 这个pwm模式就是pwm的输入模式。 是专门为测量pwm频率和占空比设计的。 这个pwm模式。 我们等会儿再详细分析。 接着继。 续可配合组成触发模式。 实现硬件全自动测量。 这个主从触发模式我们也等会儿再详细介绍哈。 总之我觉得后面这两项功能。 pwm模式和主从触发模式设计得非常巧妙。 把这两个功能结合起来。 测量频率占空比。 就是硬件全自动执行软件。 不需要进行任何干预。 也不需要进中断。 需要测量的时候直接读取csr计算器就行了。 使用非常方便啊。 而且极大的减轻了转折的压力。 好这就是输入捕获的整体介绍。 那既然要测量pwm信号的频率等参数。 我们还是有必要先了解一下频率测量的相关知识。 在。 这里我画了一个频率逐渐降低的方波波形哈。 越往左频率越高。 越往右频率越低。 这里信号都是只有高低电平的数字信号。 对于s t m32 测频率而言。 它也是只能测量数字信号的。 如果你需要测量一个正弦波。 那还需要搭建一个信号预处理电路。 最简单的就是用运放搭一个比较器啊。 把正弦波转换为数字信号。 再输入给htmx 2就行了。 如果你测量的信号电压非常高。 那还要考虑一下隔离的问题啊。 比如用一些隔离放大器。 电压互感器等软件隔离高压端和低压端。 保证电路的安全。 总之经。 过处理最终输入给sm 32的信号。 要是这样的高低电平信号。 高电平3.3伏。 低电平零负。 然后我们来研究一下测量这样一个信号的方法哈。 首先未来测量频率我们有两种方法可以选择。 第一种是测评法。 执行流程是在闸门时间t内对上升沿计次。 这里既是下降沿也可以啊。 只是急性不同而已。 都是一样的。 之后为了方便我们统一以上升沿为一个周期的开始进行描述哈。 那g4 得到n则待测信号的频率就是fx等于n除t。 测评法的图是说明哈。 就是这个图的左边。 比如我们要测量这。 一块信号的频率。 那就可以制定一个闸门时间。 t通常设置为疫苗哈。 在一秒时间内对信号上升沿计次从零开始记每来一个上升沿计次加一。 每来一个上升沿。 其实就是来了一个周期的型号啊。 所以在一秒时间内来了多少个周期。 那它的频率就是多少赫兹。 这符合频率的基本定义。 那频率就是多少赫兹。 所以我们在一秒的咱们时间内对上升沿g4 g是多少。 频率值就是多少赫兹。 这个没问题啊。 所以这种直接按频率定义来进行测量。 的方法就叫测评法。 另外这个闸门时间也不是必须为疫苗哈。 也可以两秒的。 咱们时间那既次值除以二就是频率。 也可以0.5秒的。 咱们时间g4 乘二也是频率啊。 所以得到这个公式g4 n除咱们时间t就是频率。 当t等于一秒时。 g是n就直接是频率。 这个好理解吧。 这就是测评法。 然后我们继续看下一个方法。 测周法执行流程是两个上升眼泪。 以标准频率fc g次得到n则频率fx等于fc除n。 测周法的基本原理就是周期的倒数就是频率哈。 我们如果能测出一个周期的时间。 再取个倒。 数不就是频率了吗。 所以我们看一下这右边的侧轴法图示。 说明我们捕获信号的两个上升沿。 然后测量一下这之间持续的时间就行了。 但实际上我们并没有一个精度无穷大的秒表来测量时间哈。 测量时间的方法实际上也是定时期地刺。 我们使用一个已知的标准频率fc的计次时钟来驱动计数器。 从一个上升沿开始记。 计数器从零开始一直记到下一个上升沿停止。 记一个数的时间是fc分之一。 即n个数时间就是fc分之n。 fc分之n就是周期。 再取个倒数就得到了公式。 fx等于fc除以n。 这个应该也好理解吧。 这就是侧轴法。 测评法和测周法都是测量频率的重要方法。 那这两种方法都有什么区别呢。 实际情况使用哪种方法更好呢。 我们来一一分析。 首先测评法适合测量高频信号。 测周法适合测量低频信号。 这个从图里也可以看出来哈。 测评法在闸门时间内最好要多出现一些上升盐。 计次数量多一些。 这样有助于减小误差哈。 假如你定了一秒的咱们时间。 结果信号频率非常低。 一秒的时间才只有寥寥无几的几个上升沿。 甚至一个上升沿都没有。 那你总不能认为频率是零吧。 在计时n很少时。 误差会非常大。 所以测评法要求信号频率要稍微高一些。 那对于侧头法就要求信号频率低一些了。 低频信号周期比较长。 这次就会比较多。 有助于减小误差哈。 否则的话。 比如标准频率fc为一兆赫兹。 待测信号频率太高。 比如待测信号500 千赫。 那在一个周期内只能记一两个数啊。 如果待测信号再高一些。 甚至一个数也记不到。 那总不能认为频率无穷大吧。 所以测得法需要待测信号频率低一些。 然后是测评法测量结果更新的慢一些。 数值相对稳定。 侧轴法更新的快。 数据跳。 变也非常快。 看一下测评法测量的是在闸门时间内的多个周期。 所以它自带一个均值滤波。 那得到的其实是这一段时间的平均频率哈。 如果咱们时间选为一秒。 那么每隔一秒才能得到一次结果。 所以测评法结果更新慢。 测量结果是一段时间的平均值。 只比较平滑。 反观测周法。 它只测量一个周期就能出一次结果。 所以出结果的速度取决于待测信号的频率。 一般而言待测信号都是几百几千赫。 所以一般情况下测周法结果更新更快。 但是由于它只测量。 一个周期。 所以结果只会受噪声的影响。 波动比较大。 这就是这两种方法的基本特征对比哈。 然后刚才我们说了。 高频适合使用测评法。 低频适合使用测周法。 那多高算高。 多低算低呢。 这就涉及到中介频率的概念了。 中介频率是测评法与侧轴法误差相等的频率点。 我们之前说的测评法系次和侧轴法记次。 这个计次数量n尽量要大一些。 n越大。 相对误差越小。 因为在这些方法中。 g次可能会存在正-1误差。 比如测评法在咱们时间内并不是每个周期信号都是完整的。 比如在最后时间里。 可能。 有一个周期刚出现一半。 咱们时间就到了。 那这只有半个周期只能舍弃掉。 或者当作一整个周期来看。 因为g是只有整数。 不可能计次0.5个数吧。 那在这个过程就会出现多记一个或者少记一个的情况。 这就叫做正-1误差。 另外在测试法这里也有哈。 标准频率f c g次在最后时刻有可能像这样一个数。 刚数到一半计时就结束了。 那这半个数也只能舍弃。 或者按一整个数来算了。 这里也会出现正-1误差。 所以说正-1误差是这两种方法都固有的误差。 要想减小正-1误差的影响。 就。 只能尽量多记一些数。 当计值n比较大时。 正-1对n的影响就会很小。 就像是你去超市买瓶水。 本来两块钱。 商家卖三块钱。 那你肯定会说黑心商家是吧。 如果你买个电脑本来5000块钱。 商家卖5001。 那你可能就觉得无所谓了。 所以总结就是n越大。 正-1误差对我们的影响越小。 那当有一个频率测评法和测周法计次的n相同。 就说明误差相同。 这不就是中介频率了吗。 所以这个公式fm等于根号fc除t怎么来的。 我们把测评法的n提出来。 侧头法n也提出来。 令这两个方法n相等。 把fx。 解出来就得到中介频率fm等于根号fc除t了。 对应图上当待测信号频率小于中介频率时。 测周法误差更小。 选用测周法更合适。 当。 待测信号频率大于终结频率是测评法。 误差更小。 选用测频法更合适。 好。 到这里。 频率测量的基本知识我就讲完了。 接下来我们用sm 32来实现这两种方法。 首先测评法。 这个我们用之前学过的外设就可以实现啊。 我们之前写过对设是红外传感器。 计次定时器。 外部时钟。 这些代码稍加改进。 就是测评法。 比如对设置红外传感器g4。 每来一个上升沿计次加一。 那我。 们再用一个定时器定一个一秒的定时中断。 在中断里每隔一秒取下计次值。 同时清零计次。 为下一次做准备啊。 这样每次读取的计次值就直接是频率。 对应定时器外部时钟的代码也是如此。 每隔一秒取一下g次。 就能实现测评法测量频率的功能呢。 这部分代码应该也不难实现吧。 大家可以自行研究哈。 我就不再演示了。 我们本节输入捕获测频率使用的方法是测周法。 那接下来我们来研究一下这个电路如何实现测轴法。 我们先回到这。 个定时器框图啊。 先详细了解一下书补或者各部分电路。 从左到右来看。 最左边是四个通道的引角。 参考引脚定义表哈。 就能知道这个银角是复用在了哪个位置。 然后银角进来。 这里有一个三输入的异或门。 这个异或门的输入接待了通道123端口。 输出引脚就产生一次电平。 翻转之后输出通过数据选择器到达输入捕获通道。 一数据选择器如果选择上面一个。 那输入捕获通道一的输入就是三个引脚的异或值。 如果选择下。 面一个那异或门就没有用四个通道。 各用各的引脚啊。 设计这个异或门其实还是为三相无刷电机服务的。 无刷电机有三个霍尔传感器。 检测转子的位置。 可以根据转子的位置进行幻象。 有了这个异或门就可以在前三个通道接上无刷电机的霍尔传感器。 然后这个定时器就作为无刷电机的接口。 定时器去驱动幻象电路工作哈。 这个了解一下。 我们本节暂时不涉及。 然后继续看输入信号过来来到了输入滤波器和边缘检测器。 输入滤波器可以对信号进行滤波。 避免一些高频的毛刺信号误触。 发哈。 然后边缘检测器。 这就和外部中断那里是一样的了。 可以选择高电平触发或者低电平触发。 当出现指定的电瓶时。 边缘检测电路就会触发后续电路执行动作。 另外这里它其实是设计了两套滤波和边缘检测电路哈。 第一套电路经过滤波和急性选择。 得到ti 1 fp一输入给通道一的后续电路。 第二套电路经过另一个滤波和急性选择。 得到ti 1 fp 2输给下面通道二的后续电路。 同理下面ti 2信号进来也经过两套滤波和极性原则。 得到ti 2 f p一和ti 2 fp 2。 其中t i n f p一输给上。 面t i f p2 输入给下面。 在这里两个信号进来可以选择各走各的。 也可以选择进行一个交叉。 让c h2 引脚输入给通道一或者c区阴角输入给通道二。 那这里为什么要进行一个交叉连接呢。 这样做的目的啊。 个人认为主要有两个。 第一个目的可以灵活切换后续捕获电路的输入。 比如你一会儿想以c h e作为输入。 一会儿想以c h2 作为输入。 这样就可以通过这个数据选择器灵活的进行选择。 第二个目的啊。 也是它交叉的主要目的。 就是可以把一个引脚的输入同时映射的两个捕获。 单元。 这也是pwm模式的经典结构哈。 等会讲pwm模式的时候。 你就知道这样设计的好处了。 第一个捕获通道使用上升沿触发用来捕获周期。 第二个通道使用下降沿触发用来捕获占空比。 两个通道同时对一个硬件进行捕获。 就可以同时测量频率和占空比。 这就是pwm模式。 等会儿再来继续分析啊。 那先回到这里。 一个通道灵活切换两个硬件和两个通道同时捕获一个硬件。 这就是这里交叉一下的作用和目的。 同样下面通道三和通道四也是一样的结构啊。 也可以选择进行。 交叉。 另外这里还有一个tr c信号。 也可以选择作为捕获部分的输入。 这个tc信号是来源于这里的。 这样设计也是为了无刷电机的驱动哈。 这个知道一下就行了。 我们暂时不用。 然后继续往后看。 输入信号进行滤波和即兴选择后就来到了预分频器。 分屏之后的触发信号就可以触发捕获电路进行工作了。 每来一个触发信号。 cnt的值就会向cci转运。 一次。 转运的同时会发生一个捕获事件。 这个事件会在状态计算器治标注位。 同时也。 可以产生中断哈。 如果需要在捕获的瞬间处理一些事情的话。 就可以开启这个捕获中断。 这就是整个电路的工作流程。 比如我们可以配置上升沿触发捕获。 每来一个上升沿c nt转运到csi一次。 又因为这个sn t计数器是由内部的标准始终驱动的。 所以3t的数值其实就可以用来记录两个上升沿之间的时间间隔。 这个时间间隔就是周期。 再取个倒数就是测周法测量的频率了。 那回到这里是不是就和这里的侧刀法差不多的意思啊。 上升沿用于触发输入捕获。 c nt用于计数计时。 每来一个上升沿取消c n t的值。 自动存在c加阿里c加r捕获到的值就是计数值n cnt的驱动时钟。 就是fc fc除n就得到了待测信号的频率。 另外这里还有一个细节问题啊。 就是每次捕获之后。 我们都要把c t701 下。 这样下次上升盐再捕获的时候。 取出的cnt才是两个上升沿的时间间隔。 这个在一次捕获后自动将c n t70 的步骤。 我们可以用主从触发模式自动来完成。 等会再。 详细介绍好。 到这里输入捕获电路的执行流程和测频率的原理。 我们应该已经大概的了解了哈。 接下来就是执行细节的问题。 把电路执行的细节都了解清楚。 这样写程序的时候才能得心应手是吧好。 那接着看一下这里。 这是输入捕获通道一的一个更详细的框图。 这个框图就是我们刚才那个框图的一个细化结构化。 基本功能都是一样的。 看一下银角进来还是先经过一个滤波器。 滤波器的输入是ti 1。 就是h一的银件输出的ti 1 f就是滤波后的信号。 f d t s是滤波器的采样时钟来源。 下面ccm 21计算器里的i c f位可以控制滤波器的参数。 那这个滤波器具体是怎么工作的呢。 可以看一下手册哈。 在ccm 21进入系这里。 有a c e f为描述。 是这几位定义了ti一输入的采样频率及数字滤波长度。 数字滤波器是由一个事件计数器组成。 它记录到n个事件后。 会产生一个输出的跳变。 简单理解这个滤波器工作原理就是以采样频率对输入信号进行采样。 当连续n个值都为高电平。 输出才为高电平。 连续n个值都为低电平。 输出才为低电平。 如果你信号出现高频抖动。 导致连续采样n个值不全都一样。 那输出就不会变化。 这样就可以达到滤波的效果。 采样频率越低。 采样个数n越大。 滤波效果就越好。 那下面这些。 描述啊就是每个参数对应的采样频率和采样个数。 在实际应用中。 如果波形噪声比较大。 就可以把这个参数设置大一些。 这样就可以过滤噪声了。 然后回过来滤波之后的信号通过边缘检测器捕获上升沿或者下降。 沿用这个cc e r进器里的cc 1 p位就可以选择极限了。 最终得到ti 1 fp一触发信号。 通过数据选择g进入通道一后续的捕获电路。 当然这里实际上应该还有一套一样的电路哈。 得到ti 1 fp 2触发信号。 连通到通道二的后续电路。 这里并没有画出来。 同样通道二有ti 2 f p1。 连通道通道一的后续通道二也还有t i f p2。 连通到通道二的后续。 总共是四种连接方式啊。 然后经过这里的数据选择器进入后续捕获部分电路。 c c e s位可以对数据选择信心。 选择之后。 sap s v可以配置这里的分频器。 可以选择不分屏。 二分屏。 4分米。 8分米。 最后cc 1 e为控制输出死人或私人。 如果死人的输出输入端产生指定边缘信号。 经过层层电路啊。 到达这里就可以让这里cnt的值转运到ccr里面来。 另外我们刚才说了。 每捕获一次cnt的值。 都要把c n t清零一下。 以便于下一次。 的捕获。 在这里硬件电路就可以在捕获之后自动完成c nt的清理工作。 如何自动清0c nt呢。 看一下这里这个ti 1 fp一信号和ti一的边缘信号。 都可以通向重模式控制器。 比如t i e f p一信号的上升沿触发捕获。 那通过这里t i e f p一还可以同时触发重模式。 这个从模式里面就有电路可以自动完成cnt的七零。 所以可以看出这个从模式就是完成自动化操作的利器哈。 那接下来我们就来研究一下这个主从触发模式。 主从触发模式有什么用。 如何来完成硬件自动化的操作。 我们看。 一下啊主从触发模式这个名字是我自己起的哈。 手册里并没有这个描述。 主从触发模式就是主模式。 从模式和触发源选择这三个功能的简称。 其中主模式可以将定时器内部的信号。 映射的t r g o0 件用于触发别的外设。 所以这部分叫做主模式。 从模式呢就是接收其他外设或者自身外设的一些信号。 用于控制自身定时器的运行。 也就是被别的信号控制。 所以这部分叫重模式。 触发源选择就是选择从模式的触发信号源的。 你可以认为它是从模式的一部分哈。 触发源选择选择指定的一。 个信号得到tga t i g i去触发重模式。 重模式可以在这个列表里选择一项操作来自动执行。 如果想完成我们刚才说的任务。 想让t i e f p一信号自动触发c n t70。 那触发源选择就可以选中这里的ti 1 fp 1。 从模式执行的操作就可以选择执行reset的操作。 这样t i e f p一的信号就可以自动触发重模式。 重模式自动清零。 sn t实现硬件全自动测量啊。 这就是主从触发模式的用途。 那有关这些信号的具体解释哈。 可以看看手册。 比如主模式的这些触发源都什么意思。 可以看一下手。 册的这里哈。 这里就有各种主模式的解释。 比如你想实现定时器的几年。 就可以选择一个定时器主模式输出更新信号到t i g o。 另一个定时器选择上一个定时器触发。 从末时从模式选择执行外部时钟模式一的操作。 这样就能实现定时器的几点了。 还有其他很多高级的功能都可以用主从触发模式来实现。 使用非常灵活。 然后主模式还可以选择复位死人比较脉冲和四个ocr掩护信号。 作为t i g o的输出。 具体描述哈可以看看这里的文字。 这些东西不用特别去记哈。 知道有这个功能就。 行了需要用的时候再来看看。 然后接下来继续往下。 这里有从模式触发源的可选信号啊。 可以选择这些信号去触发重模式。 触发重模式后可以执行哪些操作呢。 继续看重模式选择。 可以执行这么多的操作哈。 比如我们本节会使用到复位模式。 执行的操作就是选中触发输入的上升盐。 重新初始化计数器。 是不是就是t0 c nt的意思啊。 这就是重模式。 那回到bt总结下来就是这三个图。 主模式触发源选择重模式。 在库函数里也非常简单哈。 这三块东西就对应三个函数。 调用函数。 给个参数就行了。 这些就是主从触发模式的内容。 接下来我们就来。 最后理一下思路。 把之前的东西组合在一起哈。 得到这两个图。 这两个图也分别对应了我们演示两个代码的逻辑。 先看第一个数组或基本结构。 这个结构啊我们只使用了一个通道。 所以它目前只能测量频率在右上角。 这里是实际单元。 我们把实际单元配置好。 启动定时器。 那这个c n t啊就会在预分屏之后的这个时钟驱动下不断自增。 这个cnt就是我们测周法用来计数计时的东西。 经过预分屏之后。 这个位置的时钟频率就是驱动c nt的标准频率。 fc这里不难看出来。 标准频率等于72。 兆除以预分频系数。 然后下面输入捕获通道一的gpl口。 输入一个这样的方波信号。 经过滤波器和边缘检测。 选择t i e f p一为上升沿触发之后输入选择直连的通道。 分频器。 选择不分屏。 当t i e f p一出现上针眼之后。 cnt的当前记录值转运到cc一里。 同时触发源选择选中ti e f p一为触发信号。 从模式选择复位操作。 这样t i e f p一的上升眼也会通过上面这一路去触发cd清零。 当然这里会有个先后顺序哈。 肯定是得先转运sn t的值到c加r里去。 再触发重模式。 给c nt 70或者。 是非阻塞的。 同时转移cnt的值转移到csr。 同时零转移到cnt里面去。 总之肯定不会是先清零再捕获啊。 叫板捕获值肯定都是零了。 这是这两条路的执行逻辑。 然后看一下左上角的图。 在这里信号出现一个上升沿c c r e等于c n t。 就是把cnt的值转运到cc一里面去。 这是输入捕获自动执行的。 然后c n t等于零清零计数器。 这是重模式自动执行的。 然后在一个周期之内。 c nt在标准时钟的驱动下不断自增。 并且由于之前清零过了。 所以c nt就是从上升沿开始从零开始计数。 一直加加。 直到下。 一次上升沿来临。 然后执行相同的操作。 c c i e等于c n t c n t等于零。 注意第二次捕获的时候。 这个cnt是不是就是从这里到这里的计数值。 这个计数值就自动放在c加一里面。 然后下一个周期继续同样的过程。 cnt从零开始自增。 直到下一个上升沿。 这时c c r e刷新为第二个周期的计数值。 然后不断重复这个过程。 所以当这个电路工作时。 cci e的值始终保持为最新一个周期的记录值。 这个计数值就是这里的n。 然后fc除n就是信号的频率。 所以当我们想要读取信号的频率时。 只需。 要读取csr一得到n再计算fc除n就行了。 当我们不需要读取的时候。 整个电路全自动的车辆不需要占用任何软件资源。 然后还有几个注意事项说明一下。 首先是这里snt的值是有上限的。 ai一般设置为最大6535。 那cnt最大也只能记6535个数。 如果信号频率太低。 c nt计数值可能会溢出。 另外还有就是这个重模式的触发源选择。 在这里看的话。 只有t i e f p一和ti 2 fp 2。 没有ti 3和ti的信号。 所以这里如果想使用重模式自动清理c nt就只能用通道一和通道二。 对于通道三和。 通道四就只能开启捕获中断。 在中断里手动清理了。 不过这样程序就会处于频繁中断的状态。 比较消耗软件资源哈。 这个注意一下好。 接下来我们继续来看最后一个ppt。 这里展示的是pwi基本结构。 这个pwm模式使用了两个通道。 同时捕获一个硬件。 可以同时测量周期和占空比啊。 我们来看一下上面这部分结构和刚才演示的一样。 下面这里多了一个通道。 首先t i e f p一配置上升演出法。 触发捕获和704nt正常的捕获周期哈。 这时我们再来一个ti 1 fp 2配置为下降严肃法。 通过交叉通。 道去触发通道二的捕获单元。 这时会发生什么呢。 我们看一下左上角的这个图。 最开始上升演c3 r一捕获同时清零cnt之后。 c n t一直加加。 然后在下降沿这个时刻触发ccr 2捕获。 所以这时csr 2的值就是cnt从这里到这里的基础值。 就是高电平期间的基础值。 ccr 2捕获并不触发cnt 70。 所以c nt继续加加。 直到下一次上升盐c3 r一捕获周期c n t70。 这样执行之后。 ccr一就是一整个周期的计数值。 cc 2就是高电平期间的计数值。 我们用c32 除以c321。 是不是就是占空比呢。 这。 就是pwm模式使用两个通道来捕获频率和占空比的思路。 另外这里你可以两个通道同时捕获第一个硬件的输入。 这样通道二的前面这一部分就没有用到行。 当然也可以配置两个通道同时捕获第二个硬件的输入。 这样我们就是使用ti 2 f p一和t i2 f p2 这两个硬件的。 这两个输入可以灵活切换啊。 好到这里。 我们本小节的内容差不多就结束了哈。 最后大致看一下手册。 我们本节的内容在手册里主要对应这两节输入捕获模式和pwm输入模式。 看一下哈。 他这里也是对这两种模式的。 一些介绍哈。 不过这里的描述全是寄存器的方式。 还是不太好理解的。 那听完我的讲解。 再来看一下它的描述。 应该就比较容易明白是啥意思了吧。 这个大家自己再看看吧。 加深一下理解。 然后这个图就是pwm模式的例子。 一个通道捕获周期。 也就是频率。 一个通道捕获脉宽。 也就是占空比。 这就是这两种输入捕获的模式。 另外我们本节还讲了主从触发模式。 这个有什么用。 在定时器同步。 这里有介绍。 就是定时器几年啊。 然后一个定时器使能另。 一个定时器。 一个定时器启动另一个电器等等哈。 这些定时器同步的功能比较高级。 了解一下就行了。 主要还是理解这个重模式。 在这里配合输入捕获完成硬件自动化的用途。 好。 那本小节的内容到这里就结束了。
18. 大家好。 欢迎回来。 先看一下经验图。 打开六杠六的图片。 看一下上小节我们也说过。 目前我们这个测量信号的输入引脚啊。 是pa 6信号。 从p a6 进来。 待测的pwm信号也是s t m32 自己生成的。 输出引脚是p a0。 所以接线这里直接用一根线。 把pa 0引到pa 6就行了。 如果你有信号发生器的话。 也可以设置成方波信号输出。 高电平3.3伏啊。 低电平零负。 然后直接接到pa 6。 另外也别忘了供地。 这样接线也行。 那这就是接线图。 目前我们这两个代码的经验都是一样的哈。 都是接一根线。 从pa 0到pa 6。 一端接在pa 6。 另一端接在pa 0。 这样接线就完成了。 然后回到工程文件夹开始写程序哈。 目前我们要借用一下之前写好的pwm模块。 以便生成待测信号。 所以程序这里直接复制六杠三。 pwm驱动led呼吸灯的代码。 在这个工程的基础上写哈。 改个名字叫六杠六。 输入捕获模式。 测频率。 打开工程。 先编译一下哈。 之前的这些代码先删掉。 然后pwm模块这里我们还要再进行一些改进。 目前这个代码的逻辑是。 初始化tm 2的通道一产生一个pwm波形。 输出引脚是p a0 哈。 然后通过下面这个set compare一的函数。 可以调节ccr一寄存器的值。 从而控制pwm的占空比。 但是目前pwm的频率啊。 是在初始化里写好来的。 是固定的。 运行的时候调节不太方便。 所以我们在最后再加一个函数。 用来便捷的调节pwm频率哈。 如何调节pwm频率。 通过公式我们知道pwm频率等于更新频率。 等于72兆除以p sc加一。 除a r加一。 所以psc和a r都可以调节频率。 但是占空比等于cr除以a2 加一。 所以通过调节ai调节频率。 还同时会影响到占空比。 而通过p s c调节频率不会影响占空比哈。 显然比较方便。 所以我们的计划是固定a r r为100-1。 通过调节psc来改变pwm频率。 另外a r r为100-1。 cc r的数值直接就是占空比哈。 用起来比较直观。 所以可以看出。 这个p w模块还是比较复杂的哈。 频率和占空比都需要计算。 并不是我们想象的那样。 出装好了一个计算器控制频率。 另一个净水器控制占空比。 写入多少就是多少。 没那么方便哈。 当然实际使用也是有技巧的。 一般我们可以根据分辨率的要求。 先确定好a r。 比如分辨率1%就足够了。 那a r给100-1。 这样p sc决定频率。 c加r决定占空比。 这就好算了是吧。 如果我们想要更高的分辨率。 比如0.1%。 那ai就先固定1000-1。 这样频率就是72兆除以预分频除1000。 占空比就是ccr除1000。 这样也好算哈。 好在这里。 目前ai我们固定给100-1。 p s c初始化。 这里的话就先不管。 我们后面再写一个函数。 在初始化之后单独修改p s c void。 pwm set for gular uint。 压制港体boss glar。 在这里面。 我们就要调用库函数里。 单独写入p sc的函数了。 在tm点区里找一下。 这里这个tm percular configure。 就是单独写入psc的函数。 因为这个函数还有一个重装模式的参数啊。 所以它并不叫spoiler。 而叫婆sklar configure。 这是这个库的命名规范哈。 但其实都是一个意思。 就是写入p sc。 我们复制这个函数。 然后放到这里。 参数第一个tm x我们使用的是定时器二。 所以给tm 2。 第二个percular就是要写入ps sc的值。 我们直接把外层函数的这个参数传进去。 第三个reload mode就是重装模式。 我们转到第一看一下解释。 这里的参数解释是指定定时器。 预分频器的重装模式。 这个参数可以是下面的其中一个值。 第一。 个update预分频器在更新四件重装。 第二个immediate预分频器立即重装。 说白了就还是影子寄存器预装载。 这个问题啊。 就是你写入的值是立刻生效。 还是在更新事件生效。 立刻生效。 可能会在子改变时产生切断波形的现象。 比如你p w m一个周期刚过去一半。 立刻生效了。 那就立刻切断当前波形。 开始新的一个周期。 在频率变化时哈。 这里会出现一个不完整的周期。 那在更新事件生效呢。 就是会有个缓存器延迟参数的写入时间。 等一个周期结束了。 在更新事件时。 在统一改变参数。 保证每个周期的完整。 哈那目前我们这个程序使用哪个参数呢。 其实无所谓。 我们要求不高。 哪个都行啊。 这里就选择立刻生效吧。 复制然后放在第三个参数的位置。 这样我们这个sposca的函数就写好了。 我们把它放在头文件声明一下哈。 这样这个模块就改造好了。 通过set sklar改变频率。 通过set compare一改变通道一的占空比。 编译一下。 没问题啊。 然后回到b.c使用一下。 先p w m1 it初始化。 再调用pwm spogular参数。 给个720-1。 计算频率的公式放在右边哈。 频率f21 q等于72兆除以psc加一。 再除2+1。 目前ai加141百。 所以目前频率经过计算是1000Hz。 然后调用pwm set compare一参数给50。 计算占空比的公式也放在右边哈。 占空比duty等于ccr除以a r加一。 a2 加一是100。 所以目前占空比是50%。 这样调用之后。 pa 0口就能输出一个频率1000Hz。 占空比50%的待测信号了。 编一下。 没问题啊。 下载看一下。 当然现在直接看是看不出什么现象的哈。 如果你有示波器的话。 可以先验证一下pa 0的波形。 看一下是不是符合要求。 那接下来我们回到程序开始写。 输入捕获的代码。 自己测。 自己看一下pa 0口的频率和占空比是多少。 那还是先建一个模块。 在这个hardware文件夹右键添加新文件。 选择c文件。 输入捕获名字就叫ac存放路径。 加上反斜杠还在y哈。 add。 然后继续添加新文件。 选择h文件叫c存放路径。 加上反斜杠hy。 接下来头文件的固定部分快速写一下。 c文件这里加一个s t m32 的头文件。 这样就行了。 然后在这里我们写个初始化函数啊。 word i c e it word。 在这里进行输入捕获者初始化。 初始化的步骤呢。 也是对照着ppt的这个基本结构来。 目前我们需要配置电路。 连接成图示的这个样子啊。 所以步骤就是第一步。 racc开启时钟。 把gpl和tm的时钟打开。 第二步。 gp i o初始化。 把gpl配置成输入模式。 第三步配置实际单元。 让cnt计数器在内部时钟的驱动下。 自增运行。 这一步和之前的代码是一样的。 第四步配置输入捕获单元。 即兴啊。 直连通道还是交叉通道。 分频器这些参数。 用一个结构体就可以统一进行配置了哈。 第五步选择从模式的触发源。 触发源选择为ti e f p一啊。 这里调用一个扩展数。 给个参数就行了。 第六步选择触发之后执行的操作。 执行reset操作。 这里也是调用个扩展数就行了。 最后当这些电路都配置好之后。 调用tm c m d函数开启定时器。 这样所有的电路就能配合起来。 按照我们的要求工作了。 当我们需要读取最新一个周期的频率时。 直接读取cci计算器。 然后按照fc除n计算一下就行了。 这就是整个程序的思路。 那思路清楚了。 我们回到q来看一下库函数。 打开gm点缀的文件看一下。 首先t i m i s e d。 这个根据以往的经验一看就知道。 肯定就是用结构体配置输补或单元的函数。 第一个参数选择哪个电子器。 另外注意啊。 输入捕获和输出比较都有四个通道。 oc d4 个通道。 像这样。 每个通道单独占一个函数。 而i c e d呢四个通道是共用一个函数的。 在结构体里会额外有一个参数。 可以用来选择。 具体是配置哪个通道。 因为可能有交叉通道的配置哈。 所以函数合在一起比较方便。 然后继续。 下面还有一个输入捕获的初始化函数。 g m p w m i configure。 这个函数和上一个函数类似哈。 都是用于初始化输入组合单元的。 但是上一个函数只是单一的配置一个通道。 而这个函数可以快速配置两个通道。 把外设电路结构配置成。 我们ppt这里展示的p w m i模式。 这个等会儿我们写第二个代码的时候。 会用到哈。 然后往下看。 tm is a struct it。 可以给书捕获结构体赋一个初始值。 然后继续往下看。 tm select input。 trigger选择输入触发源。 t r g i这个函数就对应ppt的这里。 从模式的触发源选择调用这个函数。 就能选择从模式的触发源了。 比如我们本节要用的ti fp 1。 然后继续看。 这个tm select output trig。 选择输出触发源t r g o。 这个应该好理解吧。 它对应的就是ppt的。 这里选择主模式输出的出发源。 然后继续t i m select slave mode。 选择重模式好。 这下三兄弟就凑齐了。 这个函数对应的就是ppt这里的重模式。 选择的部分。 使用还是比较简单明了的哈。 然后继续往下看。 这里tm sec 1234 pogular。 分别单独配置通道1234的分屏器哈。 这个参数结构体里也可以配置。 是一样的效果。 最后就是tm get capture。 1234分别读取四个通道的ccr。 这四个函数和上面的set compare。 1234是对应的。 读写的都是ccr。 计算器输出比较模式下ccr是只写的。 要用set compare写入。 输入捕获模式下ccr是只读的。 要用get capture读出。 这就是这些函数好到这里。 函数介绍就完成了。 现在思路有了。 函数也有了。 我们就来开始写程序。 首先前面几步开启时钟啊。 配置gp o啊。 配置实际单元啊。 我们之前已经写过很多次了哈。 所以就直接到之前的代码复制一下。 我们打开这个pwm.c。 把这前面的三部分代码复制一下哈。 之后回到c d这里粘贴。 这三行删掉哈。 那这些就也是我们本次代码的前三步。 开启时钟配置。 gpu配置。 实际单元。 接着我们来一一修改一下第一个开启时钟。 这里开启的是tm 2。 我们这个代码还需要tm 2输出p wm哈。 所以输入捕获的定时器要换一个。 我们就换到tm 3。 gm 3也是a p p一的外设。 所以函数还是a p p一的。 这个之后gpo的始终啊。 这个就要查一下引脚定义表了。 我们看一下引脚定义。 在这里可以看到tm 3的通道一和通道二。 对应pa 6和pa 7。 通道三和通道四对应pb 0和pb 1。 所以银角需要根据实际需求来哈。 我们本次代码计划用tm 3的通道一引脚。 所以银角就是pa 6。 如果你选择其他通道或者其他电子器。 那这个引脚就需要变了哈。 回到代码。 我们计划用pa 6的通道一。 所以开启g p l a的时钟没问题啊。 然后gp i o初始化我们要用pa 6引脚。 所以gpl p0 改成p6。 下面初始化gp l a没问题啊。 只是g p i o模式。 这里需要gpl目的。 ipo上来输入。 那这样gpo配置就完成了。 接下来就是实际单元选择内部时钟没问题。 但是这里定时器要换成tm 3啊。 别忘了。 然后是实际单元的参数。 a i自动重装值。 根据上一小节的分析。 我们最好要设置大一些。 防止计数溢出。 这里我们就给最大值65536-1。 也就是16位的计数器可以满两层技术含。 之后是psc预分频器。 根据上一小节的分析啊。 这个值决定了侧轴法的标准频率。 fc 72兆除预分频。 就是计数器自增的频率。 就是技术标准频率。 这个呢需要根据你信号频率的分布范。 围来调整哈。 我们暂时先给72-1。 这样标准频率就是72兆。 除72=1兆赫兹表方面计算函。 然后计数器还是采用向上技术的模式。 下面实际单元初始化改成tm 3。 把这些参数配置到tm 3的实际单元。 这样实际单元就配置好了。 那接下来按照流程。 我们进入第四步。 初始化。 输入捕获单元到tm点区里看一下。 我们要用这个tm i c d函数复制。 然后放到这里。 第一个参数给tm 3。 第二个参数是结构体。 我们跳转到函数的定义哈。 在上面这里有结构体的类型名。 复制在这上面粘贴。 起个变量名叫tm。 复制一下。 然后把结构体成员都引出来。 最后把这个结构体的地址。 放到c d函数里面好。 我们来看一下参数。 第一个tm channel。 这个就是我们刚才说的。 选择通道的那个参数。 因为i c e d函数只有一个。 所以要靠结构体的这个参数来指定。 是配置哪个通道。 转到第一。 看一下。 这里选一下哈。 我们ctrl f搜索一下这个参数列表。 这里通道12344个参数。 需要配置哪个通道就选哪个参数。 目前我们计划使用的是tm 3的通道一。 所以选择tm千楼一复制放到这里。 接着继续看下一个tm i s filter。 这个参数用来选择输入捕获的滤波器哈。 也就是ppt这里这个滤波器。 如果你信号有毛质和噪声哈。 就可以增大滤波器参数。 可以有效避免干扰。 那在程序这里我们转到定义。 右边的解释是。 这个参数可以是0x0 到0x f之间的。 一个数数越大。 滤波效果越好。 每个数值对应的采样频率和采样次数啊。 在参考手册里有我们上下节讲过哈。 那这里呢我们就给点滤波。 就给0x f放到这里。 注意滤波器和分频器的区别哈。 虽然他俩都是计次的东西。 但是滤波器计时。 并不会改变信号的原有频率。 一般滤波器的采样频率都会远。 高于信号频率。 所以它只会滤除高频噪声。 使信号更平滑。 1000Hz滤波之后仍然是1000Hz。 信号频率不会变化。 而分屏器就只对信号本身。 进行技自然会改变频率。 1000Hz。 二分屏之后就是500Hz。 四分明就是250Hz。 这个注意一下。 然后继续下一个参数。 tm s polity即兴。 这个对应的就是图里的这个边缘。 检测极性选择的部分了。 选择是上升沿触发还是下降沿触发。 转到第一看一下。 这里参数列表搜索看一下。 这里有三个参数。 第一个ration上升演出发。 第二个falling下江演出法。 第三个boss埃及上升沿。 下降沿都触发。 所以复制第一个放到这里。 接着继续tm i a percular分屏器。 这个参数配置的是我们结构体的这个哈。 触发信号。 分屏器不分屏。 就是每次触发都有效。 二分屏就是每隔一次有效一次一次类推啊。 那我们转到第一看一下。 这里搜索一下参数列表。 可以看到有这些参数啊。 d i v一就是不分屏。 d i v2。 二分屏之后4分米8分米。 这个分明值并不能任意指定哈。 只能选择这四种。 那我们目前需要每次触发都有效。 所以选择d i v一部分屏复制放到这里。 接着最后一个参数gma selection。 选择触发信号。 从哪个引脚输入。 看一下ppt啊。 显然这个参数是配置这个数据选择器的。 可以选择直连通道或者是交叉通道。 我们看一下。 转到定义。 然后右边搜索一下参数列表。 下面这里可以看到direct。 ti就是直连通道的输入。 in direct的ti就是交叉通道的输入。 当然还有个t i c硬件哈。 这个我们暂时不用。 那对于这个代码来说。 我们需要选择直连通道。 所以复制第一个参数放到这里好。 到这里我们输入捕获的通道就配置完了。 对应这个图来看。 是不是每一部分都对应一个结构体参数哈。 不多不少参数配置完了。 这个通道的电路就连接好了。 然后我们继续按照流程来。 把主从模式的这两个东西配置好。 第五步配置t i gi的触发源为t i。 e f p1。 那回到代码找一下函数啊。 触发源选择用这个tm select input trigger。 复制放在这下面。 第一个参数给tm 3。 第二个参数就是要选择哪个触发源。 转到定义看一下。 可以看到这里给出了八个可选的出发源。 这八个除法源就对应我们ppt的这里哈。 具体的解释可以看看手册。 那我们要选的很显然是这个tmt s t i e f。 p一复制放到这第二个参数的位置。 这样触发源就选择好了之后继续第六步。 配置重模式为reset。 找一下函数。 使用这个tm select slave mode。 选择从模式复制放在这里。 参数还是类似的。 第一个给tm 3。 第二个看一下定义。 这里给出了这四种冲模式。 就对应ppt这里的下面四个重模式。 上面这三个incode。 重模式是给编码器接口用的哈。 还会另外有函数进行配置。 所以这个函数的参数就没有给出。 那在这里我们需要选择reset。 这个参数复制放到这里。 这样重模式就配置好了。 接下来最后一步。 我们就要用tm c m d参数给tm 31 able。 启动定时器。 这样整个电路的配置就完成了。 当我们启动定时器之后。 cnt就会在内部时钟的驱动下不断自增。 即使信号没有过来哈。 他也会不断之争。 不过这也没关系。 因为有信号来的时候。 它就会在从模式的状态下自动清零。 并不会影响测量好。 那初始化之后。 整个电路就能全自动测量了。 当我们想要查看频率时。 需要读取c c r进行计算。 所以我们在下面再写一个函数unit。 三二杠t c gf e q y的在里面。 我们需要执行ppt这里的公式。 fx等于fc除n fc呢之前说过。 等于72兆除p s c加一。 目前p s c是72-1。 所以fc等于一兆赫兹。 所以下面这里直接return 000000。 这是遗照。 然后除以n n就是读取cci的值。 我们到tm点去找一下函数。 需要用这个tm get capture。 一复制放到这里。 参数给tm 3。 这样就行了。 目前我们这个函数。 返回的是最新一个周期的平均值哈。 单位是赫兹。 那我们来测试一下。 先把这两个函数放到头文件声明一下。 编译看一下。 没问题哈。 然后回到m.c开始写代码。 先include一下a点。 去在这里调用c1 it初始化整个电路。 接着直接调用c gf e q显示频率就行了。 那我们先把固定的字符串显示一下啊。 o i d修string。 一行一列显示字符串。 f r e q冒号00000Hz。 然后这里。 pwm模块已经将带色信号输出到p a0 了。 p a0 又通过导线输入到pa 6。 pa 6是tm 3的通道。 一通道一通过输入捕获模块测量得到频率。 然后在主循环里我们不断刷新显示频率。 o l d修lab一行六列。 显示c gf e q长度为五哈。 这样就行了。 我们测试一下编译没问题哈。 下载看一下。 可以看到目前测量得到的频率是1001。 但是我们输出的是1000Hz啊。 多了一点点。 按理说自己输出自己测应该不会有误差呀。 但是这确实很稳定的。 多来一点哈。 就我个人推测吧。 可能是技术刚到1000Hz的那个数值。 信号也刚好跳变。 因为电路结构啊或者其他什么原因。 导致这一个数刚好没记到。 才会有一点误差哈。 不过这个也属于正-1误差的范畴。 目前这个误差也是符合要求的。 但是总是差那么一点。 逼死强迫症啊。 所以我决定还是在。 程序上给他补回来。 那么回到程序在这里加个括号。 给计算值加一。 给它补一个数哈。 这样再试一下。 下载看一下。 现在测量1000Hz没有问题哈。 凑个整。 现在就舒服多了哈。 好到这里。 第一个程序就完成了。 有关这个测评率的性能评估啊。 参数调节什么的。 我们等会儿下一个代码再来研究哈。 那第一个程序到这儿就结束了。 我们来继续写下一个代码。 回到工程文件夹。 复制一下刚才这个工程啊。 我们在这个工程基础上修改。 改个名字叫六杠7p w m i模式。 测频率占空比。 打开工程。 这个代码我们就按照ppt。 这第二个结构图来进行配置。 我们来看一下。 首先开启时钟。 gpo和实际单元都不需要更改。 然后这里输入捕获初始化的部分。 需要进行一下升级。 配置成两个通道。 同时捕获同一个硬件的模式。 怎么配置呢。 一个简单的想法。 就是把这个通道初始化的部分复制一份。 这个结构体定义的不要复制了哈。 然后呢通道一是直连输入。 上升演触发。 这个还沿用这个配置。 接着下面通道一改成通道二。 直连输入改成这个交叉输入。 上升沿触发改成下降演出法。 这样看一下是不是就。 对应我们ppt的这个结构了。 通道一直连输入上升。 演出发通道二交叉输入下降沿触发。 这样就完事儿了。 回到代码哈。 这样配置是可行的。 没问题。 但是呢sg公司怕我们觉得麻烦。 还专门给我们分装了一个函数。 来快捷的完成这个配置。 到tm点区里看一下。 这个函数就是我们之前说过的。 tm p w m i config。 我们复制一下。 然后在这里下面这一大段都不需要了。 直接调用pw mi肯贝格第一个参数tm 3。 第二个参数取例子。 把结构体变量放过来。 这样就行了。 目前演示的这个代码。 就和刚才那个代码的效果是一样的哈。 使用这个函数。 你只需要传入一个通道的参数就行了。 在函数里会自动把剩下的一个通道。 初始化成相反的配置。 比如这里传入通道一直连上升眼。 那函数里面就会顺带配置通道二。 交叉下降眼。 如果传入通道二直连上升盐呢。 函数就会。 顺带配置通道一交叉下降沿。 这就是这个函数的操作。 可以快捷地把电路配置成。 pwm模式的标准结构。 那我是咋知道的呢。 转到定义分析一下源码就知道了。 这里可以看到它会进行判断哈。 如果我传入的是vision。 则对象就是funny。 否则我传入funny对象就是re。 然后如果选择的是直连对象。 就是交叉。 否则我选择交叉对象就是直连。 最后如果选择配置通道。 一则结构体参数配置到ti 1。 对象参数配置的ti 2。 如果选择配置通道。 二则结构体参数配置的ti对象。 参数配置的ti 1。 总之就是一堆if进行判断。 以传入任意一个通道的参数。 都会顺带把另一个通道配置成相反的参数。 这就是这个函数的操作逻辑哈。 但这里也可以看出。 这个函数只支持通道一和通道二的配置。 不要传入通道三和通道四行。 那返回到这里。 执行完这个函数。 我们的p w m i电路就配置好了。 接着组成模式。 启动电阻器。 这些都不需要更改。 最后获取频率的函数不用改。 我们再写一个获取占空比的函数。 unit 32杠t ei。 get duty word。 根据上一小节的分析啊。 高电平的技术值存在cci 2里。 整个周期的计数值存在ccr一里。 我们用ccr。 除ccr一就能得到占空比了。 所以这里直接return tm get。 开不下tm 3除以tm get开不下一tm 3。 这样就得到占空比。 显然这个数的范围是0~1啊。 我们要显示整数的话。 可以在这里给他乘个100。 扩大一百倍。 这样返回值的范围就是0~100。 对应占空比0%到百分之百。 另外还是那个问题啊。 经过实测。 这个c加r总会少一个数。 所以我们给它各加一个数补回来哈。 看着舒服些。 好我们来测试一下。 把这个函数放到头文件。 声明一下。 没问题。 然后没点c这里先显示一下固定的字符串。 复制一下二行一列。 显示d o t y冒号零零百分之二。 之后小蓝宝也复制一下二行六列。 显示ac get duty长度为二。 这样程序就完成了。 我们测试一下编译。 没问题啊。 下载看一下目前测量结果。 频率1000Hz。 占空比50%。 没问题啊。 我们修改一下看看。 比如预分屏改成7200。 频率就是100Hz。 c加r改成80。 占空比就是80%。 再试一下。 下载看看。 也没问题啊。 大家可以自行更改参数尝试一下。 那到这里我们第二个代码就写完了。 最后我们来研究一下这个测频率的性能哈。 首先是测频率的范围。 目前我们给的标准频率是一兆赫兹。 计数器最大只能g到6535。 所以所测量的最低频率是一兆除6535。 这个值算一下大概是15Hz。 如果信号频率再低。 机器就要溢出了。 所以最低频率就是15Hz左右。 那如果想再降低一些最低频率的限制呢。 我们可以把这个预分屏再加大点。 这样标准频率就更低。 所支持测量的最低频率也。 就更低。 这是测量频率的下限。 然后是测量频率的上限。 就是支持的最大频率。 这个最大频率哈并没有一个明显的界限。 因为随着待测频率的增大。 误差也会逐渐增大。 如果非要找一个频率上限。 那应该就是标准频率一兆赫兹。 超过一兆赫兹。 信号频率比标准频率还高。 那肯定测不了的。 但是这个一兆赫兹的上限并没有意义啊。 因为信号频率接近一兆赫兹时。 误差已经非常大了。 所以最大频率要看你对误差的要求。 上一小节我们说到了正-1误差。 记100个数误差。 一个相对误差就是百分之。 1g1000 个数误差。 一个相对误差就是1‰。 所以正-1误差可以认为是一除计数值。 在这里。 如果你要求误差等于1‰时。 频率为上限。 那这个上限就是一兆除以1000。 等于1000Hz。 如果要求误差可以到1%。 那频率上限就是一兆除100等于十千赫。 这就是频率的上限。 如果想提高频率的上限。 那我们在这里就要把psc给降低一些。 提高标准频率上限就会提高。 除此之外。 如果频率还要更高呢。 那我们就要考虑一下测评法的测评法。 适合高频。 测周法。 适合低频。 我们这里是测。 周法。 所以对于非常高的频率。 还是交给测评法来解决吧。 然后呢还有一个就是误差分析。 除了我们之前说的正-1误差外。 在实际测量的时候还会有晶振误差。 比如我们s t m32 的晶振不是那么准。 在祭祀几百几万字之后。 误差积累起来也会造成一些影响。 当然目前我们这个现象还是自己测量。 自己不存在竞争误差。 所以数值还是非常稳定的。 如果你要测量别的信号。 那数值可能就会有些抖动了哈。 后期可以再做一些滤波处理好。 那这些就是对这个书补或测评。 率的性能评估哈。 其他。 更深入的内容就需要大家在实践中不断研。 究。 总结了那本小节输入捕获的代码部分。 我们就写完了。 我们下节再见。
19. 哈喽大家好。 本小姐。 我们来继续学习定时器哈。 这是定时器的最后一部分内容呢。 我们来学习一下定时器的编码器接口。 先看一下最终程序的现象哈。 本小节只有一个程序。 就是编码器接口测速。 我们试一下。 下载看一下面包板。 在这里我接了一个旋转编码器模块哈。 这个代码和之前我们写的旋转编码器记制的代码。 实现的功能基本都是一样的。 目前我们这个代码本质上也是旋转编码器计次。 只不过这个代码是通过定时器的编码器接口来自动几次啊。 而我们之前的代码是通过触发外部中断。 然后在中断函数里手动进几次。 使用编码器接口的好处就是节约软件资源。 如果使用外部中断来计次。 那当电机高速旋转时。 编码器每秒产生成千上万个脉冲程序就得频繁进中断哈。 然后进中弹之后完成的任务又只是简单的加1-1。 是不是我们的软件资源就被这种简单而又低级的工作给占用了哈。 所以对于这种需要频繁执行操作比较简单的任务。 一般我们都会设计一个硬件电路模块来自动完成。 那我们本节这个编码器接口就是用来自动给编码器进行记制的电路。 如果我们每隔一段时间取一下g4 值。 就能得到编码器旋转的速度了哈。 那我们看一下程序。 目前oled显示的是10b的速度。 我们旋转试一下。 向右慢速旋转数值为正。 计时比较小啊。 向右快速旋转几次就会增大。 然后向左慢速旋转。 数值为负。 及时表小。 向左快速旋转g4 也是负向增大。 然后停下来速度就是零。 这就是编码器测速的实验现象。 使用定时器的编码器接口啊。 再配合编码器就可以测量旋转速度和旋转方向了哈。 这里编码器测速一般应用在电机控制的项目上。 使用pwm驱动电机。 在使用编码器测量电机的速度。 然后再用p i d算法进行闭环控制。 这是一个比较常见的使用场景哈。 一般电机旋转速度比较高。 会使用无接触式的霍尔传感器或者光栅进行测速哈。 我们这里为了方便就是用这个触点式的旋钮编码器来演示哈。 电机旋转呢就用人工旋转来模拟。 当然实际使用的话。 这个旋钮编码器和电机的霍尔光栅编码器都是一样的效果哈。 好程序看完我们来看一下ppt。 先看一下编码器接口的简介哈。 首先编码器接口它的英文是encoder interface。 直译过来就是编码器接口的意思啊。 这个英文认识一下就行了。 然后下一条就是编码器接口的工作流程。 概述了编码器接口可以接收增量编码器的信号。 或者叫做正交编码器。 都是一个意思啊。 什么是正交编码器呢。 等会儿我们会介绍哈。 就是像这样输出的两个方波信号相位相差90度。 超前90度或者滞后90度。 分别代表正转和反转。 这就是正交编码器。 然后继续看编码器接口。 可以根据编码器旋转产生的正交信号脉冲。 自动控制c n t自增或自检。 从而指示编码器的位置。 旋转方向和旋转速度。 这就是编码器接口的工作流程。 就是接收正交信号。 自动执行c nt的自增或质检。 最终的实验现象就是这是一个编码器。 它有两个输出。 一个是a项。 一个是b项。 然后接入到sm 32定时器的编码器接口。 编码器接口自动控制定时器实际单元中的c nt计数器进行自增或质检。 比如初始化之后。 升t初始值为零。 然后编码器右转身t就加加右转产生一个脉冲。 cnt就加一次。 比如右转产生十个脉冲后停下来。 那么这个过程cnt就由零自增到十停下来。 编码器左转c n t就减减。 左转产生一个脉冲。 c n t减一次。 比如我编码器在左转产生五个脉冲。 那sn t就在原来十的基础上自减五停下来。 这个编码器接口啊。 其实就是相当于一个带有方向控制的外部始终。 它同时控制着cnt的技术始终和技术方向。 这样的话cnt的值就表示了编码器的位置。 如果我们每隔一段时间。 取是cnt的值。 再把c n t清零。 是不是每次取出来的值就表示了编码器的速度哈。 借用一下上一小节测评法和侧轴法的知识点。 这个编码器测速实际上就是测评法测正交脉冲的频率啊。 c g g4。 然后每隔一段时间取值计时。 这就是测评法的思路对吧。 只不过这个编码器接口计时更高级。 它能根据旋转方向。 不仅能自增记词。 还能自检即词是一个带方向的测速啊。 好以上就是编码器接口的工作流程了。 那我们继续看ppt。 下一条。 每个高级定制器和通用定时器都拥有一个编码器接口。 这个。 编码器接口的资源还是比较紧张的哈。 如果一个定时器配置成了编码器接口模式。 那它基本上就干不了其他活了。 我们这个c8 t6 芯片只有tm 12344个定制七。 所以最多只能接四个编码器。 而且接完四个编码器就没有定时器可以用了哈。 所以如果你编码器比较多的话。 需要考虑一下这个资源够不够用。 不过实在不行的话。 你还是可以用外部中断来接编码器的。 这样就是用软件资源来弥补硬件资源了哈。 所以这里也可以看出硬件资源和软件资源是互补的。 硬件资源越多。 软件。 就会越轻松啊。 硬件不够呢。 那就软件来凑对吧。 比如pwm我可以直接来个定时中断。 然后在中断里手动技术手动翻转填平。 比如输入捕获。 我可以来个外部中断。 然后在中断里手动把sn t取出来。 放在变量里。 比如编码器接口。 我也可以来外部中断。 然后在中断里手动自增或自检基数。 这都可以实现功能。 怎么输出比较啊。 输入捕获啊。 编码器接口啊都不需要。 但是这样就是消耗软件资源了。 所以一般有硬件资源的情况下。 我们可以优先使用硬件资源。 这样节约下来的软件资源可以去干更重要。 的事情。 那继续往下看。 编码器接口的两个输入硬件。 借用了输入捕获的通道一和通道二。 这个等会儿从结构框图就可以看出来哈。 编码器的两个输入引脚就是每个定时器的h一和h20 件。 c3 和c4 不能接编码器啊。 好这些就是编码器接口的简介了。 我们接下来来看一下正交编码器。 正交编码器一般可以测量位置或者带有方向的速度值哈。 它一般有两个信号输出零件。 一个是a项。 一个是b项。 编码器的样子和结构呢。 我们之前外部中断这里也介绍过哈。 我们大概回顾一下。 这里看。 一下图片。 第一个是只有一个光栅加红外对管的编码器。 这只能输出一个方波信号。 并不是正交编码器啊。 第二个图就是我们套件使用的编码器里面靠两个金属触点交替导通。 可以输出a项和b项两个正交信号。 是正交编码器啊。 这里有四个硬件。 上面两个是供电的正极和负极。 下面两个是a项和b项的输出。 第三个图是电机后面自带的一个编码器。 电机旋转带动中间的磁铁旋转。 两个霍尔传感器90度放置。 最终输出a项和b项两个正交信号是正交编码器。 下面这里一般有六根线。 最左和最右是直接接到电机的。 然后是靠里一些的两根线是编码器电源。 最中间的两根就是a项和b项的输出了。 接着最后一个图是单独的编码器。 软件一般都是正交编码器哈。 当然也有的不是这个要看清商品的说明。 接线的零件一般有六个。 两个是编码器。 电源。 两个是a b项。 一般还有一个编码器零位置的输出啊。 也就是z项零位置就是编码器每转到一个固定位置时。 输出一个脉冲。 一般应用于位置常量哈。 较重零位置用的。 最后还有一个硬件。 一般是空间没有用到。 这就是常见的编。 码器外观和工作原理。 那回到这里。 当编码器的旋转轴转起来时。 a项和b项就会输出这样的方波信号。 转得越快。 这个方波的频率就越高。 所以方波的频率就代表了速度。 我们取出任意一项的信号来测频率。 就能知道旋转速度了。 但是只有以上的信号无法测量旋转方向。 因为无论正转还是反转。 它都是这样的。 方波想要测量方向。 还必须要有另一根线的辅助。 比如我可以不要这个b项哈。 再定义一个方向。 输出角正转至高电平。 反转至低电平。 这是一种解决方案哈。 但是这样的信号并不是正。 交信号另一种解决方案就是我们本节所说的正交信号。 当正转时a项提前。 b项90度。 反转时a项之后。 b项90度。 当然这个正转是a项提前还是a项之后。 并不是绝对的。 这只是一个极限问题啊。 毕竟正转和反转的定义也是相对的。 总之就是朝一个方向转。 是a项提前。 另一个方向是a项之后。 那使用正交信号相比较单独定义一个方向引脚有什么好处呢。 首先就是正交信号精度更高。 因为ab向都可以计时。 相当于计时频率提高了一倍。 其次就是正交信号可以抗噪声。 因为正交信号两。 个信号必须是交替跳变的。 所以可以设计一个抗噪声电路。 如果一个信号不变。 另一个信号连续跳变。 也就是产生了噪声哈。 那这时计时值是不会变化的。 这个等会会再介绍哈。 接着我们来看一下右边这个表。 看一下正交信号如何计次和区分旋转方向呢。 首先我们观察一下波形的特点。 在正传的时候。 第一个时刻a项上升眼对应b项。 此时是低电平。 也就是表里的第一行。 继续。 第二个时刻。 b向上升盐对应a项高电平是表里的第三行。 继续。 第三个时刻。 a项下降眼对应b项高电平是表里的。 第二行最后是b项下降盐对应a项低电平。 是表里的第四行。 再然后就是a向上升。 沿b向低电平了。 和第一个状态重复啊。 所以在正传的时候。 我们总结了右边这个表。 当出现这些边缘时。 对应另一项的状态是这四种。 那反转呢我们看一下第一个时刻。 b项上升盐对应a项低电平。 第二个时刻。 a项上升盐对应b项高电平。 第三个时刻。 b项下降盐对应a项高点评。 第四个时刻。 a项下降沿对应b项低电平。 然后把这四种状态也列一个表。 这里就可以发现。 当a b项出现这些边缘时。 对于逆向。 的状态。 正转和反转正好是相反的。 比如a向上升延时正转。 b项就是低电平。 反转b项就是高电平。 剩下的大家可以自己看一下啊。 也都是相反的。 所以我们编码器接口的设计逻辑就是。 首先把a项和b项的所有边缘作为计数器的技术。 始终出现边界性。 20就计数自增或自检。 然后到底是增还是减呢。 这个计数的方向由另一项的状态来确定。 当出现某个边缘时。 我们判断另一项的高低电频。 如果对应另一项的状态出现在上面这个表里。 那就是正转即时制。 真反之。 另一项的状态出现在下。 面这个表里。 那就是反转即是质检。 这样就能实现编码器接口的功能呢。 这也是我们s t m32 定时器编码器接口的执行逻辑哈。 那接下来我们先来看一下这个定时器的框图。 看一下这个编码器接口的电路是如何设计的。 这里编码器接口处于定时器的这个位置啊。 高级电子器和通用电子器都是一样的。 每个定时器都只有一个编码器接口。 然后基本定时器是没有编码器接口的。 我们来看一下。 这里编码器接口有两个输入端。 分别要接到编码器的a项和b项。 然后这里是两个网络编号。 分别写的是t i e f p一和t i f p2。 对应的就是这里ti 1 fp 1。 另一个是这两ti fp 2电路是这样连接的。 可以看出哈这个编码器接口的两个硬件。 借用了输入捕获单元的前两个通道。 所以最终编码器的输入硬件啊。 就是定时器的h一和h2 这两个音响信号的通路是c h1。 通过这里通向编码器接口。 h2。 通过这里通向编码器接口。 c3 和c h4 与编码器接口无关。 其中c h一和h2 的。 输入捕获滤波器和边缘检测编码器接口也有使用哈。 但是后面的是否交叉预分频器和ccr寄存器与编码器接口无关。 这就是编码器接口的输入部分。 那编码器接口的输出部分啊。 其实就相当于重模式控制器了。 去控制cnt的技术始终和技术方向。 简单来说。 这里的输出执行流程是按照我们之前总结的那个表。 如果出现了边缘信号。 并且对应另一项的状态为正转。 则控制c nt自增。 否则控制c t自检。 注意在这里啊。 我们之前一直在使用的72兆赫兹内部。 始终和我们在实际单元初始化。 时设置的技术方向并不会使用哈。 因为此时技术始终和技术方向都处于编码器接口托管的状态。 就税的自增和自减受编码器控制好。 这就是编码器接口的电路结构了。 然后我们看一下。 这里我给出了一个编码器接口基本结构哈。 这个结构就比较清晰了是吧。 输捕获的前两个通道通过gpl口接入编码器的a b项。 然后通过滤波器和边缘检测即兴选择产生t i e f p一和t i f p2。 通向编码器接口。 编码器接口通过预分频器控制c n t计数器的时钟。 同时编码器接口还根据编码器。 的旋转方向控制cnt的技术方向。 编码器正转时c n t自增。 编码器反转时c n t自检。 另外这里a r也是有效的哈。 一般我们会设置a r为6535。 最大两层。 这样的话利用补码的特性很容易得到负数啊。 比如cn g初始为零。 我正转c t自增01234567等等。 这都没问题。 但是我反转呢。 cnt质检零下一个数就是6535。 接着是6534。 6533等等。 这里负数不应该是-1-2吗。 6535是不是就出问题了哈。 但是没关系。 我们会做一个操作。 直接把这个16位的无符号数转。 换为16位有符号数。 根据补码的定义。 这个6535就对应-1啊。 6534就对应-2。 6533就对应-3等等。 这样就可以直接得到负数。 非常方便。 这是我们读出数据得到负数的一个小技巧。 二。 那到这里我们这个电路结构就了解差不多了。 最后我们来看一些工作细节哈和两个小例子。 那先看一下这里工作模式的这个表。 这个表描述的就是我们刚才说的编码器接口的工作逻辑哈。 这里t i e f p一和t i f p2。 接着就是编码器的a b项在a项和b项的上升沿或者下降沿。 触发技术到底是向上技术还是向下技术呢。 取决于边缘信号发生的这个时刻。 另一项的电瓶状态。 也就是这里的相对信号的电平。 t i e f p一对应ti 2。 ti 2 fp 2对应ti 1。 就是另一项电瓶的意思啊。 然后在这里这个编码器还分了三种工作模式。 分别是仅在t i e技术。 仅在ti 2技术和ti 1 ti 2都技术。 这三个模式是啥意思呢。 我们回到这里看一下。 我们目前总结的是这四种状态都是正转。 都可以计时至臻。 下面这四种状态都是反转。 都可以即时质检。 这四种状态涉及了两个硬件。 分别。 是a向上升沿a向下两眼。 b向上升。 沿b向下降沿。 如果这四种状态都执行自增和自减。 就是a项和b项的边缘都记住。 那就对应这里的第三种模式。 ti和ti都计数。 当然这里我们还可以忽略一些边缘啊。 比如我们可以仅在a项的上升沿和下降沿自增或之间。 而b项的这两个状态忽略掉。 不执行技术。 或者仅在b项的上升沿和下降沿技术a项的边缘。 不管它这样是不是也可以实现功能啊。 只不过是g4 的精度低了些。 看图比划一下。 就是如果两个边缘都记住。 记住的时刻就是这样。 如果。 仅在a项边缘技术技术的时刻。 就是这样。 b项的边缘忽略掉哈。 如果仅在b项边缘技术也是同理。 那这两种仅在一个边缘技术的模式就对应这表里的前两种模式。 仅在ti技术和仅在ti 2技术。 然后这个表右边什么时候自增。 什么时候自检。 和我们前面这里的表也是一样的。 我们把这个表拿过来对比一下。 这里假设t i e接a项。 ti 2接b项。 当a b项为左边这四个状态时。 就是正转计数器需要自尊。 我们看一下左边第一个状态。 a向上层眼。 b向低电平右边查一下a向上升眼。 这里先看第三种模式啊。 那对于另一项低电平执行的是向上技术。 然后左边第二个状态。 a项下降。 沿b向高电平右边查一下a项下降。 沿b向高电平也是相当基础。 左边第三个状态b向上升。 沿a项高电平右边扎一下b向上升眼。 a项高点平也是向上基础。 左边第四个状态b向下降。 沿a向低电平又表达一下b向。 下降沿a向低电平还是向上计数。 正好啊。 这里正转的状态都是向上级数。 你也可以把反转的状态拿过来比较一下。 就对应另外这四个向下技术。 所以总结一句话就是正转的状态都向上技术。 反转的状态都向下技术。 这是编码器接口执行的逻辑。 然后上面这两种模式应该也好理解哈。 就是指在一项的边缘技术。 另一项的边缘忽略。 也就是不计数技术的逻辑啊。 和最下面这个模式都是一样的。 一般情况下我们都会使用最下面这个模式哈。 因为这个模式技术精度最高。 上面这两个模式如果。 你有这个需求的话可以了解一下哈。 这就是编码器接口的三种工作模式。 那接着我们再来看一下这个实例图。 这个图里使用的就是两个硬件的边缘都技术的模式。 执行的逻辑我放在这上面了。 然后看一下这里是t一和t2 的时序信号。 下面是计数器值的变化情况啊。 第一个状态。 ti一上身眼ti 2低电平查表。 上层眼低电平对应向上技术。 所以这里计数器变高了一级。 接着后面的这几个状态啊。 大家可以查一下表。 都是线上技术。 这是正转没问题。 接着后面这个地方展示的就是正交编码。 器抗噪声的原理了。 在这里t2 没有变化。 但是ti一却跳变了好几次。 这不符合正交编码器的信号规律。 正交信号两个输出交替变化。 就像人走路一样。 先迈左腿再迈右腿。 在左腿。 在右腿。 这里就是右腿没动。 左腿连续走了好几步。 显这个左腿的动作是一个毛刺信号。 而通过我们上面这个表的逻辑。 就可以把这种一个腿没动。 另一个腿连走好几步的噪声滤掉。 比如这里t i e上升眼ti 2低电平查表得向上级处这里自增啊。 然后下一个状态ti一下降眼ti还是低电平查表。 就是向下技术。 所以。 这里质检。 然后继续ti一上升。 演ti 2低电平指针。 继续ti一下降。 沿t2 低电平值减。 所以你看这里如果出现了一个引脚不变。 另一个引脚连续跳变多次的毛色信号。 就系就会加减加减。 来回摆动。 最终计数值呢还是原来那个数并不是毛刺噪声的影响。 这是正交编码器抗噪声的原理。 然后继续往右看。 这里是反转的波形。 对照上表都查一下啊。 都是向下计数。 这里计数值就下降。 然后t i e不动。 t2 多次跳变计数值也是来回摆动。 过滤噪声啊。 最后是正转向上技术。 这就是编码器接口的一个。 实例哈。 这个图展示了什么时候向上技术。 什么时候向加技术。 以及正交编码器抗噪声的原理哈。 最后我们再来看一下这个实例。 这个实例展示的是急性的变化对技术的影响。 前面这个是两个引脚都不反向的图。 后面这个是ti一反向。 t i2 不反向的图哈。 t i e反向是什么意思呢。 我们看一下这个图。 这里t一和t2 进来都会经过这个急性选择的部分。 在输入捕获模式下。 这个极限选择是选择上升沿有效还是下降沿有效的。 但是根据我们刚才的分析啊。 编码机接口显然始终都是上升。 沿和下降沿都有效的哈。 上升沿和下降沿都需要记刺对吧。 所以在编码器接口模式下。 这里就不再是边缘的极限性选择的。 而是高低电平的极限选择。 如果我们选择上升沿的参数。 就是信号直通过来。 高低电平急性不反转。 如果选择下降沿的参数。 就是信号通过一个非门进来高低电平极性反转。 所以这里就会有两个控制极限的参数转折。 要不要在这里加一个非门哈。 反转一下即兴。 那对于这里。 如果两个信号都不反转。 就是这里的均不反向。 如果把ti一高低电平反转一下。 就是这里的ti反。 向分析的时候呢。 这里图上画的是输入信号啊。 如果你直接对照上面这个表得到的技术方向就是错误的。 比如第一个状态。 ti一上升眼。 ti低电平查表应该是向上激素啊。 但是这里实际却是向下计数。 所以t i e反向之后。 我们先这样把t i e高低电平取反。 这才是反向后实际给编码器接口的电平。 然后再查表。 第一个状态应该是ti一下降眼。 ti 2低电平查表得到是向下技术和这里是对应的哈。 后续状态大家可以自行查表。 一一对照哈。 我就不再演示了。 那ti一反向之后。 我们对照上一个。 图显然这两个图的技术方向是相反的。 这有什么用呢。 比如你接个编码器。 发现它数据的加减方向反了。 你想要正转的方向。 结果它自减了。 你想要反转的方向。 结果它自增的。 这时就可以调整一下。 即兴把任意一个引角反向就能反转技术方向了。 但如果想改变技术方向的话。 我们还可以直接把a b项两个引角换一下。 这也是可以的哈。 有很多地方都可以调整极性。 还是非常方便的。 好了到这里我们这个编码器接口的知识点就讲完了哈。 最后大概看一下手册。 我们本节的内容对应手册。 这里。 的编码器接口模式。 最开始这里是编码器接口的整体介绍哈。 大家可以仔细看看。 这里有一句话的概述。 就是编码器接口模式。 基本上相当于使用了一个带有方向选择的外部时钟。 然后下面这个表就是编码器接口执行的逻辑有三种模式。 什么状态对应如何自证和质检都可以参考这个表。 最后就是两个例子。 演示了如何自增和自减抗噪声原理和极性选择的作用哈。 总共就是这么多的内容。 剩下还有一些说明文字。 大家可以再自行查看哈。 那本小节的内容就到这里。 我们下小节来写编码。 器接口的代码。
20. 欢迎回来。 那接下来我们就来写一下编码器接口测速的代码。 首先还是接线部分。 我们打开接线图。 打开六杠八的图片。 看一下。 这个接线和支线外部中断那一节的类似哈。 我们把旋转编码器插在左边。 vcc和jd接上电源正负极下面的a项输出。 我们接到pa 6硬件。 d项输出。 接到p a7 硬件。 这里p a6 和pa 72个硬件可以交换一下。 a项接pa 6。 b项接p a7。 或者a项接p a7。 b项接p a6 都是可以的哈。 就是正转和反转的急性不一样而已。 但是pa 6和pa 7这两个引脚不能随便更换。 我们看一下引脚定义。 p6 和p7 是tm 3的通道一和通道二。 我们计划用tm 3接编码器。 所以需要接在pa 6和p7 这两个音箱。 其他定时器的话也都需要参考这个表哈。 接在对应tm的h一和h2 这两个引脚的位置。 所以这里编码器的ab项我们接的是pa 6和pa 7。 这就是接线图。 首先拿出旋转编码器模块。 然后用跳线接一下上面的电源部分。 vcc接电源正。 接地接电源负。 最后再拿两根飞线啊。 a项接在pa 6。 b项接在p a7。 这样接线就完成了。 之后我们回到工程文件夹开始写代码哈。 我们从这个定时器定时中断的代码基础上写。 复制一下。 改个名字。 第二款八编码器接口测速。 打开工程。 这里原来这些代码先注释掉哈。 定时中断。 这部分先也注释掉。 我们等会儿还会使用哈。 先编译一下。 没问题好。 我们来看一下编码器接口的代码。 先新建一个模块。 在hardwell处右键添加新文件。 选择c文件。 编码器接口。 我们的名字还叫encoder。 存放路径。 加上反斜杠。 它的y add。 然后继续添加新文件。 选择h文件叫encoder存放路径。 加上反斜杠hy。 接下来头文件的固定部分快速写下。 c文件。 这里加一个s t m32 的头文件。 这样模块就建好了。 然后在这里我们写一个初始化函数y的encoder it word。 在这里进行编码器接口的初始化。 还是先看一下结构图。 熟悉一下流程啊。 第一步。 rc c开启时钟。 开启gpl和定时器的时钟。 第二步配置gpo。 这里需要把pa 6和p7 配置成输入模式。 第三步配置实际单元。 这里预分频器我们一般选择部分屏自动重装。 一般给最大6535。 只需要个c n t执行技术就行了。 第四步配置输入捕获单元。 不过这里书补和单元只有滤波器和极性这两个参数有用。 后面的参数没有用到哈。 与编码器。 无关。 第五步配置编码器接口模式。 这个直接调用一个库函数就可以了。 最后调用tm c m d启动定时器就完事了。 电路初始化完成之后。 cnt就会随着编码器旋转而自增自减。 如果想要测量编码器的位置。 那直接读出cd的值就行了。 如果想测量编码器的速度和方向。 那就需要每隔一段固定的闸门时间取出一次cd。 然后再把c n d清零。 这样就是测评法测量速度了。 那流程干完。 我们来看一下库函数。 打开tm点区的文件。 在这里找一下库函数啊。 只有这。 一个tm encoder interface configure。 定时器编码器接口配置。 第一个参数选择定时器。 第二个参数选择编码器模式。 然后面两个参数分别选择通道一和通道二的电频集性。 这是配置编码器接口的函数。 其他函数啊我们就不需要再了解了。 那回到这里。 我们开始写代码哈。 首先前面几步和之前的代码基本一样。 我们还知道之前的代码复制一下。 我们打开这个书捕获的代码。 然后从这里。 到这里复制下来。 在这个include it里面粘贴。 然后主号看一下。 第一步开启时钟tm 3 g p l a没问题。 第二步gp l o初始化。 我们使用的是pa 6和p7。 所以gpl p这里我们加个或gpl p下面初始化gpa。 这样就是把pa 6和p7 配置成上拉输入模式。 另外这里这个gpu模式可以选择上拉下拉或者浮空上拉和下拉。 如何选择呢。 我们一般可以看一下接在这个银角的外部模块输出的默认点评。 如果外部模块空闲。 默认输出高电平。 我们就选择上来输入默认输入高电平。 如果外部模块默认输出低电平。 我们配置下拉输入。 默认输入低电平和外部模块保持默认状态一致哈。 防止默认电瓶打架。 这是上拉和下拉的选择原则啊。 所以一般上拉输入用的比较多。 然后如果你不确定外部模块输出的默认状态。 或者外部信号输出功率非常小。 但是缺点就是当硬件选空时。 没有默认的电瓶了。 输入就会受噪声干扰。 来回不断的跳变。 这就是三种输入模式的选择原则函。 再大概讲一下。 然后继。 续往下看。 定时器内部始终配置这一行就不需要了。 因为编码器接口会托管时钟。 编码器接口就是一个带方向控制的外部时钟啊。 所以这个内部时钟就没有用了。 接下来是实际单元配置计数器模式。 这个参数目前也是没有作用的哈。 因为技术方向也是被编码器接口托管的。 自动重装值。 目前还是给6536-1。 也就是满量程技术啊。 这样技术的范围是最大的。 而且方便换算为负数。 预分频器。 这里改成1-1。 预分频给零就是不分平啊。 编码器的始终直接驱动计数器。 最后初始化tm 3。 这。 就是实际单元部分的配置。 接着继续往下看。 下一步就是输入捕获单元的配置。 这里看一下ppt啊。 可以看出苏补和单元并没有全部使用到编码器接口。 只使用了通道一和通道二的滤波器和即兴选择。 所以我们只需要配置这两部分的参数即可。 那在代码里就是后面这两个参数与编码器无关啊。 我们可以直接删掉。 或者你留着也行。 只是他们目前没有作用。 那删掉之后。 目前结构体的配置是不完整的。 为了防止结构体中出现不确定值可能会造成的问题啊。 我们最好用struct elite给结构体赋一个。 初始值加个struct elite。 也是提醒一下我们哈。 结构体并没有配置完整。 那在定义结构体变量之后。 我们来一个tm ac struct dt结构体初始化。 把这个结构体的地址传进去。 -1个初始值哈。 转到定义看一下。 这些就是它默认给的初始值。 然后回到这里。 初始值负号之后。 我们再制定通道为一。 滤波器为零。 x f电瓶极星为上层岩。 上下节。 我们说过这里的上层岩并不代表上层岩有消寒。 因为编码器接口始终都是上升沿。 下降沿都有效的。 这里的上升沿参数代表的是高低电平极性不反转。 也就是我们ppt这里演示的ti 1 ti 2是否反向对应通道给上升沿。 就是不反向给下降沿就是反向这个意思。 其实这里的这个极限函数啊。 等会儿我们配置编码器接口的时候。 也有属于重复配置的。 这里这个其实。 也可以删掉。 等会儿对比一下之后再删哈。 那这里参数配置好了。 最后传给i c e。 把这些参数写到通道一。 然后还有通道二。 我们复制一下。 这下面一部分把通道号改成签到二。 另外两个参数可以在这里指定哈。 指定好之后再调用i c e d。 把下面这些参数写入到通道二。 整理一下这一块代码的逻辑啊。 就是首先定义结构体变量。 然后struct it给结构体赋予一个初始值。 在部分修改我们想要的参数。 调用sd配置。 以便电路这个结构体变量的配置哈。 调用c d函数之后就写入到硬件的计算器了。 所以以dt之后这个结构体我们可以换个值继续使用。 不需要重新定义新的结构体了哈。 那到这里两个通道的滤波器和极性就都配置好了。 这一步也就完成了。 接下来下一步配置编码器接口。 这里我们只需要调用一个函数就行了。 到tm点区里复制这个tm encoder interface configure。 放到这里。 参数第一个tm x给tm 3。 剩下的转到定义看一下哈。 第二个编码器模式可以选择下面三个参数之一。 第一个ti一就是仅在ti一技术。 第二个ti就是仅在ti 2技术。 第三个ti 12就是t一和t2 都记住。 对应我们ppt这个位置的三个模式。 那我们一般使用ti和ti 2都记住哈。 所以复制第三个参数放到这里。 接着继续转到定义。 看一下后两个参数就是s一的极限和s2 的极限了。 参数列表一样哈。 都是falling和ration。 选择ration就是这个通道不反向。 选择falling就是这个通道反向。 这个可以根据实际情况来配置哈。 我们目前可以先选择ration复制。 放到这里。 然后最后一个参数再给一次reaction。 这样参数就配置好了。 然后大家可以注意到哈。 这里后两个参数和上面这里的两个参数是一样的。 实际的效果呢确实就是一样的。 这两个地方的参数啊。 其实都配置的是同一个计算器。 属于重复配置的哈。 后配置的参数会覆盖前面的参数。 所以我们可以把这前面这个极限的参数也删掉哈。 只使用后面这个函数来配置机型。 不过要注意这是一定要保证这个in code函数位于c d函数的下面。 否则的话就是c1 d覆盖inq这函数的配置。 这个注意一下。 那现在看这个i c e d的参数啊。 就只剩一个滤波器。 还有用好。 到这里。 我们整个电路就配置完成了。 最后我们再调用一个tm c m d tm 3以内部开启定时器。 这样初始化配置就结束了。 调用一下这个include int函数编码器旋转就能控制c n t自增自减了。 那我们下面再写个get函数啊。 unit 16杠t encoder get word。 在这里面我们暂时先直接返回cd的值看看。 直接return tm get counter tm 3。 这样来测试一下。 那我们把这两个函数都放在头文件。 声明一下。 没问题啊。 然后回到main dc测试一下。 先include一下。 include点去。 然后main函数进来。 先include it初始化。 目前呢我们就直接在储存环里不断刷新cd的值就行了。 这个显示字符串改成cn g。 然后主循环解除注释。 不断修lab一行五列显示in code get。 目前in code get就是直接返回升d的值哈。 长度为五。 这样来试一下编译。 没问题。 下载看一下。 目前显示cnt是零。 可以看到值变成四了。 我们这个编码器是有这个段落感。 它每转一格。 它输出的波形其实是这样的。 a项产生一个低电平脉冲。 b项产生一个相位差90度的脉冲。 提前还是之后。 取决于正转还是反转。 如果连续转动啊。 就和我们p p t的波形是一样的啦。 那可以看出现在编码器转动一格。 a b项各出现了一个下降沿和上升眼。 所以计次总共加了四次。 但如果你是电机的编码器。 那就不会有这个段落感了。 然后我们继续往右转。 cnt。 就继续指针往左转呢。 c n t就自检这个现象没问题啊。 然后接下来我们来实验一下。 我们转到零再往左转转慢点啊。 可以看到零在自减计数器反向溢出。 回到自动重装值6535。 然后继续往下减。 这就是目前我们使用uint 16杠t数据的现象。 那如果我们想要零之后变为-1。 就直接把u int 16杠t类型强制转换成int 16杠t就行了。 我们试一下。 你可以直接把修number改成修三的number。 这样就行。 也是进行一大类型相转。 那我们还是在这里get的时候就转换。 一下吧。 这里函数的返回值直接换成int交流杠t。 然后函数声明也不要忘了改一下。 在主循环里改成修三的number。 这样就能显示负数了。 我们试一下。 下载看一下。 现在是零。 数值自增。 直至减零之后变成负数。 继续自检哈。 这就是借用不慢的特性。 快速完成负数转换的小技巧啊。 之后我们再来研究一下极限的问题。 如果这个方向和你想要的不一致的话。 可以修改一下即兴在硬件上面。 我们可以这样把ab项两根线换一下。 这样增减方向就可以反过来了。 试一下。 现在向右是减。 向左是真。 那在软件层面呢。 我们可以修改这里的两个输入通道的即兴。 把任意一个极限反转一下。 方向就会反过来。 如果两个极限都翻转。 那极限还是保持不变哈。 所以我们目前想改变极性的话。 可以把第一个这里的ration改成falling。 试一下看看。 下载现在极限就是又反转过来了。 向右是针。 向左是减。 这就是极限的问题。 目前我们这个代码是编码器测量位置。 如果需要测量位置的话。 就这样直接get counter就行了。 那我们继续研究。 把这个线先改回来。 程序这里即兴也改回来。 如果我们想用这个编码器来测速的话。 就可以在固定的闸门时间读一次sn t。 然后把sn t70。 我们修改一下这个get函数要求读完后704nt。 所以我们要定义一个临时变量int 16杠t tap。 然后temp等于tm get counter。 获取cd之后。 tm set counter tm 30给3t清零。 最后return tp。 这是读取cd。 然后把cd清零的逻辑。 所以需要用tp缓存一下哈。 我们来试一下。 在主循环里每隔一段时间get一次。 所以下面可以给一个d类1000ms。 因为我们人手转比较慢哈。 所以咱们时间就给一秒。 如果你是电机飞速旋转的话。 咱们时间就可以给短对哈。 这样可以提高速度刷新的频率。 而且防止计数器溢出哈。 我们来试一下。 下载看一下目前cnt的值就代表速度单位是脉冲个数每秒。 我们向右慢速转速度是正数比较小哈。 快速转正数比较大。 向左慢速转速度负数比较小。 快速转负数比较大。 好这就是我们这个用旋钮模拟编码器测速的程序现象。 当然我们目前只是用这个旋钮模拟的测速啊。 如果你有编码电机的话。 可以实际接电机的编码器试试看。 现象都是一样的哈。 不过要注意把这个咱们时间弄短点。 防止计数器溢出。 那程序现象到现在就完成了。 如果你主。 程序没有其他东西的话。 可以这样来做。 但是如果有其他东西的话。 最好就不要在主循环加入过长的delay哈。 这样会阻塞主循环的执行。 那比较好的方法就是用这里留了这么久的定时中断了。 我们解除注释。 上面time it也解除注释。 这里定时中断目前是每隔一秒执行一次。 你可以修改定时中断的时间哈。 来调整咱们时间之后。 我们可以在前面定义一个全局变量int 16杠t4 b的。 然后在定制中断里执行10b的等于。 include get。 每隔一秒读取一下速度。 存在10b的变量里。 然后主循环就可以快速刷。 新显示10b的了。 delay可以删掉。 这样就不会阻塞主循环就行了。 然后前面的字符串我们也改成speed。 下面显示数字的位置。 往后挪两格。 改到七列。 这样我们整个程序就完成了。 我们试一下编译。 下载看一下向右旋转正的速度。 向左旋转负的速度停止速度为零。 这就是我们最终程序的现象哈。 好到这里。 我们这个编码器接口测速的代码就写完了。 我们下节再见。
21. hello。 大家好。 欢迎继续观看s t m32 入门教程。 模拟数字转换器。 那我们先来看一下本节课程序的现象啊。 本节课共有两个程序。 第一个程序是ad单通道。 第二个是a d多通道。 先看一下第一个ad单通道下载。 我接了一个电位器。 就是滑动变阻器哈。 用这个电位器产生一个0~3点3伏连续变化的模拟电压信号。 然后接到s t m32 的pa 0口上之后。 用s t m32 内部的adc读取电压数据显示在屏幕上。 这里屏幕第一行显示的是a d转换后的原始数据。 第二行是经过处理后实际的电压值哈。 那我们理一下这个电位器。 试一下。 往左拧。 d值减小。 电压值也减小啊。 a d值最小是零。 对应的电压就是0伏。 往右你ad值变大。 对应电压值也变大。 s t m32 的a d c是12位的。 所以a d结果最大值是4095哈。 也就是二的12次方减一对应的电压是3.3伏。 这就是第一个程序的现象。 那对于gp i o来说。 它只能读取引脚的高低电频哈。 要么是高电平。 要么是低电平。 只有两个值。 而使用了a d c之后呢。 我们就可以对这个高电平和低电平之间的任意电压进行量化。 最终用一个变量来表示。 读取这个变量就可以知道引角的具体电压到底是多少来。 所以a d c其实就是一个电压表哈。 把引脚的电压值测出来。 放在一个变量里。 这就是adc的作用好。 那我们继续看一下第二个代码。 第二个代码是ad多通道。 看一下。 在这里我又接了三个传感器模块哈。 分别是光敏电阻。 热敏电阻和反射红外模块。 把他们的ao啊。 模拟电压输出端分别接待了a1 a2 a3 引脚。 加上刚才的电位器啊。 总共四个输出通道。 然后测出来的四个ad数据分别显示在屏幕上。 我们来试一下第一个电位器啊。 看第一行的ad 0。 往左拧减小。 往右拧增大。 和上一个程序现象一样哈。 然后光敏电阻看第二行的第一遮挡一下光敏电阻。 光线减小。 a地值增大。 你看光线增大。 a地值减小。 然后证明电阻看第三行的ad 2。 用手热一下这个热敏电阻温度升高。 a地值减小。 一开温度降低。 a地值增大。 最后是反射红外传感器啊。 手靠近有反光d值减小。 一看没有反光。 ad值增大。 这就是第二个程序的现象。 好那接下来我们就来看一下ppt啊。 首先看一下a abc的简介。 译为模拟到数字转换器啊。 简称魔术转换器或者叫ad转换器。 下面一条a d c可以将引脚上连续变化的模拟电压。 转换为内存中存储的数字变量。 建立模拟电路。 数字电路的桥梁。 那刚才通过程序现象我们也看到了哈。 s t m32 主要是数字电路。 数字电路只有高低电平。 没有几伏电压的概念哈。 所以如果想读取电压值。 就需要借助adc模数转换器来实现了。 adc读取引脚上的模拟电压转化为一个。 数据存放在寄存器里。 我们再把这个数据读取到变量里来。 就可以进行显示啊。 判断记录啊等等操作了。 a d c可以将模拟信号转换为数字信号。 是模拟电路到数字电路的桥梁哈。 a d c是模拟到数字的桥梁。 那反过来有模拟到数字的桥梁。 那肯定就有数字到模拟的桥梁对吧。 这就是dac数字模拟转换器。 使用dc就可以将数字变量转化为模拟电压。 不过在上一节呢我们还学到了一个数字的模拟的桥梁是啥呢。 p w m上节我们使用pwm来控制led的亮度啊。 电机的速度。 这就是dc的功能哈。 同。 时pwm只有完全导通和完全断开两种状态。 在这两种状态上都没有功率损耗啊。 所以在直流电机调速这种大功率的应用场景。 使用pwm来等效模拟量是比dc更好的选择。 并且pwm电路更加简单。 更加常用。 所以可以看出p wm还是挤占了dc的很多应用空间哈。 目前d a c的应用主要是在波形生成这些领域。 比如信号发生器。 音频解码芯片等。 这些领域。 pwm还是不好替代的哈。 好这就是adc和dac的简单介绍了。 大家就自行了解了。 我们这个型号的s t m32 也没有。 dc的外设哈。 那继续看下一条s t m32 的adc是12位逐次逼近型的a d c。 1微秒的转换时间逐次逼近型。 这是这个a d c的工作模式啊。 等会再细说。 然后12位和1微秒的转换时间。 这里就涉及到adc的两个关键参数了。 第一个是分辨率。 一般用多少位来表示啊。 12位a d值它的表示范围就是0~2的12次方减一。 就是量化结果的范围是0~4095位数越高啊。 量化结果就越精细。 对应分辨率就越高。 第二个是转换时间。 就是转换频率啊。 a d转换是需要花一小段时间的。 这。 里1微秒就表示从a d转换开始到产生结果需要花1微秒的时间。 对应a d转换的频率就是一兆赫兹。 这个就是s t m32 adc的最快转换频率哈。 如果你需要转换一个频率非常高的信号。 那就要考虑一下这个转换频率是不是够用啊。 如果你的信号频率比较低。 那这个最大一兆赫兹的转换频率也完全够用了哈。 然后看下一条输入电压范围。 0~3点3伏。 转换结果范围0~4095。 这个a abc的输入电压。 一般要求都是要在芯片供电的负极和正极之间变化的啊。 最低电压就是负极。 0伏最高电压是正极3.3伏经过adc转换之后。 最小值就是零。 最大值是4095。 零符对应零三点。 3伏对应4095。 中间都是一一对应的线性关系啊。 这个计算起来就非常简单了是吧。 直接乘除一个系数就行了。 然后继续看这个adc有18个输入通道。 可测量16个外部和两个内部信号源。 外部信号源就是16个g po口啊。 在银角上直接接模拟信号就行了。 不需要任何额外的电路。 银角就直接能测定呀。 这个还是非常方便的。 两个内部信号源是内部温度传感器和内部参考电压。 温度传感器可以测量cpu的温度哈。 比如你电脑可以显示一个cpu温度。 就可以用a d c读取这个温度传感器来测量内部参考电压。 是一个1.2伏左右的基准电压。 这个基准电压是不随外部供电电压变化而变化的。 所以如果你芯片的供电不是标准的3.3伏哈。 那测量外部引脚的电压可能就不对。 这时就可以读取这个基准电压进行校准。 这样就能得到正确的电压值了。 然后继续规则组合注入组两个转换单元。 这个就是s t m32 adc的增强功能的。 普通的ad转换流程是启动一次转换。 读一些值。 然后再启动再读值。 这。 样的流程。 但是s t m32 的a d c就比较高级哈。 可以列一个组。 一次性启动一个组。 连续转换多个值。 并且有两个组合。 一个是用于常规使用的规则组。 一个是用于突发事件的注入组。 这个等会儿我们再去看哈。 那继续看模拟看门狗自动监测输入电压范围。 这个a d c啊。 一般可以用于测量光线强度温度。 这些机子并且经常会有个需求啊。 就是如果光线高于某个阈值。 低于某个阈值或者温度高于某个阈值。 低于某个阈值时。 执行一些操作。 这个高于某个阈值。 低于某个阈值的判断就可以。 用模拟看门狗来自动执行模拟看门狗可以监测指定的某些通道。 当d值高于它设定的上余值或者低于下余值时。 它就会申请中断。 你就可以在中断函数里执行相应的操作。 这样你就不用不断的手动阻止啊。 再用if进行判断了。 这个可以了解一下。 然后最后一条s t m32 f103 c8 t6 啊。 就是我们用的这个信号。 他的adc资源有adc 1 adc 2。 共有两个adc。 外设十个外部输入通道。 也就是它最多只能测量十个外部引脚的模拟信号。 我们之前这里说的16个外部信号源啊。 这是这个系列。 最多有16个外部信号源。 但是我们这个芯片引脚比较少。 有很多音调没有引出来哈。 所以就只有十个外部信号源。 如果你想要更多的外部通道。 可以选择银角更多的型号。 具体有多少通道呢。 那还需要再参考一下数据手册来好。 有关s t m32 a d c的简介。 我就讲这么多。 接下来我们就来了解一下这个逐次逼进行a d c到底是怎么测电压的。 我们看一下这个图。 这就是逐次逼近型adc的内部结构。 因为s t m32 的a d c原。 理和这个是一样的。 但是s t m32 只画了一个框啊。 表示a d c并没有描述内部结构。 所以我们先介绍一下这个结构哈。 这样在理解s t m32 的a d c就会简单一些了。 我们来看一下这个图是adc 0809的内部结构图哈。 逐次逼近行a d c芯片。 在以前的时候啊。 单片机的性能还不是很强。 所以需要外挂一个adc芯片才能进行ad转换。 这个adc 0809就是一款比较经典的adc芯片。 那现在单片机的性能和集成度都有很大的提升。 很多单片机内部就已经集成了。 adc外设。 这样就不用外挂芯片的银角可以直接测电压。 使用还是非常方便的哈。 我们来看一下这个结构。 通过通道选择开关。 选中一路输入到这个点进行转换。 下面这里是地址所存和一码。 就是你想选中哪一路哈。 就把通道号放在这三个角上。 然后给一个锁存信号。 上面这里对应通路开关就可以自动拨号了。 这部分就相当于一个可以通过模拟信号的数据选择器啊。 因为adc转换是一个很快的过程。 你给一个开始信号。 过个几微秒就转换完成了。 所以说如果你想转换多路信号。 那不必设计多个a d转换器啊。 只需要一个a d转换器。 然后加一个多路选择开关。 想转换哪一路就先拨一下开关。 选中对应通道。 然后再开始进行转换就行了。 这就是这个输入通道选择的部分。 这个adc 0809只有八个输入通道。 我们s t m32 内部的a d c是有18个输入通道的。 所以对应这里就是一个18路输入的多路开关。 那然后输入信号选好了。 到这里来。 怎么才能知道这个电压对应的编码数据是多少呢。 这就需要我们用逐次逼近的方法来。 一比较了。 首先这是一个电压比较器。 它可以判断两个输入信号电压的大小关系。 输出一个高低电平只是随大随小。 它的两个输入端。 一个是在侧的电压。 另一个是这里d a c的电压输出端。 d a c是数模转换器哈。 我们之前说过了。 给它一个数据。 它就可以输出数据对应的电压。 dc内部是使用加权电阻网络来实现的转换。 具体可以看我五一单片机教程里的a d d a那一集。 这里我就不再细说了哈。 那现在我们又来一个外部通道输入的未知编码的电压。 和一个dac输出的已知编码的电压。 他俩同时输入的电压比较器进行大小判断。 如果d ac输出的电压比较大。 我就调小d a c数据。 如果dc输出的电压比较小。 我就增大d ac数据。 直到dac输出的电压和外部通道输入的电压近似相等。 这样dac输入的数据就是外部电压的编码数据的。 这就是dc的实现原理。 这个电压调节的过程就是这个逐次逼近sr的完成的。 未来最快找到位置电压的编码。 通常我们会使用二分法进行寻找哈。 比如这里是八位的a d c。 那编码就是从0~255。 第一次比较的时候。 我们就给d a c输入。 255的一半进行比较。 那就是128。 然后看看谁大谁小。 如果dc电压大了。 那第二次比较的时候就再给128的一半64。 如果还大。 第三次必要的时候就给32。 如果这次dc电压小了。 那第四次就给32~64中间的值。 然后继续这样依次进行下去。 就能最快的找到未知电压的编码。 并且这个过程哈如果你用二进制来表示的话。 你会发现128。 64 32这一数据正好是二进制每一位的味全。 这个判断过程就相当于是对二进制从高位到低位依次。 判断是一还是零的过程。 这就是逐次逼近型名字的来源。 那对于八位的a d c从高位到低位依次判断八次。 就能找到未知电压的编码了。 对于12位的a d c就需要依次判断12次。 这就是逐次逼近的过程。 那然后ad转换结束后。 dac的输入数据就是未知电压的编码。 通过这里进行输出。 八位就有八根线哈。 12位就12根线。 最后上面这里eoc是end of convert转换结束信号。 start是开始转换给一个输入脉冲。 开始转换啊。 可clock是a d c始终。 因为a d c内部是一步一步进行判断的。 所以需要时钟来。 推动这个过程。 下面vr e f正和v r e f负是dc的参考电压。 比如你给一个数据255瓦是对应5伏还是3.3伏呢。 就由这个参考电压决定这个d a c的参考电压。 也决定了a d c的输入范围。 所以它也是a d c参考电压。 最后左边是整个芯片电路的供电哈。 vcc和g n d通常参考电压的正极和vcc是一样的。 会接在一起。 参考电压的负极和基地也是一样的。 也接在一起啊。 所以一般情况下adc输入电压的范围就和adc的供电是一样的。 好到这里。 相信你对逐次逼进行a d c就已经。 了解差不多了哈。 接下来我们就来看看s t m32 的注释b进行a d c。 看看s t m32 的a d c和这个相比有什么更高级的变化啊。 那我们看一下s t m32 的这个adc框图。 一般在手册里啊。 每个外设的最前面都有一个整体的结构图。 这个结构图还是非常重要的啊。 需要多花点时间看看。 我们看一下。 在这里左边是adc的输入通道。 零到in 15和两个内部的通道。 一个是内部温度传感器。 另一个是vr e f i n t内部参考电压。 总共是18个输入通道。 然后到达这里。 这是一个模拟多入开关。 可以指定我们想要选择的通道啊。 右边是多路开关的输出。 进入到模数转换器这里。 魔术转换器就是执行我们刚才讲过的逐次比较的过程啊。 转换结果会直接放在这个数据寄存器里。 我们读取寄存器就能知道a b c转换的结果了。 然后在这里对于普通的a d c多路开关。 一般都。 是只选中一个的啊。 就是选中某个通道开始转换。 等待转换完成取出结果。 这是普通的流程。 但是这里就比较高级了。 它可以同时选中多个。 而且在转换的时候还分成了两个组哈。 规则通道组和作物通道组。 其中规则组可以一次性最多选16个通道。 注入组最多可以选中四个通道。 这有什么用呢。 举个例子啊。 这就像是你去餐厅点菜。 普通的a d c4。 你指定一个菜老板给你做。 然后做好了送给你。 这里就是你指定一个菜单。 这个菜单最多可以填16个菜。 然后你直接递个菜单给老板。 老板就。 按照菜单的顺序依次做好。 一次性给你端上来。 当然你的菜单也可以只写一个菜哈。 这样这个菜单就简化成了普通的模式了。 那对于这个菜单呢也有两种。 一种是规则组菜单可以同时上16个菜。 但是它有个尴尬的地方啊。 就是在这里这个规则组只有一个数据计算器。 就是这个桌子比较小啊。 最多只能放一个菜。 如果上16个菜。 那不好意思啊。 前15个菜都会被挤掉。 你只能得到第16个菜。 所以对于规则总转换来说。 如果使用这个菜单的话。 最好配合。 dma来实现。 dma是一个数据转运小帮手啊。 他可以在每上一个菜之后把这个菜挪到其他地方去。 防止被覆盖。 这个dma我们下一节就会这样了。 现在先大概了解一下。 那现在我们就知道了。 这个规则组虽然可以同时转换16个通道。 但是数据寄存器只能存一个结果。 如果不想之前的结果被覆盖。 那在转换完成之后。 就要尽快把结果拿走。 这个组就比较高级了。 它相当于是餐厅的vip座位。 在这个座位上一次性最多可以点四个菜。 并且这里数据寄存器有四个是可以同时上。 四个菜的对于诸如而言就不用担心数据覆盖的问题了。 这就是规则组和侏儒组的介绍。 一般情况下我们使用规则组就完全足够了。 如果要使用规则组的菜单。 那就再配合dma转移数据。 这样就不用担心数据覆盖的问题了。 所以接下来我就直接规则组的操作哈。 注主涉及的不多。 大家可以看手册自行了解啊。 首先左下角这里是触发转换的部分。 也就是这里的start信号开始转换。 那对于s t m32 的adc触发adc开始转换的信号有两种。 一种。 是软件触发。 就是你在程序中手动调用一条代码就可以启动了。 另一种是硬件触发。 就是这里的这些出发员啊。 上面这些是注入组的出发源。 下面这些是规则组的出发源。 这些触发源主要是来自于定时器啊。 有定时器的各个通道。 还有t r g o定时器主模式的输出。 这个之前讲定时器的时候也介绍过哈。 定时器可以通向a d c d a c这些外设用于触发转换。 那因为adc经常需要过一个固定时间段转换一次。 比如每隔1ms转换一次。 正常的思路就是用定时器每隔1ms申请一次中断。 在中断里手动开启时转换。 这样也是可以的哈。 但是频繁进中段对我们的程序是有一定影响的。 比如你有很多中端都需要频繁进入。 那肯定会影响主程序的执行。 并且不同中段之间啊。 由于优先级的不同。 也会导致某些中断不能及时得到响应。 如果触发a d c的中断不能及时响应。 那我们a d c的转换频率就肯定会产生影响了。 所以对于这种需要频繁进中段。 并且在终端里只完成了简单工作的情况。 一般都会有硬件的支持。 比如这里就可以给tm 3定一个1ms的时间。 并且把tm 3的。 更新事件选择为tr g o输出。 然后在adc这里选择开始触发信号为tm 3的tr g o。 这样tm 3的更新事件就能通过硬件自动触发adc转换了。 整个过程不需要进终端。 节省了中断资源。 这就是这里定时器触发的作用。 当然这里还可以选择外部中断引脚来触发循环。 都可以在程序中配置啊。 这就是触发转换的部分。 然后接着看左上角。 这里是vr e f正v r e f负v d d a和v s s a。 上面两个是adc的参考电压。 决定了adc输入电压的范围。 下面两个是a d c的供电引脚。 一般情况下v r e f正。 要接v d d a v r e f负。 要接v s s a在我们这个芯片上没有为i e f正和v r e f负的银角。 它在内部就已经和v d d a和v s s a接在一起了。 vd d a和v s s a在这个引脚定义里也可以看到哈。 我们之前讲过了。 v d d a和v s s a是内部模拟部分的电源。 在这里v add a接3.3伏。 vs s a接g n d。 所以a d c的输入电压范围就是0~3点3伏。 然后继续看右边。 这里是adc。 clk是adc的。 始终也就是这里的clock啊。 适用于驱动内部逐次比较的。 时钟这个是来自a d c预分频器。 这个a d c预分频器是来源于r c c的。 我们找一下。 在这里哈ab 20中72兆赫兹。 得到adc cl k a d c clk最大是14兆赫兹。 所以这个玉粉饼器就有点尴尬哈。 他可以选择2468分屏。 如果选择二分屏。 72兆除以2=36兆。 超出允许范围了。 四分屏之后是18兆也超了。 所以对于a d c预分频器只能选择六分屏。 结果是12兆和八分屏。 结果是九兆这两个值。 这个在程序里要注意一下。 然后回到这里。 这是adc的。 始终继续看上面这里是dma请求。 这个就是用于触发dma进行数据转运的。 我们下节再讲哈。 然后是两个数据计算器。 用于存放转换结果的上面。 这里还有模拟开门狗。 它里面可以存一个阈值高线和阈值低线。 如果启动了模拟看门狗。 并且指定了开门的通道。 那个看门狗就会关注他开门的通道。 一旦超过这个阈值范围了。 它就会乱叫啊。 就会在上面申请一个模拟看门狗的中段。 最后通向n v i c。 然后对于规则组合注五组而言呢。 它们转换完成之后也会有一个e o c转换完成的信号。 在这里eoc是规则组的完成信号。 z uc是注入组完成的信号。 这两个信号会在状态计算器里制一个标志位啊。 我们读取这个标志位就能知道是不是转换结束了。 同时这两个标志位也可以去到n v i c申请中断。 如果开启了n v i c对应的通道。 它们就会触发中断。 好有关a abc的这个框图哈。 我们就介绍完了。 那接下来就来看一下。 我这里总结了一个a abc基本结构图。 再来回顾一下哈。 左边是输入通道。 16个gpl口。 外加两个内部的通。 道。 然后进入ad转换器a d转换器里有两个组。 一个是规则组。 一个是注入组。 规则组最多可以选中16个通道。 诸如组最多可以选择四个通道。 然后转化的结果可以存放在ad数据计算器里。 其中硅胶组只有一个数据计算器。 注入组有四个。 然后下面这里有触发控制。 提供了开始转换这个十大的信号。 触发控制可以选择软件触发和硬件触发。 硬件触发主要是来自于定时器啊。 当然也可以选择外部中断的硬件。 右边这里是来自于r c c的adc。 始终clock a d c逐次比较的过程。 就是由这个时终。 推动的。 然后上面可以布置一个模拟看门狗。 用于监测转换结构的范围。 如果超出设定的阈值。 就通过中断输出控制向nvc申请中断。 另外规则组和柱组转换完成后会有个eoc信号。 它会自己一个标志位啊。 当然也可以通向nvc。 最后右下角这里还有个开关控制在库函数中啊。 就是a d c cmd函数用于给a d c上电的。 那这些就是s t m32 abc的内部结构图了。 接下来我们再了解一些细节的问题啊。 首先看一下输入通道。 刚才我们说了。 这里有16个外部通道。 那这16个通道对应的都是哪些。 gpl口呢我们就可以看一下这个表。 这些就是a d c通道和引脚复用的关系。 这个对应关系也可以通过引脚定义表看出来。 我们看一下。 在这里可以看到abc 1210对应的是pa 0硬件in一对应pa硬件。 然后印二印三印四印五in 6 in 7 in 8 in 9。 依次对应的是p a2 到p b1。 这里只有10~19哈。 总共只有十个通道。 然后其他地方就没有了。 所以这个芯片就只能有十个外部输入通道。 然后a d c1210 的意思是。 a d c一和a d c2 的一零都是在p a0 上的。 然后下面全都是a。 d c12 啊。 这说明adc一和adc 2的银角全都是相同的。 既然都相同。 那要a d c2 还有啥用呢。 这个就要再说一个a d c的高级功能呢哈就是双a d c模式。 这个模式比较复杂哈。 这里只简单介绍一下。 不需要掌握哈。 双a d c模式就是a d c一和a d c21 起工作。 他俩可以配合组成同步模式啊。 交叉模式等等模式。 比如交叉模式a d c一和a d c2 交叉的对一个通道进行采样。 这样就可以进一步提高采样率。 就像你打拳一样啊。 左手打一拳。 右手打一拳。 左手打一拳。 右手打一拳。 快速。 交叉的打拳。 那打击的频率肯定就比一个拳头打得快对吧。 当然还有其他的模式啊。 这里就不再细说了。 这就是a d c一和a d c2 配合使用的双a d c模式。 当然adc一和adc 2也是可以分开使用的哈。 可以分别对不同的硬件而进行采样。 这样也是可以的。 那回到这里。 这个表就是adc的通道和银角对应表和引脚定义那个是一样的哈。 这里通道有零到17。 总共是18个通道。 通道16对应a d c一的温度传感器。 通道17对应a d c一的内部参考电压。 这里只有a d c一有通道。 16和。 17啊。 a d c2 和a d c3 是没有的。 然后上面是gpu的引脚。 a d c一和a d c2 的引脚是完全相同的。 a d c3 中间会有些变化。 不过我们这个芯片也没有a b c3 哈。 不用管的。 这里银角的顺序就是pa 0到pa 7。 然后pb 0到pb 1。 再然后pc 0到pc 5。 由于我们这个芯片没有pc 0到pc 5。 所以这些通道就没有了。 这就是通道和银角的关系。 了解一下。 接下来我们再了解一下规则组的四种转换模式。 分别是单次转换非扫描模式。 连续转换非扫描模式。 单次转换扫描模式和连续转换扫描模。 式那在我们a d c初始化的结构体里会有两个参数啊。 一个是选择单次转换还是连续转换的。 另一个是选择扫描模式还是非扫描模式的。 这两个参数组合起来就有这四种转换方式。 我们来逐一看一下。 第一种单次转换非扫描模式。 这个是最简单的哈。 这里我画了一个列表。 这个表就是规则组里的菜单。 有16个空位。 分别是序列一到序列16。 你可以在这里点菜啊。 就是写入你要转换的通道。 在非扫描的模式下。 这个菜单就只有第一个序列一的位置有效。 这时菜单同时选中一组的方式。 就退化为简单的选中一个的方式来。 在这里我们可以在序列一的位置指定我们想转换的通道。 比如通道二写到这个位置。 然后我们就可以触发转换啊。 a d c就会对这个通道二进行模数转换。 过一段时间后啊。 转换完成。 转换结果放在数据计算器里。 同时给e o c标志位置一。 整个转换过程就结束了。 我们判断这个e o c标志位。 如果转换完了。 那我们就可以在数据计算器里读取结果了。 如果我们想再启动一次转换。 那就需要再触发一次转换结束至e o c标志位读结果。 如果想换一个。 通道转换啊。 那在转换之前把第一个位置的通道二改成其他通道。 然后再启动转换。 这样就行了。 这就是单次转换非扫描的模式。 没有用到这个菜单列表哈。 也是比较简单的一种模式。 接下来我们看一下连续转换非扫描的模式。 首先它还是非扫描模式。 所以菜单列表就只用第一个。 然后他与上一种单次转换不同的是。 他在一次转化结束后不会停止。 而是立刻开始下一轮的转换。 然后一直持续下去。 这样就只需要最开始触发一次之后就可以一直转换了。 这个模式的好处就是开始转换之后。 不需要等待一段时间的。 因为他一直都在转换。 所以你就不需要手动开始转换了。 也不用判断是否结束的。 想要读d值的时候。 直接从数据计算器取就死了。 这就是连续转换非扫描的模式。 然后继续看单次转换扫描模式。 这个模式也是单次转换。 所以每触发一次转换结束后就会停下来。 下次转换就得再触发才能开始。 然后它是扫描模式。 这就会用到这个菜单列表的。 你可以在这个菜单里点菜。 比如第一个菜是通道二。 第二个菜是通道五等等等等。 这点每个位置是通道挤压。 可以任意指定并。 且也是可以重复的。 然后初始化结构体里还会有个参数。 就是通道数目。 因为在16个位置里可以不用完。 只用前几个。 那你就需要再给一个通道数目的参数。 告诉他我有几个通道。 比如这里指定通道数目为七。 那他就只看前七个位置。 然后每次触发之后。 他就依次对这前七个位置进行a d转换。 转换结果都放在数据进入器里。 这里为了防止数据被覆盖。 就需要用dma及时将数据挪走。 那七个通道转换完成之后产生eoc信号。 转换结束。 然后再触发下一次就又开始新一轮的转换。 这就是单次转。 换扫描模式的工作流程。 那最后再看一下连续转换扫描模式。 这个模式就应该可以猜出来了吧。 它就是在上一个模式的基础上变了一点。 就是一次转换完成后。 立刻开始下一次的转换。 和上面这里非扫描模式的单次和连续是一个套路。 还这就是连续转换扫描模式。 当然在扫描模式的情况下。 还可以有一种模式哈。 叫阶段模式。 它的作用是在扫描的过程中。 每隔几个转换就暂停一次。 需要再次出发才能继续。 这个模式我没有列出来啊。 要不然模式太多了。 大家了解一下就可以了。 暂时不需要。 掌握好这些就是s t m32 a d c的四种转化模式。 我们在写程序的时候会用到哈。 到时候再看看程序现象有什么不同。 那接下来继续。 我们再来看几个小知识点。 第一个是触发控制。 这个我们刚才讲过啊。 这个表就是规则组的触发源。 也就是前面adc框图在这里啊。 在这个表里有来自定时器的信号。 还有这个来自银角或定时器的信号。 这个具体是银角还是定时器啊。 需要用a f o重映射来确定。 最后是软件控制位。 也就是我们之前说的软件触发这些触发信号怎么选择。 可以通过设置右边这个寄存器来完成。 当然使用库函数的话。 直接给个参数就行了哈。 这就是触发控制。 再简单说一下。 接着下一个知识点是数据对齐。 我们这个a d c是12位的。 它的转换结果就是一个12位的数据。 但是这个数据寄存器是16位的。 所以就存在一个数据对齐的。 问题这里第一种是数据右对齐。 就是12位的数据向右靠高位多出来的几位就补零。 第二种是数据左对齐是12位的数据。 向左靠低位多出来的极为不灵。 在这里我们一般使用的都是第一种右对齐啊。 这样读取这个16位寄存器。 直接就是转换结果。 如果选择左对齐直接读的话。 得到的数据会比实际的大。 因为数据左对齐实际上就是把数据转移了四次。 二进制有个特点哈。 就是数据左移一次。 就等效于把这个数据乘二。 那这里左移来四指。 就相当于把结果乘16了。 所以直接读的话会。 比实际值大16倍。 那要这个左对齐有啥用呢。 这个用途就是如果你不想要这么高的分辨率。 你觉得0~4095数太大了。 我就做个简单的判断。 不需要这么高分辨率。 那你就可以选择左对齐。 然后再把这个数据的高八位取出来。 这样就舍弃掉了后面四位的进度。 这个12位的a d c就退化成了八位的a d c来。 这就是左对齐的作用。 不过我们一般用的话。 选右对齐就行了哈。 如果需要裁减一些分辨率。 大不了就先把12位都取出来再做处理。 这也是可以的哈。 就是多算了一步而已。 这。 就是数据左对齐和右对齐。 接着看一下下一个知识点。 转换时间。 这个大概讲一下哈。 不过转换时间这个参数我们一般不太敏感。 因为一般a d转换都很快啊。 如果不需要非常高速的转换频率。 那转换时间就可以忽略了。 我们来看一下哈。 之前我们说了a d转换是需要一小段时间的。 就像厨子做菜一样。 也是需要等一小会才能上菜的。 那a d转换的时候有哪些步骤需要花时间呢。 这里第一条a d转换的步骤有四步。 分别是采样保持量化编码。 其中采源宝石可以放在一起哈。 电话编码可以。 放在一起总共是这两大步。 量化编码。 好理解哈。 就是我们之前讲过的a d c逐次比较的过程。 这个是需要花一段时间的。 一般位数越多。 花的时间就越长。 那采样保持是干啥的呢。 我们看一下前面。 这个我们前面这里并没有设计哈。 为什么需要采样保持呢。 这是因为我们的a d转换就是后面的量化编码哈。 是需要一小段时间的。 如果在这一小段时间里。 输入的电压还在不断变化。 那就没法定位输入电压到底是在哪了是吧。 所以在量化编码之前。 我们需要设置一个采样开关。 先打开采样开关。 搜集一下外部的电压。 比如可以用一个小容量的电容存储一下这个电压。 存储好了之后。 断开采二开关。 再进行后面的ad转换。 这样在量化编码的期间。 电压始终保持不变。 这样才能精确地定位位。 置电源的位置。 这就是采样保持电路。 那采样保持的过程啊。 需要闭合采样开关。 过一段时间再断开。 这里就会产生一个采样时间。 那回到这里。 我们就得到了第二条s t m32 a d c的总转换时间为t convert。 等于采样时间加12.5个a d c周期。 采样时间是采样保持花费的时间。 这个可以在程序中进行配置哈。 采样时间越大。 越能避免一些毛刺信号的干扰。 不过转换时间也会相应延长。 来12.5个a d c周期是量化编码花费的时间。 因为是12位的adc。 所以需要花费12个周期。 这里。 多了半个周期啊。 可能是做一些其他东西花的时间。 a d c周期就是从r c c分屏过来的。 a d c c r k这个a d c clk最大是14兆赫兹。 所以下面有个例子啊。 这里就是最快的转换时间。 当a d c c lk等于14兆赫兹。 采样时间为1.5个a d c周期。 t convert等于1.5。 加12.5=14个a d c周期在14兆赫兹。 a d c c r k的情况下就等于1微秒。 这就是最快1微秒时间的来源。 如果你采样周期再长些。 它就达不到1微秒了。 另外你也可以把a d c clk的时钟设置超过14。 兆赫兹。 这样的话adc就是在超频的那转换时间可以比1微秒还短。 不过这样稳定性又没法保证的哈。 好有关转换时间的内容就讲这么多。 接下来看一下下个知识点校准。 看一下这几段话。 a d c有一个内置自教准模式。 校准可大幅减少因内部电容器组的变化而造成的精度误差。 这个码用于消除在随后的转换中。 每个电容器上产生的误差。 建议在美式上线后执行一次校准。 超过至少两个a d。 c时钟周期。 这个看上去挺复杂的是吧。 但是我们不需要理解这个校准过程是固定的。 我们只需要在abc初始化的最后加几条代码就行了。 至于怎么计算。 怎么叫总的哈。 我们不需要管。 所以这个了解一下就行好。 最后看一下硬件电路啊。 我们应该怎么设计呢。 这里我给出了三个电路图。 第一个是电位器产生一个可调的电压。 这里电位器的两个固定端哈。 一端接3.3伏。 另一端接建立。 这样中间的滑动端就可以输出一个0~3点3伏可调的电压输出来。 我们这里可。 以接a d c的输入通道。 比如pa 0口。 当滑动端往上滑时。 电压增大。 往下滑时电压减小。 另外注意一下这个电阻的阻值啊。 不要给太小。 因为这个电阻两端也是直接跨接在电源正负极的。 如果阻值太小。 那这个电阻就会比较费电哈。 再小就有可能发热冒烟了。 一般至少要接千欧级的电阻啊。 比如这里接的是10k的电路。 这是电位器产生可调电压的电路。 然后中间是传感器输出电压的电路。 一般来说像光明电阻。 热敏电阻。 红外接收管。 麦克风等等啊。 都可以等效为一个可变电阻。 那电阻阻值没。 法直接测量啊。 所以这里就可以通过和一个固定电阻串联分压。 来得到一个反应电阻值电压的电路。 那这里传感器阻值变小时下拉作用变强。 输出端电压就下降。 传感器阻值变大时下拉作用变弱。 输出端受上拉电阻的作用。 电压就会升高。 这个固定电阻一般可以选择和传感器阻值相近的电阻焊。 这样可以得到一个位于中间电压区域比较好的输出。 但这里传感器和固定电阻的位置也可以换过来。 这样的话输出电压的极性就翻过来了。 这就是这个分压方法来输出传感器阻值的电路来。 看一下我们之前传感器模块的介绍哈。 在这里传感器也是使用分压的方法来进行输出的。 我们这一节a d转换需要用到ao这个硬件。 所以这一块和这一块是没用的。 ao直接从这里输出。 我们在这里接线就行了。 好回到这里。 我们看一下最后这个电路。 这是一个简单的电压转换电路啊。 比如你想测个0~5伏的微信电压。 但是a d c只能接收0~3点3伏的电压。 那就可以搭建一个这样的简易转换电路。 在这里还是使用电阻进行分压。 上面组织十几k。 下面组织33k加一起是50k。 所以根据分压公式。 中间的电压就是。 v in除以50k乘以33k。 最后得到的电压范围就是0~3点3伏就可以进入a b c转换了。 这就是这个简单的电压转换电路。 如果你想采集5伏10伏这些电压的话。 可以使用这个电路哈。 但是如果你电压再高一些。 就不建议使用这个电路了。 那可能会比较危险哈。 高电压采集最好使用一些专用的采集芯片。 比如隔离放大器等等。 做好高低电压的隔离。 保证电路的安全啊。 好到这里。 有关a d c p p t的内容就讲完了。 那最后我再带大家简单的翻一下手册。 在手册的这里。 数字模拟。 转换就是a d c的介绍了。 前面这里是dc的介绍。 12位18个通道。 然后是一些主要特征哈。 这是a d c的框图。 这个再仔细看看。 这里是v dd和v r e f的使用介绍。 然后是a d c开关控制写a d2 尾可以给a d c上电。 然后是a d c始终a d c c lk来源于r c c a p p2。 始终的分屏通道。 选择有规则组和注入组。 可以进行一系列的转换。 下面有单次转换模式。 连续转换模式。 这个也都介绍过啊。 之后是时序图。 演示它adc的转换过程。 这个可以再看看模拟开门狗可以定一个这样的警戒区域哈。 然后是扫描模式。 就是一次性提交一个菜单。 一次转换。 这里还有一个阶段模式。 就是在扫描模式的情况下。 可以每隔几个暂停一下。 这个没有详细讲哈。 大家可以再看看这里。 接着下面是校准过程。 是固定的。 看看就行了。 然后是数据对齐。 有左对齐和右对齐。 可编程的通道。 采样时间可以设置采样。 保持开关的导通时间。 采样时间短。 速度快。 采样时间长。 避免保持干扰。 下面是外部触发转换可以由软件触发和硬件触发。 这里有很多表盘和框图里是对应的。 之后dma请求在扫描模式的情况下。 可以使用dma转移数据。 然后是双a d c模式。 是a d c一和a d c2 配合使用的情况。 这个就比较复杂了。 我们可以暂时不用了解。 有这么多哈。 然后是温度传感器。 这里有公式可以计算温度值。 adc中断有三个规则组。 uc柱主uc和模拟开门狗。 那最后就是计算器介绍了。 我们看一下第一个状态计算器。 其中eoc信号就可以在这里自标志位。 我们读取这里的标志位就可以知道硬件的状态了。 下面控制计算器可以用于对adc进行配置啊。 是否允许中断等等。 控制计算机二软件触发控制啊。 数据对齐等等。 下面采样时间计算器可以配置通道的采样时间。 然后模拟开门go的高低阈值规则组的序列。 猪猪的序列adc数据寄存器。 存放转换结果的计算器。 最后就是一个寄存器的总表哈。 这里有所有的计算器。 然后这里还有这些计算器的复位值。 也就是说上电复位后。 寄存器都会变成复位值。 这里负a值对应的就是各个外设的默认配置。 输出数据计算器默认输出低电平等等。 如果你想了解上天后的默认配置。 就可以参考这里的寄存器默认值。 再对照相应的寄存器描述。 这样就能知道默认配置了。 这个计算器一般上电都默认全为零哈。 不过也有的不是权威。 你大家可以找找看哈。 好那有关s t m32 a d c的介绍到这里就结束了。 我们下一小节来开始写代码。
22. 好本小姐。 我们先看一下经验图。 打开七杠一ad单通道的图片。 看一下这个接线图还是比较简单的。 在这里我们接了一个电位器。 这个电位器有三个引脚。 分别插在这三排孔里。 电容器的内部结构是这样的哈。 左边和右边的两个引脚。 接的是电阻的两个固定端。 中间这个引脚接的是滑动抽头。 电位器外边这里有个十字形状的槽。 可以领呀。 往左拧车头就往左靠。 往右拧车头就往右靠。 我们把左边的固定端接在负极。 右边的固定端接。 在正极中间就可以输出从负极到正极。 可调到电压了。 然后右边这里我们把可调的电压输出。 接在pa领口。 在这里根据引脚定义表。 pa 0到pb 7。 这十个引脚是a d c的十个通道啊。 所以这十个硬件你可以任意选接。 带哪个都行。 但是其他的这些硬件不是a d c的通道。 就不能接模拟电压了。 首先拿出这个蓝色的小电位器。 把这三个硬件的一次啊放在上面。 接着用跳线把最左侧眼角引到负极。 最右侧引脚引得正极。 中间是输出啊。 用一根飞线引到pa领口。 这样电路就完成了。 那接下来我们打开工程文件夹。 复制一下id的工程。 改个名叫七杠一ad单通道。 打开工程。 这些先删掉啊。 编译一下。 老规矩。 我们给a d转换。 先建一个模块。 这个步骤已经演示过很多次了哈。 好现在我们就已经在hardware文件夹下。 建好了d.c和d.h的文件。 然后在d.c文件里写个初始化函数。 word d d。 在这里我们对adc进行初始化。 那初始化的步骤呢。 我们还是看一下。 这里我总结的这个结构框图啊。 我们把这个结构打通。 在原理上能够让这个外设运转起来。 那该怎么配置。 自己心里就应该有数了哈。 具体的步骤就是第一步开启rtc时钟。 另外这里adc clk的分频器也需要配置一下。 然后从左到右。 第二步配置gpo。 把需要用的gpu配置成模拟输入的模式。 第三步配置这里的多路开关。 把左边的通道接入到右边的规则组列表里。 这个过程就是我们之前说的点菜啊。 把各个通道的。 菜列在菜单里。 接着第四步就是配置a adc转换器了。 在库函数里是用结构体来配置的。 可以配置这一大块电路的参数。 扫描还是非扫描。 有几个通道触发言是什么。 数据对齐是左对齐还是右对齐。 这一大批参数啊。 用一个结构体配置就可以了。 然后上面这些如果你需要模拟开门口。 那会有几个函数。 用来配置阈值和监测通道的。 如果你想开启中断。 那就在中段输出控制里。 用it config函数开启对应的中断输出。 然后再在nvc里配置一下优先级。 这样就能触发中断。 了。 不过这一块模拟看门狗和中断。 我们本节暂时不用哈。 如果你需要的话。 可以自己配置试一下。 那接下来就是开关控制。 调用一下a d c command的函数。 开启a d c。 这样a d c就配置完成了。 就能正常工作了。 当然在开启a d c之后。 根据手册里的建议啊。 我们还可以对adc进行一下校准。 这样可以减小误差。 那在a d c工作的时候。 如果想要软件触发转换。 那会有函数可以触发哈。 如果想读取转换结果。 那也会有函数可以读取结果。 这个等会儿介绍库函数的时候。 就可以看到了。 好这些就是我们。 程序的大概思路了。 然后我们回到程序这里。 来看一下a d c相关的库函数啊。 首先我们看一下a d c c lk的配置函数。 这个是在r c c里面的啊。 我们找一下。 打开这个r c c.h文件。 拖到最后。 在这里啊。 可以看到这个r c c abc clk configure。 这个函数是用来配置adc clk分频器的。 它可以对a b2 的72兆赫兹。 始终选择2468分频输入的a d c cl k。 这就是这个函数的作用。 是在r c c库函数里面的哈。 别忘了配置了。 然后我们找一下a d c的款式。 打开a d c点去文件。 拖到最后看一下。 首先前面几个delete恢复确认配置。 elite初始化。 使struct itt结构体初始化。 这些都是老朋友啊。 不用多讲。 然后a d c cmd这个是用于给adc上电的。 也就是ppt这里的开关控制。 然后dma。 cm d这个是用于开启dma输出信号的。 如果使用dma转运数据。 那就得调用这个函数。 这个我们下节讲dma的时候再用。 接着是it configure。 中断输出控制。 也就是p p t的这里啊。 用于控制某个中段能不能通过nvc。 接下来这里有四个函数。 分别是复位校准获取。 复位校准状态。 开始校准获取。 开始第二种状态。 这就是用于控制校准的函数。 我们在a d c初始化完成之后。 依次调用就行了。 然后继续adc软件开始转换控制。 这个就是用于软件触发的函数。 调用一下就能软件触发转换了。 也就是这里的触发控制。 我们这个代码目前使用软件触发。 接着下面是adc获取软件开始转换状态。 从名字上来看。 这个函数好像是。 判断转换是不是正在进行的。 那我们是不是可以调用这个函数。 来判断转换是否已经结束呢。 答案是不行的。 这个可以分析一下源码。 我们跳到源码。 可以看出。 这个函数就是用来获取cr 2的sw 10 start。 这一位。 然后再对照手册的寄存器描述找一下。 可以看到啊。 这一位的作用是开始转换。 规则通道由软件设置改为已启动转换。 转换开始后。 硬件马上清除此为。 所以这里这个函数就是给sw start位置一。 以开始转换的。 这个函数是返回sw start的状态。 由于sw start位在转换开始后立刻就清零了。 所以这个函数的返回值跟转换是否结束。 毫无关系啊。 那如何才能知道转换是否结束呢。 我们需要用到下面这个看书。 get flag status。 获取标志位状态。 然后参数给e o c的标志位。 判断e o c标志位是不是至一了。 如果转换结束。 u c标注位置一。 然后调用这个函。 数判断标志位。 这样才是正确的判断转换是否结束的方法。 所以简单来说这个函数其实没啥用啊。 我们一般不用不要被他误导了。 然后下面这两个函数。 是用来配置阶段模式的。 第一个函数是每隔几格通道间断一次。 第二个函数是是不是启用间断模式。 需要间断模式的话。 可以了解一下。 接着下面这个函数a d c规则组通道配置。 这个函数比较重要哈。 它的作用就是这里给序列的每个位置。 填写指定的通道。 就是填写点菜菜单的过程。 第一个参数是a d c x。 第二个a d c channel就是理想指。 定的通道。 第三个rank就是序列几的位置。 就是指定通道的采样时间。 这是这个函数。 接着下面abc外部触发转换控制。 就是是否允许外部触发转换。 然后是adc获取转换值。 这个函数也比较重要。 就是获取ad转换的数据寄存器。 读取转换结果就要使用这个函数之后。 a d c获取双模式转换值。 这个是双a d c模式。 读取转换结果的函数啊。 我们暂时不用好到这里。 以上这些函数就是对adc的一些。 基本功能和规则组的配置。 然后接下来这里有一大批函数。 这些函数里面都带了一个injected。 就是注物主的意思。 所以这一大批函数都是对a d c。 注入组进行配置的。 那注入。 组我们暂时不多讲啊。 大家感兴趣的话可以自己看看。 然后继续下面的这三个函数。 就是对模拟看门狗进行配置的。 第一个是是否启动模拟开门狗。 第二个是配置高低阈值。 第三个是配置开门的通道之后。 adc温度传感器内部参考电压控制。 这个是用来开启内部的两个通道的。 如果你要用这两个通道。 那得调用一下这个函数开启一下。 要不然是读不到正确的结果的。 这个注意一下。 那最后四个获取标志位状态。 清除标志位。 获取中段状态。 清除中断挂几位。 这些函数也是常用函数了哈。 不用多。 说好函数看完我们来开始写代码。 回到d.c文件在这里开始数字化。 第一步。 那当然是开启时钟呢。 2c c a p b2。 外设时钟控制cc a b b2。 外设abc 1。 开启a d c一的时钟。 adc都是a b2 上的设备啊。 所以这里用a p p2 开启时钟的函数。 然后我们还要使用pa领口。 所以复制一下。 这里改成gpa。 再开启一下gpa的时钟。 这样时钟就开启好了。 接着不要忘了哈。 还有一个a abc c l k需要配置。 我们到rc c点距离来。 复制一下这个a abc clk configure。 放到这里看一下参数啊。 这里一目了然。 有四个参数。 分别是2468。 分屏配置好之后。 adc的clk等于p c lk 2÷2468。 这个pcl k2 就是a b2 始终的意思。 那我们选择这个六分屏放到这里。 分屏之后。 adc clk等于72兆赫兹。 除以6=12兆赫兹。 这样adc clk就配置好了。 接着我们进行下一步配置gpo。 我们打开这个d.c复制一下初始化代码。 放到这里看一下。 首先gpl模式这个要改一下。 我们转到定义这里。 要选择ae模拟输入这个模式。 这个我们之前讲gp o的时候也说过哈。 在ae模式下。 gpl口是无效的。 断开gpl房子里。 gpl口的输入输出对我模拟电压造成干扰。 所以ae模式就是a d c的专属模式。 那这里复制gpl目的a e放到这里。 然后gbp改成p0。 下面初始化gpa。 这样pa 0口就被初始化成了。 模拟输入的硬件了。 接下来我们进行下一步。 选择规则组的输入通道。 这里看一下。 我们需要用到这个a abc regular channel config函数。 复制一下。 放到这里。 参数第一个a abc x给adc 1。 剩下的转到定义看一下。 第二个参数是指定通道。 这个参数可以是下面的一个字啊。 然后下面就是通道零到通道17。 我们选择通道零啊。 放到这里。 接着继续。 第三个参数。 rank解释是规则组序列器里的次序。 这个参数必须在一到16之间。 对应的就是规则组这里的16个序列。 那我们目前只有pa 01个通道。 使用的是非扫描的模式。 所以这里指定的通道就放在第一个序列。 一的位置之后继续啊。 还有一个参数指定通道的采样时间。 下面就是采样时间的参数啊。 这个就根据你的需求来了。 需要更快的转换。 就选择小的参数。 需要更稳定的转换。 就选择大的参数。 如果对速度和稳定性都没啥要求。 那随便选就可以了哈。 这里我们这个项目没啥要求啊。 所以就随便选个五五吧。 这时的采样时间就是55点。 五个adc clk的周期。 那之后把参数放到这里。 这样输入通道就选择好了。 现在我们的配置是。 在规则组菜单列表的第一个位置。 写入通道零。 这个通道在p p t的这个图里表示的话。 就是在这个序列一的位置写入通道零。 如果你还想在序列二的位置。 写入其他的通道。 那就复制一下这个代码。 把这个序列数改成二。 然后指定你想要的通道。 比如通道三。 通道八。 通道十等等。 如果还想继续填充菜单。 那就再复制修改序列和通道。 这样就可以了。 另外每个通道也可以设置。 不同的采样时间哈。 这个在最后一个参数修改下就是了。 那这就是填充菜单列表的方法。 我们目前只需要一个通道。 零后面的先删掉啊。 那接下来我们进行下一步。 用结构体初始化abc。 这里我们需要用到a d c d的函数。 第一个参数给abc 1。 第二个参数是结构体。 那我们转到定义。 复制一下这个结构体类型名。 在这里粘贴起个名字啊。 adc 1 it structure。 把结构体成员都引出来。 这里把结构体稍微换个次序啊。 这样好看一些。 换个次序对功能没有任何影响啊。 最后把结构体地址放在初始化函数里。 这样就好了。 然后依次看一下参数。 第一个a d c mod是adc的工作模式。 我们看一下介绍。 这个参数是配置adc。 搜索一下参数取值范围啊。 有这么多模式可以选择。 就是a d c一和d32 各转换各的。 剩下的就全是双a d c的模式了。 这些比较复杂哈。 我们先不用。 接着是数据对齐。 看一下。 这里介绍是指定a d c数据。 是左对齐还是右对齐。 搜索一下参数列表。 这里第一个是右对齐。 第二个是左对齐。 这两个对齐方式上下角我们也讲过啊。 所以这里就选择右对齐复制放在这里。 这是数据对齐。 接着下一个外部触发转换选择。 就是触发控制的触发源啊。 看一下介绍。 这里说的是定义用于启动规则组转换的。 外部触发源参数取值列表。 搜索一下。 在这里有这么多参数啊。 它们对应的就是ppt这里的这个结构框图。 到这里哈。 外部触发源选择这里。 这些参数都是一对应的。 大家可以看一下。 然后这里有个外部触发浪。 就是不使用外部触发。 也就是使用内部软件触发的意思。 那我们本节代码使用软件触发。 所以就选择这个参数复制。 然后放在这里。 这就是触发源。 使用软件触发。 接着下面三个参数啊。 第一个连续转换模式。 这个可以选择是连续转换还是单次转换。 第二个扫描转换模式。 这个可以选择是扫描模式还是非常描模式。 第三个通道。 数目这个是指定在扫描模式下。 总共会用到几个通道。 那对应的就是我们ppt的这四种模式了。 单次转换非常描。 连续转换非常描。 单次转换扫描连续转换。 扫描通道数目的参数就是这里啊。 扫描模式总共需要扫描几个通道。 那回到代码这三个参数怎么配置。 应该就有思路了。 我们看一下参数介绍。 第一个跳转一下。 这里写的是指定转换。 是连续模式还是单次模式。 这个参数可以是你label或disable。 enable就是连续模式。 disable就是单次模式。 然后另一个参数在这里介绍是指定转换式。 扫描模式。 多通道还是非扫描模式。 单通道这个参数也是enable和disable。 enable就是扫描模式。 disable就是非扫描模式。 然后最后一个参。 数在这里啊。 介绍是指定规则组转换列表里通道的数目。 这个参数必须在一到16之间。 这些应该不难理解吧。 那我们回到这里。 我们这个代码目前使用的是单次转换。 非扫描的模式。 所以这两个参数都给disable。 这样转换模式就配置好了。 然后通道数目目前是一个通道。 所以给一。 其实这个参数仅在扫描模式下才需要用啊。 如果是非扫描的模式。 那整个列表就只有第一个序列有效。 所以在非扫描的模式下。 这个参数其实是没有用的。 你无论写多少数目。 最终都只有序列一的位置有效。 好到这里。 我们a d c的整体结构就配置完成了之后。 中断和模拟开门狗。 你如果需要的话。 可以在这里继续配置。 那我们就暂时不用了哈。 所以这里就可以开启a d c的电源了。 看一下函数。 复制这个adc cmd函数放到这里。 参数第一个a d c e。 第二个e label。 开启a d c的电源。 这样adc就准备就绪了。 那在开启电源之后。 根据手册的建议。 我们还需要对adc进行校准。 对于校准。 我们之前已经介绍过校准的函数了对吧。 来找一下。 这里有四个函数。 对应校准的四个步骤。 第一步调用第一个函数-1脚准。 第二步调用第二个函数。 等待复位校准完成。 第三步调用第三个函数开始校准。 第四步调用第四个函数。 等待校准完成。 这样就行了。 那我们复制第一个函数放在这里。 参数给a d c1。 这样就可以复位校准了。 接下来继续。 复制第二个函数放到这里。 参数abc 1。 这个函数是返回复a校准的状态。 所以如果要等待复位完成的话。 还需要加一个while循环。 如果没校准完成。 就在这个while空循环里一直等待。 那获取的标志位和是否调用完成。 是怎样的对应关系呢。 这个得参考一下寄存器说明哈。 我们跳转到函数定义返回值。 说明是adc复位校准寄存器的状态。 set或reset在下面可以看出来。 它获取的就是cr 2计算器里的r s t。 c l标志为。 那之后就需要参考一下手册的寄存器。 描述啊。 在这个cr计算器里找一下。 这里就是这个标志位的说明啊。 他说该位由软件设置。 并由硬件清除。 在校准寄存器被处理化后。 该位将被清除。 所以该位的用法就是你软件自该位为一。 那硬件就会开始复位校准。 当复位校准完成后。 该位就会有硬件自动清零。 那回到代码的这个。 我们这一行代码开始复位校准看一下啊。 就是把这一位置一。 然后获取复a校准状态。 就是读取这一位。 所以在读取这一位的时候。 如果它是一。 那就需要一直控制环等待。 如果它变为零了。 那就说明复位校准完成。 可以跳出等待。 所以这里while的条件就是获取标志位。 是不是等于等于set。 如果等于set。 while条件为真。 就会一直空循环。 一旦标志位被硬件清零了。 这个空循环就会自动跳出来。 这样就实现了等待复位校准完成的效果。 当然这个等于等于set也是可以省略的哈。 因为返回值set直接作为条件和。 是不是等于等于set作为条件。 效果是一样的。 好接下来继续啊。 我们看一下函数。 复制第三个开始校准放到这里。 参数给adc 1。 这样就能启动。 叫做呢。 之后内部电路就会自动进行校准过程。 不需要我们管哈。 最后我们还需要等。 待校准完成。 看一下函数。 复制第四个函数获取校准状态。 然后放到这里。 参数还是abc 1。 同样我们也用while把它套起来。 循环条件是校准标志位是不是等于等于s。 这样就可以等待校准是否完成了。 到这里a d c的初始化就已经完成了。 我们配置好了时钟gpl口。 选择好了。 输入通道。 初始化好了。 a d c。 我们目前的模式是单次转换非扫描的模式。 最后给a d c上电进行校准。 这样a d c就处于准备就绪的状态了。 那我们想启动转换获取结果。 就可以在下面再写一个函数。 函数的返回值是uint 1。 六杠t5 -26位整形名字。 起一个叫a d get value参数暂时不需要。 然后在这个函数里面。 我们直接的流程就是ppt的。 这里按照这个流程来进行就行了。 首先软件触发转换。 然后等待转换完成。 也就是等待eoc标志位置一。 最后读取a d c数据计算器就完事了。 回到代码看一下函数触发转换。 我们用这个软件触发转换的函数。 复制放到这里。 第一个参数给adc 1。 第二个新的状态给补。 这样就可以触发。 a d c就已经开始进行转换了。 那转换需要一段时间。 所以我们还需要等待一下。 看一下函数。 啊。 我们需要用到这个获取标志位状态的函数。 复制放到这里。 第一个参数给adc 1。 第二个参数看一下。 这里有五个参数。 第一个awd模拟开门口。 标注为第二个uc规则组转换完成。 标注为第三个g o c柱主转换完成表。 作为第四个g start作组开始转换。 标志为第五个start规则组开始转换标志为。 那我们需要判断规则组是不是转换完成了。 所以就使用第二个规则组转换完成。 标注为这个参数。 然后放在这里。 第二个参数的位置。 同样我们也需要套一个while空循环。 来实现一个等待的过程。 那返回的标。 志位set reset和转换是否完成的。 对应关系是怎样的呢。 我们还是参考一下手册的计算器描述。 在这个状态计算器里有这个eoc。 转换结束标志。 为我们获取的就是这个uc标志位啊。 介绍是该位由硬件在规则或注入通道组。 转换结束时设置哦。 这个eoc是规则组或注入组。 完成时都会质疑。 之前说的这个uc只是规则组的完成标志位。 是有点问题的哈。 这里排除一个错误。 注意一下。 所以说这个寄存器描述也是很重要的哈。 有很多细节的问题。 还是需要看寄存器描述才能清除。 那我们接着看这一位由。 软件清除或由读取adc dr时清除。 a d c d r是数据计算器啊。 一般e o c标志位置一。 我们就会来读取数据。 所以它就多设计了一个功能。 就是这一位可以在读取数据计算器之后。 自动清除。 就不需要你再手动清除了。 可以省一条代码。 这就是这个表述为当它为零时。 表示转换未完成。 为一表示转换完成。 所以在这里当eoc标志位等于等于reset时。 转化未完成。 while条件为真执行控制环。 转换完成后。 uc由硬件自动制一。 那while循环就自动跳出来。 这样就是等待转换完成的代码。 那具体会等待多长时间。 呢我们刚才配置的时候。 指定了这个通道的采样周期是55.5。 转换周期是固定的。 12.5。 加在一起就是68个周期。 前面我们配置的a d c clk。 是72兆赫兹的六分屏。 就是12兆赫兹。 12兆赫兹。 进行68个周期转换才能完成。 最终的时间可以算一下。 就是12兆分之一。 再乘68。 结果大概是5.6微秒哈。 这个我们上一小节讲转换时间的时候。 也讲过。 如果想算的话。 就这样算。 所以这个while循环。 大概会等待5.6微秒。 这就是等待的时间。 那等待完成之后。 我们就可以取结果了。 看一下函数啊。 取结果就用这个a abc获取转换值。 复制放到这里。 参数给adc 1。 它的返回值就是ad转换的结果。 这里我们可以直接把返回值return过去。 获取转换值的函数。 也可以看一下内部代码。 它就是直接读取abc的dr数据净水器。 那这里因为读取dr计算器。 会自动清除eoc标志位。 所以这之后。 我们就不需要再手动清除标志位的。 这样启动等待读取的过程就写好了。 它和我们ppt的这个流程是对应的哈。 调用一次这个函数就相当于执行那一次。 这个流程大家可以对照着来理解哈。 好那这个ad单通道的代码就写好了。 我们来测试一下。 首先把这两个函数的第一行放在头文件里。 声明一下。 编译看着。 没有问题。 然后回到总数。 先include一下ad.h的头文件。 然后内涵处理。 先调用a g e d初始化a d c之后。 在主循环里直接调用ad。 get value这个函数里启动。 等待读取。 一气呵成啊。 返回值直接就是转换结果。 那我们在上面定义一个变量。 由int 16杠t1 ad value。 然后把返回值放在ad value里存着。 最后调用o l d显示一下。 先在上面啊。 o o d修string。 一行一列显示ad value。 然后在下面oled修number。 一行九列显示ad value长度为四啊。 这样就行了。 编译看一下。 没问题啊。 可以看到oid上已经有数据了。 领一下电位器。 看一下。 往左拧。 数据减小最小值是零。 我用你数据增大最大是4095。 可以看出啊。 目前的代码功能是没问题的。 在这里a d值的末尾会有一些抖动啊。 这是正常的波动。 如果你想对这个直径判断再执行一些操作。 比如光线的a d值小于某一阈值就开灯。 大于某一阈值就关了。 那可能会存在这样的情况哈。 比如光线逐渐变暗。 地值逐渐变小。 但是由于波动。 ad值会在判断阈值附近来回跳边。 这会导致输出产生抖动。 来回开灯关灯。 开灯关灯是吧。 那如何避免这种情况呢。 这个可以使用尺子比较的方法来完成。 在这两个阈值低于下阈值时开等。 高于上预值时采光等。 这就可以避免输出抖动的问题了。 这个。 跟我们gpl赖姐讲的。 另外如果你觉得数据跳变太厉害。 还可以采用滤波的方法。 让a d值平滑一些。 比如均值滤波啊。 就是读取十个或20个值。 取平均值作为滤波的ad值。 或者还可以裁剪分辨率。 把数据的尾数去掉啊。 这样也可以减少数据波动。 这都是可行的方法啊。 大家实际遇到这方面问题的话。 可以考虑一下好。 我们接着来看这个代码。 如果想显示一下实际的电压值怎么办呢。 这只需要对这个数据进行一个线性变换。 就行了。 那我们再在上面定义一个变量表。 示电压float wattage。 然后修string复制一下。 现在二行一列显示个vtage。 冒号0.005。 最下面y t g等于ad value。 除以4095x3.3。 这样就能把0~4095的范围。 变换到0~3点三了。 另外这里因为a d value是整数啊。 在除4095之后会舍弃掉小数部分。 这样会导致计算错误。 所以我们先把ad value类型强转为float。 这样再除才不会出问题。 还有啊。 这里实际上a d值等于409 60。 才对应3.3伏啊。 会有一个数的偏差。 所以ad值最大的4095。 实际上对应应该是3.3伏。 小一丢丢。 没有办法达到满量。 程3.3伏。 这个是受限于a d c的结构啊。 具体就不再细说了。 总之就是你认为4095对应3.3伏。 可以认为4096对应3.3伏。 也可以只有一点点偏差哈。 也看不出来差别。 那回到这里。 电压的数据有了。 接下来用o i d显示一下吧。 我提供的o i d驱动。 还没有显示浮点数的函数。 这个之后讲yd的时候再给大家安排上。 还有显示汉字啊。 显示图像的功能也都会安排的。 目前这里我们如果想显示浮点数。 可以用显示整数的函数来操作啊。 o i d修lab。 在二行九列显示wattage长度为一。 vd的范围是0~3点三。 如果直接修number的话。 小数就会舍弃掉。 这就是显示整数的部分。 然后再来一个oled show lab。 在二行11列显示y t g乘以100。 先把数扩大一百倍。 现在就是123。 然后再对100取余。 123。 对100取余就是23。 显示在11列。 另外由于浮点数是不能区域的。 所以vt age乘100之后要括起来。 然后进行强制类型转换。 变成整数。 比如uint 16杠t再对100取余。 这样才行。 然后显示的长度为二。 这样就。 可以显示浮点数了。 那最后加一个delay 100毫秒哈。 让它刷新的慢一些。 然后再试一下编译。 下载看一下。 这样电压值就已经出来了。 灵动电位器ad值在变化。 电压值也对应变化。 这就是第一个程序的现象。 如果你需要把ad值换算成电压的话。 就可以这样做。 乘出一个系数变换一下就行。 一般的话如果就只是进行阈值判断。 数据记录的话。 也可以不进行变化啊。 直接使用原始的ad数据。 这样也是可以的。 好第一个程序到这里就差不多了。 看一下ppt啊。 这里我们使用的是第一种转换方式。 单次转换非扫描。 那在这里我们还可以使用第二种转换方式。 连续转换非常妙。 这个模式的好处就是不需要不断的触发。 也不需要等待转换完成的。 这种模式也可以在这个工程上给大。 家演示一下哈。 只要稍作修改就行。 我们回到d点。 c文件要切换为连续转换。 那这个连续转换模式。 这个参数甲改成enable。 现在就是连续转换的模式。 然后看一下流程图。 连续转换仅需要在最开始触发一次就行了。 所以这里软件触发转换的函数。 就可以挪到初始化的。 最后在初始化完成之后触发一次就行了。 这时内部的a d c就会一次接着一次。 转换结构放在数据运算器里。 此时数据计算器会不断地刷新。 最新的转换结果。 所以在ad get value这里就不。 需要判断标志位了。 直接return数据进器的值就行了。 这样程序就是单通道连续转换。 非扫描的模式。 我们看一下现象啊。 下载。 程序现象和刚才是一样的。 也能实现单通道的ad转换。 这就是连续状态非常美妙的模式。 那回到代码这里就先改回来哈。 需要哪种模式。 你可以根据实际需求来选。 那第一个代码到这里就结束了。 接下来我们来看一下下一个代码。 先看一下接线图啊。 打开七杠二ad多通道的图片。 看一下。 在这里我们使用了四个d通道。 第一个通道还是电位器啊。 接在pa领口之后。 上面又接了三个传感器模块。 分别是光敏传感器。 正面传感器反射是红外传感器。 他们的vcc和g n d。 然后这个ao就是模拟量的输出硬件。 三个模块的ao分别接在pa 1。 pa 2和p a3 口。 加上电位器的p a0。 总共是四个输入通道啊。 同样在gpl口。 也是可以在pa 0到pb一之间任意选择的。 我这里就选择前四个了。 接一下电路啊。 这里拿出光敏模块。 接上三根杜邦线。 输出要接在a o啊。 不要接成d o了。 d o是输出输出。 然后这边vcc和gd接电源。 ao输出接待pa一口。 这就行了。 接下来热门模块也是同样的解法。 vcc接d接电源。 a o输出接在pa 2口。 最后反射红外传感器vcc建立接电源。 ao输出接在pa 3口。 这样接线就完成了。 然后回到工程文件夹。 复制一下三个代码。 改个名字叫七杠二ad多通道。 打开工程。 在这个过程里。 我们修改一下这个代码。 来实现ad多通道采集的功能。 那看一下ppt如何实现多通道采集。 多通道。 我们首先想到的应该是。 后面这两种扫描模式是吧。 利用这个列表把四个通道都填进去。 然后触发转换。 这样就能实现多通道了。 这样确实是一种不错的方法。 但是还是那个数据覆盖的问题。 如果想要用扫描模式实现沟通的。 最好要配合dma来实现。 我们下节讲完dma之后。 再来试一下扫描模式。 那你可能会问啊。 我们一个通道转换完成之后。 手动把数据转运出来不就行了。 为啥非要用。 dma来转运呢。 这个方案看似简单。 但是实际操作起来会有一些问题。 第一个问题就是在扫描模式下。 你启动列表之后。 它里面每一个单独的通道转换完成之后。 不会产生任何的标志位。 也不会触发中断哈。 你不知道某一个通道是不是转换完了。 它只有在整个列表都转换完成之后。 才会产生一次eoc标志位。 才能触发中断。 而这时前面的数据就已经覆盖丢失了。 第二个问题就是a d转换是非常快的。 刚才我们也计算过。 转换一个通道大概只有几微秒。 也就是说。 如果你不能在几微秒的时间内把。 数据转运走。 那数据就会丢失。 这对我们程序手动转移数据。 要求就比较高了。 所以在扫描模式下。 手动转移数据是比较困难的哈。 不过比较困难也不是说手动转运不可行啊。 我们可以使用阶段模式。 在扫描的时候每转换一个通道就暂停一次。 等我们手动把数据转移走之后。 再继续出发。 继续下一次转换。 这样可以实现手动转移数据的功能哈。 但是由于单个通道转换完成之后。 没有标注位。 所以启动转换完成之后。 只能通过delay延时的方式。 延时足够长的时间。 才能保证转换完成。 这种方式既不。 能让我们省心啊。 也不能提高效率。 所以我们暂时不推荐使用。 那这些方法都不行。 我们本节是不是就不能实现多通道了呢。 答案是能实现。 而且非常简单。 怎么实现呢。 我们可以使用上面的这个单次转换。 非扫描的模式来实现多通道。 只需要在每次触发转换之前。 手动更改一下列表。 第一个位置的通道就行了。 比如第一次转换先写入通道零之后触发。 等待组织。 第二次转换。 再把通道零改成通道一之后触发。 等待周知。 第三次转换再先改成通道二等等等等。 这样在转换前先指定一下通道再启。 动转换。 就可以轻松地实现多通道转换的功能呢。 那回到代码这里。 也只需做一些简单的修改就行了哈。 我们可以把这个填充通道的代码剪切。 然后在触发转换之前粘贴放在这里。 然后我们想指定的通道。 可以提取成ad get value的参数。 这里可以先转到定义啊。 把它的这个参数复制一下。 然后回来原封不动的向上一级传递。 这里通道零改成参数指定的通道。 这样就行了。 这样我们再调用a d get value进行转换时。 只需要指定一个转换的通道。 返回值就是我们指定通道的结果了。 我们现在要指定的。 通道是通道0123。 所以上面这里的gpl初始化也不要忘了。 或者gp l p一复制一下。 再和上p2 p3。 把这几个通道的引脚初始化一下。 然后剩下的就不需要更改了。 最后头文件这个函数的声明呀也更新一下。 这样就完成了。 好接下来我们试一下。 看看回到命点c先把这些先删掉啊。 编一下看看。 没问题啊。 先定义几个变量。 uint 16杠七。 ad 0 d1 d2 d3。 然后显示字符串进行一列。 显示ad 0冒号。 复制一下。 二列显示d1。 三列。 第24d a d3 之后。 在主循环例ad 0等于ad。 get value。 给个参数指定通道参数是什么呢。 跳转定义看一下。 然后再跳转这个函数。 这些就是可选的参数。 我们选择通道零放在这里。 这样返回值就是通道零的转换数据的之后。 同样的方法复制粘贴几个ad一等于通道一。 ad 2等于通道2a d3 等于通道三。 这样就行了。 最后o i d显示一下o i d。 修number。 一行五列。 显示a d0 长度为四。 复制一下。 二行五列显示a第一。 三行五列显示a第二四行五列显示d3。 最后da 100毫秒。 这样就完事儿了。 现在是依次启动四次转换。 并且在转换之前指定了转换的通道。 每次转换完成之后。 把结果分别存在四个数据里。 最后显示一下。 这就是使用单次转换非扫描的模式。 实现a d多通道的方法。 也是一个比较简单直观的方法。 试一下看看。 下载看一下现象。 首先是电位器。 看ad里的数据啊。 没问题。 然后是光明看ad 1。 也没问题啊。 热敏看第二。 任敏这个值变化的比较小哈。 也没问题的。 最后对射传感器看ad 3。 也是没问题的啊。 这就是第二个程序的现象。 好到这里。 有关a d转换的代码部分就完成了。 a d转换的扫描模式和更高级玩法。 那本节的内容到这里就结束了。 我们下节再见。
23. hello。 大家好。 欢迎继续观看s t m32 入门教程。 直接存储器存取。 dma是一个数据转运小助手。 它主要是用来协助cpu完成数据转运的工作的。 那我们先看一下本节程序的现象。 本节课共有两个程序。 第一个是八杠一dma数据转运。 第二个是八杠2d m a加a d多通道。 先看一下第一个。 在这个程序里。 我们将使用dma进行存储器到存储器的数据转运。 也就是把一个数组里面的数据复制到另一个数组里。 先看一下最终的代码啊。 这里我定义了一个数组。 da里面存的是123。 四作为待转运的元数据。 然后下面再定义一个数组。 作为转运数据的目的地。 之后我们将会写一个模块叫买dma。 然后买dma初始化。 把原数组和目的数组的地址传进去。 再传入转移数据的长度。 四接着执行主循环的流程啊。 第一步自增变化一下原数组data ta的测试数据啊。 第二步显示一下data ta和db。 然后延时硬表方便观看啊。 第三步调用一下买dma串字符函数。 使用dma进行数据转运。 调用一下这个函数啊。 和下面这里直接for循环使用cpu。 一个个手动的转移数据效果是一样。 的啊。 接着最后再显示一下da和db。 看一下数据是不是从data ta转运到来db啊。 我们下载看一下。 这里第一行是da。 右边是da数组的地址。 第二行就是data ta的原数据来。 每隔两秒变一次。 第三行是db。 右边是db数组的地址。 最后一行是db的目的地数据可以看到啊。 data a每变一次。 抵了一秒后。 数据就转运到了db。 这个转运过程就是由dma来完成的。 我这里屏幕比较小哈。 所以就只定义了四个数据。 演示一下现象。 也可以定义100个1000个等等数据。 然后使用dma来进行转运都是可以的。 那这就是第一个程序的现象。 接着继续来看第二个程序。 dma加ad多通道。 这个程序就是我们上一节预告过的哈。 使用a d c的扫描模式来实现多通道采集。 然后使用dma来进行数据转运。 最终ad转换的数据就会像这样直接自动的跑到我们定义的数组里面来。 之后我们就只需要用o l d显示一下就行了。 看上去还是非常方便的是吧。 那我们下载看一下现象。 这个硬件电路和程序现象啊。 和上一节的ad多通道是一模一样的。 也是测量pa 0到pa 3这四个通道的模拟量。 这里再简单看一下。 领一下电位器。 看ad 0的数据往左拧变小。 往右拧变大。 接着光敏传感器看a d1。 没问题啊。 然后热敏传感器看ad 2。 没问题。 最后反射传感器看ad 3。 有没有问题啊。 好这就是第二个程序的现象和上一节ad多通道的现象是一样的啊。 就只是在s t m32 端使用了扫描模式。 并且加了dma转移数据。 那线下看完我们来看一下ppt啊。 先看一下dma的简介。 第一条dma它的英文全称是direct memory access。 直译就是直接存储器存取或者叫直接存储器访问。 从这个dma名字的意思来看啊。 dma这个外设是可以直接访问s t m32 内部的存储器的。 ram程序。 存储器。 flash和寄存器等等。 dma都有权限访问他们。 所以dma才能完成数据转运的工作。 那接着看dma可。 以提供外设和存储器或者存储器和存储器之间的高速数据传输。 无需cpu干预。 节省了cpu的资源。 这里外设指的就是外设寄存器啊。 一般是外设的数据计算器。 dr data register。 比如abc的数据计算器。 串口的数据计算器等等。 这里存储器啊指的就是运行内存ram和程序存储器。 flash是我们存储变量数组和程序代码的地方。 在外设和存储器或者存储器和存储器之间进行数据转运。 就可以使用dma来完成。 并且在转运的过程中无需cpu的参与。 节省了cpu的资源。 cpu省下时间就可以干一些其他的更加专业的事。 情搬运数据这种杂货啊。 交给dma就行了。 其中dma一有七个通道。 dma 2有五个通道。 这个通道就是数据转移的路径啊。 从一个地方移动到另一个地方。 就需要占用一个通道。 如果有多个通道进行转运。 那它们之间可以各转各的。 互不干扰。 这就是dna的通道。 之后继续看下一条。 每个通道都支持软件触发和特定的硬件触发。 搬运数据这种杂货啊。 比如我们想把flash里的一批数据转运到sram里去。 那就需要软件触发。 了使用软件触发之后。 dma就会一股脑的把这批数据啊以最快的速度全部转运完成。 这也是我们想要的效果哈。 那如果dma进行的是外设到存储器的数据转运。 就不能一股脑的转运了。 因为外设的数据是有一定时机的。 所以这时我们就需要用硬件触发。 比如转运a d c的数据。 那就得a d c每个通道a d转换完成后。 硬件触发一次dma之后。 dma再转运触发一次。 转运一次。 这样数据才是正确的。 才是我们想要的效果。 所以存储器到存储器的数据转运。 我们一般使用软件触发外设到存储器的数。 据转运。 我们一般使用硬件触发。 那这里我写的是特定的硬件触发。 意思就是每个dma的通道。 它的硬件触发源是不一样的。 你要使用某个外设的硬件触发源。 就得使用它连接的那个通道。 而不能任意选择通道啊。 这个我们等会儿再详细分析。 那接着最后一条s t m32 f103。 c8 t6 的dma资源是d m a17 个通道。 我们这个芯片只有dma一的七个通道啊。 没有dma 2。 这个注意看一下数据手册啊。 好有关dma的简介。 我就讲这么多。 接着下一个ppt。 我们来看一下htm 32的存储器印象。 既然dma是。 在存储器之间进行数据转运的。 那我们就应该要了解一下s t m32 中都有哪些存储器。 这些存储器又是被安排到了哪些地址商。 这就是存储器印象的内容。 那我们知道计算机系统的五大组成部分是运算器。 控制器。 存储器。 输入设备和输出设备。 其中运算器和控制器一般会合在一起啊。 叫做cpu。 所以计算机的核心关键部分就是cpu和存储器。 存储器又有两个重要知识点。 一个是存储器的内容。 另一个就是存储器的地址。 那s t m32 也不例外。 这里有个表啊。 这个表就是s t m32 中所。 有类型的存储器和他们所被安排的地址。 在s t m32 的数据手册。 这里也会有个存储器印象的图。 我这个表就是从这个图里总结出来的哈。 都是一个意思。 在这个表里。 无论是flash还是s ram还是外设寄存器。 它们都是存储器的一种。 实际上也是存储器。 我们前面这里说的是外设到存储器。 存储器到存储器。 本质上其实都是存储器之间的数据转运啊。 说成外设的存储器。 只不过是s t m32。 它特别指定了可以转运外设的存储器而已。 这个了解一下好。 我们来看一下这个。 表在这个表里。 存储器总共分成两大类。 rom和ram入门就是只读存储器。 是一种非意识性掉电不丢失的存储器。 ram是随机存储器。 是一种意识性掉电丢失的存储器。 其中room目分为了三块。 第一块是程序存储器。 flash也就是主闪存哈。 它的用途就是存储c语言编译后的程序代码。 也就是我们下载程序的位置。 运行程序一般也是从主闪存里面开始运行的这一块存储器。 s t m32 给它分配的地址是0x08000000。 起始地址。 也就是第一个字节的地址是0800这个哈。 然后剩余志杰的。 弟子依次增长。 每个字节都分配一个独一无二的地址。 就像给每个住户编门牌号一样。 只有分配了独一无二的门牌号程序才能精准地访问这个存储器。 最终终止地址是多少呢。 这取决于它的容量编到哪里。 哪里就是中子地址。 这就是主闪存的地址范围。 你之后如果在软件里看到某个数据的地址是0800开头的。 那你就可以确定它是属于主闪存的数据。 接着继续看下面两块系统存储器和选项字节。 这两块存储器也是入门的一种哈。 掉电不丢失。 实际上他们的存储介质也是flash。 只不过。 是我们一般说flash指的是主闪存flash哈。 而不止这两块区域。 那看一下地址。 他们的地址都是1f f f开头的。 紧跟着2000开头的就是ram去的。 所以可以看出这两块存储器的位置是在入m区的。 最后面它们的用途啊。 看下右边说明系统存储器的用途是存储bootloader。 用于串口下载。 这个下一节讲串口的时候。 再给大家演示那个bootloader程序存储的位置就被分配到了这里。 bootloader程序是芯片出厂自动写入的哈。 一般也不允许我们修改之后。 选项字节。 它的。 位置是在rom区的最后面。 你下载程序可以不刷新选项字节的内容。 这样选项字节的配置就可以保持不变。 选项字节里存的主要是flash的毒保护协保护啊。 还有看门狗等等的配置。 这个如果需要的话。 可以了解一下。 然后我们看一下ram区域。 首先是运行内存。 sram分配的地址是0x20000000。 用途是存储运行过程中的临时变量。 也就是我们在程序中定义变量数组结构体的地方。 你可以试一下。 定义一个变量。 再取他的地址显示出来。 那这个地址肯定就是2000开头的。 类比于电脑的。 话运行内存就是内存条。 然后ram区剩下的还有外设寄存器。 它的地址是0x40000000。 这块区域用途是存储各个外设的配置参数。 也就是我们初始化各个外设最终所读写的东西。 刚才我们说了。 外设寄存器也是存储器的一种。 它的存储介质其实也是sram哈。 外设寄存器就直接叫寄存器了。 接下来最后是内核外设计算器地址是0x10000000。 这片区域用途是存储内核各个外设的配置参数。 内核外设就是nvc和cs t。 因为内核外设和。 其他外设不是一个厂家设计的。 所以他们的地址也是被分开的哈。 内核外设是1000。 其他外设是4000。 那以上这些就是s t m32 里的存储器和他们被安排的地址。 接着我们在这个图里也看一下啊。 在s t m32 中。 所有的存储器都被安排到了0~8个f这个地址范围内。 因为cpu是32位的哈。 所以寻址范围就是32位的范围。 32位的寻址范围是非常大的。 最大可以支持四gb容量的存储器。 所以这个四gb的寻址空间会有。 大量的地址都是空的。 算一下地址的使用率还不到1%。 在这个图里有灰色填充的就是reserve的区域。 也就是保留区域没有使用到。 然后这个零地址啊实际上也是没有存储器的。 他这里写的是别名到flash或者系统存储器。 取决于boot 0件。 因为程序是从零地址开始运行的。 所以这里需要把我们想要执行的程序映射到零地址来。 如果映射在flash区。 就从flash执行。 如果映射在系统存储器区。 就是从系统存储器运行bot road。 如果映射到sram。 就是从sram启动。 怎么选择。 由boot 0和boot 12个硬件来决定。 这就是。 零地址里的别名区啊。 接着剩下的0800开始的flash区。 用于存储程序代码。 1f f f开始的系统存储器和选项字节是在rom区的最后面啊。 存在什么东西。 刚才也都介绍过之后。 2000开始的是sram区。 4000开始的是外设寄存器区里面可以展开。 就是右边这些东西。 具体到每个外设又有他们自己的起始地址。 比如tm 2的地址是4000万。 tm 3440000400。 然后外设地址里面又可以具体细分到每个寄存器的地址。 寄存器里每个字节的地址。 最终所有字节的地址就都可以算出来了。 就上面这里1000开始的区域存放的就是内核里面的外设计算器了。 那到这里相信你对s t m32 里面有哪些存储器。 每种存储器都对应在哪个地址区间里就应该清楚了吧。 那接下来继续我们来看一下这个dma的框图。 这个框图我们在第一节s。 t m32 的系统结构里也见过一个类似的是吧。 剩下的这所有东西啊。 你都可以把它看成是存储器。 所以总共就是cpu和存储器两个东西。 flash是主闪存。 sram是运行内存。 各个外设都可以看成是寄存器。 也是一种sram存储器啊。 寄存器是一种特殊的存储器。 一方面cpu可以对寄存器进行读写。 就像读写运行内存一样。 另一方面寄存器的每一位背后都连接了一根导线。 这些导线可以用于控制外设电路的状态。 比如自引脚的高低电平啊。 导。 通和断开开关。 切换数据选择器。 或者多位结合起来当做计数器。 数据进行器等等等等。 所以寄存器是连接软件和硬件的桥梁。 软件读写寄存器就相当于在控制硬件的执行。 回到这里啊。 既然外设就是寄存器。 寄存器就是存储器。 那使用dma进行数据转运就都可以归为一类问题了。 就是从某个地址取内容。 再放到另一个地址去。 我们看图啊。 为了高效有条理的访问存储器。 这里设计了一个总线矩阵。 总线矩阵的左端是主动单元。 也就是拥有存储器的访问权。 右边这些是被动单元。 它们的存储器只能被左边的主动单元读写。 主动单看这里内核有抵扣的和系统总线。 可以访问右边的存储器。 其中抵扣的总线是专门访问flash的。 系统总线是访问其他东西的。 另外由于dma要转移数据。 所以dma也必须要有访问的主动权。 那主动单元除了内核cpu。 剩下的就是dma总线了。 这里dma一有一条dma总线。 dma 2也有一条dma中心。 下面这还有一条dma中心。 这个可以不用管的。 在dma一和dm a2 里面可以看到。 dma一有七个通道。 dma 2有五个通道。 各个通道可以分别设置它们转移数据的原地址和目的地址。 接着下面这里有个仲裁器。 但是最终dma总线只有一条。 所以所有的通道都只能分时复用这一条dna中线。 如果产生了冲突。 那就会由仲裁器根据通道的优先级决定谁先用谁后用。 另外在总线矩阵这里也会有个仲裁器啊。 如果dma和cpu都要访问同一个目标。 那么dma就会暂停cpu的访问。 以防止冲突。 不过总线仲裁期啊。 仍然会保证cpu得到一半的总线带宽。 使cpu也能正常的工作。 这就是仲裁器的作用。 然后继续看下。 面这里是a h b重设备。 也就是dma自身的寄存器。 因为dma作为一个外设。 它自己也会有相应的配置计算器。 这里连接在了总线右边的hb总线上。 所以dma既是总线矩阵的主动单元。 可以读写各种存储器。 也是hb总线上的被动单元。 cpu通过这一条线路就可以对dma进行配置了。 接着继续看。 这里是dma请求请求。 就是触发的意思啊。 这条线路右边的触发源是各个外设。 所以这个dma请求就是dma的硬件出发员。 比如adc转换完成串口接收到数据。 需要触发dma转运数据的时候。 就会通过这条线路向dma发出。 硬件触发信号之后。 dma就可以执行数据转运的工作了。 这就是dma请求的作用。 好到这里。 有关dma的结构就讲得差不多了。 hb从设备用于配置dm参数。 dma请求用于硬件触发dma的数据转运。 这就是这个dma的各个部分和作用。 最后再额外说一个问题啊。 就是这里的flash它是入m只读存储器的一种。 如果通过总线直接访问的话。 无论是cpu还是dma都是只读的。 只能读取数据。 而不。 能写入。 如果你dma的目的地址填写了flash的区域。 那转运时就会出错。 这个注意一下啊。 当然flash也不是绝对的不可写入。 我们可以配置这个flash接口控制器。 对flash进行写入。 这个流程就比较麻烦了。 要先对flash按e进行擦除。 再写入数据。 不过这是另一个课题了哈。 这里就不再讨论。 总之就是cpu或者dma直接访问flash的话。 是只可以读而不可以写的。 然后s ram是运行内存。 可以任意读写。 没有问题。 外设计容器的话得看参考手册里面的描述。 有的寄存器是只读的。 有的寄存器是只写的。 不过我们主要用的是。 数据进器啊。 数据计算器都是可以正常读写的。 好这个图目前就讲到这里。 接着继续看下一个ppt。 这里是我总结的dma基本结构图。 如果想编写代码实际去控制dma的话。 那这个图就是必不可少的了。 刚才这个框图只是一个笼统的结构图啊。 对于dma内部的执行细节。 它还是没体现出来。 所以我们再来分析一下这个图。 看看dma具体是怎么工作的。 在这个图里。 这两部分就是数据转运的两大站点了。 左边是外设净水器站点。 右边是存储器站点。 在s t m32 手册里。 他所说的存储器啊。 一般是特指flash和s ram。 外设计容器它一般直接称作外设。 所以就是外设到存储器。 存储器的存储器这样来描述。 虽然我们刚才说了。 寄存器也是存储器的一种。 但是s t m32 还是使用了外设和存储器来作为区分哈。 这个注意一下描述方法的不同。 那在这里可以看到dma的数据转运可以是从外设到存储器。 也是可以从存储器到外设。 具体是向左还是向右。 有一个方向的参数可以进行控制。 另外还有一种转运方式。 就是存储器到存储器。 比如flash到sram或者s ram到s ram这两。 种方式。 由于flash是只读的。 所以dma不可以进行sram到flash或者flash到flash的转移操作。 然后我们继续看这两边的参数。 既然要进行数据转运。 那肯定就要指定从哪里转到哪里。 具体怎么转呢。 所以外设和存储器两个站点就都有三个参数。 第一个是起始地址。 有外设端的起始地址和存储器端的起始地址。 这两个参数决定了数据是从哪里来到哪里去的。 之后第二个参数是数据宽度。 这个参数的作用是指定一次转运要按多大的数据宽度来进行。 他可以选择字节bt半自half word和字word字节就是八位啊。 也。 就是一次转用一个uint 8杠t这么大的数据半径是16位。 就是一次转运一个ut 16杠七怎么打。 这是32位。 就是一次转运unit 32杠七怎么打。 比如转运a d c的数据。 a d c的结果是unit 16杠七怎么打。 所以这个参数就要选择半指一次转运一个unit的幺六缸体。 这样才对。 然后第三个参数是地址是否自增。 这个参数的作用是指定一次转移完成后。 下一次转运是不是要把地址移动到下一个位置去。 这就相当于是指针p加加这个意思。 比如a d c扫描模式。 用dma进行数据转运。 外设地。 址是a d c d r计算器寄存器这边显然地址是不用指针的。 如果指针那下一次转运就跑到别的计算器哪里去了。 存储器这边地址就需要指针。 每转运一个数据后就往后挪个坑。 要不然下次再转就把上次的覆盖掉了。 这就是地址是否自尊的作用。 就是指定是不是要转运一次。 挪个坑。 这个意思。 这就是外设站点和存储基站点各自的三个参数了。 如果要进行存储器到存储器的数据转运。 那我们就需要把其中一个存储器的地址放在外设的这个站点。 这样就能进行存储器的存储器的专用。 了只要你在外设其实地址里写flash或者sram的地址。 那他就会去flash或sram找数据。 这个站点虽然叫外设存储器。 但是它就只是个名字而已哈。 并不是说这个地址只能写寄存器的地址。 如果写flash的地址。 那他就会去flash里找。 写s ram。 他就会去s ram里找。 这个没有限制哈。 甚至你可以在外设站点写存储器的地址。 存储器站点写外设的地址。 然后方向参数给反过来。 这样也是可以的。 所以我这里就按照它的名字来做的p p t。 你也可以把它叫做站点a站点b。 从a到b或者从b到a转移数据。 不必拘泥于他写的外设站点存储器占点这个名字的好。 接着往下面看。 这里有个东西叫做传输计数器。 这个东西就是用来指定我总共需要转运几次的。 这个传输计数器是一个质检计数器啊。 比如你给他写个五。 那dma就只能进行五次数据转运。 转运过程中每转运一次机由器的数就会减一。 当传输计数器减到零之后。 dma就不会再进行数据转运了。 另外它减到零之后之前自增的地址哈也会恢复到起始地址的位置。 以方便之后dna开始新轮的转换。 在传输计。 数器的右边有一个自动重装器。 这个自动重装器的作用就是传输计数器减到零之后。 是否要自动恢复到最初的值。 比如最初传输计数器给五。 如果不使用自动重装器。 那转运五次后da就结束了。 如果使用自动重造器。 那转运五次计数器减到零后就会立即重装到初始值五。 这个就是自动重装系。 它决定了转运的模式。 如果不重装就是正常的单次模式。 如果重装就是循环模式。 比如如果你想转运一个数组。 那一般就是单次模式转运一轮就结束了。 如果是a d c扫描模式加连续转换。 那为了。 配合a d c d m a也需要使用循环模式。 所以这个循环模式和adc的连续模式差不多啊。 都是指定一轮工作完成后。 是不是立即开始下一轮工作。 然后继续往下看啊。 这一块就是dma的触发控制了。 触发就是决定dma需要在什么时机进行转运的触发。 原有硬件触发和软件触发。 具体选择哪个。 由m2 m这个参数决定。 m l m就是memory to memory。 因为二的英文to和two同音。 所以m2 m就是m to m存储器到存储器的意思。 当我们给m2 m为一时。 dma就会选择软件收发。 这个软件触发并不是调用某个函数。 一次触发一次啊。 争取早日把传输机游戏清零。 完成这一轮的转换。 所以这里的软件出发和我们之前外部中断和a d c的软件出发。 可能不太一样哈。 你可以把它理解成连续处罚。 那这个软件触发和循环模式不能同时用哈。 因为软件触发就是想把传输计数器清零。 循环模式是七零后自动重装。 如果同时用的话。 那dma就停不下来了。 这就是软件触发。 软件触发一般适用于存储器到存储器的转运。 因为存储器的存储器的转运。 是软件启动不需要时机。 并且想尽快完成的任务。 所以上面这里m2 mv给一就是软件触发。 就是应用在存储器到存储器转运的情况。 当m2 m v给零。 那就是使用硬件触发了硬件触发言。 可以选择a d c啊。 串口定时器等等。 使用硬件触发的转运一般都是与外设有关的转运。 这些转运需要一定的时机。 比如a d c转换完成串口时的数据定时时间到等等。 所以需要使用硬件触发。 在硬件达到这些时机时。 传个信号过来来触发dma进行转运。 这就是硬件触发。 然后最后就是开关控制了。 也就是。 dma cm d函数。 当给dma死人后。 dma就准备就绪。 可以进行转运了。 dma进行转运有几个条件。 第一就是开关控制dma cm d必须死人。 第二就是传输计数器必须大于零。 第三就是触发源必须有触发信号。 触发一次转运一次。 传输计数器自检一次。 当传输计数器等于零。 且没有自动重装时。 这时无论是否触发dma都不会再进行转运了。 此时就需要dma cm d给disable关闭dma。 在为传输计数器写一个大于零的数。 在d m a c m d给label开启dma。 dma才能继续工作。 注意一下。 写传输计数器时。 必须要先关闭dm再进行。 不能在。 这是手册里的规定哈。 好到这里。 dma的基本结构我就介绍完了。 接下来我们再看几个细节的问题。 第一个是dma请求。 这张图表示的就是我们上面这里的这部分结构。 dma触发的部分。 我们来看一下这张图是dma一的请求印象。 下面是dma的七个通道。 每个通道都有一个数据选择器。 可以选择硬件触发或软件触发。 这里画的图啊。 我觉得可能不太好理解。 你看他把e n位画在了数据选择器的侧边。 一般数据选择器的侧边是输入选择控制位哈。 难道这里的意思是e n给e选。 择硬件触发e n给您选择软件触发吗。 那显然不对啊。 而且他左边这里写的是软件触发括号。 memory to memory way。 难道m2 m v是软件触发吗。 这个也不太好理解哈。 所以这个图我重新给他布了个局。 就是上面我这里画的这样。 m2 m v是数据选择器的控制位。 用于选择是硬件触发还是软件触发。 an位是开关控制。 e n等于零时不工作。 1n等于一时工作。 这样就好理解一些了。 那这里他这样画的意思应该是。 e n并不是数据选择器的控制位啊。 而是决定这个数据选择器要不要工作。 1n等于零数。 据选择器不工作。 1n等于一数据选择器工作。 然后软件触发后面跟个m2 m v的意思应该是当m2 mv等于一时。 选择软件触发。 这样理解的话就跟我这个图里是一个意思了。 那然后继续看左边的硬件出发源。 这里是外设请求信号啊。 可以看到每个通道的硬件出发源都是不同的。 如果你需要用a d c e来触发的话。 那就必须选择通道一。 如果需要定时期二的更新事件来触发的话。 那就必须选择通道二。 剩下的也是同理哈。 因为每个通道的硬件出发源都不同。 所以如果你想使用某个硬。 件出发源的话就必须使用它所在的通道。 这就是硬件触发的注意事项。 而如果使用软件触发的话。 那通道就可以任意选择了。 因为每个通道的软件触发都是一样的。 所以在ppt的在前面写的是每个通道都支持软件触发和特定的硬件触发。 这就是特定的意思。 选择硬件触发是要看通道的。 然后回来继续看哈。 这里通道一的硬件触发是a d c1。 定时器二的通道三和定时器四的通道一。 那到底是选择哪个触发源呢。 这个是对应的外设是否开启了dma输出来决定的。 比如你要使用a d c1。 那。 会有个库函数叫adc dmc md。 必须使用这个快速开启a d c一的这一路输出太太有效。 如果想选择定时器二的通道三。 所以这三个出发源具体使用哪个。 取决于你把哪个外设的dm a输出开启了。 如果三个都开启了。 那这边是一个或门哈。 理论上三个硬件都可以进行触发。 不过一般情况下我们都是开启其中一个。 这就是这部分电路之后。 这七个出发员进入到仲裁器进行优先级判断。 最终产生内部的dma 1。 请求这个优先级的判断啊。 类。 似于中断的优先级。 默认优先级是通道号越小。 优先级越高。 当然也可以在程序中配置优先级啊。 这个其实影响并不是很大。 大家了解一下就行了。 之后我们再看一个细节问题啊。 就是数据宽度与对齐。 这里有个表。 这个表是用来说明什么问题的呢。 我们可以看一下前面这里这里数据转移到两个站点。 都有一个数据宽度的参数。 如果数据宽度都一样。 那就是正常的一个个转运。 如果数据宽度不一样。 那会怎么处理呢。 这个表就是来说明这个问题的。 我们看一下这里第一列是远端宽度。 第二列。 是目标宽度。 第三列是传输数目。 当远端和目标都是八位时。 转运第一步。 在远端的零位置读数据。 b0 在目标的零位置写数据。 b0 就是把这个b0 从左边挪到右边之后的步骤。 就是把b一从左边挪到右边。 接着b2 b3。 这是远端和目标都是八位的情况。 操作也很正常啊。 接着继续。 原端是八位。 目标是16位。 那他的操作就是在远端读b0。 在目标写零零比零之后读b一写00b一等等。 这个意思就是如果你目标的数据宽度比原端的数据宽度大。 那就在目标数据前面多出来的空位补。 零之后八位转移到32位也是一样的处理哈。 前面空出来的都不灵。 然后下面当目标数据宽度比原端数据宽度小时。 比如由16位转到八位去。 现象就是读b1 b0 只写入b0。 读b3 b2 只写入b2。 也就是把多出来的高位舍弃掉。 之后的各种情况也都是类似的操作。 总之这个表的意思就是。 如果你把小的数据转到大的里面去。 高位就会补零。 如果把大的数据转到小的里面去。 高位就会舍弃掉。 如果数据宽度一样。 那就没事儿。 这个操作我们也可以想象的到哈。 就是跟unit 8杠t u int。 幺六杠t和unit。 三二杠t变量之间相互赋值一样。 不过就补零。 超了就舍弃高位。 这是一个道理哈。 那最后我们再来看两个例子。 看看在这些实际的任务下。 dma是如何工作的。 第一个例子就是数据转运加点为。 第二个例子是a d c扫描模式加点a。 这两个例子和我们演示的两个程序是对应的哈。 看一下第一个例子。 这个例子的任务是将sram里的数组da转运到另一个数组db中。 我们看一下这种情况下。 这个基本结构里的各个参数该如何配置。 首先是外设站点和存储器。 站点的起始地址。 数据宽。 度地址是否自增这三个参数。 那在这个任务里。 外设地址显然应该填da数组的首地址。 存储器地址给db数据的收地址。 然后数据宽度两个数组的类型都是unit t8 杠t1。 所以数据宽度都是按八位的字节传输之后。 地址是否之争在中间可以看到啊。 我们想要的效果是data ta 0转到db 0。 da一转到dotb一等等。 两个数组的位置一一对应啊。 所以转运完data a0 和db 0之后。 两个站点的地址都应该指针都移动到下一个数据的位置。 继续转运data a一和db一这样来进行。 如果你左边不指针。 右边指针。 效果就是这样的。 转运完成后。 db的所有数据都会等于da 0。 那效果就是这样的。 转运完成后。 db 0等于da的最后一个数。 db其他的数不变。 那就一直是da 0转到db 0。 其他的数据不变。 这就是地址是否自增的效果之后这里的方向参数。 那显然就是外设站点转运的存储机站点了。 如果你想把db的数据转运到da那可以把方向参数换过来。 这样就是反向转运了。 然后是传输计数器和是否要自动重装在这里啊。 显然要转运七次。 所以传输进游戏给七自动重装。 暂时不。 需要之后触发选择部分。 这里我们要使用软件触发。 因为这是存储器到存储器的数据转运是不需要等待硬件时机的。 尽快转移完成就行了。 那最后调用dma cm d给dma死人。 这样数据就会从data a转移到db了。 转运七次之后。 传输计数器自减到零。 dma停止转运完成。 这里的数据转运是一种复制转运哈。 转运完成后。 data ta的数据并不会消失。 这个过程相当于是把da的数据复制到了db的位置。 这就是第一个任务啊。 存储器到存储器的数据占用。 接着看第二个任务。 a d c扫描模式加dma。 左边是a d c。 扫描模式的执行流程。 在这里有七个通道触发一次后。 七个通道依次进行a d转换。 然后转换结果都放到a d c d r数据计算器里面。 那我们要做的就是在每个单独的通道转换完成后。 进行一次dma数据转运。 并且目的地址进行自增。 这样数据就不会被覆盖了。 所以在这里dma的配置就是外设地址写作abc dr这个景气的地址。 存储器的地址可以在sram中定义一个数组a d value。 然后把ad value的地址当作存储器的地址之后。 数据宽度。 因为a b c d r和sram数组我们要的都是应用的一六杠t的数。 据所以数据宽度都是16位的。 半自传输。 继续使地址是否自证。 存储器地址自增。 传输方向是外设站点的存储器。 站点传输计数器。 这里通道有七个属计数。 七次计数器是否自动重装。 这里可以看adc的配置。 adc如果是单次扫描。 转换一轮就停止。 如果a d c是连续扫描。 那dma就可以使用自动重装。 在a d c启动下一轮转换的时候。 dma也启动下一轮的转运。 a d c和d a同步工作。 最后是触发选择。 这里a abc dr的值是在。 adc单个通道转换完成后才会有效。 所以dma转运的时机需要和adc单个通道转换完成同步。 所以dma的触发要选择a d c的硬件触发。 最后硬件触发这里要说明一下啊。 我们上一节说了。 a d c扫描模式在每个单独的通道转换完成后。 没有任何标志位。 也不会触发中断。 所以我们程序不太好判断某一个通道转换完成的时机是什么时候。 但是根据我的研究哈。 虽然单个通道转换完成后不产生任何标志位和中段。 但是他应该会产生dma请求去触发dma转运。 这部分内容首选里并没有详细描述哈。 根据我实际实验啊。 单个通道的dma请求肯定是有的。 要不然这个实验就做不成了。 好这些就是adc扫描模式和dma配合使用的流程。 一般来说dma最常见的用途就是配合a d c的扫描模式。 因为a d c扫描模式有个数据覆盖的特征。 或者可以说这个数据覆盖的问题是a d c固有的缺陷哈。 这个缺陷是a d c和d m a成了最常见的伙伴。 adc对dma的需求是非常强烈的。 像其他的一些外设使用dma可以提高效率。 是锦上添花的操作。 但是不使用也是可以的。 顶多是损失一些性能。 但是这个a abc的。 扫描模式如果不使用dma功能都会受到很大的限制。 所以adc和dma的结合最为常见。 好到这里。 我们dma的ppt部分就讲完了。 最后我们再来看看参考手册哈。 看看参考手册上都讲了哪些东西。 本节我们涉及的内容有第十章dma控制器。 另外我们还花了一些时间来介绍存储器映射的内容。 这些在手册的第二章存储器和总线架构里有介绍啊。 在第二章这里是存储器和总线架构。 首先是系统架构。 这个我们在课程第一节哈和刚才都了解过。 这个图就是s t m32 的整体架构。 下面有这些总线的介。 绍啊大家可以再看看。 之后就是存储器组织的内容。 这里有个存储器的印象表。 这个表就是各个外设计算器和它分配的地址范围哈。 可以看到外设计算器的地址都是四零开头。 然后是嵌入式sram运行内存。 它的起始地址是2000。 这里之后这里还有一个未段区域啊。 这两个位段区映射的外设计容器和s ram中全部的位。 这个未断区就相当于是未寻子哈。 你操作这个新的地址就相当于操作其中某一个位。 因为32位的地址有99%都是空的。 所以地址空间很充足。 即使把每一位都单独编码。 那毫无压力。 所以就存在了这样一个位段。 用于单独操作计算器或sram的某一。 位位大区是另找了一个地方。 开辟了一段地址区域。 还其中s ram微单区域是2200开头的区域。 外设计容器的微端区是4200开头的区域。 需要用的话可以了解一下。 这里就不再多讲了哈。 之后继续嵌入式闪存。 闪存被分为了很多页。 他们的地址都是0800开头的。 在闪存区的最后就是系统存储器和选项字节。 这两个区域统称为信息块。 这是外设的一部分哈。 你看他的地址是四零开头的。 所以它显然是一个外设。 这个外设可以对闪存进行读写哈。 这就是闪存的部分。 其他的一些描述大家可以自己来看看啊。 然后是启动配置。 配置不t0 和bot 12个硬件来选择程序从哪里启动。 这个我们第一节和刚才也介绍过啊。 大家可以再看看这里。 这就是第二章内容。 接着看一下dma的章节。 首先是dma的简介和一些主要特性。 然后是结构框图。 这个可以再好好看看。 功能描述。 当cpu和da访问相同目标时。 dma会暂停cpu。 但是cpu可以得到一半的带宽da处理。 这里讲了一次请求发生时。 dma是如何处理的。 之后仲裁器配置通道的优先级。 来决定哪个通道先执行哪个通道后执行dma。 通道里面有可编程的数据量地址指针。 指针。 如何配置。 循环模式和存储器到存储器的模式这些。 如果还有不清楚的。 可以再看看这个描述。 然后是这个表。 我们刚才也说过哈。 错误管理。 当读写一个保留的地址区域。 将会产生dma传输错误。 下面是中段有传输过半。 传输完成和传输错误的中断。 就是dm请求。 就是硬件触发和软件触发。 这就是触发的连接图。 下面这个表啊。 就是上面这里硬件触发归纳的一个表是一样的内容哈。 然后是dma 2的请求图和表。 那最后就是dma的计算器了。 首先是中断状态寄存器发生中断后会在这里自标志位。 如果配置的n vc就会向cpu申请中断之后。 中断标志位清除。 用于清除标志为。 然后是通道配置计算器。 各个通道的参数啊。 比如优先级数据宽度地址是否之争。 循环方向是否允许中断。 都是配置均水器的内容。 然后传输数量计算器就是传输计数器啊。 它只有第16位。 有效范围是0~6535。 所以传输个数最。 多是6535个之后就是外设地址计算器。 存储器地址计算器用于指定两个传输站点的地址。 最后是计算器的一个汇总表哈。 然后就结束了。 这就是dma的所有内容。 好那本节课的内容到这里就结束了。 我们下一小节来开始写代码。
24. 本小节我们来写一下dma的代码哈。 那我们先看一下经验图。 打开八杠一dma数据转运的图片。 看一下这个电路和o l d显示屏是一样的哈。 因为这个数据转运都是在s t m32 内部进行的。 所以外围电路就加一个o r d显示一下就行了。 其他的模块都不需要。 然后面包板这里也就是一个oled显示屏的电路就行了。 接下来我们回到工程文件夹。 复制一下oled显示屏的工程。 改个名字叫八杠一dma数据转运。 打开工程。 这些删掉先编译一下哈。 没问题好。 那在正式开始dma代码之前。 我们先花一段时间做个小实验来验证一下这个存储器印象的内容。 看一下我们定义的数据。 它到底是不是真的存在了这相应的地址区间里。 我们回到代码哈。 在这上面先随便定义一个变量啊。 u int 8杠t a a等于0x660 x66 是一个16进制的数啊。 然后在主函数里oled show hex number。 一行一列显示aa长度为二。 这就是正常的定义变量引用变量哈。 然后我们再显示一下这个变量的地址。 看看也是16进制显示地址。 一般都习惯用16进制表示啊。 接着二行一列显示取地址a这个与号放在一个变量前面。 表示取这个变量的地址。 然后这个变量举例子之后。 应该要存在一个指针变量里。 这里如果直接想当做一个数字显示的话。 还得在前面加上强制类型转换。 括号二由int 32杠t如果不加强制类型转换。 就是指针跨级复制了。 编译的时候会给你报个警告哈。 最后显示长度为八八个。 16进制的数表示的是32位。 32位的系统地址都是32位的啊。 有关指针和地址还不会的话。 可以看一下我空间里的指针教程哈。 里面都有介绍好。 让我们看看现象编译。 下载看一下。 现在第一行显示的是aa变量的内容。 六六没问题。 第二行显示的就是aa这个变量。 它被存储的地址。 可以看到这个地址是2000万。 地址是二零开头的。 那对照p的这个表就知道了。 a a这个变量存储的位置是sram区。 在sram区它的地址肯定是20开头的。 那它的具体地址是多少呢。 这个是由编译器来确定的。 目前s ram区还没什么东西。 所以编译器就把这个变量放在了s ram区的第一个位置。 也就是2000万。 那回到代码。 我们可以在这个变量前面加一个const。 关键字cos的是c语言的关键字表示的是常量的意思。 被cos的修饰的变量在程序中只能读不能写。 那我们上一小节说了。 flash里面的数据也是只能读不能写的。 所以cost和flash就联系起来了。 在s t m32 中。 使用cos的定义的变量是存储在flash里面的。 当然这里就不应该说是变量了。 而应该说是常量。 因为它是不能变的。 这个变量的值只能在定义的时候给。 如果你在程序这里尝试再次给它赋值。 那就会报错啊。 错误意思就是不能给cos的常量赋值。 那我们下载看一下。 在这里就可以看到aa这个变量的地址就变成0800开头的了。 在ppt的表格里可以知道现在aa是被存储在了flash里。 在flash里存储的是程序代码。 当然还有常量数据哈。 这里没写出来。 那这里的地址尾部有些偏移哈。 不像s ram里那样直接安排在第一个位置。 这是因为flash里还有程序代码这些东西放在了前面。 所以编译器给这个常量安排的地址就相对靠后了一些。 这就是定义变量和常量的方法。 正常情况下我们使用的都是变量哈。 直接定义就行。 不需要加cos的。 那什么时候需要定义常量呢。 这个是当我们程序中出现了一大批数据。 并且不需要更改时。 就可以把它定义成常量。 这样能节省hm的空间。 比如查查表。 字库数据等等。 我们可以打开这个oled font.h文件。 这里面就是o l d显示英文的字库。 这是一个数组哈。 它里面的数据决定了每个字符应该显示哪些像素点。 这个数组非常的长啊。 而且是不需要更改的。 所以在这里就可以加一个concert。 把它定义在flash里面。 这样就可以节省s ram的空间。 这里如果你一不小心把这个const去掉了。 那程序功能并不会有任何影响。 但是sram里会有和这个数组一样大的空间被浪费掉了。 如果数值很小。 那影响也不大。 如果数值很大。 那就得考虑一下sram是不是消耗得起来。 这就是cos的关键字的用途。 如果你有个很大的查找表或者智库。 最好加一个cos的好。 那我们继续。 接下来我们再研究一下外设寄存器的地址。 这些东西先删掉啊。 那对于变量或者常量来说。 它的地址是由编译器确定的。 不同的程序地址可能不一样啊。 是不固定的。 对于外设计算器来说。 它的地址是固定的。 在手册里都能查得到哈。 在程序里也可以用结构体很方便的访问计算器。 比如要访问a d c e的低压计算器。 就可以写a d c e杠大于号低压。 这样就可以访问a d c e的dr计算器了。 我们把这个计算器放在这里。 显示一下地址。 看看编译。 看一下。 可以看到a d c e的d r进器。 它的地址是4001244。 c是四零开头的。 对照pp的表可以知道他确实是外设计算器的区域哈。 这个具体地址4001244c是固定的哈。 在手册里也可以查到。 我们看一下。 首先打开第二章。 看一下这个存储器印象。 找一下。 可以看到a d c e的起始地址是40012400。 接着再打开abc的章节。 看一下最后面这个寄存器总表。 找一下。 可以看到a d c d r寄存器的地址偏移是4c。 之前i d c一的起始地址是40012400。 dr偏移是4c。 所以a d c e的d r地址就是4001244。 c和我们这里显示的是一样的哈。 所以如果你想算某个寄存器的地址。 就可以查手册计算一下。 首先查一下这个计算器所在外设的起始地址。 然后再在外设的计算器总表里查一下偏移。 起始地址加偏移就是这个计算器的实际地址。 来回到代码。 我们再来研究一下这个a d c一刚好大于号。 dr这个东西是如何知道adc 1 dr寄存器的地址的呢。 这种结构体的方式又是如何访问到寄存器的呢。 我们可以在abc一处右键跳转到定义。 可以看到adc一就是这个东西。 左边是一个强制类型转换。 把a d c e base转换为了a b c type底范类型的指针。 右边adc一贝斯就是adc一的基地值。 基地址就是歧视地址的意思。 也就是我们刚才查表看到的40012400哈。 转到定义看一下abc 1 g地址。 就是a p p2 y设计地址加上0x2400。 再转到定义app 2 y设计地址就是外设基地址加0x10000。 再转到定义外设基地址就是0x40000000。 可以看到上面还有s m g地址啊。 是2000flash基地址是0800。 和我们之前讲的都是一致的哈。 那这里回过来看外设基地址是4000万。 加上10000=400100004。 app 2 y设计地址。 再回过来再加2400=40012400。 就得到了a b c一的基地值。 也就是首次表里写的那个哈。 再回过来。 现在基地址有了。 但是基地址加偏移才是计算器的实际地址。 在这里啊。 它使用了一个非常巧妙的方法来实现这个偏移。 就是使用结构体来实现我们跳转到结构体的定义。 可以看到这里是依次定义的各种计算器这个结构体成员的顺序哈。 看一下手册和这个寄存器实际存放的顺序是一一对应的。 sr cr cr 2等等。 在结构体里面也是sr cr cr等等。 所以说回到这里。 如果我们定义一个a abc结构体的指针。 并且指针的地址就是这个外设的起始地址。 那这个结构体的每个成员就会正好映射实际的每个寄存器。 换个内存图。 就是在内存的40012400开始的位置。 存放的是a d c e的计算器。 存放顺序是s r c r e c r2 等等。 我们定义abc type define这样一个结构体。 那它在内存的存储情况啊。 也是sr c r e c r等等这样来存储的。 如果我指定这个结构体的起始地址就是abc一外设计算器的起始地址。 那么这个结构体的内存和外设计算器的内存就会完美重合。 我在访问结构体的某个成员。 就相当于是访问这个外设的某个计算器的。 这就是s t m32 中使用结构体来访问计算器的流程。 回到这里。 现在这个a d c一杠大于号dr你就应该明白他是啥意思了吧。 a d c一是结构体指针。 指向的是a d c e外设的起始地址。 访问结构体成员就相当于是加一个地址偏移。 其实地址加偏移就是指定的计算器。 这里因为a b c一是一个结构体指针哈。 所以要用杠杆大于号。 也就是箭头哈这个符号来取乘员。 不得不说s t m32 这个库函数啊。 把访问一个计算器做的还是非常麻烦的哈。 其实如果你想简单点的话。 直接用指针访问某个物理地址就行了。 比如定义一下define a d c e下划线dr它是0x4001244 c。 然后把这个地址强占为一个ut 32杠七的指针。 之后。 使用星号取a d c e d r指针内容。 这样也是可以访问a d c e的dr进行器哈。 和这个结构体访问的效果是一模一样的。 好到这里有关这个存储器地址常量和变量。 结构体访问寄存器啊。 这些知识点我就讲完了。 算是给大家扩展了一些内容哈。 那接下来我们回到正题。 看一下dma的配置。 把这些先删掉。 首先我们定义一下dma转运的原端数组和目的数组。 第一个uint 8杠七data a。 这个是原端数组里面的数据是0x010 x020 x030 x04。 目前总共有四个数据哈。 当然实际情况可能会有成千上万个数据。 这样才能发挥出dma转运的优势哈。 目前测试的话就先给四个就行了。 然后第二个数组u int 8杠七db里面的数据是0000。 当然如果你不写零的话。 全局变量默认也是零哈。 接下来我们的任务就是初始化dma。 然后让dma把这里da的数据转运到db里面去。 这就是我们第一个代码的任务。 那我们还是先给dma建个模块。 这里dma不涉及外围硬件电路。 所以可以在system里添加。 在这里右键快速添加下模块。 好现在我就添加好了这个买dma的模块。 这个模块的名字啊。 为了防止与库函数里面的dma重复。 我就起了个买dma当起什么名字。 看你的喜好了。 然后再买dma模块里面先来一个初始化函数。 word买dma 1 ite void。 在这里面我们将初始化dma初始化的步骤啊。 我们还是看一下p p t的这个基本结构图。 初始化第一步。 racc开启dma的时钟。 这个没问题啊。 第二步就可以直接调用dma 1 it初始化这里的各个参数了。 包括外设和存储器。 站点的起始地址。 数据宽度地址是否自增方向传输。 路由器是否需要自动重装。 选择触发源。 当然还有一个通道优先级哈。 这里没画出来。 那这所有的参数通过一个结构体就可以配置。 好了之后就可以进行开关控制。 dma cm d给指定的通道死人就完成了。 那在这里如果你选择的是硬件书法。 不要忘了在对应的外设调用一下叉叉叉。 d m a c m d开启一下触发信号的输出啊。 如果你需要dma的中段。 那就调用dma i t configure。 开启中段输出。 再在n v i s a里配置相应的中断通道。 然后写中断函数就行了。 中断的配置啊。 各个外设都一样。 这里结构图我暂时没有画中段的部分啊。 最后在运行的过程中。 如果转运完成传输计数器清零了。 这时再想给传输计数器赋值的话。 就dma 4能写传输计数器。 dma是能这样就行了。 这就是dma的编程思路。 接下来我们看一下dma的库函数哈。 找一下打开dma点去拖。 到最后函数就这么多。 看上去应该还是比较简单的哈。 我们看一下dd恢复确认配置。 一it初始化是dk的一it结构体初始化c m d死人。 it configure。 中断输出使能。 这些都是经典函数了哈。 应该已经很熟悉了吧。 然后接下来dma设置当前数据计算器。 这个函数就是给这个传输计数器写数据的哈。 之后dma获取当前数据进器。 这个函数就是返回传输计数器的值。 如果你想看看还剩多少数据没有转运。 就可以调用这个函数获取一下传输计数器。 这样就行了。 然后最后四个函数获取标志位状态。 清除标志位。 获取中段状态。 清除中断挂起为这些也是近点函数了哈。 不用多说。 那到这里dma的库函数就结束了。 除了中间这两个函数。 剩下的全是经典函数啊。 应该说还是比较好理解的。 然后我们来开始写代码。 第一步开启时钟二cc hb外设时钟控制。 dma是a h b中心的设备哈。 所以要用a h b开启时终端函数。 我们转到定义。 看一下第一个参数的解释在这里啊。 这里说的是对于互联型设备。 这个参数可以是下面这一支的组合。 对于其他设备这个参数是这下面的组合。 互联型是s t m32 f105107 的型号哈。 我们这个是f103。 所以我们在下面这个参数表里选。 很显然选择这个dm一的参数就行了。 复制放到这里。 第二个参数label开启dma一的时钟。 然后接下来dma 1 it初始化dma先定义初始化结构体啊。 dma 1 it tab def。 dma一是structure之后把结构体成员全部引出来。 这里成员比较多哈。 我们重新排个序。 好了现在看一下。 其实已经不难理解了哈。 前面六个成员外设站点的起始地址。 数据宽度是否自真存储器占点的起始地址。 数据宽度是否是真对应的。 就是图里的这六个参数之后。 dr传输方向。 buffer size。 缓冲区大小其实就是传输记录器。 海mod传送模式。 其实就是是否使用自动重装m2 m选择是否是存储器到存储器。 其实就是选择硬件触发还是软件触发哈。 最后priority优先级。 这个按照参数要求给个优先级就行了哈。 那对应这个图从上到下每个参数都是可以用结构体来配置的。 这就是初始化结构体的参数。 然后dma一例函数转到定义看一下哈。 这里第一个参数就不止是dma几了。 这里写的是第一个参数是d m a y cho x。 其中y可以是一或二。 用来选择是哪个dva x可以是1~7。 对于dm一或者可以是1~5。 对于dm 2可以选择是哪一个通道。 所以这里dma一的第一个参数既选择了是哪个dma。 也选择了是dma的哪个通道。 那我们复制这个dm y嵌入x放到这里。 然后y改成一选择dma 1 x选择通道。 这里因为是存储器到存储器的转运用的是软件触发。 所以通道可以任意选择哈。 这里就给通道一半之后。 复制一下结构体的名字。 把结构体的地址放在第二个参数。 这样就是把结构体指定的参数配置到d m一的通道一里面去。 那接下来我们看一下结构体的参数啊。 第一个是外设站点的基地址。 在这里要写一个32位的地址哈。 比如0x20000000 这样的地址。 对于sram的数组。 它的地址是编译器分配的。 并不是固定的。 所以我们一般不会写绝对地址。 而是通过数组名来获取地址。 那这里我们就把这个地址提取成初始化函数的参数。 这样在初始化的时候。 你想转移哪个数组。 就把哪个数组的地址传进来就行了。 所以这里void改成int 32杠t a d d r a。 然后把adda放在这里。 这样外设站点的第一支就完成了。 之后数据宽度跳转的定义。 看一下介绍。 是指定数据宽度。 这个参数可以是这里面的一个值。 ctrl f搜索一下。 这里可以看到有bat字节。 就是unit 8个题。 half word半字就是unit 16缸t word字就是unit 32缸体。 那这里我们想要以字节的方式传输。 所以就复制第一个。 然后放在这里。 接着地址是否自真调查定义。 看一下解释是指定外设地址是至臻或者不是参数取值。 搜索一下。 这里有两个选择。 第一个至臻able就是自增。 第二个字真disable。 就是不自尊。 根据上一小节的分析啊。 我们这种数组之间的转运地址肯定是要自尊的啦。 所以负责第一个放到这里。 这样外设站点的三个参数就配置完成了之后。 存储器占点的三个参数也是类似的东西啊。 第一个存储器占点的基地值。 我们也把它提取成参数。 在这里加一个参数。 u int 32杠t a d d r b。 然后把a d d r b放在这里。 作为存储器占点的起始地址。 接着数据宽度转到定义哈。 搜索一下这个参数列表。 我们也选择这个bt参数以字节传输。 然后放到这里。 接着继续存储器占点地址指针转到定义搜索一下参数列表哈。 这里也选择地址自增赋值放到这里。 这样外设站点和存储器占点的参数就配置好了。 然后继续看d i r转到定义。 看一下解释是指定外设站点是远端还是目的地参数取值搜索一下。 这里有两个参数啊。 第一个是外设站点作为d s t desitization目的地。 外设站点作为目的地。 其实就是传输方向是存储器到外设站点这样来传输的。 第二个是外设站点作为src source源头。 也就是外设站点到存储器站点的传输方向。 那我们打算是把da放在外设站点。 db放在存储器占点。 传输方向就是外设站点到存储器站点。 所以这里选择第二个参数。 外设站点作为数据源复制放到这里。 这就是传输方向。 接着buffer size转到定义。 看一下。 这里解释是以数据单元指定缓冲区的大小。 这个数据单元等于外设数据宽度或者存储器。 数据宽度取决于传输方向啊。 这句话有点难理解哈。 以数据单元指定缓冲区大小。 就是说你要传送几个数据单元。 这个数据单元等于你传输原端站点的data set。 说简单点就是buffer size。 就是传输计数器哈。 指定传输几次。 这个你可以看一下dma e d函数的源码哈。 这个buff size参数其实就是直接赋值给了传输计数器的计算器。 它的取值是0~6535。 那回到这里。 我们把这个buffer size也提取到函数的参数里。 来加一个uint 16杠t size。 然后把size放到这个buffer size参数这里。 这样传输次数就完成了。 之后mod指定传输进游戏是否要自动重装。 转到定义看一下。 这里解释是指定操作方式。 下面这里是参数取值列表。 然后下面还有一个note注意事项啊。 写的是循环模式。 也就是自动重装哈。 不能应用在存储器到存储器的情况下。 也就是我们上一小节说的自动重装和软件触发不能同时使用。 如果同时使用dma就会连续触发啊。 永远也不会停下来。 那输出参数列表。 这里有两个参数。 第一个是循环模式。 就是传输路由器自动重装。 第二个是正常模式。 就是传输路由器不自动重装。 自检到零后停下来。 这里我们转移数组是存储器的。 存储器的传输转运一次停下来就行了。 所以选择第二个正常模式放到这里之后。 m2 m转到定义。 看一下。 这里解释是dma是否应用于存储器到存储器的。 专业存储器到存储器的模式啊。 就是软件触发啊。 搜索一下参数表。 这里第一个m2 m1 label就是使用软件触发。 第二个disable就是不使用软件触发。 也就是使用硬件触发我们转移数组。 所以选择第一个复制放到这里。 然后继续看最后一个参数。 priority转的定义解释是指定通道的软件优先级。 看一下参数取值表哈。 这里有四个优先级。 第一个是very high。 非常高。 第二个是high高。 第三个是medium中等。 第四个是low低。 这个优先级哈。 如果你有多个通道的话。 可以指定一下。 确保紧急的转运有更高的优先级。 目前一个通道。 那优先级就随便了。 这里就选择一个中等优先级复制放到这里。 这样优先级就配置好了。 好到这里。 这个dma的参数就配置完成了。 这个参数虽然比较多哈。 但是对照着框图来理解的话。 应该还是不难的吧。 那到目前为止。 dma还暂时不会工作。 dma转运有三个条件。 第一个条件传输计数器大于零。 第二个条件触发原有触发信号。 第三个条件dma死人三个条件缺一不可。 目前如果传一个大于零的size的话。 第一个条件满足触发源为软件触发。 所以一直都有触发信号。 第二个条件满足最后一个条件。 dma还没有死人。 第三个条件不满足。 所以到目前为止。 dma还不会工作。 如果你想在初始化之后就立刻工作的话。 可以带着最后加上dma cm d参数。 第一个dm一嵌入一。 第二个label使人dma之后三个条件满足。 dma就会进行数据转运了。 转运一次。 传输计数器质检一次。 当传输路由器减到零之后。 转运完成。 同时第一个条件就不满足了。 转运停止。 这样就完成了一次数组之间的数据转运。 我们现在就可以来试一下看看哈。 那先把这个函数放在头文件声明一下。 然后回到卖点c里面来樱可乐的买dma点去。 然后在主循环之前调用买dma一这些编译一下哈。 要不然没有参数提示。 然后看一下参数。 第一个是原装地址。 这里直接写da给它传入da数组的首地址。 因为数组名就是地址。 所以就不需要再加取地址符号的。 然后强制类型转换转换成uint 32杠t类型的数据。 这样就行了。 之后是db目的地址。 也强制类型转化为ut 32缸体。 最后是传输次数。 这里有四个数据。 所以传输四次。 这样就完事儿了。 当调用完这个函数之后。 dma就会立刻工作。 把da数组的数据转运到db里面去。 那我们用2d显示看一下。 首先转移之前我们显示一下data a和db的内容。 o i d修hx number。 一行一列显示da 0长度为二。 之后复制一下。 一行四列显示da 1。 一行七列显示da 2。 一行十列显示da 3。 这是在第一行显示da的数据哈。 然后继续复制。 显示一下db。 把行号都改成二。 这里给大家介绍一个小技巧。 先按住键盘上的alt键。 然后按鼠标左键进行框选。 这样就可以像这样以方框的形式框选。 如果不按alt键。 那就是一行一行连续的框选。 所以这里可以按住alt键把一框选起来。 然后改成二。 这样改的就非常快哈。 之后data a也都改成b。 这样就是在第二行显示db的数据。 接下来在转移之后。 我们再显示一下da和db。 把显示部分复制下来。 第三行显示转运后的data a。 第四行显示转运后的db。 这样测试程序就完成了。 我们来试一下啊。 编译。 没问题。 下载看一下。 在这个屏幕上。 前两行是转运前的da和db。 可以看到da是1234。 db是0000之后调用买dma elite。 初始化dma。 并且初始化之后就立刻开始了转运。 转运之后可以看到贝塔a和贝塔b的数据都变成了1234。 这说明da的数据成功地转运到了db。 在整个过程中。 原装数据data a是不会变化的。 这就是目前程序的现象。 接着我们继续来写这个代码哈。 现在我们是初始化之后。 立刻就进行转运。 并且转运一次之后。 dma就停止了。 如果da的数据又变化了。 我们想再转运一次。 那该怎么办呢。 这时我们就需要给传输进游戏重新复制了。 我们可以在初始化之后再写一个函数啊。 word买dma transform boy的dma传输函数。 调用一次这个函数就再次启动一次dma转运。 在里面我们需要重新给传输计数器赋值。 传输计数器赋值必须要先给dma私人。 所以这里复制一下dma cm d函数。 把label改成disable。 然后就可以给传输计数器赋值了。 我们看一下库函数。 复制这个dma set current data counter放在这里。 参数第一个是dma y迁入x选择dma和通道。 那我们复制一下上面这个就行了。 第二个是你指定要给传输计数器写入的值。 这里我们需要获取一下初始化这里的size参数啊。 但是它俩不在一个函数。 不能直接传递过来。 所以我们可以在这上面定义一个全局变量。 1t16 杠t买dma size。 然后初始化的时候把塞子往这个全局变量也存一份。 之后在这个函数里就可以使用全局变量的买dma size了。 这样就可以重新给传输机器负责了。 最后再次复制这个cmd函数。 参数给label。 这样dma传输的三个条件又重新满足了。 dma就会再次开始转运。 然后上面这里我们先给dc。 不让dma抽出来之后就立刻进行转运哈。 而是等调用了transform函数之后再进行转运。 调用一次转运一次。 这样来工作。 当然在转运开始之后。 我们还需要做一个工作。 就是等待转运完成。 因为转运也是要花一些时间的哈。 那在这里等待转运完成。 我们可以找一下dma的函数。 复制这个dma get flag state参数。 查看一下标志位。 然后放到这里。 总共就一个参数哈。 转到定义看一下。 这里有这么多的标志位可以查看。 总共就是四种标志位哈。 第一个是全局标志位。 第二个是转运完成标志位。 第三个是转运过半标注为。 第四个是转运错误标注位。 然后所有的通道都是这四种标志位啊。 这里我们需要检查dm一通道一转运完成的标志位。 所以选择这个dm 1 flag tc一参数复制放到这里。 转运完成之后标注位置一。 所以我们需要加一个while循环。 等待这个标志位等于等于reset。 如果没有完成。 就一直循环等等。 这样就实现了等待转运完成的效果了。 标志位置一之后。 不要忘了清除标志位哈。 这个标志位是需要手动清除的。 所以使用这里的dma可莉flag函数放到这里。 参数和上面的一样哈。 这样就行了。 好到这里我们这个模块就全部写完了。 然后我们测试一下。 先把这个transform函数放到头文件声明一下。 然后在b.c里我们来实现这个代码的最终功能。 首先先显示一些基本信息哈。 在这里o l d修正。 一行一列显示da。 复制一下。 三行一列显示一下d下b。 然后再显示一下他们的地址。 看看复制一下oled show hx number。 一行八列显示data a强转为优异的三个杠t。 长度为八。 三行八列。 显示db的地址。 八位好。 这些是基本的信息。 然后显示数据的位置换一下哈。 在第二行显示da的数据。 第四行显示db的数据。 把买dma初始化放在前面。 下面这些先删掉。 现在先看一下现象海编译。 下载看一下。 目前显示的是data a地址是20000002。 现在可能是模块里的那个size变量被分配到了零的位置。 所以这个地址就往后偏移那两个字节。 然后数据是1234贝塔b地址是20000006。 数据是0000。 现在还没有进行数据转运哈。 之后回到代码。 我们在主循环里测试。 先变换一下da的原装测试数据。 都给他们自证一。 之后把显示部分挪到这里。 显示一下da和db。 dna一秒。 看一下转运前的da和db。 然后调用买dma transform函数。 开始转运函数。 执行完成后。 转运就结束了。 然后再复制一下显示函数。 看一下转运后的da和db再低了一秒。 方便观看啊。 这样程序就完成了。 我们编译下载看一下。 可以看到现在的现象就是我们最开始演示的单元函。 da的数据先变换一下。 然后转运db的数据就和data塔a相同的。 这就是dma转移数据的效果。 然后回到代码。 如果你想把flash的数据转运到sram里的话。 可以在这个data a前面加一个const。 把data a定义在flash里面。 那下面这里da加加哈就不能要了。 因为cos的数据不能重新更改。 然后编译下载看一下。 此时可以看到da的地址是零八开头的。 说明da是flash里面的数据。 下面db的数据和data一样。 说明da的数据成功转运到db里面来了。 好这就是第一个程序的全部内容了。 这里先改回来。 编译一下。 那第一个代码dma存储器到存储器的数据转运我们就写完了哈。 接下来我们来写第二个程序a d c加dma应用啊。 先看一下经验图。 打开八杠二dma加d多通道的图片。 这里接线图和上一节a d多通道是一样的哈。 也是pa 0接个电位器。 pa一到pa 3接三个传感器模块的ao输出。 那我们看一下面包板。 这里快速接下线哈。 首先是电位器接在pa 0口。 光敏模块gpa一口。 任命模块。 接pa 2口。 反射红外模块。 接p3 口。 这样就完成了。 接着我们回到工程文件夹这里复制ad多通道的工程。 我们从a d多通道的基础上更改哈。 改个名字叫八杠二dma加ad多通道。 打开工程。 目前这里是ad多通道的代码。 先编一下。 到d.c里面来。 在这里我们给它加上dma转运数据的功能。 那dma的配置都是差不多的哈。 我们回到上一个代码。 把这个dma的初始化部分全部都复制下来。 然后在这里a d c死人之前粘贴。 把这个开启dma始终的函数挪到前面去。 开启时钟我们都放在一起。 那这样我们abc和dma初始化的代码就都有了。 接下来我们来修改一下参数。 把adc和dma给配合起来。 这里代码我们使用的是a d c的扫描模式。 加dma数据转运执行的流程哈。 就是ppt最后一页是这样的。 首先我们要扫描pa 0到pa 3这四个通道。 所以点菜菜单这里复制一下。 放在这里。 复制四份哈。 点四个菜。 其中通道零放在序列一的位置。 然后通道一放在序列二。 通道二放在序列三。 通道三放在序列四。 这样菜单就点好了。 菜单上的1~4号的空位。 我填上了0~3这四个通道。 当然这个通道和秩序哈你可以任意修改。 这样的话最终结果存放的顺序也会相应变化哈。 点菜完成之后继续往下看。 a d c这里扫描模式这个参数要改成label。 告诉厨师我点了多个菜。 你不要只盯第一个菜看。 然后number of 5000 l改成四。 告诉厨师我点的是四个菜。 你看前四个位置就可以了。 连续模式。 这里可以是连续扫描哈。 也可以是单次扫描。 这个我们等会儿都演示一下看看啊。 这里先用单次扫描到这里。 adc扫描模式就配置完成了之后。 我们来配置一下dma。 这里dma你可以想象成服务员a d c这个厨师把菜做好了。 dma这个服务员要尽快把菜端出来。 防止被覆盖。 看一下dma的参数啊。 第一个外设基地址。 这里是端菜的源头。 厨师把菜做好就放在a abc dr计算器里。 所以端菜的源头地址就填abc dr的地址。 之前我们也算过哈。 a d c e的dr寄存器地址就是0x4001244 c。 所以可以这样来填。 不过我们一般都不自己算哈。 因为库函数已经帮我们算好了。 所以这里可以这样写。 a d c一箭头低压取地址。 再强转为int 32杠t。 这样得到的结果其实就是刚才写的4001 24c啊。 那这样外设地址就填好了之后。 数据宽度我们想要低压计算器低16位的数据。 所以数据宽度就是half world。 以半至16位来转移外设地址。 至臻给disable不自增。 始终转运同一个位置的数据。 接下来存储基站点。 存储器基地址。 也就是端菜的目的地哈。 我们想要把数据存在sram数组里。 所以我们先在前面定义一个数组。 116杠t ad value 4。 然后在这里把ad value数组的地址作为目的地。 把数组的地址强度为u30 杠七。 这样就行了。 之后数据宽度也是半自have word。 地址是否是真给able存储器的地址是自增的哈。 每转运一次挪一个坑到这里。 dma的远端和目的地的参数就配置好了。 之后传输方向外设站点是圆没问题。 传输数量给四个。 因为有四个a d c通道。 所以传输四次传输模式。 这个可以给正常的单机模式哈。 也可以给自动重装的循环模式。 这里先给正常模式。 等会可以都试试啊。 然后m2 m要给disable。 不使用软件触发。 我们需要硬件触发触发源为a b c一厨师。 每个菜做好了。 叫我一下。 我再去端菜。 这样才是合适的时机。 最后所有的参数都配置到dm一的通道一里面去。 这里通道就不能任意选择了。 我们看一下ppt的。 这里可以看到adc一的硬件出发是指接在了dm一的通道一上。 所以这里通道必须要使用dv一的通道。 一其他的通道都不行。 接着dma cm d这里可以直接使人哈。 这时dma转运的三个条件。 第一个传输计数器不为零。 满足第三个dma使人满足。 但是第二个触发原有信号目前是不满足的。 因为这里是硬件触发adc还没启动。 不会有触发信号。 所以这里dma死人之后不会立刻工作。 最后在a d c死人之前。 还有一个事情需要做。 就是开启a d c到dma的输出。 这个我们三小节说过哈。 这里有三个硬件出发源。 具体使用哪个取决于把哪个的dma输出给开启了。 那这里我们找一下函数啊。 打开adc.h的库函数。 可以看到这里啊。 有个a b c d m a c m d。 这个函数就是用来开启dma触发信号的复制。 我们把这个函数放到这里。 参数是adc 1 label。 这样就行了。 到目前为止。 adc和dma配合工作的配置就完成了。 接下来看一下下面adc get value参数和返回值都不需要蓝。 函数里面因为现在adc还是单色模式。 所以还需要软件触发一下a abc开始。 其他的不需要了。 因为dma也是正常的单次模式。 所以在触发a d c之前。 需要再重新写入一下传输计数器哈。 我们到这里来复制一下这个代码。 放在启动abc之前。 传输次数给四。 最后等待adc转换和dma转运完成。 这里因为转运总是在转换之后的。 所以我们可以复制一下。 这里等待dma完成的代码。 然后放在这里等待adc转换完成的代码就不需要了。 这样当我们调用一下a d get value函数。 adc开始转换。 连续扫描四个通道。 dma也同步进行转运。 a d c转换结果依次存放在这上面的a d value数组里。 好我们来测试一下。 先把这个get value放在头文件。 声明一下。 另外这个ad value数组我们也放在头文件里声明一下。 把这个数组作为一个外部可调用的数组。 答案数组前面加一个extern。 声明一下啊。 那回到总函数。 把这些删掉。 在主循环里先ad get value。 无参无返回值之后。 数据就直接跑到a d value数组里了。 我们显示一下ad y60 是第一个序列通道零的转换结果。 ad y61 是通道一的结果。 二是通道二。 三是通道三。 这样就完事了。 编译。 没问题。 下载看一下这里四个通道的转换结果就出来了。 测试一下哈。 也都是没问题的。 这就是adc单次扫描加dma单次转运的模式。 那我们还可以配置成a d c连续扫描加d a循环转运的模式。 这样代码就会更加方便。 我们在这里改一下adc连续模式。 打开。 dma循环模式也打开。 最后把adc触发直接放在初始化的最后一行。 当adc触发之后。 a d c连续转换d m a循环转运。 两者一直在工作。 始终把最新的转换结果刷新到s m数组里。 当我们想要数据的时候。 随时去数组里取就行了。 这样最后面的get value函数完全就不需要了。 头文件这里删掉主函数。 这里也删掉主循环。 啥都不干。 直接读取a d y6 数组就能得到结果。 试下看看。 下载。 可以看到这样也可以完成ad多通道转换的功能。 这就是adc连续扫描加dma循环转运的程序代码。 可以看到此时硬件外设已经实现了相互配合和高度的自动化哈。 各种操作都是硬件自己完成的。 极大的减轻的软件负担。 软件什么都不需要做。 也不需要进任何终端。 硬件自动就把活干完了。 另外这里你还可以再加一个外设哈。 比如定时器a b c用单次扫描。 再用定时器去定时触发。 这样就是定时器触发a d c a d c触发d m a整个过程完全自动。 不需要程序手动进行操作。 节省软件资源。 这就是s t m32 中硬件自动化的一大特色啊。 各个外设互相连接。 互相交织。 不再是传统的这样一个cpu单独控制多个独立的外设。 这样的新型结构啊。 而是外设之间互相连接。 互相合作。 形成一个网状结构。 这样在完成某些简单且繁琐的工作的时候。 就不需要cpu来统一调度了。 可以直接通过外设之间的相互配合。 自动完成这些繁琐的工作。 这样不仅可以减轻cpu的负担。 还可以大大提高外设的性能。 在我们之前的学习中。 也经常遇到过这样的设计哈。 比如定时器的输出可以通向a d c d a c或其他定时器。 adc的触发源可以来自定时器或外部中断。 dma的触发源可以来自a d c定时器串口等等。 这就是这个s t m32 外设互相配合工作的特色。 好到这里。 本节课的内容就差不多了哈。 本节课我们演示了dma存储器到存储器。 外设到存储器的情况。 当然还有一个存储器到外设的情况啊。 我们目前还没有讲。 比如串口发送一批数据。 就可以使用dma进行存储器到外设的转运。 这个就留给大家以后自己去研究了哈。 相信你学会了本节课的内容。 再扩展到存储器到外设的应用。 应该也是没问题的哈。 那本节课就到这里。 我们下节再见。
25. hello。 大家好。 欢迎继续观看s t m32 入门教程。 从本节开始。 在s t m32 中集成了很多用于通信的外设模块。 比如这个表里u s a r t i f c s p i can和usb这么多通信接口。 我们这个c8 t6 芯片是全部都支持的。 我们先看一下本节课程序的现象。 本节课共有两个程序。 第一个是串口发送。 第二个是串口发送加接收。 先看一下第一个代码哈。 串口发送。 目前这个代码只有发送的功能啊。 我们。 可以写一个串口的模块。 通过串口通信把一些数据发送到电脑上的串口助手来显示。 大概看一下最终的代码。 在这里先串口初始化。 然后我们会写一些功能函数。 比如串口发送一个字节。 字节数据是0x41 串口发送一个数组。 把这个迈尔瑞数组一起发送出去。 还有串口发送字符串。 发送数字这些函数。 这样就能发送字符串和数字了。 最后这里我还给出了三种实现print f函数的方法。 print f函数我们学c语言经常会用到哈。 它是一个非常强大的格式化打印字符串函数。 在这里我们也可以。 把print f函数移植到串口这里来。 用于向电脑的串口助手打印消息。 那我们下载看一下现象。 看一下htm 32。 这里我们通过这个usb转串口模块。 把s t m32 的串口引脚接到电脑上来之后。 电脑端可以打开串口助手的软件。 选择一下窗口号啊。 其他参数也根据sm 32程序的配置来。 最后打开串口。 按一下s t m32 的复位键。 我们的程序在每次上电之后会通过串口发送一批数据哈。 这里看一下。 第一个是0x41。 也就是程序第一个sbt发送的之后。 0x420 x30 x40 x5。 是这里森。 德尔瑞发送的。 然后下面的这些是发送的文本数据哈。 我们可以切换一下接收模式。 选择文本模式。 再复位一下。 这时软件就会对刚才的数据进行文本映射。 找到每个数据对应的字符啊。 以字符串的形式显示出来。 这样这里显示的就是number一等于一一。 number。 2=2。 二等等。 和我们程序在下面发送的东西是一样的哈。 然后在上面0x4142434445。 这五个数。 它们对应的字符其实就是a b c d e啊。 这就是第一个程序的现象。 串口发送数据到电脑。 那接着继续看第二个程序。 串口发送加接收。 看一下。 这里程序的主体部分是判断是否收到数据。 如果收到数据。 则读取数据。 将数据回传到电脑。 并且也在o l d上显示一下。 这就是第二个程序的功能。 下载看一下。 这里我们打开串口助手啊。 发送模式选择hex模式。 接收模式也选择hex模式啊。 写一个数据四一发送。 可以看到oled上显示了接收到的数据是一。 并且屏幕接收区也收到了四一这个数据。 如果我们把接收模式换成文本模式再发送。 可以看到这就是数据四一对应的字符文本a实际上在串口中啊。 只能发送二进制数。 也就是16进制的最直接的数据啊。 如果想发送字符。 那我们就需要一个数据到字符的映射表。 最简单最常用的映射表就是20克码表。 在20克码表里。 0x41 这个数就映射为字符a所以发送0x41。 如果以hex模式显示。 就是数据本身。 如果以文本模式显示。 它就会先去找一下映射表。 最终发现0x41 对应的是字符a。 所以就显示a了。 这就是hex模式和文本模式的区别。 那到这里程序线下就看完了哈。 接下来我们回到ppt看一下本节课的知识点。 首先我们来了解一下通信接口啊。 先看一下第一条。 我们为什么需要通信。 也就是通信的目的。 它是将一个设备的数据传送到另一个设备扩展硬件系统。 比如这是我们的s t m32 芯片。 它里面集成了很多功能模块。 什么定时器计算。 pwm输出啊。 ad采集等等。 这些都是芯片内部的电路。 这些电路的配置计算器啊。 数据计算器都在芯片里面操作。 这些计算器非常简单。 直接读写就行了。 但是也有些功能是s t m32 内部没有的。 比如我们想要蓝牙无线遥控的功能。 测量姿态的功能。 s t m32 没有。 所以就只能外挂芯片来完成。 那外挂的芯片它的数据都在s t m32 外面。 s t m32 如何才能获取到这些数据呢。 这就需要我们在这两个设备之间连接上一根或多根通讯线。 通过通讯线路发送或者接收数据。 完成数据交换。 从而实现控制外挂模块和读取外挂模块数据的目的。 所以在这里通信的目的是将一个设备的数据传送到另一个设备。 单片机有了通信的功能。 就能与众多别的模块互联。 极大地扩展了硬件系统。 接着第二条就是通信协议。 通信协议的作用是制定通信的规则。 通信双方按照协议规则进行数据收发。 比如说你考试的时候想给别人传答案。 那你就可以和对方约定一个通信协议。 比。 如先咳嗽一声代表重新开始。 然后竖一个手指代表发生a数。 两个手指代表发生b数。 三个手指代表发生c。 然后挥一挥手代表通讯结束。 这样来进行是吧。 这里面就是一种通信方式。 通信的目的是进行信息传递。 双方约定的规则就是通信协议。 当考试作弊是不对的。 还那最后在sm 32里面就有下边这么多的通信协议。 这个表大家先提前了解一下哈。 我们之后学到的时候还会再深入分析的。 另外这个表我只是列了一个最典型的参数啊。 因为各种通信协议应用都非常宽泛。 参数也很多。 所。 以这里我列出的仅是他最常用最简单的配置。 这个说明一下啊。 那我们来看一下第一个uc r t串口。 它的引脚是tx和rx。 有的地方也叫txd和rx d啊。 这两种名称是一个意思啊。 tx是数据发送角。 i x是数据接收角。 然后是fc通信零件是s scl和sda。 scl是始终。 sda是数据s spi。 通信银价是s c l k m o s i m i s o c s s cl k是时钟啊。 m o s i是主机输出数据角。 m i s o是主机输入数据角。 cs是片选用于指定通信的对象。 看通性您就是看h和看l这两个是差分。 数据小哈。 用两个硬件表示。 一个差分数据usb通信银角是dp和dm或者叫d正和d负海。 也是一对差分数据角。 这就是这些通信协议规定的引脚数据。 按照协议的规定在这些引脚上进行输入和输出。 从而实现通信。 接着看一下后面它们的特性。 首先是双攻模式。 这里全双工就是指通信双方能够同时进行双向通信。 一般来说全双工的通信都有两根通讯线。 比如串口一根tx发送一根2x。 接收s p i e跟m o s i发送一根m i s o。 接收发送线路和接收线路互不影响。 全双工。 剩下的这些fc can和usb都只有一根数据线。 看和usb两根差分线也是组合成一根数据线的哈。 所以都是半双工。 当然还有一种方式就是单攻。 单弓是指数据只能从一个设备到另一个设备。 而不能反着来。 比如把串口的x引脚去掉。 那串口就退化成单功了。 然后是时钟特性。 比如你发送一个波形高电平。 然后低电平接收方怎么知道你是一零还是1100呢。 这就需要有一个时钟信号来告诉接收方。 你什么时候需要采集数据。 时钟特性分为同步和异步啊。 这里iphone c和spi有单独的时钟线。 所以他们是同步的。 接收方。 可以在时钟信号的指。 引下进行采样。 剩下的串口看和usb没有时中线。 所以需要双方约定一个采样频率。 这就是异步通信。 并且还需要加一些针头真伪。 等它进行采样位置的对齐。 这是电瓶特性。 上面三个都是单端信号。 也就是他们引脚的高低电平都是对g nd的电压差。 所以单单信号通信的双方必须要供地。 就是把gd接在一起。 所以说这里通信的银件前三个还应该加一个基地。 硬件不接基地是没法通信的哈。 之后看和usb是差分信号。 它是靠两个差分引脚的电压差来传输信号的。 是差分信号。 在通信的时候可以。 不需要鉴定啊。 不过usb协议里面也有一些地方需要单端信号啊。 所以usb还是需要供给的。 使用差分信号可以极大地提高抗干扰特性。 所以差分信号一般传输速度和距离都会非常高哈。 性能也是很不错的。 最后看一下设备特性。 串口和usb属于点对点的通信。 中间三个是可以在总线上挂载多个设备的。 点对点通信。 就相当于老师找你去办公室谈话。 只有两个人直接传输数据就可以了。 多设备就相当于老师在教室里面对所有同学谈话。 需要有一个寻子的过程。 以确定通信的对象。 好通信协议。 和特征我就讲这么多哈。 大家先了解一下。 接下来的内容主要分为两个部分啊。 前半部分我们主要讲的是串口的通信协议。 就是软硬件的规则。 这部分内容与某个具体的硬件无关哈。 在我之前五幺的视频也讲过串口的通信协议。 如果这里讲完还没听懂。 也可以参考一下五一的串口通信啊。 都是一样的。 然后后半部分我们讲的就是s t m3 内部的u s a r t y设。 这个外设的作用就是按照串口协议来产生和接收高低电平。 信号实现串口通信。 那我们先看一下第一部分。 首先看一下串口通信。 串口是一种应用十分广泛的通信接口。 串口成本低。 容易使用通信线路简单。 可实现两个设备的互相通信。 在我们这个单片机的领域啊。 串口其实是一种最简单的通讯接口啊。 它的协议相比较iphone cpi等已经是非常简单的了。 而且一般单片机它里面都会有串口的硬件。 外设使用也是非常方便的。 一般串口都是点对点的重心。 所以是两个设备之间的互相动心。 那下面一句单片机的串口可以使单片机与单片机。 单片机与电脑。 单片机与各式各样的模块互相通信。 其中单片机和电脑通信啊。 是串口的一大优势。 可以接电脑屏幕。 非常适合调试程序。 打印信息。 像iphone c和spi这些一般都是芯片之间的通信啊。 不会接在电脑上。 那有了通信就是极大地扩展了单片机的应用范围。 增强了单片机系统的硬件实力。 这个也不难理解啊。 第一个是usb转串口模块。 上面有个芯片。 型号是c h340。 这个芯片可以把串口协议转换为usb协议。 它一边是usb口。 可以插在电脑上。 另一边是串口的硬件。 可。 以和支持串口的芯片接在一起。 这样就能实现串口和电脑的通信了。 中间这个图是一个陀螺仪传感器的模块啊。 这姿态参数它左右各有四个硬件。 一边是串口的硬件。 另一边是fc的硬件。 右边这个图是蓝牙串口模块。 上面的芯片可以和手机互联。 实现手机遥控单片机的功能。 那这些就是串口通信和一些使用串口通信的模块哈。 好现在模块有了。 我们来看一下硬件电路如何来接这个串口的线。 下面这个图就是串口的接线图啊。 一般。 串口通信的模块都有四个引脚。 vcc tx rx gd。 vc c和jd是供电哈。 tx和rx是通信的。 银角tx和x是单端信号。 他们的高低电平都是相对于gd的。 所以严格上来说。 基地应该也算是同一线啊。 所以串口通信的tx rx gd是必须要解的。 那vcc可以不接。 如果其中一个设备没有供电。 比如这里设备一是s t m32 设备。 那就需要把蓝牙串口的vcc和s t m32 的vcc接在一起。 s t m32 通过这根线。 向右边的子模块供电。 当然供电的电压也需要注意一下啊。 要按照纸模块的要求来。 这就是供电要求。 然后看一下上面这里说明简单双向串口通信。 有两根通讯线。 发送端tx和接收端x这里是简单的串口通信。 复杂一点的串口通信。 还有其他硬件。 比如时钟硬件。 硬件流控制的硬件。 这些银角s tm 32的串口也有哈。 不过我们最常用的还是简单的串口中心。 也就是vc c g n d t x x这四个音响。 然后下一条tx与x要交叉连接。 这个也好理解。 tx是发送。 rx是接收。 那你肯定得是一个设备的发。 送接另一个设备的接收。 一个设备的接收。 接另一个设备的发送。 这样来接线是吧。 这个注意一下。 别记错了。 之后是当只需单向的数据传输时。 可以直接一根通行线。 比如你只需要设备一项设备二的单向通行。 那就可以直接这一根tx的x的线。 另一根就可以不解。 这就变成了单弓的通行方式。 最后当电瓶标准不一致时。 需要加电瓶转换芯片。 串口也是有很多电瓶标准的哈。 像我们这种直接从控制器里出来的信号。 一般都是ttl电平。 相同的电瓶才能互相通信。 不同的电平信号需要加一个电平。 转换芯片转接一下。 那说到电瓶标准。 我们就来看一下串口常用的几种电瓶标准哈。 看一下第一条电瓶标准是数据一和数据零的表达方式。 是传输线缆中人为规定的电压与数据的对应关系。 我们在单片机电路中最常见的是ttl电平啊。 也就是5伏或者3.3伏表示逻辑一。 零符表示逻辑零。 这是我们最多遇到的电瓶标准啊。 但是串口还有一些其他的电瓶标准。 这里了解一下串口常用的电瓶标准有如下三种。 第一种就是最常见的ttl电平。 正3.3伏或者正5伏表示10伏表示零。 这里。 一的电压。 如果你是5伏的期间就是正5伏。 如果是3.3伏的气节。 就是正3.3伏。 逻辑一啊。 就是高电平的电压。 就是vcc的电压。 除了ttl电平串口。 还有rs 232电瓶和rs 485电瓶。 其中2s22 点平的规定是-三到-15伏表示一。 正三到正15伏表示零。 rs 232电瓶一般在大型的机器上使用啊。 由于环境可能比较恶劣。 静电干扰比较大。 所以这里电瓶的电压都比较大。 而且允许波动的范围也很大。 另外还有rs 485点评。 它的规定是两项压差。 正二到正6伏表示一-二到负。 6伏表示零。 这里电瓶参考是两线压差。 所以rs 485的电瓶是差分信号。 差分信号抗干扰能力非常强悍。 使用rs 485电瓶标准通信距离可以达到上千米。 而上面这两种电瓶最远只能达到几十米哈。 再远就传不了了。 这就是串口常用的这几种电瓶标准哈。 像单片机这种低压小型设备使用的都是ttl电平。 我们之后的内容也都是基于ttl电平来讲解的。 如果你做设备需要其他的电瓶。 那就再加电平转换芯片就行了。 在软件层面。 它们都属于串口啊。 所以程序并不会有什么变化。 好到这里串。 口协议的硬件部分我们就清楚了。 在硬件电路上。 协议规定是一个设备使用tx发送高低电平。 另一个设备使用rx接收高低电平。 在线路中使用ttl电平。 因为s t m32 是3.3伏的起点。 所以如果线路对d43.3伏就代表发送了逻辑一。 如果线路对地是零符。 就代表发生了逻辑零。 那现在如何接线。 如何发送一和零我们就知道了。 接下来我们来看一下串口协议的软件部分。 如何用一和零来组成我们想要发送的一个字节数据。 我们看一下下面的这两个时序图哈。 这就是串口发送一个。 字节的格式。 这个格式是串口协议规定的啊。 串口中每一个字节都装载在一个数据帧里面。 每个数据帧都有起始位。 数据位和停止位组成。 这里数据位有八个。 代表一个字节的八位哈。 在右边这个数据帧里面。 还可以在数据位的最后加一个奇偶校验位。 这样数据位总共就是九位。 其中有效载荷是前八位。 代表一个字节校验位。 跟在有效载荷后面占一位哈。 这就是串口数据帧的整体结构。 那我们来看一下串口的参数。 第一个参数就是波特率。 它的用途是规定串口通讯的速率啊。 我们之前说了。 串口一般是使用异步通信。 所以需要双方约定一个通信速率。 比如我每隔一秒发送一位。 那你就也得每隔一秒街头一位。 如果你接收快了。 那就会重复接收某些v。 如果你接收慢了。 那就会漏掉某些微。 所以说发送和接收必须要约定好速率。 这个速率参数就是波特率。 波特率本来的意思是每秒传输码元的个数哈。 单位是马原每秒或者直接叫波特。 另外还有个速率表示叫比特率。 比特率的意思是每秒传输的比特数单位是比特每秒。 或者叫bp s。 在二进制调制的情况下。 一个马云就是一个beat。 啊此时波特率就等于比特率。 像我们单片机的串口中心基本都是二进制调制啊。 也就是高电平表示一。 低电平表示零一位就是一bit的。 所以说这个串口的波特率经常会和比特率混用哈。 不过这也是没关系的。 因为这两个说法的数值相等。 如果是多进制调制。 那波特率就和比特率不一样了。 这个了解一下。 那反映到波形上。 比如我们双方规定波特率为1000bp。 那就表示一秒要发1000位。 每一位的时间就是1ms。 也就是这里这一段时间是1ms。 发送方每隔1ms发送一位。 接收方。 每隔一。 毫秒接收一位。 这就是波特率。 它决定了每隔多久发送一位。 接下来是起始位。 它是标志一个数据真的开始固定为低电平。 我们看一下下面这个波形哈。 首先串口的空闲状态是高电平。 也就是没有数据传输的时候。 硬件必须要制高电平作为空闲状态。 然后需要传输的时候。 必须要先发送一个起始位。 这个起始位必须是低电平来打破空闲状态的高电平。 产生一个下降沿。 这个下降沿就告诉接收设备这一帧数据要开始了。 如果没有提示位。 那当我发送八个一的时候。 是不是数据线就一直都是。 高电平啊。 没有任何波动对吧。 这样接收方怎么知道发送数据了呢。 所以这里必须要有一个固定为低电平的起始位。 产生下降沿来告诉接收设备。 我要发送数据了。 同理在一个字节数据发送完成后。 必须要有一个停止位。 这个停止位的作用是用于数据帧间隔固定为高电平。 同时这个停止位啊也是为下一个起始位做准备的。 如果没有停止位。 那当我数据最后一位是零的时候。 下次再发动新的一帧。 是不是就没法产生下降压了对吧。 这就是起始位和停止位的作用。 起始位固定为零。 产值下降。 沿表示传输开始停止位固定为一把银角恢复成高电平。 方便下一次再下2年。 如果没有数据了。 正好银价也为高电平代表空闲状态。 然后继续看中间的数据位。 这里数据位表示数据真的有效载荷。 一位高电平零为低电平。 低位先行啊。 比如我要发送一个字节是0x0 f那就首先把0f转换为二进制。 就是00001。 然后低位先行。 所以数据要从低位开始发送。 也就是1111万。 像这样依次放在发送银角上。 所以最终银角的波形就是这样的。 所以说如果你想发送0x0 f这一。 个字节数据。 那就按照波特率要求定时翻转引脚电平。 产生一个这样的波形就行了。 好最后看一下校验位。 它的作用是用于数据验证。 是根据数据位计算得来的。 这里串口使用的是一种叫基偶校验的数据验证方法。 奇偶校验可以判断数据传输是不是出错了。 如果数据出错了。 可以选择丢弃或者要求重传。 校验可以选择三种方式啊。 无教养鸡教养和偶教研。 无校验就是不需要校验位。 波形就是左边这个起始位。 数据位。 停止位。 总共三个部分。 基交验和偶校验的波形就是右边这个起始位数据。 位校验位停止位总共四个部分啊。 如果使用了基校验。 比如如果你传输00001111。 目前总共四个一是偶数个。 那么校验位就需要再补一个一。 连同校验位就是000011111。 总共五个亿。 保证一为奇数。 如果数据是00001110。 此时三个一是奇数个。 那么校验位就补一个零。 连同校验位就是000011100。 总共还是三个一。 一的个数为奇数。 发送方在发送数据后会补一个校验位。 保证一的个数为奇数。 接收方在。 接收数据后会验证数据位和校验位。 如果一的个数还是奇数。 就认为数据没有出错。 如果在传输中因为干扰有一位由一变成零或者由零变成一了。 那么整个数据的奇偶特性就会变化。 接收方已验证发现一的个数不是奇数。 那就认为传输出错。 就可以选择丢弃或者要求重传。 这就是基校验的差错控制方法。 如果选择双方约定偶交验。 那就是保证一的个数是偶数。 校验方法也是一样的道理哈。 当然奇偶校验的检出率并不是很高哈。 比如如果有两位数据同时输出奇偶特性不变。 那就校验不。 出来了。 所以奇偶校验只能保证一定程度上的数据校验。 如果想要更高的减除率。 可以了解一下cr c校验哈。 这个校验会更加好用。 当然也会更复杂。 我们这个sm 3 r内部也有cr c的外设。 可以了解一下。 那在这里串口的时序我们就了解了。 最后再说明一下哈。 我们这里的数据位有两种表示方法。 一种是把校验位作为数据位的一部分。 就像下面这个时序一样。 分为八位数据和九位数据。 其中九位数据就是八位有效载荷和一位校验位。 数据位就是有效。 像我上面的描述啊。 就是把数据位和较量位分开描述了。 在串口助手软件里也是用的这种分开描述的方法。 数据为八位。 将验为一位。 总之无论是合在一起还是分开描述。 描述的都是同一个东西啊。 这个应该也好理解。 那最后我们来看几个串口通信的实际波形啊。 看完这些波形。 相信你就能理解串口是如何来传输数据的了。 这些波形我是用示波器实测的哈。 操作方法是把探头的g n d接在负极。 探头。 接在发送设备的tx引脚。 然后发送数据就能捕捉到这些波。 形了。 那我们先看一下第一个波形。 这个波形是发送一个字节数据0x55 50。 在tx引脚输出的波形。 波特率是9600。 所以每一位的时间就是1÷9600。 大概是104微秒哈。 可以看到这里一位就是100微秒。 多一点就是104微秒。 没发送数据的时候是空闲状态。 高电平数据帧开始先发送起始位产生下降。 盐代表数据帧开始哈。 数据0x55 转为二进制。 低位先行。 就是一次发送10101010。 然后这个参数是八位数据。 一位停止无效验。 所以之后就是停止。 位把银角自回高电平。 这样一个数据帧就完成了。 在htm 32中。 这个根据字节数据翻转高低电平。 自由u s a r t外设自动完成的哈。 不用我们操心。 当然你也可以软件模拟产生这样的波形。 那就是定时器定一个104微秒的时间。 时间到之后按照数据真的要求调用gpl rebeat至高低电平。 产生一个和这一模一样的波形。 这样也是可以完成串口程序的tx引脚发送。 就是至高低电平。 那在rx引脚接收显就是读取高低电平了。 这也可以由u s a r t y设自动来完成。 不用我们操心。 如果想要软。 件模拟的话。 那就是定时调用gpl read input data bit来读取每一位。 最终拼接成一个字节。 当然接收的时候应该还需要一个外部中断哈。 在其实为了下降沿触发进入接收状态。 并且对其采样时钟。 然后依次采用八次。 这就是接收的逻辑。 接着看一下下面的波形。 如果发送0x a a波形就是这样的起始位。 然后01010101停止位结束在下面。 如果发送0x f f就是八个一。 那波形就是这样。 其次为八个一。 停止位结束在起始位下降盐之后的一个数据帧的时间内。 这个高电平就是作为数据一来。 看的当数据帧结束后。 这里虽然还是一没有任何变化。 但此时的一已经是属于空闲状态了。 他需要等待下一个下降沿来开启新的一帧数据之后再看下面。 如果发送0x00 就是八个零。 那波形就是起始位八个零。 停止为智慧高电平。 这样来定型。 然后继续看右边的波形。 这里如果把波特率改成4800呢。 也就是波特率变为一半。 那相应的波形时长就会变为原来的二倍。 可以看到这里十位数据总共大概2ms多一点。 具体应该在2.08ms对吧。 那一位就是208微秒。 是之前的二。 倍哈数据波形的时间拉宽。 波形的变化趋势是不变的哈。 之后看下面这个波形。 这里加了一个偶叫燕位。 数据是0x55 数。 下一的个数是四个。 已经是偶数了。 所以输出的校验位是零低电平。 最后看一下停止位的变化。 串口的停止位是可以进行配置的哈。 可以选择一位1.5位。 两位等。 看一下这上面的波形是一位停止位。 连续发送两个0x5。 两个数据真会接在一起。 中间没有空闲状态。 下面这个波形是两位停止位。 连。 续发送两个0x5。 可以看到这里停止位就是两位的宽度。 中间也没有空间状态。 不过这样数据分隔的就更宽一些了。 这就是不同长度停止位的现象。 好到这里。 有关串口协议的硬件和软件就介绍完了。 总结一下就是tx引脚输出定时翻转的高低电平。 rx引脚定时读取引脚的高低电平。 每个字节的数据加上起始位。 停止位。 依次输出在tx硬件另一端。 x引脚依次接收。 这样就完成了字节数据的传递。 这就是串口通信。
26. 了解完串口协议啊。 那接下来我们就来看一下s t m32 的u s a r t y设。 先看一下第一句啊。 u s a r t它的英文全称是这一大串。 直译就是通用同步异步收发器。 这个s就是同步的意思啊。 另外我们经常还会遇到串口叫ua r t。 这里少了个s就是异步收发器。 一般我们串口很少使用这个同步功能哈。 所以u s a r t和u a r t使用起来也没什么区别。 其实这个s t m32 的u s a r t同步模式啊。 只是多了个时钟输出而已。 它只支持时钟输出。 不支持时钟输入啊。 所以这个同步模式更多的是为了兼容别的协议或者特殊用途而设计的。 并不支持两个u s a r t之间进行同步通信。 所以我们学习串口主要还是异步通信。 然后继续看下一条u s a r t4 s t m32 内部集成的硬件外设。 可根据数据计算器的一个字节数据自动生成数据帧时序。 从tx引脚发送出去。 也可自动接收rx引脚的数据帧时序拼接为一个字节。 数据存放在数据进容器里。 看完这局usr t y设是干什么工作的。 就应该了解了吧。 我们之前学习了串口的协议。 串口主要就是靠收发这样的约定好的波形来进行通信的。 那这个usrt外设就是串口通信的硬件支持电路。 usrt大体可以分为发送和接收两部分。 发送部分就是将数据进容器的一个字节数据。 自动转换为协议规定的波形啊。 从tx引脚发送数据。 接收部分就是自动接收rx引脚的波形。 按照协议规定解码为一个字节数据存放在数据计算器里。 这就是u s a r t电路的功能。 当我们配置好了u c r t电路。 直接读写数据进器就能自动发送和接收数据的使用还是非常方便的啊。 接着继续看下一条自带波特率发生器。 最高达4.5兆b次每秒。 这个波特率发生器啊。 就是用来配置波特率的。 它其实就是一个分频器哈。 比如我们a p p2 总线给个72兆赫兹的频率。 然后波特率发生器进行一个分屏。 得到我们想要的波特率。 始终最后在这个时钟下进行收发。 就是我们指定的通信波特率。 然后继续可配置数据位长度。 八或九。 停止位长度0.5或一或1.5或二。 这些就是htm 32 usrt支持配置的参数了。 这个数据位长度就是我们前面这里的参数啊。 有八位和九位是包含奇偶校验位的长度啊。 一般不需要降价位就选八位。 需要降价位就选九位。 停止位长度支持这么多种停止位啊。 也就是这里的在进行连续发送时。 停止位长度决定了针的间隔。 我们最常用的就是一位停止为哈。 其他都很少用。 然后下面就是可选校验位。 无教养鸡叫眼或偶角眼。 有关基偶校验啊。 我们之前也讲过。 这里我们最常用的是无校验。 那以上这些所有的参数啊。 都是可以通过配置进容器来完成的。 使用库函数配置的话就更简单了。 直接给结构体赋值就行。 串口参数啊。 我们最常用的就是波特率9600或者115200。 数据位八位停止位。 移位无教研。 一般我们都选这种常用的参数啊。 不用纠结的选它。 就是那继续看下一条。 支持同步模式。 硬件流控制。 dma智能卡a r d a l i n这个同步模式啊。 就是多了个时钟clk的输出啊。 硬件流控制。 这个是比如a设备有个tx向b设备的rx发送数据。 a设备一直在发。 发的太快了哈。 b处理不过来。 如果没有硬件流控制。 那b就只能抛弃新数据或者覆盖原数据了。 如果有硬件流控制。 在硬件电路上会多出一根线。 如果b没准备好接收就至高电平。 如果准备好了就治低电平。 a接收到了b反馈的准备信号。 就只会在b准备好的时候才发数据。 如果b没准备好。 那数据就不会发送数据。 这就是硬件流控制啊。 可以防止因为b处理慢而导致数据丢失的问题。 硬件流控制s t m32 也是有的哈。 不过我们一般不用需要的话。 可以了解一下之后。 dma是这个串口支持dma进行数据转运哈。 如果有大量的数据进行收发。 可以使用dma转移数据。 减轻cpu的负担。 dma我们上节学过哈。 应该好理解吧。 最后智能卡a r d a l n这些是其他的一些协议哈。 因为这些协议和串口是非常的像。 所以s t m32 就对u s a r t加了一些小改动。 就能兼容这么多协议了。 不过我们一般不用哈。 像这些协议哈。 我也都没用过啊。 这个智能卡应该是跟我们刷的饭卡。 公交卡这些有关的。 arda是用于红外通信的。 这个红外通信就是一个红外发光管。 另一边是红外接收管。 然后靠闪烁红外光通信。 反正我是没见过实物哈。 这个a r d a并不是我们遥控器的那个红外通信啊。 所以并不能模拟遥控器。 l i n是局域网的通信协议。 这个感兴趣的话自己研究一下哈。 我们本节不会用的。 最后看一下我们这个芯片的usat资源。 s t m32 f103 c8 t6 的u s a r t资源。 有u s a r t e u s a r t r u s a r t3。 总共三个独立的usrt外设。 可以挂载很多窗口设备。 其中这里usr t一是a p p2 中线上的设备。 剩下的都是a p p一中线的设备。 这个就开启时钟的时候注意一下哈。 在使用的时候挂在哪个总线影响并不是很大哈。 好那这些就是关于s t m32 内部的usr t外设的总体介绍了。 接下来我们来看一下u s a r t的框图。 这个框图大家第一眼看上去还是非常复杂的是吧。 线路框框啊。 这个还是挺多的。 但是实际上主要部分也没有很多哈。 他这里就是把各个寄存器和寄存器每一位控制的地方都画出来了。 所以才显得比较乱。 我们看的时候可以先忽略这些计算器哈。 先看主体结构。 那我们来看一下。 先看左上角这里的银角部分。 这里有tx和2x这两个就是发送和接收硬件。 下面这里的s w r x a da out in啊。 这些是智能卡和i da通信的硬件。 我们不用这些协议哈。 所以这些银角就不用管了。 右边这个框框a da si这些东西也都不用管了哈。 银角这块tx发送角就是从这里接出去的。 2x接收角就是通向这里。 这样就行了。 然后看一下右边这一块。 这部分就是串口的数据计算器了。 发送或接收的字节数据就存在这里。 上面只有两个数据计算器。 一个是发送数据计算器t d r。 另一个是接收数据计算器r d r这两个计算器占用同一个地址哈。 就跟五一单片机串口的s b o f计算器一样。 在程序上只表现为一个计算器。 就是数据计算器低压。 但实际硬件中是分成了两个计算器哈。 一个用于发送t d r。 一个用于接收r d r。 t d r是只写的。 r d r是只读的。 当你进行写操作时。 数据就写到了t d r。 当你进行读操作时。 数据就是从r d r读出来的。 这个了解一下。 然后往下看。 下面是两个移位寄存器。 一个用于发送。 一个用于接收。 发送一位进器的作用就是把一个字节的数据一位一位的移出去。 正好对应串口协议的波形的数据位。 这两个计算器是怎么工作的呢。 举个例子哈。 比如你在某时刻给t dr写入了0x55。 这个数据在计算器里就是二进制存储。 01010101。 那么此时硬件检测到你写入数据了。 他就会检查当前移位寄存器是不是有数据正在移位。 如果没有这个01010101就会立刻全部移动的。 发送一位净水器准备发送。 当数据从t加移动到移位寄存器时。 会置一个标志位。 叫tx e发送进容器空。 我们检查这个标志位。 如果自一了。 我们就可以在t d r写入下一个数据了。 注意一下。 当tx e标志位置一时。 数据其实还没有发送数据。 只要数据从t d r转移到发送移位寄存器来。 t x g就会自己。 我们就可以写入新的数据来。 然后发送移位寄存器就会在下面这里的发送器控制的驱动下向右移位。 然后一位一位地把数据输出到tx引脚。 这里是向右移位的哈。 所以正好和串口协议规定的低位先行是一致的。 当数据移未完成后。 新的数据就会再次自动的从tdr转移到发送移位寄存器里来。 如果当前移位寄存器移位还没有完成。 tdr的数据就会进行等待。 一旦一未完成就会立刻转移过来。 有了tdr和移位计算器的双重缓存哈。 可以保证连续发送数据的时候。 数据帧之间不会有空闲。 提高了工作效率。 简单来说就是你数据一旦从t dr转移到移位寄存器了。 管理有没有一未完成。 我就立刻把下一个数据放在t d r等着。 一旦移完了。 新的数据就会立刻跟上。 这样做效率就会比较高对吧。 然后看一下接收端。 这里也是类似的数据。 从rx引脚通向接收一未定器。 在接收器控制的驱动下。 一位一位的读取x电瓶先放在最高位哈。 然后往右移一位。 八次之后就能接收一个字节了。 同样因为串口协议规定是低位先行。 所以接收移位寄存器是从高位往低位这个方向移动的之后。 当一个字节一未完成之后。 这一个字节的数据就会整体的一下子转移到接收数据。 进入其2d2 d来。 在转移的过程中也会置一个标志位啊。 叫rx n e接收数据进行器飞控。 当我们检测到rx ne字一之后。 就可以把数据读走了。 同样这里也是两个计算器进行缓存。 当数据从一位容器转移到2d时。 就可以直接一味接收下一帧数据了。 这就是usrt外设整个的工作流程。 其实讲到这里。 这个外设的主要功能就差不多了哈。 大体上就是数据运算器和移位计算器。 发送一位计算器往tx应叫移位。 接收一位积分器从tx应叫1v。 当然发送还需要加上针头真伪啊。 接收还需要剔除针头针尾啊。 这些操作它内部有电路会自动执行函。 我们知道有硬件帮我们做了这些工作就行了。 接着我们继续看一下下面的控制部分和一些其他的增强功能啊。 下面这里是发送器控制。 它就是用来控制发送一位计数器的工作的。 接收器控制。 用来控制接收一位计数器的工作。 然后左边这里有一个硬件数据留空。 也就是硬件流控制哈。 简称留空。 前面我们也大概介绍过哈。 如果发送设备发的太快。 接收设备来不及处理。 就会出现丢弃或覆盖数据的现象。 那有了留空就可以避免这个问题了。 这里留空有两个硬件。 一个是n r t s。 一个是n c t s。 n r t s是请求发送。 是输出角。 也就是告诉别人我当前能不能接受n c t是清除发送。 是输入角。 也就是用于接收别人n r t s的信号的。 这里前面加个n意思是低电平有效哈。 那这两个硬件怎么玩的呢。 首先得找另一个支持流控的串口。 他的tx接到我的2x。 然后我的rtx要输出一个能不能接受的反馈信号。 接到对方的cts。 当我能接受的时候。 rt就是低电平请求对方发送对方的cds。 接收到之后就可以一直发哈。 当我处理不过来时。 比如接收数据进器我一直没有读。 又有新的数据过来了。 现在就代表我没有及时处理。 那rt就会制高电平。 对方cts接收到之后就会暂停发送。 直到这里接收数据。 净水器被读走。 rt字体电平新的数据才会继续发送。 那反过来当我的tx给别人发送数据时。 我们c t就要接到对方的i t用于判断对方能不能接受。 tx和c t s是一对的哈。 r x和r t s是一对的。 c t s和r t s也要交叉连接哈。 这就是留控的工作模式。 当然我们一般不使用流控哈。 所以留空就了解一下就行。 接着继续看右边这个模块。 这部分电路用于产生同步的时钟信号。 它是配合发送一位计数器输出的哈。 发送计算器每一位一次同步时钟电瓶就跳变一个周期。 始终告诉对方啊。 我移出去一位了。 你看要不要让我这个时钟信号来指导你接收一下。 当然这个始终只支持输出哈。 不支持输入。 所以两个usat之间不能实现同步的串口通信。 那这个时钟信号有什么用呢。 第一个用途就是兼容别的协议。 比如串口加上时钟之后。 就跟s spi协议特别像。 所以有了时钟输出的串口就可以进入s p i。 另外这个时钟也可以做自适应波特率哈。 比如接收设备不确定发送设备给的是什么波特率。 那就可以测量一下这个时钟的周期。 然后再计算得到波折率。 不过这就需要另外写程序来实现这个功能了。 这个时钟功能我们一般不用。 所以也是了解一下执行。 然后继续看中间这个唤醒单元。 这部分的作用是实现串口挂载多设备。 我们之前说啊。 串口一般是点对点的通信。 点对点只支持两个设备互相通信。 想发数据直接发就行。 而多设备在一条总线上可以接多个重设备。 每个设备分配一个地址。 我想跟某个设备通信。 就先进行寻址。 确定通信对象。 再进行数据收发。 那回到这里。 这个唤醒单元就可以用来实现多设备的功能。 在这里可以给串口分配一个地址。 当你发送指定地址时。 此设备唤醒开始工作。 当你发送别的设备地址时。 别的设备就换新工作。 这个设备没收到地址就会保持沉默。 这样就可以实现多设备的串口中心了。 这部分功能我们一般不用哈。 大家也了解一下就行。 接着看下面这部分是中段输出控制。 中段申请位啊。 就是状态金容器这里的各种标注位。 状态兼容器。 这里有两个标志位比较重要哈。 一个是tx e发送计算器空。 另一个是2x n e接收计算器非空。 这两个是判断发送状态和接收状态的必要标注为刚才也都讲过哈。 剩下的标志位了解一下就行。 中段输出控制。 这里就是配置中断是不是能通向n v i c。 这个应该好理解哈。 然后最下面这里是波特率发生器部分。 之前我也大概说过哈。 波特率发生器其实就是分屏器。 app时钟进行分屏。 得到发送和接收移位的时钟。 看一下这里时钟输入是f p c l k x x等于一或二。 usr t一挂载在app 2。 所以就是pcl k2 的时钟一般是72兆。 其他的usr t都挂载在a b b1。 所以是pcl k一的时钟一般是36兆哈。 之后这个始终进行一个分屏。 除一个usr t div的分屏系数。 u s r t d v里面就是右边这样哈是一个数值。 并且分为了整数部分和小数部分。 因为有些波特率啊。 用72兆除一个整数的话。 可能除不尽会有误差。 所以这里分频系数是支持小数点后四位的分屏就更加精准哈。 之后分配完之后还要再除个16。 得到发送器时钟和接收器时钟通向控制部分啊。 然后右边这里如果t一为一。 就是发动机死了。 发送部分的波特率就有效。 如果r e为一。 就是接收气势了呢。 接收部分的波特率就有效。 好到这里。 我们这个串口的主体结构就看完了。 然后剩下还有一些计算器的指示哈。 比如各个cr控制计算器的哪一位控制哪一部分电路。 s r状态进容器都有哪些标志位。 这些可以自己看看手册里的计算器描述哈。 那里的描述比这里清晰很多。 最后我们再看看串口的引脚。 我们看一下引脚定义表哈。 这里复用功能这一栏就给出了每个u s a r t。 它的各个银角都是复用在了哪个gpo上的。 比如这里usr t2 的tx是pa 2口。 2x是pa 3口u s a r t3 的tx和x分别是pb 10和p b 11。 然后u s r t一的t x和x分别是p a9 和p a 10。 这些银角都必须按照银角定义里的规定来看。 比如你要使用u s r t1。 那t x必须是p a9。 x必须是pa 10。 或者看一下重映射。 这里啊有没有重映色。 这里有u s r t一的重新设。 所以有机会换一只口。 剩下的银角就没有机会做u s a r t一的接口了。 所以这个表在设计电路的时候很重要哈。 要提前规划好银角。 别让引脚复用功能冲突了。 有关外设的复用银角是哪个的问题。 都是看这个表盘。 一看就知道这就是串口的银角。 接下来回到p p t继续来看啊。 这里看一下我给出的这个简化结构图。 这就是u s r t最主要最基本的结构哈。 最左边这里是波特率发生器。 用于产生约定的通信速率。 时钟来源是p c lk 2或一经过波特预发器分屏后产生的。 始终通向发送控制器和接收控制器。 发送控制器和接收控制器用来控制发送移位和接收移位。 之后由发送数据计算器和发送一位计算器。 这两个计算器的配合。 将数据一位一位的移出去。 通过gpl口的复用输出输出到tx引脚。 产生串口协议规定的波形。 这里画了几个右移的符号函。 就是代表这个移位寄存器是往右移的。 是低位先行。 当数据由数据运气转移到一位计算器时。 会制一个tx e的标志。 为我们判断这个标志位就可以知道是不是可以写下一个数据了。 然后接头部分也是类似的哈。 i x引脚的波形通过gp l口输入。 在接收控制器的控制下。 一位一位地移入接收一位计数器。 这里画了右移的符号啊。 也是右移的。 因为是低位限行。 所以要从左边开始挤进来。 1万亿帧数据后。 数据就会统一转运到接收数据。 计算器。 在转移的同时。 自一个2x n e标志为我们检查这个标志位。 就可以知道是不是收到数据的同时。 这个标志位也可以去申请中断哈。 这样就可以在收到数据时直接进入中断函数。 然后快速的读取和保存数据。 那右边这实际上有四个计算器哈。 但是在软件层面只有一个低压计算器可以供我们读写。 写入dr时数据走上面这条路进发送。 读取dr时数据走下面这条路进接收。 这就是usrt进行串口数据收发的过程。 最后右下角是一个开关控制。 就是配置完成之后用cmd开启一下外设啊。 这个也是常规操作了。 那到这里usa r t的基本结构就讲完了。 接下来我们来看几个细节的问题哈。 首先看一下数据帧。 这个图是在程序中配置八位置长和九位置长的波形对比。 这里的字长啊。 就是我们前面说的数据位长度。 它这里的日常是包含校验位的。 是这种描述方式。 那看一下上面这个九位日常的波形。 第一条时序很明显就是tx发送或者接收的数据帧格式空弦高电平。 然后其实为零。 然后根据写入的数据啊。 字一或自零依次发生为零到v8 加起来就是九位。 最后停止为一。 数据帧结束。 在这里v8 也就是第九个位置哈。 是一个可能的奇偶校验位。 通过配置净水器就可以配置成鸡叫眼。 偶胶眼或者无效眼。 这里可以选择配置成八位有效载荷。 加一位校验位。 也可以选择九位。 全都是有效载荷哈。 不过既然你选择了酒味日常。 那一般都是要加上椒盐味的。 因为八位有效再喝正好对应一个字节是吧。 然后下面这个时钟就是我们之前说的同步时钟输出的功能。 可以看到啊。 这里在每个数据位的中间都有一个时钟上升沿。 时钟的频率和数据速率也是一样的。 接收端可以在时钟上升沿进行采样。 这样就可以精准定位每一位数据。 这个始终的最后一位哈。 可以通过这个lb cl位控制要不要输出。 另外这个时钟的极限啊。 相位啊什么的。 也可以通过配置寄存器配置啊。 需要的话可以了解一下。 然后下面这两个波形。 一个是空弦针。 就是从头到尾都是一。 还有一个是断开针。 从头到尾都是零。 这两个数据帧啊。 是局域网协议用的哈。 我们串口用不着不用管的。 接着下面是八位之上的波形。 可以看到这里的数据位是从未零。 一直到v7。 总共是八位哈。 比上面这个少了一个v8。 同样这个最后一位为七。 也是一个可能的奇偶校验位还是同样啊。 既然你选择了八位之上。 那这里就最好选择无校验。 要不然你降压位占位。 有效载荷就只剩七位了。 一个字节都发不了。 这不逼死强迫症吗。 总的来说。 这里有四种选择。 九味之长有交验或无交验。 八位之长有交验或无交验。 但我们最好选择九味之长。 有交盐或八位智商无教养这两种啊。 这样每帧的有效载荷都是一字节。 这样才舒服是吧。 那最后这些时钟什么的和上面也都是类似的哈。 大家自己看看就明白了。 接下来我们继续来看这个数据帧。 看一下不同停止位的波形变化。 s t m32 的串口啊。 可以配置停止位长度为0.511.52。 这四种这四种参数的区别啊。 就是停止位的时长不一样。 对应波形啊。 就是这样。 第一个是一个停止位。 这时停止位的时长就和数据位的一位啊时长一样。 然后是1.5个停止位。 这时的停止位就是数据位移位时长的1.5倍哈。 两个停车位。 那停止位时长就是两倍。 0.5个形之位时长就是0.5倍。 这个也好理解啊。 就是控制停止位时长的。 一般选择一位停止位就行了哈。 其他的参数不太常用。 这个是停止位。 那之后我们继续来看一些细节问题啊。 这两个图展示的是usrt电路输入数据的一些策略。 对于串口来说。 根据我们前面的介绍啊。 可以想到串口的输出tx应该是比输入2x简单很多。 输出理由定时发展tx引脚高低电平就行了。 但是输入就复杂一些。 你不仅要保证输入的采样频率和波特率一致。 还要保证每次输入采样的位置要正好处于每一位的正中间。 只有在每一位的正中间采样。 这样高低电平读进来才是最可靠的。 如果你采样点过于靠前或靠后。 那有可能高低电平还正在翻转哈。 电瓶还不稳定。 或者稍有误差。 数据就采用错了。 另外输入最后还要对噪声有一定的判断能力。 如果是噪声。 最好能自个标志位提醒我一下。 这些就是输入数据所面临的问题哈。 那我们来看一下htm 32是如何来设计输入电路的。 首先第一个图这里展示的是usr t的起始位侦测。 当输入电路侦测到一个数据真的起始位后。 就会以波特率的频率啊。 连续采样一帧数据。 同时从起始位开始。 采样位置就要对齐。 到位的正中间。 只要第一位对齐了。 后面就肯定都是对齐的啊。 那为了实现这些功能。 首先输入的这部分电路对采样时钟进行了细分啊。 它会以波特率的16倍频率进行采样。 也就是在移位的时间里可以进行16次采样。 然后它的策略是最开始空闲状态高电平。 那采样就一直是一在某个位置突然踩到一个零。 那么就说明在这两次采样之间出现了下降沿。 如果没有任何噪声。 那之后就应该是起始位了。 在起始位会进行连续16次采样。 没有造成的话。 这16次采样肯定就都是零啊。 这没问题。 但是实际电路还是会存在一些造成的。 所以这里即使出现下降眼呢。 后续也要再采样机制。 以防万一哈。 那根据手册的描述。 这个接收电路还会在下降沿之后的第三次五次七次进行一批采样。 在第八次九次十次再进行一批采样。 且这两批采样都要要求每三位里面至少应该有两个零。 如果没有造成。 那肯定全是零哈。 满足情况。 如果有一些轻微的噪声。 导致这里三位里面只有两个零。 另一个是一。 那也算是检测到了70位啊。 但是在状态进容器里会自一个n e噪声标志位。 就是提醒你一下数据我是收到了。 但是有噪声。 你悠着点用啊。 如果这里三位里面只有一个零。 那就不算监测到了70v。 可能前面那个下降沿是造成导致的。 这时电路就忽略前面的数据。 重新开始捕捉下降沿。 这就是s t m32 的串口在接收过程中对噪声的处理啊。 如果通过了这个其实为侦测。 那接收状态就由空弦变为接收起始位。 这样就能保证采样位置在位的正中间了。 这就是起始位侦测和采样位置对齐的策略啊。 那紧跟着我们就可以看这个数据采样的流程呢。 这里从一到16是一个数据位的时间长度。 在一个数据位有16个采样时中。 由于起始为侦测已经对齐了采样时钟哈。 为了保证数据的可靠性啊。 这里是连续采样三次没有造成的。 理想情况下。 这三次肯定全为一或者全为零。 全为一就认为收到了一。 全为零就认为收到了零。 如果有噪声导致三次采样不是全为一或者全为零。 那它就按照二比一的规则来啊。 两次为一就认为收到了一。 两次为零。 就认为收到了零。 在这种情况下。 噪声标志位n e也会质疑哈。 告诉你我收到数据了。 但是有噪声。 你有这点用。 这就是检测噪声的数据采样。 可见s t m32 对这个电路的设计考虑还是很充分的。 那最后我们再来看一下波特率发生器。 波特率发生器就是分屏器哈。 看一下发射器和接收器的波特率。 由波特率寄存器br里面的div确定。 下面这个图就是b i计算器里面就是分频系数。 div div分为整数部分和小数部分。 可以实现更细腻的分屏啊。 那波特率和分频系数的关系可以由这个计算公式进行计算。 波特率等于p c lk 2或一的时钟频率除以16倍的div。 为什么这里多个16。 看上面这个图就明白了吧。 因为它内部还有一个16倍波特率的采样时钟。 所以这里输入时钟除以diy要等于16倍的波特率。 最终计算波特率自然要多出一个16了。 举个例子啊。 比如我要配置usr d一为9600的波特率。 那如何配置这个b i计算器呢。 我们代入公式啊。 就是9600等于u s a r t一的始终是72兆除16倍的div。 记得啊d i v等于72兆除以9600÷16。 然后可以用计算器算一下。 72兆除9600÷16。 最终等于468.75哈。 这是一个带小数的分频系数。 最终写的计算器还需要转换成二进制函。 这个win 10的计算器居然不支持带小数的金额转换哈。 那我们就从网上随便找个进制转换器啊。 输入十进制的468.75转换成二进制。 最终得到二进制数是111010100.11。 所以最终写的这个计算器就是整数部分为11010100。 前面多出来的补零小数部分为一一。 后面多出来的布林。 这就是根据波特率写bi计算器的方法了解一下。 不过我们用库函数配置的话就非常方便。 需要多少波特率直接写就行了。 库函数会自动帮我们算好。 到这里我们这个p p t的内容就讲完了哈。 最后我们再看两个手册。 先看一下这个usb转串口模块的原理图。 这个图展示的就是我们套件里usb转串口模块的内部电路图。 这里还有几点注意事项。 还需要跟大家说明一下。 大概看一下最左边这里是usb的端口。 usb有四根线。 gd低正低负vcc。 usb标准供电是5伏哈。 然后中间低正和低负是通信线走的。 也是usb协议。 所以这里需要加一个c h340 芯片转换一下。 转换之后输出的就是txd和xd是串口协议。 最后通过这里的排针引出来。 那需要注意的就是这边的供电策略。 首先所有的店都是从这个vcc正五服来的。 然后vcc正5伏通过这个稳压管电路进行稳压哈。 得到vcc正3.3伏之后。 vcc正5伏和vcc正3.3伏都通过排针引出来了。 所以这个第六角和第四角是分别由5伏和3.3伏输出的哈。 那很多人迷惑的是。 这个第五角板子上标的是vc c这个硬件。 通过原理图可以看到哈。 它是通向了c h340 芯片的vcc上。 所以这个第五角实际上是c h340 的电源输入角。 一般我们这个模块的排针会有个跳线帽哈。 这个跳线帽需要插在四五角或者五六角上。 右边这里也有文字说明啊。 短路5伏到vc c c区340供电为5伏。 ttl电平为5伏。 短路3v3 到v c c c h3 至零的供电为3.3伏。 ttl电平为3.3伏。 所以这个跳线帽是用来选择通信电瓶的哈。 也是给c h340 芯片供电的。 所以最好不要拿掉。 如果你拿掉了。 就相当于这整个芯片没有供电。 不过神奇的是哈。 我试了一下。 即使把跳线帽拔掉。 不给芯片供电。 这个窗口还是能正常工作啊。 可能是从别的地方汲取的一些电流吧。 当然还有可能是别的原因。 我观察了一下啊。 我们这个模块的电路是有些变动的。 如果不插跳线帽。 我测试了哈。 通信电平为3.3伏。 不过为了稳定。 最好还是要插上天线包哈。 那我们sdm 32通信需要3.3伏。 所以把跳线帽插在这里的四五角上就行了。 那供电就只剩一个五俯角了。 所以这个供电有点折磨人哈。 要么选择5伏电瓶。 剩下供电角就只有3.3伏。 要么选择3.3伏电瓶。 剩下供电角就是5伏。 所以这个供电点的设计有点不太方便哈。 不过考虑到电瓶的5伏和3.3伏可以互相兼容。 所以如果你既需要通信又需要供电。 那就保证供电是正确的就行了。 通信亮屏没法一致。 这应该也没问题啊。 然后右边还有银角说明看一下哈。 5伏角是从usb取出来的。 5伏电源输出。 vcc是模块供电点。 3v3 是模块稳压出来的3.3伏电源输出。 txd串口数据输出。 xd串口数据输入。 gd模块负极。 这就是这些引脚说明。 最后右下角这是指示灯和电源滤波哈。 这里有pw电源指示灯和txd xd的指示灯。 如果鹰角上有数据传输。 这两个指示灯会对应闪烁哈。 方便我们观察。 这就是这整个模块的内部电路图哈。 大家了解一下。 最后我们再大概过一下这个参考手册函。 第25章通用同步异步收发器。 前面是他的一些介绍和主要特征哈。 肉制框图。 这些都可以再仔细看看。 然后是功能描述。 这些就是我p p t上介绍的那几个细节哈。 这个图描述的就是数据真格。 适合日常配置。 下面有发送器可配置的停止位。 之后单字解通信。 这里描述的就是t dr和移位进器的配合哈。 更多细节可以再看看这里的描述。 接着下面就是接收部分了。 其实为侦测字符接收。 这里是rdr和一位金属器的配合。 也可以再看看。 然后是造成错误。 这也是接收数据位的逻辑哈。 有关采样值造成状态接收到位和数据有效性。 这个表就非常清晰了。 三次采样不一致。 就是有噪声啊。 再之后就是分数波特率的产生。 这里有计算公式和例子哈。 然后是接收器容忍时钟的变化。 这个随便看看就行了。 然后这是多主机通信。 这些配置可以支持串口进行多设备的通信啊。 这个看看就行了。 然后是降压位控制。 降压位是怎么执行的。 在这里有说明哈。 之后局域网模式这个不用看。 同步模式。 这就是多了一个时钟输出啊。 这里有些图意思。 就是可以配置这个时钟的急性相位什么的。 然后单线半双工智能卡。 这些都不用看。 da也不用看。 之后是利用dma连续通信。 如果利用dma的需求。 可以看看这部分。 我们暂时不用。 然后硬件流控制。 这里描述的就是rt和c t这两个引脚的用途。 需要的话看一下哈。 我们暂时不用。 然后串口的中段。 这就是一些标志位和对应的中段输出哈。 usrt模式配置。 这是一个资源表哈。 也就是我们之前说的那些功能。 并不是每个u s r t都支持的。 哪个支持哪个不支持。 看一下这个表就知道了。 这里可以看到这个4号和5号不支持同步的功能。 所以他们的名字就直接叫uv t了哈。 那到这儿功能描述部分就结束了。 之后就是继承性描述了第一个状态。 结算机s2 里面都是各种标志位啊。 我们获取各种硬件执行状态都是通过这些标志位来实现的。 然后是数据用起d啊。 这个我们刚才也详细分析过哈。 然后波特率计算器配置计息cr其实计算器也是有几个经典的分类状态。 进容器sr存放各种标志位数据进器dr存放最关键的数据配置。 净水器cr存放各种配置参数。 这三类净水器基本每个外设都有哈。 然后剩下的就是一些零碎的计算器了。 最后是计算器的总表。 好到这里。 有关u i c i t的理论部分就结束了。 我们下小节来写串口的代码哈。 那么下小节再见。
27. 接下来我们来学习一下串口的代码部分啊。 先看一下接线图。 九杠一串口发送。 看一下。 下面这个是我们的usb转串口的模块哈。 这里有个跳线帽。 上集也说过。 要插在vcc和3v3 这两个引脚上。 选择通信的ttl电平为3.3伏。 然后通讯银角tx d和rx d要接在s t m32 的p a9 和pa 10口。 为什么是这两个口呢。 我们看一下引脚定义表哈。 这里看到ui c a r g e的tx是pa 9。 rx是pa 10。 我们计划用usr t一进行通信。 所以就选这两个家。 如果你用usr t2 或三的话。 就要在这里找一下。 接在usr t2 或三的对应角上。 然后是tx和x交叉连接。 这边一定要注意哈。 别接错了。 这里p a9 是s t m32 的tx发送。 在经验图这里接的就是串口模块的xd接收。 然后串口模块的tx e发送要接在s t m32 的pa 10。 也就是rx接收y。 然后两个设备之间要把负极接在一起进行供地啊。 一般多个系统之间互联都要进行供地啊。 这样电瓶才能有高低的参考。 就像两个人比身高一样。 他俩必须要站在同一地平面上才能比较。 如果一个人站在地球。 一个人站在月球。 那怎么知道谁高谁低呢。 对吧。 这就是共地的问题。 最后这个串口模块和st link都要插在电脑上。 这样s t m32 和串口模块都有独立供电。 所以这里通信的电源正极就不需要接了。 直接三根线就行。 当然我们第一个代码只有sm 3发送的部分。 所以通信线只有这个发送的有用。 另一根线第一个代码没有用到哈。 暂时可以不接。 在我们下一个串口发送加接收。 的代码。 两根通讯线就都需要接了。 所以我们把这两根通讯线一起都接上吧。 这样两个代码的经验图是一模一样的。 那我们看一下面包板。 接一下电路啊。 首先拿出串口模块。 确保跳线帽是插在vcc和3v3 引脚上的。 如果不是的话。 就把跳线帽拔下来。 换到这个位置啊。 然后用三根公对母的杜邦线。 把下面这三根引脚引出来。 在面包板这里。 棕色是串口模块的基地。 接到电源负极。 红色是串口模块的xt。 接到pa 9对应sm 32的tx。 橙色是串口模块的tx d接到p 10对应s t m32 的2x。 这样接线就完成了。 然后把这两个usb口全都插在电脑上。 我这里电脑usb口不够哈。 所以就用那个usb扩展坞。 那这样硬件电路就完成了。 然后我们回到电脑端。 先右键此电脑属性。 打开设备管理器。 确保串口的驱动没问题啊。 在这个端口目录下可以看到有这个cg 340的驱动。 如果出现了com号。 并且前面图标没有感叹号。 那就证明串口驱动没问题。 否则的话需要安装一下串口模块的驱动哈。 这个我们在第二节软件安装那个视频有介绍。 不会装驱动的。 可以回去看一下好。 那我们回到工程目录。 复制一下oled的工程。 改个名字叫九杠一串口发送。 打开工程。 这些删掉哈。 编一下。 然后我们给串口建个模块。 模块名字叫siri。 模块建好之后。 老规矩上来先写一个初始化函数啊。 word serial it。 我的。 初始化的流程。 看一下这个基本结构图。 第一步。 开启时钟。 把需要用的usr t和gpu的时钟打开。 第二步。 gp i o初始化。 把tx配置成复用输出。 rx配置成输入。 第三步配置usrt直接使用一个结构体。 就可以把这里所有的参数都配置好了。 第四步。 如果你只需要发送的功能。 就直接开启u s r t初始化就结束了。 如果你需要接收的功能。 可能还需要配置中断。 那就在开启usd之前。 再加上it configure和nvc的代码就行了。 整个初始化流程非常中规中矩哈。 每个函数大家应该都已经很熟悉了吧。 得益于库函数的封装。 内部各种细节问题就不需要我们再关心了。 那初始化完成之后。 如果要发送数据。 调用一个发送函数就行了。 如果要接收数据。 就调用接收的函数。 如果要获取发送和接收的状态。 就调用获取标志位的函数。 这就是uc r t外设的使用思路哈。 那我们回到代码先看一下库函数里面都有哪些库函数吧。 我们找一下uc r t.h的文件。 拖到最后这里函数一眼看上去还是挺多的是吧。 但是这里面很多都是那些增强功能和兼容其他协议的函数哈。 我们都不会用的。 真正常用的其实很少。 我们来看一下d1 d1 d struck的一it这些不用说。 clock it和clock struck elite。 这两个函数是用来配置同步时钟输出的哈。 包括始终是不是要输出始终的极性啊。 相位啊等参数。 因为参数也比较多哈。 所以也是用结构体这种方式来配置的。 需要时钟输出的话。 可以了解一下这两个函数。 然后cmd it configure这些也不用说。 uc r t d m a s m d这个可以开启uc r t到dma的触发通道。 需要用dma的话可以了解一下。 然后下面一段设置地址唤醒l n这项函数啊。 我们都不用。 最后这两个函数比较重要。 ser data发送数据。 receive data。 接收数据。 这两个函数在我们发送和接收的时候会用到哈。 send data就是写dr计容器。 receive data就是读dr金容器。 第二季容器内部有四个金融期哈。 控制发送与接收执行细节。 我们上一小节已经分析过了。 这里程序上就非常简单了。 写dr就是发送。 读dr就是接收。 至于怎么产生波形。 怎么判断输入软件一概。 不管哈。 然后继续这里大段函数。 什么智能卡i da啊。 我们也都不用不用看的。 最后四个标志位相关的函数。 这个也不用说哈。 所以总结下来我们用的函数非常少哈。 而且都是常见函数。 那我们回到初始化这里来写一下代码。 第一步开启时钟r c c a b2 外设时钟控制r c c a b b2 外设。 usd 11内部开启usrt一的时钟。 这里u si的一是a b2 的外设啊。 其他的都是a p p一的外设。 注意一下。 然后我们还需要开启一下gp i o的时钟。 刚才看银价低音表哈。 u s a r t一的t x是p a9。 i x是p a 10。 所以复制一下这一句外设改成gp l a开启gpa的时钟。 这样时钟就开好了。 接着第二步初始化gpio引脚。 这个代码我们从d.c这里复制一下哈。 放到这里稍微修改一下。 首先引导模式tx引脚是uc r t外设控制的输出角。 所以要选复用推挽输出x硬件是u s r t y设数据输入角。 所以要选择输入模式。 输入模式并不分什么普通输入。 复用输入啊。 一根线只能有一个输出。 但可以有多个输入。 所以输入角外设和gpo都可以同时用。 一般2x配置是浮空输入或者上拉输入。 它因为串口波形空闲状态是高电平。 所以不使用下拉输入这个引脚模式。 如果不清楚的话。 还是看一下手册哈。 gp i o那一节有个推荐的配置表可以参考一下。 那我。 们这里第一个程序目前只需要数据发送。 所以指初始化tx就行了。 演讲模式这里选择af p p g p l p。 选择p9。 下面初始化gp l a。 这样就是把pa 9配置成复用推挽输出。 供usr t一的tx使用。 那银角就出。 还好了。 接下来我们就可以直接初始化u s r t了。 u s r t1 it u s2 t1。 第二个是结构体哈。 在上面u s r t elite type def。 u s a r t it so structure。 然后把结构体的参数都引出来。 最后把结构体的地址放在初始化函数的第二个参数啊。 看一下参数有关这个参数的解释哈。 我就不再一一跳转定义一带大家看了。 大家如果不清楚的话。 可以自己再转到定义看一下步骤。 我们之前已经演示过很多遍了是吧。 这个解释我直接讲一下哈。 省下时间。 我们还有更重要的内容要讲好。 那我们看一下第一个参数。 波特率。 在这里我们可以直接写一个波特率的数值哈。 比如9600。 这样就行了。 写完之后这个it函数内部会自动算好9600对应的分频系数。 然后写到b i计算器。 计算步骤我们上一小节的最后也讲过哈。 所以这里我们就非常方便了。 需要什么波的率直接写就行了。 然后第二个参数是硬件流控制它的取值列表。 我们可以直接复制参数的名称哈。 放到这里。 然后按ctrl alt加空格联想一下代码。 这里就可以看到它的取值列表。 因为这个参数取值啊。 一般都是以参数名称作为前缀的。 所以复制一下参数名称。 在开启代码提示就可以很方便地选出参数了。 如果没提示到合适的参数。 那就再跳转定义看看解释咋说啊。 可能这个参数是需要你自己写的。 而不是。 选的哈。 那我们看一下这个参数的取值可以是ln不使用流空。 只用c t s。 只用rt或者c t s r t s都使用。 我们不使用留空哈。 所以选择l接下来串口模式复制放到这里。 ctrl alt加空格提示一下。 可以看到这里可以选择tx发送模式和x接收模式。 如果你既需要发送。 又需要接收。 那就用或符号把tx和rx和起来。 就跟gpp一或gpp 2这一样的用法。 那我们这个程序只需要发送功能哈。 所以就选择tx这一个参数就行了。 然后是校验位。 同样的操作。 这里校验位可以选择no 5校验二的基调研一文偶。 叫盐我们不需要校验哈。 所以选择漏。 然后停止位操作一下。 这个参数可以选择0.511.5。 我们选择一位停止为。 最后是自常操作一下。 这个参数可以选择八位或九位。 我们不需要叫银行。 所以日常就选择八位。 这样就行了。 那到这里我们结构体参数的初始化就完成了。 目前我们串口的配置是9600波特率。 八位智商五校验。 一位停止位。 无流控。 只有发送模式。 最后我们再来个usrt cmd。 usr t e e liber。 这样整个u s r t就配置完成了。 是不是觉得还挺简单的。 程序上没有新的东西啊。 全都是经典函数。 那初始化完成了。 接下来我们来写一个发送数据的函数。 调用这个函数就可以从tx音角发送一个字节数据。 word cereal send beat。 参数给个ut 8杠t bt。 在这里面我们需要调用串口的sd data函数对吧。 到usr t点区里找一下。 复制这个usr t cd data。 然后放到这里。 参数第一个给u s h e。 第二个给bt把形参传递过去。 然后转到第一。 看一下函数内部哈。 这里bt传递给data这个变量之后。 data与上e f f就是把无关的高位清零哈。 然后直接赋值给低压进容器。 因为这是写入d。 所以数据最终通向tdi发送数据进行器。 t d r再传递给发送一位金容器。 最后一位一位的把数据移出到tx引脚。 完成数据的发送。 在这里可以看出哈。 单片机是一种软件和硬件高度配合的产品。 要想学二单片机程序思维和电路分析都是必不可少的。 那我们回到这里调用这个库函数。 bt变量就写入到tdr的。 写完之后。 我们还需要等待一下。 等tdi的数据转移到移位寄存器。 了我们才能放心哈。 要不然如果数据还在t d r进行等待。 我们再写入数据。 就会产生数据覆盖啊。 所以在发动之后。 我们还需要等待一下标志位。 在这里调用usrt get flag st函数参数u s2。 第一第二个跳转。 第一看一下。 我们需要使用这个tx一发送数据。 运动器空标志为复制放到这里。 然后我们要等待tx一至一哈。 所以还是套一个while循环。 如果tx e标志位等于等于reset。 就一直循环哈。 直到set结束等待。 然后是标志位是否需要手动清除的问题。 这个可以看一下手册哈。 在状态金容器这里有对tx这。 一位的描述。 当tdr计容器中的数据被硬件转移到移位寄存器的时候。 该位被硬件制位。 如果usr t c r e进气中的tx 1 ie为一。 就是允许中断哈。 则产生中断。 最后有一句对usrt dr的写操作。 将该位清零。 所以说这里标志位置一之后不需要手动清零哈。 当我们下一次再生的data时。 这个标志位会自动清零。 那这样我们这个sbt函数就完成了。 现在我们可以进行发送部分的测试。 那把这两个数放在头文件声明一下。 再编译一下哈。 没有错误。 然后到b.c先include cereal。 点下去。 然后在main函数组循环前先调用serial it初始化usr t。 然后再调用serial sbt发送一个字节的数据哈。 参数先随便给一个0x41。 这样程序的逻辑就是上电后初始化串口。 再调用串口发送一个0x41。 调用这个函数之后。 tx引脚就会产生一个0x41 对应的波形。 这个模型可以发送给其他知识串口的模块哈。 也可以通过usb转串口模块发送到电脑端哈。 我们本节主要是和电脑通信。 所以是在电脑端接收数据。 那我们先下载试试看。 编译。 下载看一下。 我们按一下复位键。 这时候可以看到串口模块的接收指示灯闪了一下哈。 说明有波形发过来了。 那在电脑端我们需要打开串口助手这个软件哈。 来查看接收到的数据。 在我提供资料的工具软件目录下。 由我提供了一个串口助手软件哈。 这个串口助手软件是我自己做的哈。 工程源码也放在这里了。 大家感兴趣的话可以拿去学习。 那我们打开串口助手这个软件。 串口号选择我们刚才这个设备管理器里这个com号啊。 两个com号保持一致。 这里必须要插上串口。 且串口是空闲状态。 才能扫描到对应的串口哈哈如果没有显示到串口号。 那需要你先检查一下设备管理器。 看是不是有设备。 然后再关掉其他串口软件哈。 防止串口号被占用了。 好那之后下面的参数这里需要合理。 s t m32 初始化。 这里的配置保持一致。 双方约定的参数必须一致哈。 要不然接收就会解析错误。 所以这里波特率选择9600。 数据位。 八位停止位。 移位。 校验位无。 然后打开串口。 这。 样电脑的串口就准备就绪了。 然后我们再按一次复位键。 可以看到这个数据四幺就接收到了位置。 接收到一个四幺啊。 这就是发送一个字节数据的现象。 然后大家注意到下面这里有一个接收模式。 目前选择的是hex模式。 也就是以原始数据的形式显示。 发送四幺显示就是四角本身。 如果我们想显示一下字符串怎么办呢。 那就可以选择文本模式。 这样就是以字符的形式显示。 在发送试一下。 可以看到目前四幺这个数据就解析成了字符a。 我们来看一下ppt啊。 最后这里就是不同数据模式的具。 体解释第一条hex模式。 有的地方也称作16进制模式啊。 或者二进制模式。 这些称呼都是一个意思。 它表示的是以原始数据的形式显示收到什么数据。 就把这个数据本身显示出来哈。 在这种模式下。 只能显示一个个的16进制数。 比如41427a8 b不能显示文本哈。 比如hello world和各种符号。 比如感叹号逗号点。 如果想显示文本。 那就要对一个个的数据进行编码了。 这就是文本模式或者叫字符模式。 它是以原始数据编码后的形式显示。 在这种模式下。 每一个字节数据通过查找字符集编码。 成一个字符哈。 比如下面这个表展示的就是阿斯克码字符集。 在这里面就可以看到0x41。 这个数据对应的就是大写字母a如果想要显示小写字母呢。 可以看到右边这里0x6 爻对应的就是小写字母a。 如何象限是字符形式的数字。 那在这边可以看到0x30 到0x39 对应的就是字符形式的0~9。 然后这里还有各种各样的标点符号。 背后其实都是对应了一个自己的数据哈。 另外最前面这里还有一些不可见字符。 比如退格换行换页等等。 这些字符可以用于控制文本的打印。 最后字符集的第一个字符原始数据是0x00。 对应字符是空字符。 也就是保留位哈。 不映射任何字符。 一般这个零经常作为字符串的结束标志位。 字符串遇到数据0x00 之后就代表字符串结束了。 这就是阿斯克码字符集的大概分布哈。 大家在做数据和字符串的相互转换时。 需要查一下这个表。 阿斯科码是一种最简单最常用的字符集啊。 如果想显示和存储汉字的话。 也得制定汉字的字符集。 由于汉字的比较多哈。 所以这需要多个字节才能编码一个汉字。 常用的汉字字符集有gb 23。 一二gbk。 gb 18030等等。 对于外国也有相应的支付机。 比如欧洲的20个扩展码。 日本的编码。 韩国的编码等等。 随着计算机的发展哈。 全球互相通信。 为了防止不同国家编码的不兼容现象。 我们可以把所有国家的字符全部收录到一个统一的字符集。 这就是优利库的字符集。 优酷的最常用的传输形式是ut f8。 有关字符编码的内容哈。 大家可以自己再去网上搜一搜。 如果编码不匹配。 就会出现非常烦人的乱码。 这个得注意一下哈。 然后我们看一下右边这个模式图。 这个图描述的是字符和。 数据在发送和接收的转换关系哈。 比如最上面发送0x41。 数据发送到线路传输的就是0x41。 接收方如果以原始数据形式显示。 就是0x41。 如果以字符显示。 就是走下面这一路。 通过字符及译码。 这个密码的字符集就是我们刚才说的阿斯克码。 gbk u t f8 等等。 通过字符集一码找到字符。 然后显示字符a在发送方也可以直接发送字符。 还比如发送字符a这时他就会先从字符集找到a的数据进行编码。 发现a对应的数据是0x41。 最终在线路中传输的必须是16进制数哈。 0x41。 然后接收方可以选择查看原始数据。 连x41 也可进行一码。 得到指数a这就是字符和数据在发送接收过程中经历的变化。 那我们回到程序这边来。 这里sbt也可以这样写。 单引号引一个字符a这样就是以字符的方式发送。 它先会对a进行编码。 找到数据0x41。 最终发送的其实还是0x41 哈。 我们编译下载看一下。 这个现象其实和刚才是一样的。 因为在线路中传输的数据本身0x41 并没有改变哈。 数据还是字符。 只是数据的一种表现形式而已。 好这就是发送一个字节数据或者发送一个字符的程序现象。 那接下来我们再分装一些函数模块哈。 这些函数大家之后用串口肯定会经常用的。 光有一个发送字节函数功能太简单哈。 满足不了需求。 接下来我写的函数其实都是对sbt的分装。 是纯软件的内容哈。 那首先是发送一个数组。 比如我们有一个很大的数组需要通过串口发送到电脑。 那就需要一个发送数据的函数y的cereal森德尔瑞参数。 第一个给一个uint 8杠t辛格瑞。 这是一个unit 8杠t的指针类型哈。 指向带发送数组的首地址传递数组需要使用指针。 这个我在指针教程里有讲哈。 然后第二个参数u int 16杠t认识。 由于数组无法判断是否结束。 所以需要再传递一个认识进来认识类型。 我觉得16位的就够了哈。 如果你觉得不够。 可以定义为32位的。 然后在函数里面先定义一个变量。 由int 16杠t i。 然后来个for a等于零。 a小于认识。 哎佳佳。 这样的话for循环就会执行n 10次。 可以对ara数据进行变厉害。 那在循环里就不断调用serial sbt了。 发送array。 这样就是依次取出数组array的每一项。 然后通过cbt进行发送了。 这就是发送一个数组。 我们测试一下。 放在头文件声明一下哈。 编一下。 然后main函数这里先定义一个数组。 一int 8杠t maari。 里面的数据有0x420 x430 x440 x45。 总共四个数据啊。 实际应用的话想几个就可以及格。 注意别超出unit 16杠七数据的范围就行了。 之后serial sarray第一个参数把数组名传进去。 也就是数组的首地址啊。 第二个参数指定传输四个字节。 这样就可以把迈尔瑞数组一次性发送过去了。 非常方便啊。 然后上面这里先注释掉哈。 好我们编译下载看一下现象。 这里接收模式选择hex模式。 圣德尔瑞一般应用在hx模式下哈。 清空一下。 复位目前收到了四个数据。 就是我们森德瑞发过来的。 12~15没问题啊。 那这里森德尔瑞就测试完成了。 接下来我们继续分钟写一个sd string函数。 写下with cereal sd string参数。 给一个chain string。 这里类型给ut 8杠2t星也可以哈。 都是一样的效果。 然后由于字符串自带一个减速标志位。 所以就不需要再传递长度参数了。 在里面执行逻辑和森德尔瑞是非常类似的哈。 先定义变量unit 8杠t i for a等于零。 这里循环条件就可以用结束标志位来判断了。 spring i不等于零。 这里数据零刚才说过了哈。 对应空字符是字符串结束标志位。 如果不等于零。 就是还没结束进行循环。 如果等于零。 就是结束了。 停止循环。 这里数据零也可以写成字符的形式哈。 就是单引号引起来反斜杠零。 这就是空字符。 的转义字符表示形式和直接显灵最终效果是一样的哈。 这里就以转义字符的形式来写吧。 最后a加加。 然后在循环里还是一样。 将string字符串一个个取出来。 通过cbt发送。 这样就是发送字符串那头文件声明一下。 然后试一下。 在main函数这里可以写serial。 send string字符串。 用双引号引起来哈。 然后给一个hello word感叹号。 在写完这个字符串之后。 编译器会自动补上减速标志位啊。 所以字符串的存储空间会比字符的个数大一。 我们看一下程序现象啊。 上面先注释掉编译。 下载看一下这里ser string一般应用在文本模式哈。 那我们复一下可以看到这里显示的hello world。 这里如果要进行换行。 可以在这里用转义字符反斜杠二。 反斜杠n来执行换行的命令。 这里注意需要用反斜杠r。 反斜杠n两个专一字符才能执行换行。 这两个转移字符在20个码表里也可以查到。 反斜杠r就是0d。 反斜杠n就是零。 a都是不可见的控制字符啊。 那么下载看一下。 这样在每次打印之后就会执行一次换行命令。 这就是sin string函数。 接下来我们继续分装cd lab函数。 调用cd lab发送一个数字。 最终能在电脑显示字符串形式的数字哈。 那写一下。 void cereal and the number。 由于t32 杠题。 number unit t8 杠题。 number类型给32位哈。 稍微大一些。 认识类型八位就行。 然后在函数里面我们需要把lab的个位。 十位。 百位等等以十进制拆分开。 然后转换成字符数字对应的数据哈。 依次发送出去。 怎么以十进制拆开呢。 可以这样来做。 比如有个数字是12345取万位。 就是12345÷10000。 对十取余等于一取千位。 就是12345÷1000=12哈。 再对十取余等于二取百位。 12345÷100=123。 再对十取余等于三。 取十位就是除以十对十取余取个位就是除以一对十取余总结。 下来取某一位就是数字除以十的x次方。 再对此取余除以十的x次方。 就是把这一位的右边去掉哈。 对十取余就是把左边去掉。 这就是拆分数字的思路。 所以我们先需要写个次方函数。 在这里下。 unit。 三二杠t serial power unit。 三二杠t x unit。 三二杠t y。 这个函数的返回值等于x的y次方法。 内部逻辑就是unit 32杠t result等于一wy减减。 这就是循环外次。 然后result乘等于x result里程y次x就是x的y次方哈。 最后return result。 这样就行了。 那回到cd number也是依次发送数字的每一位这个逻辑哈。 首先定义unit t8 杠t i。 然后for循环i等于零。 a小于认识加加循环认识字在里面发送字节哈。 serial sbt。 按照之前的公式取出number的每一位number除以serial power。 十的二次方再对时取。 然后i这里便利是从零开始的哈。 十的零次方是个位。 第一个数据肯定不是个位的。 所以方向要反过来认识减a再减一哈。 这里要再减一个一试一下。 假设认识为二。 第一次循环2-0-1=10的一次方。 就是发动十位哈。 第二次循环2-1-1等于零十的零次方就是发送个位。 这样逻辑才是正确的。 目前循环参数就会以十进制从高位到低位依次发送。 当然最终我们要以字符的形式显示啊。 所以这里还要再加一个偏移。 可以看一下20个码表哈。 字符零对应的数据是0x30。 所以这里还得加上一个0x30。 或者以字符的形式写。 就是单引号零。 这就是发生了数字的逻辑。 其实这两个函数sin string和cd number和o d的修string和修number是一样的。 逻辑哈。 可以对照o i d的代码看看都是一样的。 那我们测试一下。 先函数声明哈。 编译一下。 然后主函数这里上面注释掉。 写一个cal深的number。 12345。 长度为五。 下载试一下。 复位可以看到目前显示文本形式的12345。 新的string配合cd number就可以显示各种字符和数字的。 但这里cd number默认是十进制。 显示其他进制的可以参考一下o l e的代码。 这里就不再演示了哈。 那这些就是串口常用的模块函数。 发送一个字节。 发送一个数组。 发送字符串。 发送字符形式的数值。 那最后再给大家介绍一下print f函数的移植方法。 使用print f之前。 我们需要打开工程选项。 把这个use mercury内部勾上。 micro lib是kill为嵌入式平台优化的一个经典哭喊。 我们等会要用的print f函数就可以用这个mro lib。 所以先勾上这个ok然后我们还需要对print f进行重定向。 将print函数打印的东西输出到串口哈。 因为print f函数默认是输出到屏幕。 我们单片机没有屏幕。 所以要进行重定向步骤就是在串口模块里最开始加上井号。 include std io点去之后。 在这后面重写fp的下函数。 int f put c int c去fl新f这是f葡萄下函数的原型哈。 这个参数什么的。 按照我这样写就行啊。 不需要管那么多的。 然后在里面我们要把fpx重定向到串口。 就是cereal snbc一句。 最后return这样就行了。 那。 重定向f px跟print f有什么关系呢。 这是因为这个f pcr是print f函数的底层。 print f函数在打印的时候就是不断调用f px函数一个个打印的。 我们把f px函数重定向到了串口。 那print f自然就输出到串口了哈。 好这样图形带f就移植好了。 我们到主函数试一下。 上面注释掉哈。 这里直接写print f。 比如打印一个number等于百分号d杠r杠n逗号666。 看一下编译。 这里有个警告啊。 说的是print f函数隐私声明。 这一般是没包含头文件哈。 我们这里使用了print f。 但是这个文件之上没有定义或声明print f。 那我们可以在串口的头文件哈加上井号include的。 s t d i o点去串口头文件。 包含s t d i o。 s t d i o里面有print f的声明。 m.c又包含串口头文件。 所以相当于main里面也有print f的声明。 我们再试一下。 没问题了哈。 下载。 说一下可以看到number等于666。 print f移植没有问题啊。 接下来我再介绍两种print f函数的移植方法。 刚才这一种方法print f只能有一个。 你从定向到串口一了。 那串口二再用就没有了。 如果多个串口都想用print f怎么办呢。 这时就可以用s print f。 s print f可以把格式化字符输出到一个字符串里。 所以这里可以先定义一个字符串。 char string 100长度给够哈。 然后s prinf第一个参数是打印输出的位置。 我们指定打印到string之后就跟print f一样了哈。 复制一下目前这个格式化的字符串。 在spring里。 最后需要再来一个cereal sd string时。 ring把字符串string通过串口发送数据。 这样就完成了。 因为srf可以指定打印位置。 不涉及重定向的东西。 所以每个窗口都可以使用s分的f进行格式化打印。 来看一下现象上面的注释掉哈。 编译下载看一下。 这个现象和刚才是一样的。 那最后再介绍一种方法。 就是你看s prinf每次都得先定义字符串。 再打印到字符串。 再发送字符串。 太麻烦了哈。 我们要是能分装一下这个过程就再好不过了。 所以第三种方法就是分装s print f。 由于print f这类函数比较特殊哈。 它支持可变的参数。 像我们之前写的函数。 参数的个数都是固定的。 可变参数。 这个执行起来比较复杂。 如果想深入学习的话。 可以百度搜索哈c语言可变参数学习一下。 这里时间关系我就只能讲分装的步骤了哈。 首先在串口模块里先添加头文件。 include的s t d a r g d h。 然后在最后这里对s print f函数进行分装。 y的cereal print f参数给恰心format这个参数用来接收格式化字符串啊。 之后逗号再加三个点。 这部分用来接收后面的可变参数列表。 在函数里面首先定义输出的字符串。 char string 100。 注意接下来的部分就比较难了哈。 v杠list a r g第一个参数列表变量哈。 v杠历史的是一个类型名。 a r g是变量名哈。 然后va杠start a r g format从fmt位置开始接收参数表哈。 放在a r g里面之后。 s print f打印位置是string。 格式化字符串是format参数表示a r g在这里sprinnf要改成vs rnf啊。 因为srt f只能接收直接写的参数。 对于这种分装格式要用vs print f之后。 va杠n a r g释放参数表。 最后就是c ral center string。 把string发送出去。 这样就把print f这种可变参数的格式分装好了。 这里面出现了很多没见过的函数。 如果没学过这种用法。 可能比较难理解哈。 这个也没关系。 知道这样移植就行了。 如果学过来。 那其实是基本操作哈。 大家也可以学学这种可变参数的用法。 自己写其他函数的时候也可以用哈。 还是非常高级的好。 我们来。 测试一下。 把这个函数放到头文件。 声明一下。 编译看看。 没问题哈。 然后总函数这里调用serial pnf。 里面的东西和上面这是一样的哈。 这个注释掉试一下。 下载。 可以看到这样也可以实现print f的功能函好。 那以上就是print f函数的移植方法了。 最常见的是第一种哈。 如果你有多个print f的需求。 可以了解一下后两种方法。 最后我再讲一个显示汉字的操作方法。 之前有人经常反应print f打印函数经常会乱码哈。 这里给大家提供几种解决方案。 目前我们这个汉字编码格式选的是u tf 8。 所以最终发送到串口汉字会以u tf 8的方式编码。 最终串口助手也得选择u tf 8才能解码正确。 先说一下u tf 8不乱码的方案哈。 比如我这里写个字符串。 你好。 世界不过这样直接写汉字编译器有时候会报错啊。 我在网上搜索了一下。 这里需要打开工程选项c c加加。 这里咋向控制了哈。 写上杠杠n o杠m u l t i b y t e c h a r s。 需要给编译器输入一个这样的参数哈。 注意别写错了。 然后ok这样编译。 没问题。 下载看看。 在串口助手这里目前是乱码哈。 密码房是要选择u t m8。 复一下。 这样汉字就没问题了。 这是u tf 8的解决方案。 但是u tf 8可能有些软件兼容性不好啊。 所以第二种方式就是切换为gb 2312编码。 在这里打开配置encoding。 选择gb 2312。 这是汉字的编码方式啊。 ok目前这个文件编码格式其实还是有tf吧。 我们需要把汉字删掉。 再把文件关掉再打开。 等字体变为这种宋体了。 编码格式才算改过来。 然后再写你好事件。 这样编码就是gb 2312。 然后下载试一下。 在串口助手这里选择gbk编码。 一般windows软件默认就是gbk的编码。 gbk和gb 23121样。 都是中文的编码基本都是兼容的啊。 再复位可以看到这样也是没问题的。 所以总结一下就是要么ko和串口助手都选择u tf 8。 且q加上杠杠六杠。 mart。 bt杠chess参数。 要么都使用gb开头的中文编码格式。 参数不用加的哈。 如果你已经有很多选好编码格式的工程了。 这里资料里我也提供了一个转码软件哈。 可以批量进行转码。 记得关闭文件的只读哈。 这个了解一下。 这就是汉字乱码的技术方案。 那工程这里我把。 它修改为最开始演示的来源哈。 编码格式还是选择ut f8。 既然最开始选择了u tf 8。 再多乱码也不离不弃哈。 底下x413 到瑞42~45深的水准。 先换个行哈。 然后number一等于cd number给一一长度为三。 print f换行蓝二等于2%。 d。 srt f换行number 3等于百分2d3。 三三分装的print f换行number 4等于百分2d44。 最后再来个换号啊。 程序最终保留这个版本供大家参考编译。 下载看一下现象。 这就跟最开始演示的一样的哈。 没问题。 对于英文来说。 任何编码都是兼容的。 所以英文怎么选都不会乱码。 好。 有关串口发送的代码到这里就结束了。 接下来我们来学习一下串口接收哈。 这个工程先关掉。 经验这里呢和串口发送的是一样的哈。 我们已经把tx和x的线都接好了。 然后回到工程目录。 复制一下串口发送的代码。 名字改成九杠二。 串口发送加接收。 当然这个代码侧重的是接收部分啊。 打开工程。 我们在这个工程的基础上加上接收的代码。 之前的这些先删掉哈。 然后初始化这里加上接收的部分。 首先是gpl口。 我们要使用x的硬件。 在引脚定义表里。 我们知道u s r t e的x附用在了p s硬件。 所以这里需要再初始化一下p 10。 我们复制一下下面这部分。 结构体定义。 这行不用复制。 然后改一下银角改成g p l p 10。 音调模式可以选择浮空输入或上拉输入。 那我就选择gpl目的i p u上拉输入模式啊。 下面初始化gp l a这样pa 10就初始化好了。 就要继续下面这些参数大部分不用改。 只需要改一下模式。 这个参数后面加上一个或串口模式ex。 这样就是同时开启发送和接收的部分。 如果你只需要接收。 那就把前面这个tx去掉就行了。 目前我们就同时开启。 然后呢串口接收代代码其实就配置差不多了哈。 对串口接收来说。 可以使用查询和中断两种方法。 如果使用查询。 那初始化就结束了。 如果使用中段。 那还需要在这里开启中段配置n v i c。 像我们最开始演示的这个现象哈。 使用查询的方法就可以完成。 这里我就先演示一下查询。 再演示一下中段查询的流程是在主函数里不断判断x n e标志为。 如果质疑了就说明收到数据了。 那再调用receive data读取dr计算器。 这样就行了。 我就在主函数直接演示一下哈。 就不带分装了。 在while循环里直接一usr t get flag。 st usr。 一usr at flag。 x n e等于等于set。 if成立就说明收到数据了。 上面我们定一个数据哈。 uint 8杠t x data。 然后这里rx data等于usrt receive data u s r t1。 目前接收到的一个字节数据就已经在ex data里了。 接下来我们可以进行显示哈。 o i d hex number。 一行一列。 x data强度为二。 然后还有个清标志位的问题啊。 我们看一下手册。 这里有i x n e标志位的说明。 当r d r一位计数器中的数据被转移到uc r t d r金融系统。 该位被硬件制为。 如果usr t c r e进入器中的x n e ie为一。 则产生中断。 对u s r t d r的读操作可以将盖为清零。 这里读dr可以自动清零。 标注为。 所以这里读完低压就不需要我们在清除。 标志位了。 那我们看一下这个代码的现象。 编译。 没问题。 下载看一下。 这里串口助手我们需要在发送区里写入数据哈。 发送模式可以选择hex模式或文本模式。 hex就是原始数据。 文本模式首先要过一遍字符编码哈。 我们选择hex模式。 然后在这里写。 比如四幺。 在hex模式下。 这里只能写16进制数哈。 也就是0~9。 a到f不用写0x的两个数为一组非法字符都将会被忽略哈。 那我们点发送在面包板上可以看到就收到了数据四幺。 然后我们改一个。 比如a f发送。 这里显示af。 这就是查询方法的串口接收程序。 建议如果你程序比较简单。 查询方法是可以考虑的哈。 那接下来我们再演示一下中断方法的程序。 如何使用中段呢。 首先初始化这里我们要加上开启中段的代码。 流程是第一步。 u s r t i t configure usr。 第一第二个参数看一下解释。 这里选择i x ne的中段复制一下。 然后放到这里。 第三个参数。 开启i x n e标志位到n v i c的输出之后。 就是配置n v i c的。 先分组n vs a priority group configure。 n vs a priority group。 在初始化n vc的usr t e通道。 nva 1 t太不敌fn vs 1。 it strug。 把结构体参数引出来哈。 最后nvsc 1 d把结构体地址放进去。 参数第一个中段通道。 我们跳转一下。 搜索这个。 这里找一下。 我们需要用这个u s i d e r q n复制放到这里。 第二个给label之后。 优先级啊。 先随便给个都给一好。 到这里。 i x n e标志位一旦置一了。 就会向n v c申请中断之后我们可以在中断函数里接收数据啊。 中断函数的名字。 我们看一下启动文件。 找一下。 复制这个u s c a r t e a q h。 然后在这最下面写word粘贴才是word的。 在这里面老样子啊。 先判断标志位。 if u c r t get it statu s a r t1 u s a r t i t。 x n e等于等于s。 如果rx ne确实质疑了。 就进一步这里if最后要不要清除标志位呢。 如果你读取来dr就可以自动清除。 如果没读取dr就需要手动清除啊。 我们这里直接给清一下吧。 这个也不影响usit可莉it pending beat。 参数和这一样。 之后在这里面你可以直接读取dr执行一些操作。 当然由于这个代码是在模块里。 不太适合加入过多其他的代码哈。 我是比较喜欢弄个分装。 大家可以根据自己的需求来哈。 那我就在最上面定义两个变量。 一个是unit 8杠t cereal ax data。 一个是uint 8杠t serial x flag。 在这个函数里面。 我们先读取到模块的变量里。 serial ax data等于u s a r t。 receive data usr t。 一读完之后。 这个自己的标志位哈。 serial ix flag等于一。 这里有个错误啊。 看一下原因。 这也改一下。 好了。 然后对这个变量也分装一个get函数啊。 大家也可以把这两个变量x n出去都是可以的。 那这里uint 8杠t serial get ex flag word。 我们也想实现一个读后自动清除的功能哈。 所以这里写if serial x flag等于等于一。 就serial ex flag等于零。 再return 1。 否则return 0。 这就是get x flag函数。 下面再来一个哈交易t8 杠t serial gx data。 为了。 里面就直接return serial x data。 好到这里。 中断接收和变量的分装我们就完成了。 其实这里我就是在中断里把数据进行了一次转存哈。 最终还是要扫描查询这个x flag来接收数据的。 对于这种单字节接收来说。 可能转成一下意义不大哈。 这里这样写主要是给大家演示一下中断接收的操作方法。 另外也是为我们下一小节多字节数据包接收做一个铺垫哈。 那我们测试一下。 先把这两个get函数放在头文件声明一下。 然后主函数这里就改成我们自己的函数。 这里改成if serial get flag。 等于等于一里面改成x data。 等于serial get x data。 这样代码的功能和之前演示的也是一样的哈。 我们就把最终的现象也完成一下。 上面显示先来个o l d修string。 一行一列x data冒号。 下面位置改成八列。 然后我们再加一个数据回传功能哈。 这里加上cereal sb ax data。 把接收到的这一字节数据回传到电脑。 这就是目前程序的全部功能了哈。 我们编译下载试一下。 发送接收都设置成hex模式。 这里先给个四幺。 发送屏幕显示四幺哈。 串口接收回传的数据。 四爻改成四二。 发送屏幕显示四二。 串口接收回传的数据是二。 这就是这个程序的现象哈。 本节课的内容也差不多结束了。 目前这里只支持一个字节的节奏哈。 这功能比较简单。 那现在很多模块都需要回传大量数据。 这时就需要用数据包的形式进行传输。 接收部分也需要按照数据包的格式来接收哈。 这样才能接收多字节数据包。 数据包的发送和接收也是比较常见和重要的内容。 有关串口这部分进阶的内容。 我们下小节还会继续来为大家讲解哈。 那我们下一小节再见。
28. 大家好。 欢迎回来。 本期视频我们来继续学习串口啊。 学习一下串口数据包收发的思路和流程哈。 那先看一下本次程序的现象。 本节课共有两个代码。 第一个是串口收发hax数据包。 第二个是串口收发文本数据包。 先看一下第一个哈。 下载看一下这里o l d上面两行显示的是tx数据包。 含下面两行显示的是rx数据包。 然后usb转串口模块和之前一样。 都接好。 在pb一这里我还接了个按键哈。 用于控制。 接着电脑端打开串口助手。 发送模式和接收模式都选择hex模式。 然后按一下pb一这个按键可以。 看到o l e d第二行显示发出了一个这样的数据包哈。 在串口助手这里也显示接收到了这个数据包。 这个数据包有一个规定的格式哈。 就是以f f为包头。 f一为包围。 中间固定四个字节为数据啊。 那我们多按几次。 每按一下就发送一个数据包。 中间的数据我也设置了一个递增变化。 实际应用的话就可以替换成你实际的数据哈。 这是s t m32 发送数据包之后。 我们也可以让s t m32 接收数据包。 可以在这里的发送区发送一个数据包给s t m32 哈。 也是同样的格式。 以f f开头。 中间四个数据是用户数据。 比如给个6688a b cd。 最后以f结尾。 然后点发送。 可以看到o id这里显示接收到了6688a b c d。 包头f f和包围f e用于控制接收啊。 在这里没有显示我们随便换一个数据啊。 再发送可以看到对应接收也是没问题了啊。 这就是串口收发hax数据包的程序现象。 然后我们继续看第二个程序。 串口收发文本数据包。 下载面包板。 这里我又接了一个led用于测试哈。 然后还是串口助手。 第二个程序。 发送模式和接收模式都要选成文本模式啊。 这个程序我们要发送一个文本数据包。 数据包的格式也是个人规定的哈。 我规定的格式是以艾特符号为报酬。 中间是数据数据。 也是规定好的指令海。 比如写d下划线on。 最后以换行符为包围。 这里注意一定要打一个换行。 换行也是字符啊。 然后发送可以看到2d显示接收到了led led点亮。 然后s t m32 回传一个字符串l e d r o k。 最后串口助手收到l e d r o k如果要关灯的话。 我定义的还有指令。 这里改成led of。 换行也别忘了哈。 发送可以看到led熄灭s t m32 回传led off。 ok如果我们随便给个指令。 发送s t m32 也能收到。 但是返回error command的错误指令哈。 这就是一个简单的利用串口进行人机交互的设计。 好这就是本小节程序的现象。 我们接下来就来学习一下如何去规定一个合理的数据包格式。 以及如何收发数据包啊。 先来看一下ppt。 这里前面两个ppt就是我规定的数据包格式。 一种是hex数据包。 一种是文本数据包。 之后两个ppt展示的就是接收数据包的思路。 那先看一下hx数据包格式。 首先数据包的作用是把一个个单独的数据给打包起来。 方便我们进行多字节的数据通信哈。 我们之前学习了串口的代码。 发送一个字节。 接收一个字节都没问题。 但在实际应用中。 我们可能需要把多个字节打包为一个整体进行发送。 比如说我们有个陀螺仪传感器。 需要用串口发送数据到sm 32陀螺仪的数据。 比如x轴一个字节。 y轴一个字节。 z轴一个字节。 总共三个数据需要连续不断地发送。 当你像这样x y z x y z x y z连续发送的时候。 就会出现一个问题。 就是接收方他不知道这数据哪个对应x哪个对应y哪个对应z。 因为接收方可能会从任意位置开始接收。 所以会出现数据错位的现象。 这时候我们就需要研究一种方式。 把这个数据进行分割。 把xyz这一批数据分割开。 分成一个个数据包。 这样在接收的时候就知道了数据包的第一个数据就是x。 第二个是y。 第三个是z。 这就是数据包的任务。 就是把属于同一批的数据进行打包和分割。 方便接收方进行识别。 那有关分割打包的方法可以使自己发挥想象力来设计哈。 只要逻辑行得通就行。 比如我可以设计在这个xyz xyz数据流中。 数据包的第一个数据也就是x的数据包。 它的最高位至一。 其余数据包最高位都是零。 当我接收到数据之后。 判断一下最高位。 如果是一。 那就是x数据。 然后紧跟着的两个数据就分别是y和z。 这就是一种可行的分割方法哈。 这种方法就是把每个数据的最高位当作标志位来进行分割的。 实际也有应用的。 例子哈。 比如u t f8 的编码方法和这就是类似的。 不过他那个编码更高级一些哈。 感兴趣的话可以了解一下。 那本节我们主要讲的数据包分割方法。 并不是在数据的高位添加标志位这种方式啊。 因为这种方式破坏了原有数据。 使用起来比较复杂。 我们串口数据包通常使用的是额外添加包头包围这种方式。 比如我这里就列举了两种数据包格式。 第一种是固定包长。 含包头包围。 也就是每个数据包的长度都固定不变。 数据包前面是包头。 后面是包围。 第二种是可变爆伤含包头包围。 也就是。 每个数据包的长度可以是不一样的。 前面是八成。 后面是包围他们的数据包格式啊。 可以是用户根据需求自己规定的。 也可以是你买个模块。 别的开发者规定的。 那我这里规定是。 比如固定包场。 这里我一批数据规定有四个字节。 在这四个字节之前加个爆头。 比如我定义0x f f为报酬。 在四个字节之后加一个包围。 比如我定义0x f为包围。 那当我接收到0x f f之后。 我就知道了一个数据包来了。 接着我再接收到的四个字节。 就当做数据包的第1234个数据存在一个数组里。 最后跟。 一个包围。 当我收到0x f一之后。 就可以自己一个标志位告诉程序。 我收到了一个数据包。 然后新的数据包过来再重复之前的过程。 这样就可以在一个连续不断的数据流中分割出我们想要的数据包了。 这就是通过添加包头包尾实现数据分割打包的思路哈。 接着我们来研究几个问题啊。 第一个问题就是包头包尾和数据载荷重复的问题。 这里定义f f为包头。 f一为包围。 如果传输的数据本身就是f f和f一怎么办呢。 那这个问题确实存在。 如果数据和包头包尾重复。 可能会引起误判。 哈对应这个问题。 我们有如下几种解决方法。 第一种限制载荷数据的范围。 如果可以的话。 我们可以在发送的时候对数据进行限幅。 比如xyz 3个数据变化范围都可以是0~100。 那就好办了。 我们可以在载荷中只发送0~100的数据。 这样就不会和包头包尾重复了。 第二种。 如果无法避免载荷数据和包头包尾重复。 那我们就尽量使用固定长度的数据包含。 这样由于载荷数据是固定的。 只要我们通过包头包尾对齐的数据。 我们就可以严格知道哪个数据应该是包头包围。 哪个数据应该是载。 荷数据在接收载荷数据的时候。 我们并不会判断它是否是包头包围。 而在接收包包围的时候。 我们会判断它是不是确实是bot包围。 用于数据对齐哈。 这样在经过几个数据包的对齐之后。 剩下的数据包应该就不会出现问题了。 第三种就是增加包头包尾的数量。 并且让它尽量呈现出载荷数据出现不了的状态。 比如我们使用f f f e作为包头。 fd fc作为包围。 这样也可以避免载荷数据和包头包尾重复的情况发生啊。 接着第二个问题是。 这个包头包尾并不是全部都需要的哈。 比如我们可以只。 要一个包头把包围删掉。 这样数据包的格式就是一个包头f f加四个数据。 这样也是可以的哈。 当检测到f f开始接收收购四个字节后。 自标注位一个数据包接收完成。 这样也可以。 不过这样的话载荷和包头重复的问题会更严重一些。 比如最严重的情况下。 我再和全4f f报酬也是f f。 那你肯定不知道哪个是报酬了。 而加上f一作为包围。 无论数据怎么变化。 都是可以分辨出报酬包围的哈。 之后第三个问题就是固定包场和可变包场的选择问题。 对应hx数据包来说。 如果你的载荷会出。 现和bot boy重复的情况。 那就最好选择固定保伤害。 这样可以避免接收错误。 如果你又会重复。 又选择可变包层。 那数据很容易就乱套了哈。 如果载荷不会和包头包围重复。 那可以选择可变爆伤。 数据长度。 像这样。 四位啊。 三位啊等等。 一位十位来回任意一遍肯定都没问题。 因为包头包尾是唯一的。 只要出现包头就开始数据包。 只要出现包围就结束数据包。 这样就非常灵活。 它这就是固定爆伤和可变包场选择的问题。 最后一个问题就是各种数据转换为字节流的问题。 这里数据包都是一个字节一。 个字节组成的哈。 如果你想发送16位的整型数据。 32位的整形数据。 float double。 甚至是结构体。 其实都没问题啊。 因为他们内部其实都是由一个字节。 一个字节组成的。 只需要用一个unit 8杠t的指针指向它。 把它们当作一个字节数组发送就行了。 这个操作方法我在指针教程里也讲过哈。 不会的话可以去看一下好。 有关hx数据包定义的内容。 我就讲这么多。 接下来看一下文本数据包。 文本数据包和hx数据包就分别对应的文本模式和hx这两种模式啊。 在hx数据包里面数据都是以原始的字节。 数据本身呈现的。 而在文本数据包里面。 每个字节就经过了一层编码和译码。 最终表现出来的就是文本格式哈。 但实际上每个文本字符背后其实都还是一个字节的hg数据对吧。 那么看一下这里。 我同样给出了固定爆伤和可变爆仓这两种模式。 由于数据密码成了字符形式。 这就会存在大量的字符可以作为报酬报位哈。 可以有效避免载荷和包头包尾重复的问题。 比如我这里规定的就是以艾特这个字符作为包头。 以反斜杠r反斜杠n也就是换行啊。 这两个字符作为包围在载荷数据中间。 可以出现除了包头包尾的任意字符。 这很容易做到哈。 所以文本数据包基本不用担心载荷和包头包尾重复的问题。 使用非常灵活。 可变。 包长啊。 各种字母啊。 符号数字都可以随意使用哈。 当我们接收到载荷数据之后。 得到的就是一个字符串。 在软件中再对字符串进行操作和判断。 就可以实现各种指令控制的功能了。 而且字符串数据包表达的意义很明显哈。 可以把字符串数据包直接打印到串口助手上。 什么指令什么数据一眼就能看明白哈。 所以这个文本数据包通常会以换行作为包围。 这。 样在打印的时候就可以一行一行的显示了。 非常方便。 那hit数据包和文本数据包这两种对比下来。 其实也是各有优缺点哈。 看出数据包优点是传输最直接。 解析数据非常简单。 比较适合一些模块发送原始的数据。 比如一些使用串口通信的陀螺仪啊。 温湿度传感器啊。 缺点就是灵活性不足啊。 载荷容易和bot包围重复。 文本数据包呢优点是数据直观易理解。 非常灵活。 比较适合一些输入指令进行人机交互的场合。 比如蓝牙模块常用的at指令。 cnc和3d打印机常用的g代码都是文本数据包的。 格式。 那缺点就是解析效率低。 比如你发送一个数100汉字的数据包。 就是一个字节。 100完事。 文本数据包就得是三个字节的字符。 100收到之后还要把字符转换成数据才能得到100。 所以说我们需要根据实际场景来选择和设计数据包格式哈。 好数据包格式的定义讲完了。 接下来我们就来学一下数据包的收发流程。 首先是数据包的发送。 其实数据包的发送非常简单哈。 不用说大家应该也都能想到。 在hex数据包这里。 我如果想发送这样一个数据包。 就定义一个数组填充数据。 然后用上。 小节我们写过的森德尔瑞一发就完事了对吧。 文本数据包这里也很简单。 写一个字符串。 然后调用send string一发送也完事了对吧。 所以说发送这个数据包是很简单的。 因为发送过程是完全自主可控的。 小方啥就发啥。 我们写代码的时候也能感受到哈。 串口发送比接收简单多了。 那接下来接收一个数据包。 这就比较复杂了。 我们来学习一下。 我这里演示了固定包长。 hex数据包的结合方法和可变包装文本数据包的接收方法哈。 其他的数据包也都可以套用这个形式。 等会儿我们写程序就会根据这。 里面的流程来。 我们先看一下如何来接收这个固定包场的hx数据包。 首先根据之前的代码。 我们知道每收到一个字节。 程序都会进一遍中断。 在中断函数里我们可以拿到这一个字节。 但拿到之后我们就得退出中断了。 所以每拿到一个数据都是一个独立的过程。 而对于数据包来说。 很明显。 它具有前后关联性。 包头之后是数据。 数据之后是包围。 对于包头数据和包围这三种状态。 我们都需要有不同的处理逻辑。 所以在程序中我们需要设计一个能记住不同状态的机制。 在不同状态执行不同的。 操作同时还要进行状态的合理转移哈。 这种程序设计思维就叫做状态机。 在这里我们就使用状态机的方法来接收一个数据包。 要想设计一个好的状态机程序。 画一个这样的状态转移图是必要的哈。 我们看一下。 对于上面这样一个固定波长hex数据包来说。 我们可以定义三个状态。 第一个状态是等待包头。 第二个状态是接收数据。 第三个状态是等待包围。 每个状态需要用一个变量来标志一下。 比如我这里用变量s来标志三个状态依次为s等于零。 s等于一。 s等于二。 这一点类似于自标志。 位哈。 只不过标志位只有零和一。 而状态机是多标志位状态的一种方式哈。 然后执行流程是最开始s等于零。 收到一个数据。 进中段。 根据s等于零进入第一个状态的程序。 判断数据是不是包头f f。 如果4f f则代表收到报酬之后。 自s等于一退出中断结束。 这样下次再进中段。 根据s等于一就可以进行接收数据的程序了。 那在第一个状态。 如果收到的不是f f就证明数据包没有对齐哈。 我们应该等待数据包包头的出现。 这时状态就仍然是零。 下次进中断就还是判断包头的逻辑。 直到出。 现f f才能转到下一个状态。 那之后出现了ff。 我们就可以转移到接收数据的状态了。 这时再收到数据。 我们就直接把它存在数组中。 另外再用一个变量记录收了多少个数据。 如果没收购四个数据。 就一直是接触状态。 如果收购了就自s等于二。 下次进入钻石就可以进入下一个状态了。 那最后一个状态就是等待包围了。 判断数据是不是f1。 正常情况应该是f一哈。 这样就可以自s等于零回到最初的状态。 开始下一个轮回。 当然也有可能这个数据不是f1。 比如数据和包头重复。 导致包头。 位置判断错了。 那这个包尾位置就有可能不是f1。 这时就可以进入重复等待包围的状态。 直到接收到真正的包围。 这样加入包围的判断。 更能预防因数据和包头重复造成的错误哈。 这就是使用状态机接收数据包的思路。 这个状态机其实是一种很广泛的编程思路哈。 在很多地方都可以用到。 使用的基本步骤是先根据项目要求定义状态。 画几个圈哈。 然后考虑好各个状态在什么情况下会进行转移。 如何转移。 画好线和转移条件。 最后根据这个图来进行编程。 这样思维就会非常清晰了哈。 比。 如你要做个菜单就可以用到状态机的思维。 按什么键切换什么菜单。 执行什么样的程序。 还有一些芯片内部逻辑哈也会用到状态机。 比如芯片什么情况下进入待机状态。 什么情况下进入工作状态。 这也是状态机的应用哈。 希望大家可以研究一下。 这里的编程肯定会有帮助。 那接下来继续我们来看一下这个可变包装文本数据包的接收流程。 同样也是利用状态机定义三个状态。 第一个状态等待包头判断收到的是不是我们规定的at符号。 如果收到艾特就进入接收状态。 在这个状态下依次。 接收数据。 同时这个状态还应该要兼具等待包围的功能。 因为这是可变爆仓。 我们接收数据的时候也要时刻监视是不是收到包围了。 一旦收到包围了就结束。 那这里这个状态的逻辑就应该是收到一个数据。 判断是不是杠r。 如果不是。 则正常接收。 如果是则不接收。 同时跳到下一个状态。 等待包围杠n。 因为我这里数据包有两个包围杠r杠n所以需要第三个状态。 如果只有一个包围。 那在出现包围之后就可以直接回到初始状态了哈。 只需要两个状态就行。 因为接收数据和等待包围需要在。 一个状态里同时进行一下。 由于串口的包头包尾不会出现在数据中。 所以基本不会出现数据错位的现象啊。 这就是使用状态机接收文本数据包的方法。 好到这里。 我们这个数据包的定义啊。 分类啊。 优缺点和注意事项就讲完了。 接下来我们就来写程序验证一下刚才所学的内容吧。
29. 本小姐。 我们来写一下串口收发数据包的代码哈。 看一下经验图。 这两个代码的经验图之前都用到过哈。 应该都挺简单的。 看一下下面这个串口模块的接线。 和之前都是一样的。 没有变化。 然后这个收发hex数据包的经验图。 在这个pb一口接了一个按键。 用于控制。 之后就是收发文本数据包的检验图。 下面也同样是串口模块。 然后在这个pa一口接了一个led用于指示。 其他的就没啥了。 那我们把这两个代码的接线都一起接好。 看一下面包板。 首先usb转串口模块jd供d之后。 x d接pa 9 t x d接pa。 十串口的接线就完成了。 接着在pb一口插一个按键。 然后是pa一口差一个l d长角结阵。 短角接pa一插电。 这样接线就完成了。 之后我们来写代码。 回到工程文件夹。 复制一下九杠二的代码哈。 我们从这个代码的基础上来改改个名字。 叫九杠三串口收发数据包。 打开工程。 先编译一下哈。 到时候有代码提示框会好用一些。 然后这些代码先删掉。 我们到串口的c文件这里。 在这个文件里。 我打算加上sofhx数据包的部分哈。 其中这个hx数据包的格式。 我定义的就和ppt这里的一样。 固定包场含包头包围。 其中包头为f f。 再和数据固定四字节包围为f一好。 我们来写一下。 在这里为了收发数据包。 我们先定义两个缓冲区的数值哈。 第一个是unit 8杠t serial tx packet。 数据个数为四个。 第二个复制一下叫做ex packet。 数据个数也为四个。 这四个数据只存储发送或接收的载荷。 数据哈。 包头包尾就不存了。 之后这个ex flag留着。 如果收到一个数据包。 就自x flag接。 着继续往下。 这些初始化的代码都不需要更改哈。 发送的模块函数也先放这儿。 之后get x data这个函数删掉。 get x flag。 这个留着啊。 最后中断这些东西先删掉啊。 好在这里我们先写一个cpackt的函数。 我们想要的效果是调用一下这个函数。 tx packet数组的四个数据。 就会自动加上包头包尾发送数据。 我们来写一下y的serial send packet。 word函数里面其实也非常简单哈。 第一步cereal sbt发送包头0x f f。 第二步cereal森德尔瑞参数给sirtx packet。 长度为四海。 这样就可以一次把四个载荷数据发出去了。 第三步再send bt发送包围零。 x f1。 这样是不是就行了。 那我们现在测试一下发送是不是好使啊。 把这个函数放到头文件声明一下。 这个get ax data的函数没有了哈。 删掉。 然后这里上面这个数组。 我们也直接在头文件声明为外部可调用哈。 前面加一个extern数组声明的时候。 数量可以不要这个。 如果模块里有数组需要外部调用。 我一般就习惯直接把变量声明出去了哈。 如果要分装写个set get的话也可以。 那就得用指针进行传递哈。 不过我觉得那样太麻烦了。 所以这里就直接证明出去吧。 然后回到b.c在初始化之后。 我们可以先填充发送缓冲区数组。 siri tx packet。 第零个等于0x01。 复制一下。 一给零二。 二给零。 三。 给零四数组填充好之后。 调用一下c6 send packet。 之后send packet就会取出数组的内容。 加上包头包尾统一发送数据了哈。 我们看一下效果编译。 下载。 这里打开串口。 发送模式和接收模式都选择hex模式。 然后按一下复位。 可以看到数据包就发送过来了。 数据包格式是f f4 个载荷。 数据f一实际上就是cdri对吧。 这个没有问题。 那接下来我们就来写一下。 接收这样一个数据包的代码哈。 回到串口这里。 上面接收数据包的缓冲区和标志位。 我们已经定义好了哈。 然后再接收中断函数里。 我们就需要用状态机来执行接收逻辑了。 接收数据包。 然后把载荷数据存在rx packet输出里。 这是我们的任务哈。 根据ppt的这个状态转移图。 首先我们要定义一个标。 志当前状态的变量s。 那在中段这里。 我们可以在函数里面定义一个静态变量。 static uint 8杠t x state等于零。 这个静态变量类似于全局变量哈。 函数进入指挥初始化一次零。 在函数退出后。 数据仍然有效。 与全局变量不同的是。 静态变量只能在本函数使用啊。 那我们就用这个ex state当做状态变量s。 然后根据ppt 3个状态s分别为012。 所以在这下面根据ex state的不同。 我们需要进入不同的处理程序。 if ex state等于等于零。 就进入等待报酬的程序。 else if ex state等于等于一。 就进入接收数据的程序。 再else if。 x state等于等于二。 就进入等待包围的程序。 注意这里一定要用else if哈。 else不要去掉。 如果你只是三个并列的衣服。 可能在状态转移的时候会出现问题啊。 比如在状态零。 你想转移到状态一。 就是x等于一。 结果就会造成下面状态一的条件。 就立马满足了。 这样会出现。 连续两个义父都同时成立的情况。 这个情况我们不希望出现哈。 所以这里使用else if保证每次进来之后。 只能选择执行其中一个状态的代码。 或者你用switch case语句哈。 也可以保证只有一个条件满足好。 这就是状态选择的部分。 然后就一。 直写每个状态执行的操作和状态转移条件。 就行了。 首先获取一下x data unit。 八杠t rx data等于usrt receive data。 usr第一。 对于状态零。 我们的操作是if rx data等于等于零。 x f f就说明收到包头了。 那就可以转移状态。 rx state等于一。 如果rx data不等于f f呢。 就不转移状态。 你可以加一个else x state等于零。 当然也可以不写else哈。 x state还是零也是一样的。 效果。 之后进入下一个状态接收数据。 这里要依次接收四个数据。 存在x packet数组里。 所以还需要一个变量来记一下接收几个了。 可以在上面哈。 再定义一个静态变量。 名字叫px packet。 只是接收到哪一个了。 最开始的默认为零哈。 然后在这里就可以结束了。 cereal x packet。 dpx packet个数据等于。 x data将x data存在接收数组里之后。 别忘了px packet加加移动到下一个位置。 这样就是每进一次接触状态。 数据就转成一次缓存数组。 同时存的位置加加。 那当if px packet大于等于40。 也就是四个载荷数据已经收完了。 这时就可以转移到下一个状态了。 x state等于二。 同时这个px packet也别忘了清零哈。 为下次接收做准备。 我们可以在状态里转移到状态一。 时提前清一个零哈。 这样状态一的逻辑就完成了。 最后写一下状态二的逻辑。 等待包围。 这个应该也很简单啦。 if rx data等于等于零。 x f一判断是不是包。 围如果是的话。 就rx state等于零。 回到最初的状态。 同时代表一个数据包接收到了。 可以自一个接收标志位。 serial ex flag等于一。 如果不等于f一的话。 就是还没收到包围。 我们同样不做处理。 仍然在这个状态等待包围哈。 好到这里。 我们这个接收数据包的状态机。 程序就完成了。 大家可以对照ppt的这个图来理解哈。 都是对应的。 那我们来测试一下。 首先上面这个接收缓存数组也放在头文件。 声明一下哈。 加个extern。 另外还有get x flag这个函数。 用来判断是不是接收到了数据包。 然后到m.c这里组循环里面。 我们可以不断读取x flag。 if serial get x flag等于等于1g。 收到了数据包。 则在屏幕上显示一下o l e d修hx number。 一行一列。 显示c eo x pk的第零个长度为二。 复制粘贴一下。 一行四列显示数据。 一。 一行七列显示数据。 二。 一行十列显示数据三。 这样就完成了。 我们试一下编译。 下载看一下串口助手。 这里在发送区按照数据包格式发送数据。 包头f f数据给个1223344包围。 f一发送。 可以看到o r d。 显示了这个数据包的载荷数据哈。 123344我们改一下。 比如f f f88 f e。 这时载荷数据和包头包尾是有重复的哈。 再发送看一下目前收到的数据仍然没问题。 因为我们程序在接收载荷数据的时候。 并不会判断报酬包围。 所以这时载荷数据即使和包包与重复。 也干扰不到我们。 这就是数据包接收的程序之后。 这个程序还隐藏有一个问题。 大家需要注意一下哈。 就是这个ex pc的数组。 它是一个同时被写入又同时被读出的数组。 在中断函数里我们会依次写入它。 在主函数里我们又会依次读出它。 这会造成什么问题呢。 就是数据包之间可能会混在一起。 比如你读书的过程太慢了。 前面两个数据刚读出来。 等了一会儿才继续往后读取。 那这时后面的数据就有可能会刷新为。 下一个数据包的数据。 也就是你读出的数据。 可能一部分属于上一个数据包。 另一部分属于下一个数据包。 这个问题需要注意一下哈。 那解决方法呢可以在接。 收部分加入判断。 就是在每个数据包读取处理完毕后。 再接收下一个数据包。 当然很多情况下其实还可以不进行处理哈。 像这种hit数据包。 都是用于传输各种传感器的每个独立数据。 比如陀螺仪的xyz轴数据。 温湿度数据等等。 它们相邻数据包之间的数据具有连续性哈。 这样即使相邻数据包混在一起了也没关系。 所以这种情况下就不需要关心这个问题。 具体到底怎么处理。 还需要大家结合实际情况来操作了。 这里就提一下这个可能存在的问题。 大家了解一下就行了。 好那我们这个收发数。 据包的程序大概就讲完了。 接下来我们就来完善一下最终的程序现象。 那在这最上面先include一下k.h之后。 定义变量unit 8杠t k lab。 然后k1 it oid显示字母串。 写一下哈。 oid show string。 一行一列显示tx packet。 复制一下三行一列显示x packet。 先写一下发送的逻辑哈。 按一下按键。 变换一下数据发送到串口助手上。 首先这里先把发送缓存-1个初始值。 i send packet。 先剪切。 再组循环里k number等于k get number。 if k lamb等于等于一。 按键按下就执行发送。 先变换一下测试数据哈。 这里复制一下。 给每个数据都加加。 之后send pack发送数据包。 最后我们用id显示一下。 复制一下下面这个显示的部分哈。 行号改成二。 在第二行显示显示的内容。 改成tx packet。 这样就行了。 最后下面这个位置也换一下哈。 接收到的数据放在第四行显示。 这样我们这整个程序就完成了。 我们来最终测试一下。 下载。 看一下。 首先是发送数据包。 按一下按键变换一次数据。 发送一个数据包。 o i d显示发送数据。 串口助手收到数据没问题啊。 然后是接收数据包。 我们发送指令格式的数据包。 ori id显示接收到数据包。 换个数据包试试。 有没有问题啊。 好。 这就是第一个程序串口收发数据包的内容。 那接下来我们就继续写一下。 下一个程序串口收发文本数据包。 回到工程文件夹哈。 我们复制一下上一个工程。 在这个工程上修改。 改个名字叫九杠四串口收发文本数据包。 打开工程。 进来之后这个按键部分删掉。 发送部分删掉啊。 while循环里面的东西也全都删掉。 然后是串口的c文件。 我们修改一下我们这个程序的数据包格式。 定义就是ppt的这里自可变包长含包头包围。 以艾特符号为包头。 换行的两个符号为包围。 中间的载荷字符数量不固定哈。 那程序这里呢。 我们这里就只写接收的部分哈。 因为发送的话不方便像hex数组一样。 一个个更改的。 所以发送就直接在主函数里升个string。 或者print f就行了。 非常简单。 那接收部分我们来实现一下。 首先缓存区发送的删掉哈。 接收的数据类型定义为恰用于接收。 字符同时数量我们给多点哈。 房子溢出给个100。 这要求单条指令。 最长不能超过100个字符哈。 那接收缓存区就定义好了之后是中断的。 状态机部分参考一下ppt这里的状态转移图。 那这里状态零等待包头就是x data。 是不是等于at字符。 如果等于就转移到状态一计数器清零哈。 如果不等于就维持状态零之后。 状态一这里因为载荷字符数量并不确定。 所以每次接收之前。 我们必须先判断是不是包围。 所以这里的逻辑应该是。 if x data是不是等于等于杠r。 如果是的话。 ex state等于二跳转的状态。 二如果不是的话。 l才需要接收数据。 接收数据是这两行哈。 下面不要了。 这是状态一的逻辑。 最后是状态二。 在这个状态。 我们需要检测rx data是不是等于等于杠n。 等待第二个包围。 如果是的话。 状态至零。 接收标志位置一同时接收到之后啊。 我们还需要给我这个字符数组的。 最后加个字符串减速标志位。 杠零哈。 方便我们后续对字符串进行处理。 要不然你要修string。 它没有结束标志位。 就不知道这个字符串到底有多长呢。 加结束标志位也很简单啊。 我们复制一下这一条。 写入字符数组的下一位置数据给反斜杠零。 这样它才是一个完整的字符串啊。 那我们试一下现象。 改一下头文件这个删掉啊。 这个类型是恰下面这个函数删掉。 这样就完成了。 我们在主函数测试一下。 看看主循环这里if serial get ex flag。 等于等于一。 接收到数据包之后。 o i d显示一下。 这里收到的是字符串。 所以可以是o l d修string 4行一列。 显示cereal rx packet。 当然在显示之前。 我们还需要清除一下第四行哈。 因为这个字符串的长度不确定。 如果先显示一个长的。 再显示一个短的。 那长的那个字符串的屁股就会露出来。 所以复制一下。 先给16个空格。 这就相当于擦除第四行了。 再显示就行了。 那我们试一下编译。 这个错误哈。 这个函数忘了删了。 删掉再编译。 下载看一下串口助手。 这里发送和接收都选择文本模式。 然后按照规定的格式发送数据包。 比如艾特abc换行。 这个换行一定要打哈。 发送可以看到这里。 屏幕显示abc这个字符串。 随便修改一下哈。 发送可以看到也是没问题的。 字符串都有了。 那之后的内容其实就比较好办了是吧。 我们完善一下最终的程序。 先把d加进来。 include l d.一去。 然后led it初始化之后。 在这里就是判断字符串。 是不是等于我们规定的指令。 在执行相应的操作了是吧。 判断字符串呢。 我们可以调用c语言字符串的官方库。 在上面include的string dh。 这个库里面有很多字符串的处理函数啊。 学c语言的时候都见过。 如果不清楚的话。 可以在网上搜搜复习一下。 那在这里我们判断两个字符串是否相等。 需要用到一个函数哈。 string。 compare。 第一个字符串给cereal ex package。 第二个手写个哈。 比如d下划线二。 如果相等的话。 函数返回零。 所以套个if。 如果string compare比较字符串等于等于零相等。 那就是指令匹配。 我们可以执行d12 点亮led。 同时我们可以反馈一下信息哈。 像串口助手回传一个字符串。 serial sd。 string。 led 2 k杠r杠n。 然后o i d也显示一下发送的数据哈。 这两行复制一下位置是第二行。 内容是led啊。 ok这样led on指令的动作就完成了。 之后我们复制一下。 来个led off的。 这里是if接收到的数据与led of相同。 则d1 of回传of k显示of。 ok最后再来一个else。 也就是上面的指令都不匹配。 则不执行操作。 复制一下回传error command。 显示error command的错误指令哈。 好来这样程序的逻辑就完成了。 我们来测试一下。 下载看一下。 我们先发送一个led。 led点亮。 回传led 2 k再来个d of。 led熄灭。 回传led off。 ok再来个其他的指令。 d5 操作哈。 回传error command。 这就是我们第二个程序的现象。 最后还有一个问题需要说明哈。 同样还是之前的那个问题。 如果连续发送数据包。 程序处理不及时。 可能导致数据包错位哈。 在这里文本数据包每个数据包是独立的。 不存在连续。 这如果错位了。 问题就比较大。 所以在程序这里我们可以修改一下哈。 等每次处理完成之后。 再开始接受下一个数据包。 怎么改呢。 我们可以利用这个ex flag。 在这里就不使用读取flag之后。 立刻清除的策略了。 我们可以这样在中断函数这里。 等待报仇的时候再加一个。 条件如果数据等于报酬。 并且serix flag等于等于零才执行接收。 否则就是你发的太快了。 我还没处理完呢。 就跳过这个数据包。 然后上面这个读取标志位之后。 立刻清零的函数先删掉哈。 我们可以把这个x flag。 也声明为外部可调用。 暂时不分装了哈。 之前的函数删掉。 然后组函数这里if serial ex flag。 等于等于一代表接收到数据包了。 执行操作等操作完成之后。 x flag等于零。 把flag清零在中段。 这里只有flag为零。 那才会继续接受下一个数据包。 这样写数据和读数据就是严格分开的。 不会同时进行。 就可以避免数据包错位的现象了。 不过这样的话。 你发送数据包的频率就不能太快了哈。 否则会丢弃部分包。 这是这个逻辑。 或者你还可以再定一个指令缓冲区。 把接收好的字符串放在这个指令缓冲区。 进行排队啊。 这样处理起来会更加有条理。 有关这个数据包的手法哈。 其实还是有非常多的细节问题。 需要考虑的是吧。 实际应用的话还是得多想想。 那我们试一下这个代码。 下载看一下。 发送d2。 开灯发送lled off。 关灯没问题啊。 现象和刚才的是一样的。 如果你数据包发送频率比较低哈。 有足够长的时间处理。 那其实都没问题啊。 就是发太快的时候可能会有些问题。 这个注意一下好。 那本小节的内容到这里就结束了。 我们下节再见。
30. hello。 大家好。 这位小节我们讲点轻松的哈。 主要是教大家使用两个小软件。 这两个软件也是比较常用的。 里面有很多有意思的功能。 可以给大家介绍一下。 第一个是fly mcu这个软件。 这个软件可以通过串口给sm 32下载程序。 如果你没有s t link。 就可以用这个软件通过串口下载程序。 第二个软件是snk utility。 这个软件是配合st link使用的一个工具哈。 可以通过s t link给s t m32 下载程序。 也可以进行一些其他的操作哈。 总的来说。 这两个软件的功能差不多都可以下载程序。 flam c u是串口下载。 s link utility是st link下载。 那我们先看一下flam c u程序烧录软件。 打开软件。 这个软件是绿色软件。 直接打开就能运行。 不需要安装哈。 这个软件的作用呢。 如果你玩过htc的五一单片机的话。 应该知道s t c单片机也有个程序烧录软件哈。 叫s t c l s p。 可以通过串口给五一单片机下载程序。 这个fly mcu就跟那个s t c l s p的用途是一样的。 都是串口下载。 那接下来我就演示一下串口下载的流程哈。 首先硬件这里我们需要连接一个串口的电路。 这个电路要能保证usr t一和电脑进行串口通信哈。 这里必须要是usd 1。 因为我们这个芯片的串口下载只适配了u s a r t一哈。 接在其他u s a r t上是不行的。 那这里我的线已经接好了哈。 揭发和前期小节是一样的。 然后在软件上我们随便打开个示例代码。 比如我这里拖出来了一个led闪烁的代码作为演示哈。 打开工程。 为了实现串口下载。 我们需要配置工程。 生成一个h e x文件。 点击工程选项。 在output选项卡里把这个创建h e x文件的勾勾。 上海。 ok这时再编译一下。 下面信息多了一条创建h e x文件的信息啊。 编译没问题。 我们就可以打开工程目录。 在这个objects文件夹下找到我们刚才生成的h e x文件。 这就是我们串口下载所需要的程序文件哈。 这部分流程和五幺单片机那里是一样的。 接下来我们就可以用flam ceo下载程序了。 首先上面先点搜索窗口。 然后part这里选择我们串口通信的com号哈。 d p s波特率可以保持默认的115200。 这一部分和串口助手是一样的哈。 接着选择程序文件。 点击这里三个点的按钮。 找到我们刚才生成的h e x文件。 在这个工程目录objects文件夹里选中。 打开之后下面这些其他的配置哈。 我们暂时先保持默认。 目前对下载程序影响不大。 等会再细说啊。 然后再开始编程之前我们还需要配置boot引件。 让sm 32执行bootloader程序。 否则的话点击开始编程。 它会一直卡在这个位置哈。 如何进入bootloader呢。 我先演示流程哈。 等会再解释。 看下板子。 第一步找到这里的跳线帽。 这两个跳线帽是用来配置boot引脚的哈。 然后插在右边两个证件配置bot 0为一。 第二步按一下复位键。 让程序重新开始运行。 这里切换不同引脚之后。 一定要再按一下复位键哈。 因为s t m32 只有在刚复位时才会读取不t引脚。 程序运行之后切换步特引脚是无效的。 那这样芯片就进入bootto的程序了。 进入bootto的程序之后。 s t m32 执行的程序就是不断接收usr这一的数据。 刷新到主闪存。 然后再回到flame ceo软件。 点击开始编程。 这时就可以看到下载过程成功运行哈。 最后显示下载成功。 这样我们这个led闪烁的程序就通过boot road成功刷新到主闪存里了。 回到sm 32。 目前led还没有亮起来。 这是因为目前sm 32还在执行butler的刷机程序。 我们还需要把boot 0件换回来。 拔掉bot 0的跳线帽哈。 换到左边两个引脚。 然后按一下复位。 可以看到lled闪烁程序运行正常哈。 那接下来我们来研究两个问题。 第一个问题。 boot引脚是干啥的。 为啥这样配置不错。 dodo又是干啥的。 串口下载的原理是什么。 第二个问题。 每次下载程序都要拔插两遍。 跳线报。 太麻烦了哈。 有没有什么解决方法。 先看一下第一个问题。 串口下载的原理。 我们看一下ppt哈。 之前这里我们讲过了s t m32 的存储器。 印象在room区的0800位置存储的就是编译后的程序代码。 你把什么程序写到这个位置。 s tf 2就执行什么样的程序。 如果想使用串口下载程序的话。 我们只需要把程序数据通过串口发给s t m32。 s t m32 接收数据。 然后刷新到0800这一块位置就行了。 但是接收并转存数据这个过程本身也是程序啊。 如何利用程序实现自我更新。 这是一个问题。 就像是一个机器人给自己换电池一样。 换电池需要先拆掉旧电池。 再装上新电池。 但是一旦把旧电池拆掉。 机器人本身就无法工作了。 这样之后装上新电池的工作就没法完成了。 所以为了能让机器人自己换电池。 我们还需要再额外做一个小机器人。 需要换电池的时候就启动这个小机器人。 小机器人完成整个换电池工作之后。 再返回大机器人运行。 那同理s t m32 通过串口进行程序的自我更新。 就需要这样一个小机器人。 这个小机器人就是bot road bottodo。 是st公司写好的一段程序代码。 这段程序的存储位置就是room区的最后1f f f000。 这段区域叫做系统重塑期。 还存储的是bootl的程序或者叫自举程序。 用途是程序自我更新。 串口下载哈。 在更新过程中不烧肉的接收usr t一数据刷新的程序存储器。 这时主程序就处于瘫痪状态。 更新好之后再启动主程序。 执行新程序。 这就是串口下载的流程。 如果你给手机或电脑重装个系统的话。 就可以类比一下哈。 这个bootloader就相当于是手机的刷机模式或者电脑的pe系统。 还是辅助主程序进行自我更新的。 然后再往前翻一下。 这里有一个启动配置。 如何启动大机器人。 如何启动小机器人就由boot引脚来决定。 当boot 0为零时。 就是主闪存。 也就是0800的位置开始运行启动大机器人。 当boot 0为一。 boot一为零时。 就是从系统存储器。 也就是1f f f f000 开始运行启动小机器人哈。 最后还有一个boot 0和boot一都为一。 从s ram。 也就是2000开始运行。 这个比较高级哈。 我们暂时不用。 然后下面这里写了。 在系统复位后。 system clock的第四个上升沿布特引脚的值将被锁定。 所以说每次切换boot引脚之后。 都要按一下复位好。 到这里串口下载的原理就讲完了哈。 接下来我们来研究一下第二个问题。 每次下载都要切换跳线帽。 太麻烦了。 怎么解决呢。 刚才我们说了。 想要程序自我更新。 就必须有一个切换小机器人的过程。 不t0 引脚和st复位引脚必须得有高低电平变化。 那能不能我接两根线到电脑。 点击下载时自动帮我设置一下波特零和s的电瓶呢。 答案是可行的哈。 我们可以看一下这个串口模块的电路。 这里除了txt和rx d用于通信的硬件。 还有r t s c t s d t r和d s r这些引脚都是流控的引脚哈。 我们不使用流控。 可以把它们当做普通的g p i o来控制。 其中r t s和d t r是输出引脚。 我们可以用这两个引脚来控制bot 0和r s t哈。 一般可以用两个三极管开关来进行控制哈。 有关电路部分大家可以网上搜一下。 s t m321 键下载电路里面都有设计方案和解释哈。 当我们这个串口具备一键下载电路之后。 就不需要再频繁切换跳线帽和按复位键了。 非常方便。 回到flam ceo。 这下面有个下拉框。 就是用来配置低cr和rt的。 是高电平复位啊。 还是低电平复位啊等等配置。 这些配置需要根据一键下载电路来选哈。 一般最常用的配置是d t r的低电平复位。 rt s高电平进bootloader。 我们这个硬件哈目前没有一键下载电路。 那这里的下拉框选择哪个就无所谓了哈。 选好之后。 这里的信息可以看到哈。 下载之前会给dt r和rt制高低电平一次切换。 大机器人和小机器人工作哈。 那没有一键下载电路。 我们还有一个缓招可以使用哈。 就是勾上这里的编程后执行。 这样试一下。 看看先切换天线帽哈。 复位进入波特rolled就没有闪烁了。 回到这里。 如果选择了编程后执行。 需要去掉选项字节的这个勾。 要么下载之后会提示执行失败哈。 我们去掉一下。 开始编程。 下载完成。 然后看一下。 这时程序直接就运行了。 即使现在跳线帽仍然处于不tler的状态。 为啥呢。 我们看一下这里。 这里多了一条成功。 从0800开始运行。 这就是在软件上人工加入了一条跳转指令哈。 这样就能执行主程序了。 但是这样只是一次性的哈。 我们复位一下。 看看led不亮程序仍然是不受周的。 不过这样也可以省很多步骤。 我们可以切换到bootlo的。 不断的进行下载调试。 然后调试完成之后再切换回主程序。 这样就只需要最开始和最后切换一下天线m2 就行了。 不要省字哈。 好这个问题我也就讲这么多。 接下来我们继续来探索一下这个软件。 这里面还有很多有意思的东西。 首先是这个读flash。 我们点一下。 然后放到桌面板。 起个名字保存。 这样就可以把芯片里的程序读出来哈。 现在提示读取完成。 桌面上就出现了程序文件。 这就有意思了是吧。 比如你看到别人用s tf 2做了一个产品。 你觉得不错。 就可以抄一下他的pcb板。 然后程序文件呢又可以通过这个软件读出来。 这样就可以大批量删掉别人的产品了是吧。 不过s tf 2也可以配置独保护哈。 这个等会再说。 但是反过来。 如果你开发产品不注意这个问题的话。 是不是一不小心程序就泄露了是吧。 那我们看一下读出来的这个文件。 这个文件是点b格式的。 里面记录的就是sm 32从0800开始存储的程序数据哈。 并格式是没有地址信息的。 原始数据文件。 我们之前生成的hex文件是有地址信息的哈。 不过作为记录程序代码的文件。 这两种格式的作用其实都是一样的。 这里还有一个问题哈。 就是这个flam c u下载的时候只能选择hex文件。 如果选择b文件的话。 下载就会报一个这样的错误哈。 但是他读出来只能选b文件。 读出来的b文件不能再下载回去了。 有点折磨人哈。 可能是软件设计的时候没考虑到这个功能。 不过等会我们介绍s tan utility的时候。 这两个文件就都可以选择了哈。 那我们继续来看。 点击这个清除芯片按钮试一下。 这可以把主程序区域全部擦除哈。 擦除之后所有的数据都是f f啊。 之后读器件信息试一下。 这时会把芯片的序列号什么的信息读出来哈。 然后这里显示我这个芯片的flash容量是256k。 这个有点夸张哈。 我们这个c8 t6 芯片的标称flash容量是64k。 属于中容量产品啊。 这里读出来却是256k。 直接成大容量产品了哈。 我试过很多芯片。 有的芯片是64k。 有的是128k。 还有的像我这样是256k。 这个我百度了一下。 说是生产的时候为了省工序。 很多型号是一个模子做出来的。 但是c8 t6 只能保证前64k也没问题。 当然也还有其他的说法哈。 大家可以自行了解一下。 这个问题并不是很大。 然后这个rap sp和连续烧录模式目前用的不多哈。 大家可以自行研究。 最后我们再来研究一下这个选项字节。 看一下ppt啊。 之前我们也提到过选项字节。 在这里选项字节也是入墓区最后的一小块存储单元。 用途是纯属一些独立于程序代码的配置参数。 那究竟是哪些参数呢。 有什么作用呢。 在这里就可以看到了。 点击设置选项。 自己的按钮选择s t m32 f一的这一项啊。 这个界面展示的就是选项字节里面的参数了哈。 第一块就是读保护。 刚才我们说了。 如果你做产品不开启独保护。 别人很容易就把你的程序偷走了。 所以为了保护程序的安全。 选项字节里就有一个参数可以配置独保护。 这里可以看到射程a5 允许读出。 射程f f逐字读出。 注意一下哈。 如果你阻止读出来。 再回到q下载程序时就会失败。 如果因为毒保护导致下载失败。 那需要再到这个地方来取消毒保护啊。 取消一下就正常了。 另外在取消毒保护时会同时清空芯片的程序啊。 这样程序就不会被偷走了。 这就是读保护功能。 停机和待机模式不产生复位。 还有几位用户应该大概也许可以使用哈。 这些了解一下就行。 如果有需求的话。 可以用一下。 然后是用户数据。 直接这些东西。 如果你有需求的话。 可以自己使用哈。 那选项字节里面的参数有什么好处呢。 就是选项字节的数据相当于是世外桃源了哈。 无论程序怎么更新。 选项字节的数据都可以不变。 你可以用这些字节来存储不随程序变化变化的参数啊。 另外选项之前还有一个好处。 就是可以用上位机很方便的修改。 比如我们这个fly mcu或者s link utility。 在上位机里可以直接修改选项自己的内容哈。 是不是可以用作一些产品中可供用户配置的参数啊。 然后继续看最后一项就是写保护了。 这里可以对flash的没几个页单独进行写保护啊。 比如你在主程序的最后几页写了一些自定的数据。 不想在下载的时候被擦除了。 就可以把最后几页设置写保护锁起来。 设置写保护之后就无法再写它。 如果想再次写入的话。 解除写保护就行了。 另外注意一下。 设置写保护之后再下载。 如果需要写入保护区的话。 就会出错哈。 比如你把最前面几页写保护了。 下载一次之后再下载。 肯定就会出错。 而它这个软件设计还不能单独写入选项。 字节只能下载flash。 顺便写入选项之间。 但写保护了。 下载不了。 下载不了。 就不能解除写保护。 形成死循环了哈。 这个注意一下。 不过我们等会儿讲另一个软件的时候。 就可以单独配置选项自己哈。 就可以解决这个问题了。 好这就是选项字节的所有内容。 总共就是四大块。 读保护。 写保护。 硬件参数和用户参数配置好之后。 可以点击采用这个设置哈。 然后把编程到flash时写选项自己的勾勾上。 在执行正常的下载流程。 就能更新选项字节的配置了。 大家可以自己玩一玩试试好。 有关这个flam ceo。 我就讲这么多。 基本上各个功能也都讲完了哈。 下载程序的流程和原理。 如何解决频繁切换跳线帽的问题。 读取程序擦除芯片以及选项字节的内容就这么多。 然后呢我们就来看一下下一个软件s t link utility。 这个软件是需要安装的哈。 直接双击安装。 这里面直接下一步yes。 这里安装路径大家可以指定一下啊。 或者直接默认路径也没问题。 下一步。 最后这里提示安装s t link的驱动哈。 直接点四就行了。 完成非利息。 这样就安装好了。 安装之后桌面就会出现这样一个软件图标。 我们双击打开。 这就是软件的主界面了。 首先演示一下用这个软件下载程序的流程啊。 硬件这部分只需要把s t link连接好就行了。 串口可以不接。 然后跳线帽恢复成两个都在最左边。 复位之后。 点击这个按钮进行连接。 连接好之后。 这里就会出现一些器材信息了哈。 然后下面这个大框框展示的就是s t m32 里面。 0800开始的程序数据哈。 目前我这个芯片刚被擦除过。 所以数据全是ff。 如果你点击这个保存。 就可以把这个程序给存起来了。 这里可以选择保存为hx或者bin文件。 之后点击这个按钮就是断开连接。 点击这个橡皮擦就是擦除芯片哈。 如果要下载程序的话。 先点第一个按钮打开文件。 这里文件类型支持hex和b。 我们可以打开刚才读出来的bin文件哈。 然后点击这个编程按钮。 这一栏显示的就是程序文件的路径。 当然你也可以在这里直接打开要下载的程序文件之后。 点击start开始下载。 下载完成之后。 我们看到led闪烁没问题啊。 这就是st link utility下载程序的流程和q内置的下载基本是一样的哈。 非常简单。 然后再讲一下这个软件选项字节的配置啊。 可以点击target option beats。 这就可以打开选项字节的配置页面了。 选项字节的内容和刚才讲的一样哈。 第一块就是读保护。 可以使人或私人。 第二块也是硬件参数啊。 这些灰色的选项我们这个型号的芯片没有哈。 之后就是第三块用户参数。 第四块是写保护内容都一样。 这里配置好之后。 直接点击apply就能直接单独更改选项字节的参数了哈。 不像fly mcu必须要下载程序。 顺便更新选项字节。 所以如果你有芯片被毒保护或者写保护锁住了。 就可以到这个地方来解除保护。 这就是这个软件的选项字节配置。 最后再给大家介绍一个s t link固件更新的功能哈。 我们可以点击sd link from y update。 然后打开这个s t link upgrade。 这个界面就是给s t link更新固件了哈。 然后点击这里的connect连接。 这里提示重启一下哈。 那我们拔掉重新插。 连接可以看到目前这个s t link的固件是g29 s7。 最新的固件是j37 s7。 如果要升级的话。 点yes就能给s t0 k升级固件了哈。 需要升级的话。 可以到这里来看看。 不过如果你使用没问题的话。 也不需要经常更新哈。 能用就行了。 好那有关这两个软件的介绍。 s t m32 bootloader选项字节等等这些内容到这里就结束了。 那么下节再见。
31. hello。 大家好。 欢迎继续观看s t m32 入门教程。 关于fc通信的内容。 我主要会分为两大块来讲。 第一块就是介绍协议规则。 然后用软件模拟的形式来实现协议啊。 第二款就是介绍s t m32 的fc外设。 然后用硬件来实现协议。 因为mc是同步时序啊。 软件模拟协议也是非常方便。 目前也存在有很多软件模拟fc的代码。 所以我们先学软件i fc。 再学硬件i方c。 至于哪个更方便啊。 各自的优势和劣势啊。 等你学完之后应该会自有定论哈。 这就是本节课程的内容安排。 那iphone c通信的知识点呢。 我在五一单片机的视频里也讲过哈。 在五一单片机那个视频里。 我们使用的是t20。 在这个视频呢我们会使用m p u6050。 大家可以两个视频都看看啊。 对比一下iphone c。 在不同器件的应用有什么异同啊。 也可以加深大家对iphone c协议的理解啊。 好那我们先看一下本节课程的程序现象哈。 本节课程主要有两个代码。 一个是软件fc读写m p u6050。 另一个是硬件fc读写m p u6050。 两个代码实现的效果是一样的哈。 那先看一下这个软件。 ifc读写m p u6050 的程序现象。 下载看一下目前这个程序啊。 我们通过软件iphone这些通信。 对m p u6050。 芯片内部的寄存器进行读写。 写入到配置兼容器呢。 就可以对外挂的这个模块进行配置。 读出数据。 进行器呢就可以获取外挂模块的数据。 这就是iphone通信的目的。 最终我们读出的数据。 会显示在这个o i d上。 其中最上面这个数据是设备的id号。 我们这个mp u6050 的id号。 固定为0x68 哈。 一般我们可以读出这个id号验证。 看看是不是0x68。 用来测试fc读取数据的功能是不是正常哈。 另外我之前还测试了不同批次的芯片啊。 发现有的芯片id是0x98。 id号可能会有些不同。 不过如果数据读出来没问题的话。 这也不影响。 知道一下就行了。 传感器的输出数据分别是x轴。 右边三个是陀螺仪传感器的输出数据。 分别是x轴y轴和z轴的角速度。 我们可以改变mp u。 6050传感器的姿态哈。 这六个数据就会对应变化。 等我们介绍这个模块的时候再详细解释哈。 那这就是目前这个程序的现象。 然后回到ppt我们来看一下fc通信。 在学fc之前呢。 串口通信啊。 就是从tx引脚向x引脚发送数据流。 数据流以字节为单位。 我们可以组合多个字节。 另外串口通信的设计师啊。 一条发送线。 一条接收线。 没有时钟线的异步全双工的协议。 那现在假如有个大公司找到了你啊。 出资1000万要求你给他设计一个通信协议。 这个通信协议是用来干啥的呢。 大概就是像这里这样这个公司啊。 开发出了一款芯片。 可以干很多事情。 比如a d转换温湿度测量。 姿态测量等等。 像我们单片机一样。 这个芯片里的众多外设啊。 也都是通过读写寄存器来控制运行的。 寄存器本身也是存储器的一种啊。 这个芯片所有的寄存器也都是被分配到了。 一个线性的存储空间。 如果我们想要读写寄存器。 来控制硬件电路啊。 我们就至少需要定义两个字节数据。 一个字节是我们要读写哪个净水器。 也就是指定寄存器的地址。 另一个字节就是这个地址下。 存储器存的内容。 写入内容就是控制电路。 读出内容就是获取电路状态。 这整个流程和我们单片机cpu。 操作外设的原理是一样的哈。 那现在问题来了。 单片机读写自己的计算器。 直接用指针操作就行。 不需要我们操心。 但是现在这个模块的计算器。 在单片机的外面。 你要是直接把单片机内部的数据总线。 拽出来。 把两个芯片合为一体。 那可能不太现实啊。 所以现在这个大公司就找到了。 你要求你给他设计一种通信协议。 在单片机和外部模块连接少量的几根线。 实现单片机读写外部模块寄存器的功能。 这时候你可能会想啊。 这不太简单了。 就可以完成任务。 从单片机向外挂模块发过去。 第一个字节表示读写。 第二个字节表示读写的地址。 第三个字节表示写入的数据。 0x a a。 这就表示在0x06 地址下写入。 0x a模块。 收到之后就执行这个写入操作啊。 x010 x060 x00。 这就表示我要读取0x06 地址下的数据。 还模块收到之后就要再给我发送一个字节。 返回零至零六地址下的数据。 这样就行了。 是不是完美完成任务啊。 你自己觉得这1000万已经到手了哈。 但是呢。 这个大公司对这个通信协议的要求非常多。 其中要求一。 目前串口这个设。 计啊是一个需要两根通讯线的全双工协议。 但是可以明显的发现啊。 我们这个操作流程。 是一种基于对话的形式来进行的。 我们在整个过程中。 并不需要同时进行发送和接收。 发送的时候就不需要接收。 接收的时候就不需要发送。 这样就会导致始终存在一根信号线。 处于空闲状态。 这就是资源的浪费。 所以要求依旧是删掉一根通讯线。 只能在同一根线上进行发送和接收。 也就是把全双工变成半双工。 这就是第一个要求。 然后要求二。 我们这个协议并没有一个应答机制啊。 也就是单片机发送。 了一个数据。 对方有没有收到单片机是完全不了解的。 所以为了安全起见。 大公司要求增加应答机制。 要求每发送一个字节。 对方都要给我个应答。 每接收一个字节。 我也要给对方一个应答。 这是第二个要求。 然后第三个要求呢。 大公司说你这一根线只能借一个模块。 不给力啊。 他要求你这一根线上能同时接多个模块。 单片机可以指定和任意一个模块通信。 同时单片机在跟某个模块进行通信时。 其他模块不能对正常的通信产生干扰。 这就是第三个要求。 最后第四个要求。 你这个串口是异步的。 时序也就是发送方和接收方约定的。 传输速率是非常严格的。 始终不能有过大的偏差。 也不能说是在传输过程中啊。 单片机有点事进中断了。 这个时序能不能暂停一下啊。 对于异步时序来说。 这是不行的。 你单片机一个字节发一半暂停的。 接收方可是不知道的。 它仍然会按照原来那个约定的数据读取。 这就会导致传输出错。 所以一不时续的缺点。 就是非常依赖硬件外设的支持啊。 必须要有uc r t电路才能方便的使用。 如果没有uc r t硬件电路的支持。 那么串口是很难用软件来模拟的。 虽然。 说软件模拟串口通信也是行得通的哈。 但是由于异步时序对时间要求很严格。 一般我很少用软件来模拟串口中心啊。 所以这个大公司的要求是。 你要把这个协议改成同步的协议。 另外加一条时中线来指导对方。 足协由于存在始终线啊。 对传输的时间要求就不高了。 单片机也可以随时暂停传输。 去处理其他事情。 因为暂停传输的同时啊。 时钟线也暂停了。 所以传输双方都能定格。 在暂停的时刻。 可以过一段时间再来继续。 不会对传输造成影响。 这就是同步时序的好处。 使用同步时序就可以极。 大地降低单片机对硬件电路的依赖。 即使没有硬件电路的支持。 也可以很方便地用软件手动翻转电平。 来实现通信。 比如我们之前五幺单片机里。 那个单片机就没有fc的硬件外设。 但是同样不影响五一单片机。 进行软件模拟的fc通信。 异步时序的好处就是省一根时钟线啊。 节省资源。 缺点就是对时间要求严格。 对硬件电路的依赖比较严重。 同步时序的好处就是反过来。 对时间要求不严格。 对硬件电路不怎么依赖。 在一些低端单片机没有硬件资源的情况下。 也很容易使用软件的模拟时序。 缺。 点就是多一根时钟线哈。 这就是同步和异步的区别。 那大公司考虑到这个协议要主打下沉市场。 所以他需要一个同步的协议。 那现在要求就提完了。 是不是感觉什么玩意儿啊。 要求也太多了吧。 这个大家可以暂停一下视频。 自己拿纸和笔画一下。 看看你能不能设计出一款。 让大公司满意的协议。 其实通信协议这个东西啊。 就是一个很灵活的设计方案。 并没有很严格的要求。 说它必须是这样。 只要你的设计能实现项目要求。 符合电路原理。 性能和稳定性好。 那你的设计就是好设计。 如果能有大公。 司帮你推广。 得到了广泛的认可。 理设计的通讯协议哈。 好讲了这么多。 这个通信协议的设计背景。 大家就已经清楚了吧。 那我们进入正题。 我们来看iphone c通信。 再声明一下项目要求。 我们最基本的任务是。 通过通信线实现单片机读写外挂模块。 计算器的功能。 其中至少要实现在指定的位置写寄存器。 和在指定的位置读计算器。 这两个功能。 实现了读写计算器。 就实现了对这个外挂模块的完全控制。 另外刚才说的大公司提出的四点要求。 也别忘了哈。 必须要满足大公司的。 要求才行。 然后我们来看一下。 首先fc总线它的英文全称是英特尔s bus。 缩写就是aac或者a的平方c。 fc总线。 是由飞利浦公司开发的一种通用数据总线。 目前应用还是非常广泛的。 已经有很多模块都使用了。 iphone c的协议标准了哈。 比如下面第一个图片。 就是我们套件里的mp u6050 模块。 可以进行姿态测量啊。 使用了ifc通信协议。 第二个图片是我们套件里的o l e d模块。 可以显示字符啊。 图片等信息也是mc协议。 第三个图片是a t20 c02 存储器模。 块就是我们五幺单片机教程里。 第四个图片是d s3231 实时时钟模块。 也是使用iphone c通信啊等等。 还有很多模块都支持ifc通信。 使用了这个通用的协议。 这对于我们开发者来说就非常方便了是吧。 同样的协议在不同的硬件上。 操作方法都是极为相似的。 学会了其中一个硬件。 再学其他的硬件就很容易了。 那iphone c的标志性引脚就是两根通讯线。 s cl全称cereal clock。 串行时钟线。 s d a全称cereal data。 串行数据线。 从下面的图片中啊。 我们也可以很明显的看到。 使用iphone c通信的器件都。 有s scl和sda这两个硬件。 那sc l时钟线就满足了。 刚才大公司提出的要求。 是要使用同步的时序。 降低对硬件的依赖。 同时同步的时序啊。 稳定性也比异步的时序更高哈。 然后只有一根sda数据线。 就满足了大公司提出的要求。 一变全双工为半双工。 一根线间距发送和接收。 最大化利用资源哈。 所以我们可以看到下一条fc通信是同步。 半双工的协议。 之后fc也是一个带数据应答的协议哈。 满足了设计要求。 二最后fc支持总线挂载多设备。 满足了设计要求。 三。 并且这个挂载多设备啊支持两种模型。 一组多重和多组多重。 一组多重的意思就是单片机作为主机主导。 fc总线的运行。 挂载在iphone c总线的所有外部模块都是重击。 重击只有被主机点名之后才能控制fc总线。 不能在未经允许的情况下去碰i fc总线。 防止冲突啊。 这就算是在教室里。 老师是主机主导。 课程在进行。 所有学生都是重机。 所有重击可以同时被动地听老师讲课。 但是重击只有在被老师点名之后才能说话。 不可以在未经允许的情况下说话。 这样课堂才能有条不紊的进行啊。 这是一组多重的模型。 我们使用iphone c的绝大多。 数场景啊都是一组多重的形式。 一个单片机作为主机。 挂载一个或多个模块作为重击。 另外ifc其实还支持多组多层的模型啊。 也就是多个主机多主多从的模型。 在总线上。 任何一个模块都可以主动跳出来说。 接下来我就是主机。 你们都得听我的。 就算是在教室里。 老师正在讲课。 突然一个学生站出来说。 老师打断一下。 但是同一个时间只能有一个人说话。 这时就相当于发生了总线冲突。 在总线冲突时安放在协议会进行仲裁。 仲裁。 胜利的一方取得总线控制。 权失败的一方自动变回重击。 当然由于时钟线也是有主机控制的。 所以在多主机的模型下。 还要进行时钟同步啊。 多主机的情况下。 协议是比较复杂的。 大家感兴趣的可以自己去了解哈。 我们本课程仅使用一组多重的模型哈。 多组多重的部分不做要求。 那到这里有关ifc的设计背景和基本功能。 我们就了解了。 接下来我们就来详细分析一下。 看看iphone c是怎么实现这么多功能的。 作为一个通信协议。 它必须要在硬件和软件上都做出规定。 硬件上的规定啊。 就是你的电路应该如何连接端口的输。 入输出模式都是啥样的。 这些东西软件上的规定。 你的时序是怎么定义的。 字节如何传输。 高位先行还是低位先行。 一个完整的时序有哪些部分构成这些东西。 硬件的规定和软件的规定配合起来。 就是一个完整的通信协议啊。 接下来我们先看一下iphone c的硬件规定。 也就是硬件电路部分。 这个图就是ifc的一个典型电路模型。 这是一个一组多重的模型。 左边cpu就是我们的单片机哈。 作为总线的主机。 主机的权力很大。 任何时候都是主机完全掌控sl线。 另外在空闲状态。 下主机可以主动发起对sda的控制。 只有在重击发送数据和重击硬打的时候。 主机才会转交sda的控制权给重击。 这是主机的权利。 然后看下面这一系列都是被控c。 也就是挂载在iphone c总线上的冲击。 这些重机可以是姿态传感器啊。 o i d啊。 存储器啊。 时钟模块等等。 重击的权力比较小哈。 对于s c l时钟线。 在任何时刻都只能被动的读取重击。 不允许控制s c l线啊。 对于sda数据线重击。 不允许主动发起对sda的控制。 只有在主机发送读取重击的命令后。 或者重击应答的时候。 重击才能短暂的。 获取sda的控制权。 这是一组多重模型中协议的规定哈。 然后看接线。 这里第一条写的是。 所有fc设备的sc l连在一起。 sda连在一起。 这是接线要求。 在这个图里也可以看到啊。 主机s c l线一条转出来。 所有重击的s c l都接在这上面。 主机sda线也是一样。 转出来所有重击的sda接在这上面。 这就是s scl和sda的接线方式。 那到现在我们先不继续往后看了。 先忽略这两个电阻哈。 假设我们就这样连接。 那如何规定每个设备。 scl和sda的输入输出模式呢。 s cl应该还规定。 因为现在是一组多重主机。 拥有。 所以主机的sc l可以配置成推广输出。 或者上拉输入。 数据流向是主机发送所有重机接收。 这没问题啊。 但是到sda线这里就比较麻烦了。 因为这是半双工的协议。 所以主机的sda在发送的时候是输出。 在接收的时候是输入。 同样重击的sda。 也会在输入和输出之间反复切换。 如果你能协调好输入输出的切换时机。 那其实也没问题。 但这样做。 如果总线时序没协调好。 极有可能发生两个引脚。 同时处于输出的状态。 如果这时又正好是一个输。 出高电平。 一个输出低电平。 那这个状态就是电源短路啊。 这个状态是要极力避免的。 所以为了避免总线没协调好。 导致电源短路这个问题。 fc的设计是禁止所有设备输出。 强上拉的高电平。 采用外置弱上拉电阻。 加开漏输出的电路结构。 这两点规定就是上面的这两条哈。 设备的s scl和sda。 均要配置成开漏输出模式。 s scl和sda各添加一个上拉电阻组织。 一般为4.7000欧左右。 还对应下面这个图呢。 就是这样。 它引脚的内部结构都是右图这样的哈。 左边这一块是s。 cl的结构。 这里s c l k就是s cl的意思啊。 右边这一块是sda的结构。 这里data就是sda的意思。 首先银角的信号进来。 都可以通过一个数据缓冲器。 因为输入对电路没有任何影响啊。 所以任何设备在任何时刻都是可以输入的。 但是在输出的这部分。 采用的是开漏输出的配置。 正常的推广输出是这样的哈。 上面一个开关管接到正极。 下面一个开关管接到负极上面。 导通输出高电平啊。 下面导通输出低电平。 因为这是通过开关管。 直接接到正极和负极的。 所以这个是。 墙上拉和墙下来的模式。 而开漏输出呢。 就是去掉这个墙上拉的开关管。 输出低电平。 时下管导通是强下拉输出高电平。 时下管断开。 但是没有上管了。 此时阴角处于浮空的状态。 这就是开漏输出。 和这里图示是一样的哈。 输出低电平。 这个开关管导通银价直接接地。 是墙下来输出高电平。 这个开关管断开。 硬件什么都不接。 处于浮空状态。 这样的话所有的设备都只能输出低电平。 而不能输出高电平。 为了避免高电平造成的银角浮空。 这时就需要在总向外面。 s scl和sda个外置一个上拉电阻。 这是通。 过一个电阻拉到高电平的。 所以这是一个弱上拉。 用我们之前的弹簧和感知的模型来解释。 就是s cl或sda就是一根杆子。 为了防止有人向上推杆子。 有人向下拉杆子造成冲突啊。 我们就规定所有的人不准向上推杆子。 只能选择向下拉或者放手。 然后我们再外置一根弹簧向上拉。 你要输出低电平就往下拽。 这个弹簧肯定拽不盈利。 所以弹簧被拉伸感知处于低电平状态。 你要输出高电平就放手感知。 在弹簧的拉力下回弹到高电平。 这就是一个弱上拉的高电平。 但是完全不影响数据传输哈。 这。 样做有什么好处呢。 第一完全杜绝了电源短路现象。 保证电路的安全。 你看所有人无论怎么拉杆子或者放手。 杆子。 都不会处于一个被同时抢拉和强推的状态。 即使有多个人同时向下拉杆子也没问题哈。 第二避免了引脚模式的频繁切换。 开了加弱上拉的模式啊。 同时兼具了输入和输出的功能。 你要是想输出啊。 就去拉杆子或者放手操作杆子变化就行了。 你要是想输入啊。 就直接放手。 然后观察感知高低就行了。 因为开漏模式下。 输出高电平就相当于断开硬件。 所以在输入之前可以直接输出。 高电平不需要再切换成输入模式。 第三就是这个模式会有个线与的现象。 就是只要有任意一个或多个设备输出了。 低电平。 总先就处于低电平。 只有所有的设备都输出高电平。 总线才处于高电平。 fc可以利用这个电路特征啊。 执行多主机模式下的始终同步和总线仲裁。 所以这里s cl虽然在一组多重模式下。 可以用推挽输出啊。 但是它仍然采用了开路加上拉输出的模式。 因为在多主机模式下会利用到这个特征哈。 好以上就是fc的硬件电路设计啊。 也就是时。 序的设计了。 基本单元哈。 首先就是歧视条件。 它是指s scl高电平期间。 sda从高电平切换到低电平。 看一下左下角这个图啊。 在f c总线处于空闲状态时。 s scl和sda都处于高电平状态。 也就是没有任何一个设备去碰。 s scl和sda。 s scl和sda有外挂的上拉电阻。 拉高至高电平。 总线处于瓶颈的高电平状态。 当主机需要进行数据收发时。 首先就要打破总线的宁静哈。 产生一个起始条件。 这个起始条件就是sc l处于高电平。 不去动它。 然后把sda拽下来。 产生一个。 下降沿。 当重击捕获到这个sc l高能品。 s da下降沿信号时。 就会进行自身的复威海。 然后在sd下降点之后。 主机要再把s cl拽下来。 在下s c l y一方面是占用这个总线。 另一方面。 也是为了方便我们这些基本单元的拼接哈。 就是我们之后会保证除了歧视和终止条件。 每个时序单元的sc l都是以低电平开始。 低电平结束啊。 这样这些单元拼接起来。 s cl才能续得上是吧。 然后继续看终止条件是s scl高电平期间。 sda从低电平切换到高电平。 也就是这样。 s cl先放手回弹到高。 电平s d a再放手回弹。 高电平产生一个上升眼。 这个上升沿触发终止条件。 同时终止条件之后。 s scl和sda都是高点名。 回归到最初的平静状态。 这个歧视条件和终止条件。 就类似串口时序里的起始位和停止。 微寒。 一个完整的数据帧总是以起始条件开始。 终止条件结束。 另外啊。 歧视和中指都是由主机产生的。 重击。 不允许产生歧视和中指哈。 所以在总线空闲状态时。 重击必须始终双手放开。 不允许主动跳出来去碰这总监。 如果允许的话。 那就是多主机模型了哈。 不在本节的讨论范围之内。 这就。 是起始条件和终止条件。 接着继续看。 在起始条件之后。 这时就可以紧跟着一个发送一个字节的。 时序单元。 如何发送一个字节呢。 就是s scl低电平期间。 主机将数据为依次放到sda线上。 高位线性啊。 然后释放s c l重击。 将在s c l高电平期间读取数据为。 所以s scl高电平期间。 sda不允许有数据变化。 依次循环上述过程八次即可发送一个字节。 图示就是下面这样哈。 歧视条件之后。 第一个字节也必须是主机发送的。 主机如何发送呢。 就是最开始sc l低电平主机如果想发送零。 就拉低sda到低电。 平如果想发送一就放手sda回弹到高电平。 在sc l d音频期间允许改变sda的电瓶。 当这一位放好之后。 主机就松手。 时钟线s cl回弹到高电平。 在高电平期间是重击读取sda的时候。 所以高电平期间s da不允许变化。 sl处于高电平之后。 重击需要尽快的读取sda。 一般都是在上升沿这个时刻啊。 重击就已经读取完成了。 因为始终是主机控制的重击。 并不知道什么时候就会产生下降盐了。 你重击要是磨磨唧唧的。 主机可不会等你的。 所以重击在上升沿时就会立刻把数据读走。 那主机在放着sl一段。 时间后就可以继续拉低cl。 传说下一位主机。 也需要在s c l下降沿之后。 尽快把数据放在sda上。 但是主机有时钟的主导权哈。 所以主机并不需要那么着急。 只需要在低电平的任意时刻。 把数据放在sda上就行了。 晚点也没关系啊。 数据放完之后。 主机在双手s c l s cl。 高电平重击读取这一位。 就这样的流程。 主机拉低cl把数据放在sda上。 主机松开s cl重击读取sda的数据。 在s cl的同步下。 依次进行主机发送和重击接收。 循环八次就发生了八位数据哈。 也就是一个字节。 另外注意啊。 这里是高位。 限行。 所以第一位是一个字节的最高位b7。 然后依次是次高位b6 等等啊。 最后发送最低位b0。 这个和串口是不一样的。 串口时序是低位先行。 这里fc是高位先行。 这个注意一下。 另外由于这里有时钟线进行同步。 所以如果主机一个字节发送一半。 突然进中断了。 不操作s scl和sda的。 那时序就会在中段的位置不断拉长。 s scl和sda电瓶都暂停变化。 传输也完全暂停。 等中段结束后。 主机回来继续操作。 传输仍然不会出问题。 这就是同步时序的好处。 最后就是。 由于这整个时序是主机发送一个字。 节所以在这个单元里。 s scl和sda全程都有主机掌控重击。 只能被动读取哈。 就是发送一个字节的时序。 然后我们接着看接收一个字节。 基本流程是啊。 s scl低电平期间重击。 将数据位依次放到sda线上高位先行。 然后释放sl。 主机将在s scl高电平期间读取数据位。 所以s cl高电平期间。 s da不允许有数据变化。 依次循环上述过程八次即可接收一个字节。 注意啊。 主机在接收之前需要释放s t a。 刚才我们说了。 四方sda其实就相当于切换成输入模式啊。 或者这样来理解所有设备。 处于输入模式。 当主机需要发送的时候。 就可以主动去拉dsd a。 而主机在被动接收的时候。 就必须先释放sda。 不要去动它。 以免影响别人发送。 因为总线是线语的特征哈。 任何一个设备拉低了总线就是低电平。 如果你接收的时候还拽着sda不放手。 那别人无论发什么数据。 总线都始终是底线平。 你自己给他拽着不放。 还让别人怎么发送呢是吧。 所以主机在接收之前需要释放sd。 从流程上来看。 接收一个字节和发送一个字节。 是非常相似的。 区别就是发送一个字节是低电平。 主机放数据。 高电平重击。 读数据。 而接收一个字节是低电平重击放数据。 高电平主机读数据。 然后看一下下面的时序啊。 和上面的基本一样。 区别。 就是sda线主机在接收之前需要释放sda。 然后这时重击就取得了sda的控制权。 重击需要发送零就把sda拉低。 重击需要发送一就放手。 sda回弹高点敏。 然后同样的低电平变换数据。 高电平读取数据。 这里实现部分表示主机控制的电瓶啊。 虚线部分表示重机控制的电瓶。 s cl全程由主机控制。 sda主机在接收前要释放。 交由统计控制之后还是一样哈。 因为s c l始终是有主机控制。 的。 所以统计的数据变换基本上都是贴着s cl。 下降也进行的哈。 而主机可以在scl高电平的任意时刻读取。 这是接收一个字节的时序。 那我们再继续看最后两个基本来源。 就是应答机制的设计。 首先应答机制分为发送韵达和接收应答。 他们的死穴啊。 分别和发送一个字节。 接收一个字节的其中一位是相同的。 你可以理解成发送一位和接收一位哈。 这一位就用来作为应答看一下。 首先是发送应答。 是主机在接收完一个字节之后。 在下一个时钟发送一位数据数据。 零表示应答数据一表示非应。 答。 然后是接收应答。 是主机在发送完一个字节之后。 在下一个时钟接收一位数据。 判断乘积是否应答。 数据零表示应答。 数据一表示非应答。 然后同样主机在接收之前需要释放sda。 这个意思就是。 就要紧跟着调用接收应答的时序。 用来判断重击有没有收到刚才给打的数据。 如果重击收到了。 那在印答位这里。 主机释放sda的时候。 重击就应该立刻把sda拉下来。 然后在s scl高电平期间。 主机读取应答为。 如果硬拿位为零。 就说明重击确实受到了这个场景。 就是啊主机。 刚发送一个字节。 然后说有没有人搜到啊。 我现在把sda放手了哈。 如果有人收到的话。 你就把cd转下来。 然后主机高清明读取数据。 发现诶确实有人给他拽下来了。 那就说明有人收到了。 如果主题发现我松手了。 结果这个sda就跟着回弹到高点名了。 那就说明没有人回应。 我刚发的一个字节可能没人收的。 或者他收到了。 但是没给我回应。 这是发送一个字节。 接收应答的流程。 同理啊。 在接收一个字节之后。 我们也要给重击发送一个意大v。 发送应答位的目的是告诉重击。 你是不是还要继续发哈。 如。 果重新发送一个数据后。 得到了主机的应答。 那统计就还会继续发送。 如果统计没得到主机的应答。 那重击就会认为那我发生了一个数据。 但是主机不理我。 可能主机不想要了吧。 这时重击就会乖乖地释放sda。 交出sda的控制权。 防止干扰。 主机之后的操作就是硬打位的执行逻辑啊。 好来到这里。 我们iphone c的六块拼图就已经集齐了。 分别是歧视条件。 终止条件。 发送一个字节。 接收一个字节。 发送应答和接收应答。 接下来我们就来拼接这些基本单元。 组成一个完整的数据帧吧。 iphone c的完整时序主要。 有指定地址写。 当前地址读和指定地址读这三种。 看一下这里啊。 我们这个fc是一组多重的模型。 主机可以访问总线上的任何一个设备。 那如何发送指令。 来确定访问的是哪个设备呢。 这个需要。 首先把每个重击都确定一个唯一的设备地。 址。 统计设备地址就相当于每个设备的名字哈。 主机在起始条件之后。 要先发送一个字节。 叫一下重击的名字。 所有重击都会受到第一个字节。 和自己的名字经比较。 如果不一样。 只认为主机没有叫我。 之后的时机我就不管了。 如果一样。 那我就响应之后。 主机的读写操作在同一条i放在总线里。 挂载的每个设备地址必须不一样。 否则主机叫一个地址。 有多个设备都想赢。 那不就乱套了嘛是吧。 重启设备地址。 在fc协议标准里分为七位地址和十位地址。 我们目前只讲七位地址的模式。 还因为七位地址比较简单。 而且应用范围最广。 那在每个iphone c设备出厂时。 厂商都会为它分配一个七位的地址。 这个地址具体是什么。 可以在芯片手册里找到哈。 比如我们m p u6050。 这个芯片的七位地址是110。 a t20 c02 的七位地址。 还是101万。 一般不同型号的芯片地址都是不同的哈。 相同型号的芯片地址都是一样的。 那如果有相同的芯片挂载在同一条总线。 怎么办呢。 这需要用到地址中的可变部分呢。 一般器件地址的最后几位。 是可以在电路中改变的。 比如mp u6050 地址的最后一位。 就可以由这个板子上的ad 0引脚。 确定这个硬件接低电平。 那它的地址就是1101000。 这个零件接高电平。 那它的地址就是1101001。 比如d20 c02 地址的最后三位都可。 以分别由这个板子上的a0。 a1 a2 引脚确定。 比如a0 硬件接低电平地址。 对应的v就是零。 接高电平地址。 对应的位移就是1a1 a2 也是同厉害。 一般fc的统计设备地址。 高位都是由厂商确定的。 低位可以由银角来灵活切换。 这样即使相同型号的芯片。 挂载在同一个总线上。 也可以通过切换地址低位的方式。 保证每个设备的地址都不一样哈。 这是iphone c设备的统计地址。 然后我们来看一下fc时序。 第一个时序是指定地址写。 他完成的任务是对于指定设备。 指定设备哈。 通过室内五个的。 钻石统计地址来确定在指定地址下。 这个指定地址啊。 就是某个设备内部的reg address计算器地址。 写入指定数据啊。 就是要在这个寄存器中写入的data数据。 然后看一下下面的时序。 这个时序是我在示波器下实际抓到波形哈。 大家也可以用逻辑分析仪抓这个波形。 而且逻辑分析仪还自带协议解析的功能哈。 还是非常方便的。 我们来一一分析一下。 在这里上面的线是sl。 下面的线是sda空闲状态。 他俩都是高电平。 然后主机需要给重新写入数据的时候。 首先s cl高电平期间。 拉低s d a产生起始条件。 在起始条件之后。 紧跟着的时区哈。 必须是发送一个字节的时序。 字节的内容必须是从基地址加读写位。 正好从句地址是七位哈。 读写位是一位。 加起来是一个字节。 八位发送统计地址啊。 就是确定通信的对象。 发送读写位呢。 就是确认我接下来是要写入还是要读出。 具体发送的时候呢。 在这里低电平期间sd变换数据。 高电平期间重击读取sda。 这里我用绿色的线哈来标明了。 重击读到的数据。 比如这样的波形。 那重击收到的第一位就是高电平一。 然后sl低电平基建主机继续变换数据。 因为第二位还是一。 所以这里sda电瓶并没有变化。 然后sl高电平统计读到第二位是一。 之后继续按低电平变换数据。 高电平读取数据。 第三位就是零。 这样持续八次就发送了一个字节数据。 其中这个数据的定义是啊。 高七位表示重击地址。 比如这个波形下。 主机寻找的统计地址就是1101000。 这个就是p u6050 的地址哈。 然后最低位表示读写为零。 表示之后的时序主机要进行写入操作。 一表示之后的时序主机要进行读出操作。 这里是零。 说明之后我们要进行写入操作。 那目前啊主题是发生了一个字节。 高位先行就是0x d0。 然后根据协议规定。 紧跟着的单元就得是接收统计的应档位。 在这个时刻。 主机要释放sda。 所以如果单看主机的波形啊。 应该是这样。 释放sda之后引脚电平回弹到高电平。 但是根据协议规定哈。 重击要在这个位拉低s da。 所以单看统计的波形啊。 应该是这样。 该应答的时候。 重击立刻拽住sda。 然后应答结束之后。 重击再放开s d a。 那现在综合两者的波形。 结合现有的特性。 在主机释放sda之后。 由于sda也被重击拽住了。 所以主机松手后。 sda并没有回弹。 高电平这个过程就代表重击产生的应答。 最终高电平期间主机读取sd发现是零。 就说明我进行寻址。 有人给我硬打了传输没问题对吧。 如果主机读取sd发现是一。 就说明我进行寻址。 应答位期间我松手了。 但是没人拽住他。 没人给我应答。 那就直接产生停止条件吧。 并提示一些信息啊。 就是硬打会。 然后这个上升沿哈就是应答位结束后。 重击释放sd产生的重击。 交出了sda的控制权。 因为统计要在低电平尽快变换数据。 所以这个上层岩和s c l的下降眼。 几乎是同时发生的。 然后继续往后。 由于之前我们读写位给了零。 所以应答结束后。 我们要继续发送一个字节。 同样的时序再来一遍。 第二个字节就可以送到指定设备的内部来。 重机设备可以自己定义。 第二个字节和后续字节的用途来。 一般第二个字节可以是寄存器地址。 或者是指令控制字等。 比如mp 16050定义的。 第二个字节就是寄存器地址。 比如a d转换器啊。 第二个字节可能就是指令控制字。 比如存储器啊。 第二个字节可能就是存储器地址。 那图示这点主机发送这样一个波形。 我们一一判定数据为00011。 001即主机向重击发送的0x19。 这个数据在p u6050 里。 就表示。 我要操作你0x19 地址下的计算器了。 这同样是从机应答。 主机四方sda重击转入s da s d a。 表现为低电平。 主机收到应答位为零。 表示收到了冲击的应答。 然后继续同样的流程。 再来一遍。 主机再发送一个字节。 这个字节就是主机想要写入到。 0x19 地址下寄存器的内容了。 比如这里发送了0x aa的波形。 就表示我在0x19 地址下写入0x a a。 最后是接收应单位。 如果主机不需要继续传输了。 就可以产生停止条件。 在停止条件之前先拉低sd。 为后续s d a的上升演做准备哈。 然后释放sl。 再释放s d a。 这样就产生了s scl。 高电平期间sda的上升。 沿这样一个完整的数据帧就拼接完成了。 那套用上面这句话呢。 这个数据真的目的。 就是对于指定统计地址为100。 1000的设备。 在其内部0x19 地址下的计算器中。 写入0x aa这个数据。 这是指定义值写的时序啊。 接下来我们继续看下一个时区。 这个时序叫当前地址读。 完成的任务。 是对于指定设备。 在当前地址指针指示的地址下。 读取统计数据。 这个当前地址指针是什么意思呢。 我们等会儿再解释啊。 先看一下下面的时序图。 这就是当前地址读的时序。 如果主机想要读取重击的数据。 就可以执行这个时序。 那最开始还是s scl高电平期间。 拉低sd产生起始条件。 其次条件开始后。 主机必须首先调用发送一个字节。 来进行重击的寻址和指定读写标志位。 比如图示的波形表示。 本次寻址的目标是1001000的设备。 同时最后一位读写标志为一。 表示主机接下来想要读取数据。 紧跟着发送一个字节之后接收一下。 重新进来。 为啥从机应答。 零代表重击收到了第一个字节。 在从机应答之后。 从这里开始数据的传输方向就要反过来了。 因为刚才主机发出了毒的命令。 所以这之后主机就不能继续发送了。 要把sda的控制权交给重击主机。 调用接收一个字节的时序进行接收操作哈。 然后在这一块从机就得到了主机的允许。 可以在s scl低电平之间写入sda。 然后主机在s scl高电平期间读取sda。 那最终主机在s c l高电平期间。 一次读取八位。 就接收到了重击发送的一个字节数据。 00001111。 也就是0x0 f啊。 那现在问题就来了。 这个0x0 f是重击哪个计算器的数据呢。 我们看到在读的时序中。 ifc协议的规定是哈。 主机进行寻址时。 一旦读写标志位给一了。 下一个字节就要立马转为读的时序。 所以主机还来不及指定。 我想要读哪个计算器就得开始接收了。 所以这里就没有指定地址这个环节。 那主机并没有指定计算器的地址。 从机到底该发哪个计算器的数据呢。 这需要用到我们上面说的当前地址。 指针呢在从句中啊。 所有的计算器被分配到了一个线性区域中。 并且会有个单独的指针变量。 指示着其中一个计算器。 这个指针上电默认啊。 一般指向零地址。 并且每写入一个字节和读出一个字节后。 这个指针就会自动自增一次。 移动到下一个位置。 主机没有指定要读哪个地址。 统计就会返回当前指针指向的净水器的值。 那假设我刚刚调用了这个指定地址。 写的时序。 在0x19 的位置写出了0x a。 那么指针就会加一移动的0x1 a的位置。 返回的就是0x1 a地址下的值。 返回的就是0x1 b地址下的值。 以此类推海。 这就是当前地址读时序的操作逻辑。 由于当前地址读并不能指定读的地址哈。 所以这个时序用的不是很多。 那最后我们就继续来看下一个时序。 指定地址读。 这个时序的目的就是啊。 对于指定设备在指定地址下读取重击数据。 那这个时序为什么能指定读的地址呢。 我们看一下。 指定就是写在这前面。 一部分就是指定地址的时序。 我们把最后面的写数据的这一部分给去掉。 然后把前面这一段设置地址。 还没有指定写什么数据的时序。 给他追加到这个当前地址读时序的前面。 就得到了指定地址读的时序。 一般我们也把它称作复合格式哈。 下面的时序在这里分隔一下。 前面的部分是指定地址写。 但是只指定了地址。 还没来得及写哈。 后面的部分是当前地址读。 因为我们刚指定的地址。 两者加在一起就是指定句子读了。 所以指定句子读的时序会复杂一下啊。 我们来详细分析一下看看。 首先最开始仍然是启动条件。 然后发送一个字节进行寻址。 这里指定统计地址是1001000。 无线标志位是零。 代表我要进行写的操作。 经过重新进来之后。 再发送一个字节。 第二个字节用来指定地址。 这个数据就写入到了统计的地址指针里了。 也就是说从机接收到这个数据之后。 它的寄存器指针就指向了0x19。 这个位置之后。 我们要写入的数据啊。 不给他发。 而是直接再来个起始条件。 这个sr的意思就是重复起始条件哈。 相当于另起一个时序。 因为指定读写标志位。 只能是跟着歧视条件的第一个字节。 所以如果想切换读写方向。 只能再来个起始条件。 然后起始条件后重新选址。 并且指定读写标志位。 此时读写标志位是一代表我要开始读了。 接着主机接收一个自己这个字节。 是不是就是0x19 地址下的数据啊。 这就是指定地址读。 另外在这里啊。 你也可以再加一个停止条件。 这样也行哈。 这样的话就是两个完整的时序了。 先起始写入地址停止。 因为写入的地址会存在地址指针里面。 所以这个地址。 并不会因为时序的停止而消失啊。 我们就可以再提示读当前位置停止。 这样两条时序也可以完成任务啊。 但是ifc协议官方规定的复合格式是一。 整个数据增哈。 就是先起始再重复。 其实再停止。 相当于把两条十句拼接成一条了。 好这些就是这三个fc完整时序的介绍了。 其中第一个指定地址写。 和第三个指定句子读用的比较多哈。 也是我们本节代码使用的时序。 然后除了这三个时区啊。 fc还有这些时序的进阶版本。 大概介绍一下啊。 就是我们这些时序啊。 指定地址写只是写一个字节。 当前地址读和指定地址读啊。 也都是读一个字节。 那进阶版本就是指定地址写多个字节。 当年地址读多少个字节。 和指定地址读多少个字节。 实际上呢和这些都非常相似啊。 只需要增加一些小细节就行。 我们看一下在这里指定地址。 然后写入一个字节。 如果你只想写一个字节。 那就停止就行了。 如果你想写多个字节。 就可以把这最后一部分啊多重复几次。 比如这里重复三遍。 发送一个字节和接受应答。 这样第一个数据就写入到了指定地址。 0x19 的位置。 然后不要忘了刚才说的哈。 写入一个数据后。 地址指针会自动加一。 变成0x1 a。 所以这第二个数据就写入到了。 0x1 a的位置。 同理。 第三个数据就写入的是0x1 b的地址。 以此类推哈。 这样这个时序就进阶为在指定的位置开始。 按顺序连续写入多个字节。 比如你需要连续写入多个计算器。 就可以考虑这样来操作哈。 这样在一条数据真理。 就可以同时写入多个字节。 执行效率就会比较高哈。 然后同理当前位置读和指定位置读。 也可以多次执行。 这最后一部分时序。 由于地址指针在读后也会指针。 所以这样就可以连续读出一片区域的。 计算器。 效率也会非常高。 然后这里还要注意一下。 如果你只想读一个字节就停止的话。 在读完一个字节之后。 一定要给重新发个非印的分应答。 就是该主机应答的时候。 主机不管是da拉低。 从机读到sda为一。 就代表主机没有应答哈。 统计收到分进来之后。 就知道主机不想要继续预览重击。 就会释放总线。 把sda的控制权交还给主机。 如果主机读完仍然给冲击硬打了重击。 就会认为主机还想要数据。 就会继续发送下一个数据。 而这时主机如果想产生停止条件。 s d a可能就会因为被重击拽住了。 而不能正常弹回高电平。 这个注意一下啊。 如果主机想连续读取多个字节。 就需要在最后一个字节给分音的。 而之前的所有字节都要给印的。 简单来说就是主机给硬答了。 统计就会继续发主机给非应答了。 统计就不会再发了。 交出sda的控制权。 重击控制sda发送一个自己的权利哈。 开始于读写标志位为一。 结束于主机给应答位为一哈。 这是主机给从机发送一单位的作用。 好。 以上。 就是ipha总线的硬件规定和软件规定了。 有了这些规定。 我们就可以按照硬件规定来连接线路。 用软件规定来操作总线。 一次。 实现指定位置。 写寄存器和指定位置读计算器。 有了这两个功能。 主机就可以完全掌控外挂模块的运行了。 也就实现了我们设计这个协议的目的。 那这就是ifc协议的内容哈。 下小节我们来了解mp u6050 这个芯片。 看看它是怎样工作的。 有哪些净水器。 以及如何利用计算器控制硬件电路的运行。 那我们下一小节再见。
32. 大家好。 欢迎回来。 本小姐。 那上一小节我们主要讲的是fc通信的协议标准。 有了iphone c通信。 我们就可以实现指定地址写和指定地址读的逻辑。 这样即使这个外挂芯片的各种计算器不在sm 3的内部。 我们仍然可以通过通讯协议实现读写外挂芯片净水器的功能。 这样就能完全掌控这个外挂芯片了。 好那我们这一小节就来研究一下这个mp u6050 的芯片。 他能干什么活。 有哪些净水器以及如何操作金属器来控制它干活。 要想研究清楚这个芯片的功能啊。 看它对应的数据手册是必不可少的。 在我提供的资料文件夹里。 打开模块资料m p u6050 的文件夹。 在这里有两个手册。 一个是ps产品说明书啊。 另一个是rm寄存器印象产品说明书打开看看。 就是介绍这个芯片的功能描述啊。 电器参数啊。 引脚定义啊。 硬件电路等等的介绍。 计算机印象呢打开看看。 上面这有个总表啊。 就是这个芯片内部所有的计算器以及它们的地址。 然后剩下的内容呢就是这个总表中。 每个计算器以及计算器中每一位的详细解释。 所以这个计算器印象的手册呢。 就相当于s t m32 参考手册里面的寄存器描述。 当我们写代码实际操作硬件的时候。 寄存器描述就是必不可少的哈。 因为寄存器描述里都是实实在在的实现细节。 而当我们需要了解芯片的原理参数和硬件电路的时候呢。 就需要参考这个产品说明书了。 这里面讲的是芯片的功能概括以及电路的大体工作流程。 要想学好这个芯片。 这两个手册都是要从头到尾看一遍的哈。 当然这两个文档都是英文的。 如果你英文不好的话。 可以借助翻译软件的画质翻译功能来辅助理解啊。 现在这个翻译软件还是非常方便的好。 那我们回到ppt。 本节课我会先用几个ppt给大家介绍一下这个芯片。 让大家对这个芯片有个大体的认识。 然后我们再一起看手册。 把手册里的一些重要信息再过一遍。 这就是本小节内容的安排。 那我们先看一下这里的mp u6050 简介。 第一条p u6050 是一个六轴姿态传感器。 那在现实的三维空间里哈。 只有xyz 3个轴。 加起来总共就是六个轴哈。 所以这个芯片是六轴姿态传感器。 当然如果芯片里再集成一个三轴的磁场传感器。 测量x y z轴的磁场强度。 那就叫做九轴姿态传感器。 如果再集成一个气压传感器。 测量气压大小。 那就叫做十轴姿态传感器。 一般气压值反映的是高度信息哈。 海拔越高。 气压越低。 所以气压计是单独测量垂直地面的高度信息的。 这就是姿态传感器的一些术语哈。 之后别再说这个传感器是六折啊。 九折弯。 十指弯你就知道了。 三轴角速度和三轴磁场强度。 三轴角速度。 三轴磁场强度和一个气压强度。 这个大家了解一下。 那要这么多轴的信息是要干啥呢。 答案是通过数据融合可进一步得到姿态角。 或者叫做欧拉角哈。 这个欧拉角是什么呢。 以我们这个飞机为厉害。 我画一个比较简陋的飞机哈。 欧拉角就是飞机机身相对于初始三个轴的夹角。 飞机机头下沉或上仰。 这个轴的夹角叫做抚养脾气。 飞机机身左翻滚或者右翻滚。 这个轴的夹角叫滚转肉。 飞机机身保持水平。 这个轴的夹角叫做偏航。 要简单来说。 欧拉角就表达了飞机此时的姿态。 飞机是上扬呢还是下倾呢。 通过欧拉角都能清晰地表示出来。 如果你想做一个飞控算法。 为了保持飞机姿态平稳。 那么得到一个精确且稳定的欧拉角就至关重要。 但是可惜的是哈。 陀螺仪啊。 磁力机啊。 任何一种传感器都不能获得精确且稳定的欧拉角。 要想获得精确且稳定的欧拉角呢。 就必须进行数据融合。 把这几种传感器的数据结合起来。 综合多种传感器的数据取长补短。 这样才能获得精确且稳定的欧拉角。 常见的数据融合算法一般有互补滤波。 卡尔曼滤波等。 这就涉及到惯性导航领域里姿态解算的知识点了。 不过我们本节课的侧重点是fc通信。 我们最终的程序现象就是把这些传感器的原始数据读出来。 显示在o a d上就完事了。 所以有关姿态解算的内容啊。 暂时不会涉及这个姿态解算呢。 之后有机会的话可以单独拿出来讲讲。 那我们接着看姿态传感器计算出姿态角之后。 就常应用于平衡车。 飞行器等需要检测自身姿态的场景。 平衡车呢如果传感器检测到车身向前或者向后倾斜了。 程序就可以控制笼子进行调整哈。 保持平衡车的平衡。 飞行器呢这控制的轴就多些。 一般至少需要检测俯仰角和滚转角两个夹角哈。 然后控制电机保持飞机的平衡。 这就是这个mp u6050 姿态传感器的作用。 然后我们来看一下mp u6050 内部的六个轴传感器的作用。 它的英文全称是这个一般简称a c c e或者a acc或者a。 这个英文简称大概记一下哈。 之后会经常出现。 这里首先啊这个x y z轴。 看一下左下角这个图。 x y z轴就是一个三维的坐标系。 其中横向的这个轴定义为x轴。 纵向的这个轴定义为y轴。 垂直于芯片的这个轴定义为z轴。 这就是这个芯片对x y z轴的定义。 看一下中间这个图。 其中水平的这个虚线是感应轴线。 中间是一个具有一定质量。 可以左右滑动的小滑块。 然后左右各有一个弹簧顶着。 他可以想象得到哈。 如果你把这个东西拿在手上来回晃。 中间这个小滑块就是左右移动哈。 去压缩或者拉伸两边的弹簧。 当滑块移动时就会带动上面的电位器。 滑动这个电位器啊。 其实就是一个分压电阻。 然后我们测量电位器输出的电压。 根据流动第二定律哈。 f等于ma。 测量它所受的力f就行了。 所以你听这个名字啊。 很难理解啊。 实际上它就是一个测力计而已。 这就好理解了吧。 那在这个芯片里面啊。 xyz 3个轴分别都有这样一个测力计。 这里呢还可以再画一个模型图来辅助理解。 你有想象哈。 这个芯片里面有六个侧立的衬啊。 组成一个正方体。 然后正方体内部呢放一个大小正好的单位质量小球。 这个小球压在哪个层面上。 就会产生对应一个轴的数据输出。 比如小球压在下面。 这个面就是z轴的正直小球。 压上面。 这个面就是z轴的负值对象。 两个面一组哈。 以面为正值。 以面为负值。 比如你把芯片静置水平放在地球上。 那就只有底面测力计受到小球的压力。 所以此时数据输出就是xyz轴输出为零。 如果此时芯片正处于自由落体哈。 那就是所有面都不受力。 此时数据输出就是x y z轴都为零。 那就是底面和左面都受力。 这时候呢我们像这样求一个三角函数。 就能得到向左的倾角c塔了。 不过这个倾角只有芯片进制的时候才是正确的哈。 如果指着芯片运动起来了。 举个例子。 比如你坐在汽车里。 你是不是感觉椅子底面和靠背都受力啊。 这时如果用三角函数求角度。 得到的结果就是你的车停在一个斜坡上。 停在斜坡上也是已知底面和靠背都受力对吧。 只能在物体静止的时候使用。 当物体运动起来了。 不具有动态稳定性。 然后我们接着看下一个传感器。 三轴陀螺仪传感器。 因为是这个哈。 简称是g y r o或者g这个简称也大概记一下啊。 那它的作用是测量x y z轴的角速度。 看一下右下角这个图片啊。 这个就是陀螺仪的机械模型。 中间是一个有一定质量的旋转轮。 外面是三个轴的平衡环啊。 当中间这个旋转轮高速旋转时哈。 根据角动量守恒的原理。 这个旋转轮具有保持它原有角动量的趋势。 这个趋势可以保持旋转轴方向不变。 当你外部物体的方向转动时。 内部的旋转轴方向并不会转动。 这就会在平衡环连接处产生角度偏差。 如果我们在连接处放一个旋转的电位器。 测量电位器的电压。 就能得到旋转的角度了。 从这里分析哈。 陀螺仪应该是可以直接得到角度的。 但是我们这个mp u6050 的陀螺仪并不能直接测量角度。 可能是结构的差异啊。 或者是工艺的限制。 我们这个芯片内部的陀螺仪测量的实际上是角速度。 而不是角度哈。 这个注意一下。 陀螺仪测量x y z轴的角速度值。 分别表示了此时芯片绕x轴。 绕y轴和绕z轴旋转的角速度。 这里也可以用一个模型来辅助理解这个测量角速度的陀螺仪。 你可以把它想象成是游乐园的旋转飞椅哈。 中间的轴转得越快。 这个椅子飞的就越远。 最终我们测量一下对象。 两个椅子飞起来的距离或者飞起来的夹角哈。 就能得到中间轴的角速度了。 这是测量角速度的陀螺仪工作员厉害。 那如果我们想通过角速度得到角度的话。 我们只需要对角速度进行积分即可。 这个角速度积分得到的角度也有局限性。 就是当物体静止时哈。 角速度值会因为噪声无法完全归零。 然后经过积分的不断累积哈。 这个小噪声就会导致计算出来的角度产生缓慢的漂移。 也就是角速度积分得到的角度经不起时间的考验。 不过这个角度呢无论是运动还是静止都是没问题的。 它不会受物体运动的影响。 所以总结下来就是陀螺仪具有动态稳定性。 不具有静态稳定性。 这个陀螺仪是动态稳定。 动态不稳定。 这两种传感器的特性正好互补哈。 所以我们取长补短进行一下互补滤波。 就能融合得到静态和动态都稳定的姿态件了。 就是姿态解算的大体思路哈。 当然实际的姿态解算肯定会更加复杂一些了。 我们之后有机会再研究这个问题。 我就介绍到这里。 接下来我们来看几个mp u6050 的参数。 这里我只挑了几个我认为比较重要的参数。 其他参数等会儿看手册的时候再来分析哈。 那这里第一条16位adc采集传感器的模拟信号量化范围。 负的32768到正的32767。 之前我们也了解过哈。 它们的基本原理都是设计一种装置。 当传感器所感应的参数变化时。 这个装置能带动电位器滑动。 或者装置本身的电阻可以随感应参数变化而变化。 这样在外接一个电源。 通过电阻分压。 就能把现实世界的各种状态用电压表示出来了。 但这个传感器里面啊肯定不是图片这里这样的机械结构。 芯片里面都是通过电子的技术来完成各种参数的测量的啊。 要不然也塞不到这么小的芯片里。 我们理解的时候可以把它想象成这种机械结构。 但实际上芯片里面如何用电来完成同样的功能。 这就是这个厂家的密集了。 我们也不用管。 总之电子的传感器最终也是输出一个随姿态变化而变化的电压。 要想量化这个电压信号。 那就离不开a d转换器了。 所以这个芯片内部也是自带了a d转换器。 可以对各个模拟参量进行量化。 这个a d c是16位的。 那量化输出的数据变化范围就是二的16次方。 如果作为无符号数的话。 就是0~6535。 这里因为传感器每个轴都有正负的数据哈。 所以这个输出结果是一个有符号数。 量化范围是负的32768到正的32767。 数据是16位的啊。 会分为两个字节存储。 这个之后我们读取数据计算器的时候就可以看到了哈。 接着看下两条。 这个16位有符号数的范围啊。 它所对应的物理参量范围是多少呢。 这里就需要定义一个满量程范围。 这个满量程范围呢就相当于我们之前学a d c的时候。 那个v r e f参考电压一样。 你a d值达到最大值。 对应电压是3.3伏啊。 还是5伏啊。 需要有一个参考电压来指定。 这里也是一样。 16位ad值达到最大值对应的物理参量具体是多少。 也是由满量程范围来决定的。 正-4。 正-8。 一个g等于9.8米。 每二次方秒。 陀螺英版量产呢可以选择正负二百五十五百一千两千单位是度。 每秒就是角速度的单位哈。 每秒旋转了多少度。 这里呢如果你所测量的物体运动非常剧烈。 就可以把满量程选择大一些。 如果你所测量的物体运动比较平缓。 就可以选择比较小的量程。 这样测量的分辨率就会更大。 举个例子。 当读取a b值为最大值32768时。 当然实际的最大值是32767哈。 a d值为32768的一半时呢。 因为粒子的范围是一定的。 所以满量程选的越小。 测量就会越细腻。 就是乘以一个系数就可以了。 这跟我们之前学a d c的时候。 由a d值求电压值是一样的道理哈。 然后下面陀螺仪的满量程选择也是同样的操作。 满量程选的越大。 测量范围就越广。 满量程选的越小。 测量分辨率就越高。 所以这个满量程的选择哈要根据实际需求来。 然后继续可配置的数字低通滤波器。 在这个芯片里可以配置寄存器来选择对输出数据进行低通滤波哈。 如果你觉得输出数据抖动太厉害。 就可以加一点低通滤波。 这样输出数据就会平缓一些。 然后是可配置的时钟源和可配置的采样分屏。 这两个参数是配合使用的。 时钟元。 经过这个分频器的分屏。 可以为ad转换和内部其他电路提供时钟控制。 分频系数就可以控制ad转换的快慢了好了。 这些就是这个芯片大概的参数。 至于这里这些可配置的具体值啊。 等看手册的时候再介绍啊。 然后下面这还有一点我要提一下。 就这个芯片进行iphone这通信的重击地址哈。 这个可以在手册里查到。 当ad 0等于零时。 地址为100。 1000。 当d0 等于一时。 地址为1001001ad 0就是板子引出来的一个零件。 可以调节iphone c重击地址最低位。 这里地址是七位的。 如果像这样用二进制来表示的话。 一般没啥问题。 如果在程序中用16进制表示的话。 一般会有两种表示方式哈。 以这个1001000的地址为例。 第一种就是单纯的把这七位的二进制转化为16进制。 这里1001000d4 位和高三位切开转换。 16进制就是0x68。 所以有的地方就说pu 6050的重击地址是0x68。 然后我们看一下之前iphone c通信的时序哈。 这里第一个字节的高七位是冲击地址。 最低位是读写位。 所以如果你认为0x68 是冲击地址的话。 在发送第一个字节时。 要先把0x68 左移一位。 在安慰或上读写位独一显灵。 这是认为统计地址是0x68 的操作啊。 当然目前还有另一种常见的表示方式。 就是把0x68 左移移位后的数据当做冲击地址。 0x68 左移移位之后是0x d0。 那这样mp 16050的重击地址就是0x d0。 这时在实际发送第一个字节时。 如果你要写。 就直接把0x d0 当做第一个字节。 如果你要读。 就把0x d0 或上0x01 即0x第一当做第一个字节。 这种表示方式就不需要进行左移的操作了。 或者说这种表示方式是把读写位也融入到了重启地址里来。 0x0 是写地址。 0x d一是读地址这样表示的。 所以你之后看到有地方说零sd 0是mp 6050的重击地址。 那它就是融入了读写位的重启地址。 如果你看到有地方说0x68 是mp 26050的冲击地址。 这也不要奇怪哈。 在实际发生第一个字节时。 不要忘了先左移一位。 在货上读写位。 这是两种统计地址的表示方式哈。 当然无论哪种表示方式得到的ifc第一个字节都是一样的。 在实际情况中呢。 两种方式都有出现过。 我个人是比较喜欢融入读写位的这种表述方式哈。 所以在我的程序中。 pu 6050的重击地址是0x d0。 这个大家了解一下啊。 好来这里参数就看到这里。 我们接着继续来看一下硬件电路。 左边这里展示的就是我们这个p u6050 模块的原理图。 其中右边这个是mp u6050 的芯片。 左下角是一个八针的排针。 左上角是一个l d o低压差线性稳压器。 我们来看一下右边这个mp u6050 的芯片。 芯片本身的引脚是非常多的哈。 要放这些通信硬件啊。 供电啊。 真同步等等。 不过这里有很多硬件我们都用不到。 还有一些硬件呢是这个芯片最小系统里的固定连接。 这个最小系统哈。 一般手册里都会有。 抄过来就行了。 然后看左下角引出来的银角。 然后s scl和sda这两个硬件是fc通信的硬件。 在这里可以看到哈。 s scl和sda模块已经内置了两个4.7k的上拉电阻了。 所以在我们接线的时候。 直接把s scl和sda接在gpl口就行了。 不需要再在外面另外接上来电阻了。 接着下面有x cl和x da这两个是芯片里面的主机。 fc通信硬件设计。 这两个硬件是为了扩展芯片功能。 之前我们说过。 mp u6050 是一个六轴姿态传感器。 姿态角是有缺陷的。 这个缺陷就是绕z轴的角度。 也就是偏航角。 就像是让你坐在车里哈。 不看任何窗户。 然后让你辨别当前车子的行驶方向。 短时间内你可以通过陀螺仪得知方向的变化。 从而确定变化后的形式方向。 但是时间一长哈。 车子到处转弯。 你没有稳定的参考了。 就肯定会迷失方向。 所以这时候你就要带个指南针在身边。 提供长时间的稳定偏差角进行参考。 来对陀螺仪感知的方向进行纠正。 这是九轴姿态传感器多出的磁力剂的作用。 另外如果你要制作无人机啊。 需要定高飞行。 这时候就还需要增加气压计扩展。 为十轴提供一个高度信息的稳定参考。 所以根据项目要求啊。 这个六轴传感器可能不够用。 需要进行扩展。 那这个时候这个x cl和x d a就可以起作用了。 x cl和x d a通常就是用于外接磁力计或者气压计。 当接上磁力机或气压计之后。 mp 16050的主机接口可以直接访问这些扩展芯片的数据。 把这些扩展芯片的数据读取到mp u6050 里面。 在mp u6050 里面会有dmp单元进行数据融合和姿态解算啊。 但如果你不需要按p u6050 的结算功能的话。 也可以把这个磁力计或者气压计直接挂载在excel和sda这条中线上。 因为ifc本来就可以挂载多设备哈。 所以把多个设备都挂载在一起也是没问题的。 这是xcl和xda的用途。 然后下面a ad 01角。 这个之前说过。 他是重击地址的最低位。 接低电平的话。 七位统计地址就是1001000。 接高电平的话。 气味重击地址就是1001001。 这里电路中啊。 可以看到有一个电阻默认弱下来到低电平了。 所以银角悬空的话就是低电平。 如果想接高电平。 就可以把a d0 直接引到vcc强上。 拉至高电平啊。 最后一个引脚是nt。 也就是中段输出引脚。 可以配置芯片内部的一些事件来触发中断引脚的输出。 比如数据准备好了。 fc主题错误等。 另外芯片内部还内置了一些实用的小功能。 比如自由落体检测。 运动检测。 零运动检测等。 这些信号都可以触发i t引脚产生电瓶跳跃。 需要的话可以进行中断信号的配置。 但如果不削的话。 那也可以不配置这个硬件。 也不需要用。 那这就是这些引脚的功能描述。 那在手册里可以查到哈。 这个mp u6050 芯片的v dd供电是2.375~3.46伏。 属于3.3伏供电的设备。 不能直接接5伏哈。 所以为了扩大供电范围呢。 这个模块的设计者就加了个3.3伏的稳压器。 输入端电压vcc杠5伏可以在3.3伏到5伏之间。 然后经过3.3伏的稳压器输出稳定的3.3伏电压给芯片端供电。 然后这一块是电源指示灯啊。 只要3.3伏端有电。 电源指示灯就会亮。 所以这一块需不需要可以根据你的项目要求来。 如果你已经有了稳定的3.3伏电源了。 就不再需要这一部分了。 好以上就是这个模块的硬件电路分析啊。 我们本实验使用的时候。 直接vcc进d接上电s scl和sda。 接上fc通信的gpu口就行了。 就是硬件电路。 然后继续我们再看一下这个芯片的模块框图。 这个图就是整个芯片的内部结构哈。 其实左上角是时钟系统。 有时钟输入角和输出角。 不过我们一般使用内部时钟哈。 硬件电路这里呢可clock in直接接了。 接地。 可能和out没有引出。 所以这部分不需要过多关心。 然后下面这些灰色的部分就是芯片内部的传感器。 x y z轴的陀螺仪。 另外这个芯片还内置了一个温度传感器哈。 你要是想用它来测量温度也是没问题的。 那这么多传感器本质上也都相当于可变电阻。 通过分压后输出模拟电压。 然后通过abc进行模式转换。 转化完成之后呢。 这些传感器的数据统一都放到数据进行器中。 我们读取数据计算器就能得到传感器测量的值了。 这个芯片内部的转换都是全自动静音的。 就类似我们之前学的a d连续转换加dma转运。 每个adc输出啊。 对应16位的数据进器。 不存在数据覆盖的问题。 我们配置好转换频率之后。 每个数据就自动以我们设置的频率刷新到数据进速器。 我们需要数据的时候直接来读就行了。 其他的都不用管。 还是非常方便的。 接着这每个传感器都有个自测单元。 这部分是用来验证芯片好坏的。 当启动自测后。 芯片内部啊就会模拟一个外力施加在传感器上。 这个外力导致传感器数据会比平时大一些。 那如何进行自测呢。 我们可以先使人自测读取数据。 在私人之策读取数据。 两个数据相减得到的数据叫自测响应。 这个制造响应啊。 芯片手册里给出了一个范围。 如果自测响应在这个范围内。 就说明芯片没问题。 如果不在。 就说明芯片可能坏了。 使用的时候就要小心点啊。 这个是自测的功能。 然后下面这个东西呢是电荷泵或者叫充电泵。 cpu的硬件需要外接一个电容哈。 什么样的电容呢。 在这个手册里有说明电荷泵是一种升压电路哈。 在其他地方也有出现过。 比如我们用的这个o i d屏幕里面就有电荷泵进行升压。 电荷泵的升压原理呢。 我简单描述一下。 大家了解一下这个。 比如我有个电池电压是5伏。 然后我再来个电容。 首先电池和电容并联。 电池给电容充电。 充满之后。 电容是不是也相当于一个5伏的电池了。 然后呢关键部分来了。 我在修改电路的接法。 把电池和电容串联起来。 电池5伏电容也是5伏。 这样输出就是10伏的电压了。 是不是凭空就把电池电压升高至两倍了。 不过由于这个电容电荷比较少哈。 用一下就不行了。 所以这个并联串联的切换速度要快。 蹭电容还没放电完。 就要及时并联充电。 这样一直持续并联充电。 串联放电。 并联充电。 串联放电。 然后后续再加一个电源滤波哈。 这是电荷泵的声压原理。 那这里由于陀螺仪内部是需要一个高电压支持的。 所以这里设计了一个电荷泵进行升压。 当然这个升压过程是自动的哈。 不需要我们管了解一下即可。 然后右边这一大块就是计算器和通信接口部分了。 中断状态计算器可以控制内部的哪些事件到中断引脚的输出。 fil是先入先出。 计算器可以对数据流进行缓存。 我们本节暂时不用哈。 配置这种器。 可以对内部的各个电路进行配置。 传感器计算器也就是数据进器啊。 存储在各个传感器的数据工厂校准。 这个意思就是内部的传感器都进行了校准哈。 我们不用了解。 然后右边这个数字运动处理器简称dmp。 还是芯片内部自带的一个姿态解算的硬件算法。 配合官方的dmp库可以进行姿态解算哈。 因为姿态解算还是比较难的。 而且算法也很复杂。 所以如果使用了内部的dmp进行姿态解算。 姿态解算就会方便一些。 暂时不设计。 这个fc是正同步。 我们用不到啊。 最后上面这块就是通信接口部分的。 上面一部分就是重机的fc和s spi通信接口。 用于和s t m32 通信。 下面这一部分是主机的ifc通信接口。 用于和mp u6050 扩展的设备进行通信。 这里有个接口。 旁路选择器就是一个开关哈。 如果拨到上面辅助的i放在零件。 就和正常的i放在零件接到一起。 这样两个物种线就合在一起了哈。 s t m32 可以控制所有设备。 这时sm 32就是大哥mp u6050 和这个扩展设备都是sm 32的小弟。 如果拨到下面辅助的f30 件。 这是s t m32。 是m p u6050 的大哥。 p u6050 呢又是扩展设备的大哥。 这样来连接的。 如果使用的话。 可以再详细研究。 当然我们本节课程不会用到这个扩展功能。 然后最后下面这里是供电的部分。 按照手册里的电压要求和参考电路来接线就行了。 好以上这些就是这整个po 6050芯片的结构了。 那通过这几页p p t的介绍。 大家对这个m p u6050 芯片和姿态解算的部分之间。 就应该有个大致的了解了吧。 接下来我们就一起来看一下这两个手册。 还有一些额外的部分啊。 再说一说。 首先是产品说明书。 这个手册是p o6000 和p o6050 这两个芯片共用的。 这两个型号的芯片功能都差不多哈。 在细节上有一些区别。 我们用的是p o6050 这个型号。 然后下面是目录。 修订历史。 然后这里开始就是对产品的整体介绍了。 比如说三轴m1 m s陀螺仪。 这个m1 m s啊。 可以用电子的方案进行姿态测量哈。 然后是数字运动处理器。 dmp可以进行姿态解算。 辅助的iphone c通信可以扩展。 第三部分。 比如磁力计下面16位的a d c进行数字化。 可配置的满量程。 这些大家可以再详细看看。 了解一下芯片的大体情况。 接下来这个表给出的就是p o6000 和p o6050 的差异了。 总结下来就是两点。 v logic可以支持供电和l口不一样的电费单机。 而m p16000 没有。 二是m p o6000 同时支持ifc和s spi接口。 而m p o6050 仅支持ifc哈。 总共就是这两点差异。 其他部分基本都是一样的哈。 然后下面是这个芯片的应用场景。 比如图像稳定器啊。 位置服务啊。 游戏手柄啊。 3d遥控器啊。 玩具啊等等。 接到下面这里是产品的特性列表。 就是把芯片的各种功能啊。 低功耗等等列举一下。 大家可以详细看看哈。 然后这里是芯片的电气特性。 就是各个性能的数据表格哈。 如果要查询一些具体的数据指标哈。 就可以在这个表里找找。 一般芯片手册里哈都会有这个电器特征的表格哈。 然后这边是iphone c的时序的人。 这个芯片的ifc的sc l始终频率最大可达400 千赫。 如果你的sc l始终超过这个数值。 那这个芯片可能就跟不上了。 另外下面这里展示了哈各个电瓶它的上升沿。 下降沿以及持续时间都要满足这个表里的要求哈。 不过由于iphone c是同步时序。 对时间的要求不是非常严格。 只要你的电瓶不是转瞬即逝的那么快。 这个芯片都能跟得上哈。 所以这个400 千赫只是一个最大参数。 实际的速率可以慢一些哈。 这都没关系。 然后下面是s p i的时区要求。 不过我们p o6050 这个芯片没有s p i的接口。 还这里是绝对最大参数。 超过这个参数范围哈。 芯片就要损坏了。 比如这个v dd供电范围是-0.5伏到正6伏。 超过6伏就会损坏。 不过之前电气特征表哈。 看一下给的供电范围是2.375~3.46伏。 所以最好还是不要直接加五的电哈。 超过电机特征的供电范围。 芯片可能无法正常工作。 超过绝对最大参数芯片就要损坏了。 就是这两个参数的意义啊。 然后继续。 下面这里是应用信息。 这里给出的是p o6000 和p o6050 这两个芯片的引脚定义哈。 还有x y z轴的定义图示。 如果要理解每个零件的具体解释。 可以看一下上面的银件描述。 当然有很多硬件我们用不到啊。 所以这个模块只引出来部分关键硬件。 接着下面是参考电路。 哪地方需要接个电容啊。 电容的容值多大。 这个图和下面这个表都有参考的事例。 如果你要自己拿芯片画电路的话。 就可以参考这里给图的示例。 然后在下面就是芯片的逻辑框图。 这个我们刚才详细讲过哈。 下面是对每一部分的说明。 可以再详细看看。 接到这里就是利用辅助的x cl和xda硬件。 把六轴传感器扩展成九轴传感器的电路了。 辅助的c l和da一般外挂一个磁力传感器就可以扩展成九轴了。 这是pl 6000利用spi接口扩展九州的势力之后。 还是特性介绍哈。 这里是时钟系统。 这个芯片的时钟啊。 可以由这些时钟源提供。 第一个是内部晶振。 可以作为系统时钟。 第二个是x y z轴的陀螺仪。 他们也都会有个竞争哈。 因为陀螺仪内部需要高精度始终的支持。 这三个时钟也可以输出作为系统时钟。 然后是可以通过外部的可clock in硬件。 输入32点七六八千赫兹的方波。 或者19.2兆赫兹的方波作为系统时钟。 不过这个外部时钟还需要额外的电路。 还比较麻烦。 所以如果不是特别要求的话。 我们一般用内部竞争或者内部陀螺仪的竞争作为系统之中。 这个是始终言的选择问题。 然后下面这些是可选的中断信号。 可以配置发生这些事件时。 在mt引脚输出一个电平跳变。 然后s t m32 可以用外部中断来接收这个跳变。 这样中断信号就可以通过s t m32 的cpu了。 接下来这一部分介绍的是这个芯片内置的一些实用小功能哈。 比如自由落体检测。 运动检测和零运动检测。 这个图就是执行逻辑。 开始计数。 当技术足够多时发生自由落体事件。 可以配置这个事件去触发中断引脚的电平跳变。 如果需要这个功能的话。 可以看一看这些文字。 说明下面的运动检测和零运动检测也都是差不多的逻辑。 另外注意就是啊这里运动检测会有一个高通滤波器。 用来滤除重力造成的稳定数据偏置。 这跟电容隔直通交差不多的功能。 如果你要不用这个功能的话。 也不用管这个高通滤波器的。 之后就是数字接口。 也就是ifc总线的介绍。 这里就给出了这个设备的i放在地址。 1001000或者1001001。 下面是iphone c时序的介绍。 我们上下节也都讲过啊。 这里说的是数据帧格式。 这个是指定义值。 写一个字节开始地址加血应答计算器。 离子应答。 数据应答停止。 下面是指定地址。 写多个字节开始地址加写应答计算器地址应答数据应答。 数据应答两次读两个字节停止。 然后这里是指定地址读一个字节。 开始地址加血应答。 计算机地址应答从负开始地址加读应答。 重击发数据主机给非应答。 停止下面指定地址读多个字节。 区别就是这里哈数据应答。 数据非应答。 在最后一个数据给非应答。 然后停止这些诗句是不是跟我们之前讲iphone c的时候一样哈。 大家可以再看看这里的描述。 验证一下所学的知识哈。 我们就不看了。 接着这边描述的是啊。 当你的供电电压和l口的逻辑电压不一样时。 应该如何接线和配置。 这个看一下就行了哈。 我们这里所有器件都是3.3伏。 所以直接全部接3.3伏即可。 不存在这个问题。 那最后就是尺寸信息和pcb布线的参考了。 这个画pcb的话可以参考这些信息。 这里面也会提到一些注意事项和布线建议。 那到这里我们这个产品说明书就看完了。 然后我们继续看一下这个寄存器印象的手势。 其实寄存器还是非常重要的哈。 看原理你只能知道哪个是哪个电路怎么运作的。 真正要写程序的还得是研究计算器才能明白。 那我们s t m32 有库函数封装了。 所以对金容器要求不是很高。 但是这个芯片的话还是需要手动配置一下计算器哈。 所以研究一下计算器还是很有必要的。 那这个手册的前面这里有个计算器的总表。 这个表里计算器非常多哈。 但是我们不需要全都了解简单应用的话。 了解其中一部分就行了。 那在这里需要了解的我都用黄色标记标出来了。 其他的暂时可以不看。 需要了解的不是很多哈。 大家不要害怕。 我们来看一下这里。 第一列是寄存器的地址。 16进制表示的第二点是计算器的地址。 十进制表示的第三列是计算器的名称。 第四列是读写权限。 2w代表可读可写。 二代表只读。 这后面是计算器类的。 每一位的名字。 每个计算器都是八位的啊。 然后我们需要了解的进容器呢。 这里依次是采样频率。 分频器。 配置计算器。 陀螺仪配置计数器。 然后下面这一大块是数据计数器。 温度传感器。 陀螺仪x y z轴的数据。 这里杠l表示低八位。 杠h表示高八位。 最后是电源管理计算器一和电源管理计算器。 二户外mai。 我是谁。 也就是七件id号。 那接下来我们来一一看一下每个进气的说明哈。 第一个采样频率。 分频器里面的八位为一个整体作为分频值。 这个计算器可以配置采样频率的分频系数。 简单来说就是分屏越小。 内部的a d转换就越快。 数据进去刷新就越快。 反之就越慢哈。 这里有个公式。 采样频率你可以理解为数据刷新率哈。 等于陀螺仪输出始终频率除一加分频值。 这个时钟啊。 就是我们刚才说的那几个时钟源。 内部晶振陀螺仪进正和外部时钟引脚的方波。 这里直接是以陀螺仪竞争作为例子的哈。 陀螺仪式中除这个计算器指定的分频系数。 就是采样频率。 下面有个注意事项啊。 不使用低通滤波器时。 陀螺仪始终为8000Hz。 使用滤波器的始终就是1000Hz。 这个了解一下就行了哈。 这是采样时钟分频器接到下面这个配置。 计算器内部有两部分。 外部同步设置和低通滤波器配置。 这个外部同步哈。 我们不用可以不看。 然后是低通滤波器配置。 这些位可以选择这里的各种滤波参数。 这个低通滤波器啊。 可以让输出数据更加平缓。 配置滤波器参数越大。 输出数据抖动就比较小。 零是不使用低通滤波器。 陀螺仪始终为8000Hz。 之后使用了滤波器。 陀螺仪始终就是1000Hz。 这我刚才说过哈。 然后这个最大的参数是保留位。 没有用的。 就是配置这种器。 可以配置低通滤波器。 让数据更平滑之后陀螺仪配置人气高。 三位是x y z轴的自测试轮位。 中间两位是满量程选择位。 后面三位没用到哈。 对于自测的用法。 这里有描述。 之前我也提到过哈。 这里有个公式。 自测响应等于自测死人时的数据减自测私人时的数据。 我们上电后先使人自测读取数据。 在私人自测读取数据。 两者相减得到自测响应。 然后在这个手册里找一下自身响应的范围。 在这个电器特征的表里。 这里就是自车响应的范围。 如果在这个范围里。 芯片就通过来自测之后正常使用即可。 这是自测。 然后是满量程选择。 可以选择这四种。 这个我们p p t里也介绍过。 量程越大。 范围越广。 量乘越小。 分辨率越高。 运气和上面那个基本一样。 高三位是自测室轮位。 中间两位是满良车选择。 不过这最后面多出来三位。 这三位是配置高通滤波器的。 这个高通滤波器刚才说过哈。 就是内置小功能。 运动检测用到的对数据输出没有影响。 我们暂时用不到哈。 下面的描述和刚才的基本一致。 然后继续看。 我们想读取数据的话。 直接读取数据进器就行了。 这是一个16位的有符号数。 以二进制补码的方式存储。 我们读出高八位和低八位。 高位左移八次或上低位数据。 最后再存在一个int 16杠t的变量里。 这样就可以得到数据了。 下面温度传感器。 数据陀螺仪数据都是一样的。 操作方法。 那继续看电源管理。 计算机一有这么多位。 第一位设备复位。 这一位写一哈。 所有计算器都恢复到默认值。 第二位睡眠模式。 这一位写一芯片。 睡眠芯片不工作。 进入低功耗。 然后循环模式这一位写一设备进入低功耗。 过一段时间启动一次。 并且唤醒的频率哈。 由下一个近期的这两位确定这个模式比较省电哈。 然后这一位温度传感器私人写一之后。 禁用内部的温度传感器。 最后三位用来选择系统始终来源。 下面有个表。 分别是内部晶振x y z轴陀螺仪。 精准外部引脚的两个方波。 和我们之前介绍的时钟源一样哈。 一般我们选择内部竞争或者陀螺一竞争。 不过这里有句话哈。 现在是非常建议我们选择陀螺仪的竞争。 因为陀螺仪的竞争更加精确。 就是这个计算器。 然后下面是电源管理进器二。 前两位刚才说过哈。 后面六位可以分别控制六个轴进入待机模式。 如果你只需要部分轴的数据啊。 可以让其他轴待机。 这样比较省电。 就是电源管理经济二。 那最后一个计算器就是i d号了。 这个金容器是只读的。 id号不可修改。 i d号中间这六位固定为100100。 实际上这个id号就是这个芯片的iphone c地址。 它的最高位和最低位其实都是零。 那读出这个净水器直接固定为0x68。 然后这里有句话。 意思就是之前我们说过这个fc地址可以通过ad 0件进行配置。 但是这里的id号的最低位是不随ad 0银角的变化而变化的。 读出id号始终都是0x68。 当然这个id号也不是非要和fc地址一样哈。 只是他这样设计的i g好。 来到这里。 我们这个计算器就看完了。 最后再看一下。 这里有句话哈。 写的是所有的计算器上电默认值都是0x00。 除了下面这两个107号计算器上电默认0x40。 117号计算器上电默认0x68。 上面看一下117号就是id号。 默认0x68。 这个没问题。 107号是电源管理机器。 一默认0x40。 也就是次高位为一。 这里次高位是sleep。 所以这个芯片上面默认就是睡眠模式。 我们在操作它之前。 要先记得解除睡眠。 否则操作其他计算器是无效的哈。 这个注意一下好。 那本小节有关p u6050 的内容。 到这里就差不多了。 我们接下来的任务就是实现f c通信。 然后读写这里的计算器来操控m p o6050。 那我们下一小节来写代码。 完成这个任务哈。
33. hello。 大家好。 本小节我们来学习mp u6050 的代码部分。 正如前两小节讲的知识点来讲。 本小节的代码也是主要分为两个部分。 第一部分我们完成软件iphone c协议的时序。 第二部分我们基于fc协议读写寄存器。 来操控mp u6050。 那先看一下本节代码的硬件电路啊。 我们打开经验图。 打开十杠一的图片。 这是本节课的经验图。 由于这个模块把各种基础电路都封装好了哈。 所以经验图这里也是比较简单的。 在这里vcc和gd分别接到电源正负极进供电。 然后sl这里我引到了s t m32 的pb 10号。 硬件sda。 我已经到了pb 11号引脚。 由于我们这个代码使用的是软件fc。 就是用普通的gpl口手动翻转电平实现了协议。 它并不需要这tm 32内部的外设资源支持。 所以这里的端口其实可以任意指定哈。 不局限于这两个端口。 你也可以s c l j p a0。 s da j p b 12或者s l j p a8。 s da j p a9 等等等等。 接在任意的两个普通的gpl口就可以。 然后我们只需要在程序中配置并操作。 s scl和sda对应的端口就行了。 这算是软件fc相比硬件fc的一大优势哈。 就是端口不受限。 可以任意指定。 然后继续看。 根据iphone c协议的硬件规定啊。 s scl和sda都应该外挂一个上拉电阻。 但是这里并没有外挂上来电阻。 因为上下节我们分析模块电路的时候提到过哈。 这个模块内部自带了上拉电阻。 所以外部的上拉电阻就不需要接了。 目前这里s t m32 是主机。 po 6050是重击。 是一组一重的模型啊。 当然主机和从机的执行逻辑是完全不同的。 我们程序中一般只关注主机端的程序啊。 然后后面xdl和xda用于扩展的接口。 我们用不到ad 0硬件修改统计地址的最低位。 我们等会写程序的时候可以试下这个功能哈。 这里由于模块内置的下拉电阻。 所以引脚悬空的话就相当于接地。 最后int中断信号输出角我们用不到海。 可以不解。 那这就是硬件电路。 然后我们看一下面包板来接下线哈。 首先拿出mp u6050 的模块。 插在面包板合适的位置上。 之后用跳线接一下电源。 vcc接电源。 正极金地皆定而负极。 最后用飞线接一下通信硬件哈。 s cl接pb 10。 s d a g i p b 11。 这样接线就完成了。 然后插上sd link这个小模块上的电源指示灯亮起。 如果你插上电之后。 电源指示灯不亮。 那赶紧断电。 检查一下是不是vcc和接力接反了哈。 或者供电引脚没电。 或者模块坏了哈。 再排查一下问题好。 那这些就是硬件电路部分。 然后我们回到工程文件夹。 复制一下oled显示屏的工程啊。 改下名字。 十杠一软件iphone c读写po 6050。 打开工程。 这些删掉先编译一下。 好那在这个过程里。 先说一下我们代码的整体框架。 这个框架和之前五一单片机教程里的fc。 是一样的。 如果看过五幺教程里的ifc通信。 那应该就有些印象哈。 这里我们首先建立iphone c通信层的。 点c和点g模块。 在通讯层里写好iphone c底层的gpu。 初始化和六个时序。 基本单元。 也就是起始终止发送一个字节。 接收一个字节。 发送应答和接收应答。 写好iphone在通讯层之后。 我们再建立p u6050 的点c和d c模块。 在这一层。 我们将基于iphone c通信的模块来实现指定地址。 读指定地址写在实现写计算器对芯片进行配置。 独计算器得到传感器数据啊。 最后在媚点cd调用m p u6050 的模块。 初始化。 拿到数据显示数据。 这就是程序的整体架构。 那我们现在来开始写程序啊。 首先在hardware目录下添加文件。 为了防止和库函数里面的函数重名哈。 这里模块名称我要统一叫做买iphone c。 然后剩下的固定布置外加速一下。 那这里模块建好了。 我们先写一个初始化函数。 我的买fc 1 eley的。 那由于我们本代码要使用软件fc。 所以这个库里这个fc的库函数我们就不用看了。 软件fc只需要用g p l的读写函数就行了。 所以库函数我们不用看的。 然后这里软件fc初始化我们要做两个任务。 第一个任务。 把s cl和sda都初始化为开漏输出模式。 第二个任务把s scl和sda至高电平。 所以我们打开l d.c的文件。 复制一下这个g p l初始化的代码。 我们当前的界线sl是p b 10。 s d a是p b 11。 所以初始化这里开启时钟改成g p l b端口。 改成pin 10和pin 11。 下面初始化gp b p p 10和p 11。 都要配置成开漏输出的模式。 alt o d。 那这里虽然开漏输出啊。 名字上带了个输出。 但这并不代表它只能输出。 开漏输出模式仍然可以输入啊。 输入时先输出一。 在直接读取输入数据进器就行了。 这个过程我们在讲fc硬件规定时介绍过来。 那初始化结束之后。 调用sbs把gpl b的pin 10和pin 11都至高电平。 这样放z初始化就完成了。 调用买iphone z一定的函数。 pb 10和pb 11一两个端口。 就被初始化为开漏输出模式。 然后释放总线s scl和sda处于高电平。 此时iphone c总线处于空闲状态。 然后接下来我们就根据ppt这里的波形。 来完成iphone c的六个时序。 基本单元。 第一个基本单元是起始条件。 那这里对应写一个函数y的买ifc start void。 在这里面看一下波形。 这里我们首先把s c l和sda都确保释放。 然后先拉低sda。 再拉低s c l。 这样就能产生起始条件了。 那在这里我们可以不断的调用set beach和reset beach。 来手动翻转高低电平。 但是这样做的话会在后面的程序中啊。 出现非常多的地方来指定这个gp l端口号。 一方面这样做语义并不是很明显。 另一方面。 如果我们之后需要换一个端口。 那就需要改动非常多的地方。 所以这时我们就需要在上面做个定义。 把这个端口号啊统一替换一个名字。 这样无论是语义啊还是端口的修改。 都会非常方便。 那给端口号换一个名字呢。 有很多方法都能实现功能哈。 在五一单片机中。 我们一般使用speed来定义端口的名称。 但是speed并不是标准c语言的语法。 s t m32 也不支持这样做哈。 那这里一种简单的替换方法就是宏定义。 比如define cl port gpl b。 define sl p g pp 10。 之后如果想释放sl啊。 就set bs cl p s c l p s cl port。 就是g p r b s c l p就是g p l p 10。 这样语义比较明确哈。 而且修改引脚的时候。 直接在上面修改一下宏定义。 下面所有引用宏定义的地方都会自动更改。 这是一种简单可行的方法。 在s t m32 程序中也是挺常见的一个操作啊。 大家可以了解一下。 那进一步的。 如果你觉得每次都需要定义pd和pin比较麻烦。 还可以把这整个函数用宏定义进行替换。 比如在我给的o i d程序里就使用了这种方法。 这里我直接用宏定义把gpl ra bit。 包括参数在内的整个函数。 用宏定义替换了个名字。 新的名字叫做o l d w s l。 之后我们在需要操作sl的时候。 就可以使用这个新名字。 这样函数比较简短哈。 语义比较明确。 并且我这里使用了带参数的宏定义。 也就是有参红有参红。 是这样玩的哈。 在宏定义后面加一个括号里面写入行参。 那在实际引用的时候呢。 比如我这里调用o l d w s l 13给一。 那替换的时候。 这里的时差一就对应这里的形参x。 然后再进一步替换到函数里的x。 经过有参红替换之后。 这里这句话实际上就等效于这个复制下来。 然后把x替换为一。 这两句是一样的效果哈。 就是这个意思。 大家感兴趣的可以在百度了解了解。 这是用有参数替换整个函数的方法。 但是之前经常有人跟我反映哈。 看不懂这个意思。 而且这种方法在移植到其他库。 或者其他种类单片机时。 很多人都不知道怎么修改。 另外还有啊这种宏定义的方法。 如果换到一个主频很高的单片机中。 需要对软件的时序进行延时操作的时候。 也不太方便进一步修改哈。 所以综合以上我遇到的红利义替换的缺点。 在这里啊。 我就直接一点。 干脆再套个函数得了。 这样既容易理解又方便加软件延时。 所以在这里我直接定义函数啊。 对操作端口的库函数进行分装。 第一个函数y的买iphone c w s c l。 这个w代表写的意思哈。 参数是uint 8杠t beat value。 在这里面我调用gpl right bgpl。 b。 gpl p 10。 第三个参数给b value。 然后强转为bt类型。 这样套一个函数替换之后。 我后面再调用这个w s c l参数给一或零。 就可以释放或拉低sl了。 如果说你要把这个程序移植到别的单片集。 就可以把这个函数里的操作啊。 替换为其他单片机对应的操作。 比如sl是五一单片机的p10 口。 就可以把这句替换为p10 等于比特y6。 这样就行了。 另外如果你单片机主频比较快。 这里也非常方便。 加些延时哈。 比如我这里要求每次操作引脚之后。 都要延时15秒。 那可以这样先按阴葫芦的底了点下去。 再在这里del微秒十。 这样就能很方便的进行引脚延时操作了。 那对于m p u6050 来说。 经过我的实测海对于sdm 32 f一系列。 这里即使不加任何延时。 这个引脚发展速度啊。 p u6050 也能跟得上。 但是保险起见。 还我们还是延时个10微秒吧。 iphone c可以慢一些。 多慢都行。 但是快的话就还是要看一下手册里。 对持续时间的要求。 然后继续我们复制一份这个函数。 把sda也封装一下。 里面是pin 11。 另外我们还要再来个读sda的函数啊。 因为s t m32 库函数中。 读和写不是同一个计算器。 所以这里unit t8 杠七买iphone c2。 sd 2代表读的意思啊。 参数void函数里面先定义一个变量。 uint 8杠t beat value。 然后bit value等于gpl read。 input data。 bit。 gpl b gpl p 11。 读之后我们也延迟个十位名。 最后return bt value返回读到sda线的电瓶。 好。 那有了这三个函数的分装。 我们就实现了函数名称端口号的替换。 同时也可以很方便地修改时序的延时哈。 当我们需要替换端口。 或者把这个程序移植到别的单片机中时。 就只需要对这前四个函数里的操作对应更改。 然后后面的函数我们都调用这里封装的新名称。 进行操作。 这样在移植的时候。 后面的部分就不需要再进行修改了。 好那关于银角操作的封装和改名。 我们就完成了。 我们回到这里继续写这个程序。 在歧视条件里。 刚才说了。 我们需要先把s scl和sda都释放。 也就是都输出一哈。 然后复制一下。 先拉低sda再拉低sl。 这就是歧视条件的执行逻辑。 那这里注意一下哈。 在这前面我们最好把释放sda的放在前面。 这样保险一些哈。 p p t的也看一下。 如果起始条件之前。 s cl和sd已经是高电平了。 那先释放哪一个是一样的效果。 但是在这里。 我们这个时代还要兼容这里的重复起始条件。 s r s r最开始s c l是低电平。 s d a电瓶不敢确定啊。 所以保险起见。 我们称s c l是低电平。 先确保释放sda再释放sl。 这时sda和s cl都是高电平。 然后再拉低sda。 拉低sl。 这样这个start就可以兼容。 起始条件和重复起始条件了。 所以我们这个起始条件是这个逻辑哈。 接下来继续终止条件。 y的买ifc stop word。 看一下ppt。 在这里。 如果stop开始时s scl和sda都已经是低电平了。 那就先释放s cl再释放sda就行了。 但是在这个时序单元开始时。 sda并不一定是低电平。 所以为了确保之后释放sda能产生上升眼。 我们要在时序单元开始时先拉低sda。 然后再释放sl。 是放sd。 所以在程序里stop的逻辑是先拉低sda再释放cl。 再释放sd。 这就是终止条件。 终止条件后。 hcl和sda都回归到高电平。 然后是发送一个字节。 为的买fc send the beat。 参数是要发送的一个字节。 uint 8杠t bt发送一个字节。 持续开始时。 s cl是低电平。 实际上啊除了终止条件。 s cl与高电平结束。 所有的单元我们都会保证s cl与低电平结束。 这样方便各个单元的拼接哈。 看一下ppt。 这里sl低电平变换数据。 高电平保持数据稳定。 由于是高位先行。 所以变换数据的时候按照先放最高位。 再放次高位等等。 最后最低位这样的顺序。 依次把一个字节的每一位放在sda线上。 每放完一位后执行释放sl。 拉低sl的操作。 驱动时钟运转。 那在程序中的操作就是首先turn s cl低电平。 先把bt的最高位放在sda线上。 也就是这样写sda写一还是零呢。 取决于bt的最高位。 这里需要取出bt的最高位。 我们可以bet与上0x80。 这是一个单片机中非常常见的操作啊。 就是用按位与的方式取出数据的某一位。 或某几位列个式子比划一下。 这里bt可以是任意的数据。 叉叉叉叉叉叉叉叉。 0x80 是1000万。 两者按位与结果就是结果。 就是x0000000。 这第七位啊。 因为和零相遇。 所以结果不受bt数据的影响。 始终是零最高位和一相遇。 所以结果取决于bt的最高位。 如果bt最高位是一。 结果就是1000万。 也就是0x80。 如果bt最高位是零。 结果就是00000000。 也就是0x00。 这就相当于把bt的最高位取出来了。 注意一下。 这个式子计算结果是0x80 或0x00。 而不是一或零。 但是考虑到我们这个函数里面调用的这个函数。 具有非零即一的特性。 所以即使传入0x80。 也相当于传入了一。 所以这里可以直接这样写。 如果你不放心的话。 也可以写。 if bet与上0x80 等于零。 买fc w s d a0。 else m f c a w s d a1。 这样也行哈。 方法有很多。 不局限于我这一种写法。 那继续这样。 最高位数据就放好了。 我们再释放s z l。 拉低s zl驱动时钟走一个脉冲。 这里释放cl之后。 重击就会立刻把我刚才放在sda的数据读走。 再拉低s cl。 我们可以继续放下一位数据了。 下一位是次高位。 所以就是写sda与上0x40 取出次高位。 然后再驱动s cl来一个时钟之后。 这样来八次这个操作就可以写入一个字节了。 但是复制八次呢显得我们水平太低哈。 所以这里可以套个for循环循环八次就行了。 来定义一个迭代变量i for i等于零。 a小于8a加加循环八次。 然后把这个操作单元放在里面。 第一次循环i等于零。 需要与0x80。 第二次循环i等于一。 需要与0x40。 第三次循环i等于二。 需要与0x20 等等。 所以这里通知啊。 就是与上年x80 右移二位。 加个括号啊。 确保一线级下面就不要了。 这就是发送一个字节的逻辑。 我们就完成了。 接着继续接收一个字节。 uint 8杠t by iphone c receive feat vo。 看一下ppt。 这里接收一个字节。 持续开始时cl低电平。 此时重击需要把数据放到sda上。 为了防止主机干扰重机写入数据。 主机需要先释放sda。 释放sda也相当于切换为输入模式。 那在s cl低电平时。 重击会把数据放到sd。 如果重新想发一就释放sd。 如果重击想发零就拉低sd。 然后主机释放s cl在s cl高电平期间读取sd。 在拉低cl低电平期间。 统计就会把下一位数据放到sd上。 这样重复八次主机就能读到一个字节了。 其实这里可以发现啊。 sl低电平变换数据。 高电平读取数据。 实际上就是一种读写分离的设计。 低电平时间定义为写的时间。 高电平时间定义为毒的时间。 就像我们小时候玩的123木头人的游戏啊。 主机说123。 这个时候大家该动就可以动。 主机说木头人。 这时所有人都不能动了。 这个读写数据就是类似的流程。 那在s scl高电平期间。 如果你非要动s da来破坏游戏规则的话。 那这个型号就是起始条件和终止条件。 s scl高电平时sda下降沿为起始条件。 s da上升沿为中止条件。 这个设计也保证了骑士和中指的特异性哈。 快速的定位起始和终止。 因为起始终止和数据传输的波形有本质区别。 数据传输s scl高电平不许动s da起始终止。 s stl高电平必须动sda。 这就是这个设计还是非常巧妙的。 简单说一下。 那回到程序。 我们继续写。 接收一个字节进来之后。 s cl是低电平主机释放sda。 重新把数据放到sd。 这时主机释放s cl。 s cl高电平主机就能读取数据了。 读取数据我们用这个sda的函数套个if。 如果读sda为一。 if就成立。 我们就知道接收的这一位为一了。 那先定义一个数据。 unit t8 杠t bt给个初始值0x00。 如果第一次读sda为一。 我们就bet获胜于0x80。 就把bt最高位置一。 如果读sda为零。 if不成立。 bet默认为0x00 就相当于写入零了。 当然还是一样。 实现这样逻辑的方法有很多啊。 不局限于我这样的写法。 大家如果有自己的想法。 也可以试试看。 写代码本身就是思维的一种体现哈。 只要思路说得通。 代码就能运行。 那这里读取一位之后。 我们再把s cl拉低。 这时重击就会把下一位数据放到sda上对吧。 我们在执行相同的流程。 八次就能接收一个字节了。 所以我们写个for循环。 先定义变量i。 a等于零。 a小于八。 a加加。 把这一块放进去循环八次。 依次从高位到低位进行判断。 所以这里还是一样。 0x80。 右移二位。 top括号。 这样就能接收一个字节了。 最后别忘了return bt。 把接收的bt返回回去。 就是接收一个字节。 然后继续发送应答和接收应答。 看一下ppt。 这里发送应答和接收应答。 其实就是发送一个字节。 和接收一个字节的简化版。 发送一个字节是八位。 发送应答就是发一位。 接收一个字节是收八位。 接收应答就是收一位。 所以在程序这里我们可以复制一下这两个函数。 把for循环去掉。 稍微修改一下就成了。 首先发送应答。 把发送的一位改成a c k b。 现在的逻辑是函数进来时。 s scl高电平同机读取音的s cl。 低电平进入下一个时序单元。 这样就完事了。 最后接收进来了。 rec 5 a c k里面把for循环去掉。 定义变量a c k b初值可以不给他读sda时。 直接把读到的值赋值给a c k b就行了。 最后返回a c k b。 现在的逻辑是函数进来时。 sl低电平主机释放sda。 防止重击干扰啊。 同时重新把硬档位放在sd上。 s scl高电平主机读取应单位s cl。 低电平进入下一个视域单元。 那这个地方啊。 之前经常有人问我说。 程序里主机先把sda置一了。 然后再读取sda。 这应单位肯定是一啊。 这有什么意义呢。 那问出这样的问题。 说明你对两个知识点还不理解。 第一fc的引脚都是开漏输出加弱上拉的配置。 主机输出一并不是强制sda为高电平。 而是释放sda。 第二你要明白fc是在进行通信哈。 主机释放了sd。 那重机又不是在外面看戏啊。 重进如果在的话。 它是有义务在此时把sda再拉低的。 再读取sda。 读到的值也可能是零。 读到零代表重击给他印的。 读到一代表重击没给印的。 这就是接收应答的执行流程。 另外还有就是前面这里也有人问我说。 这里不断读取sda。 但是你for循环中又没写过sd。 那sda读出来应该始终是一个值啊。 这有啥意义呢。 这个问题和刚才那个也是一样。 就是我们iphone这是在进行通信通信是有冲击的。 当主机不断驱动sl时钟时。 重击就有义务去改变sda的电瓶。 所以主机每次循环读取sda的时候。 这个读取到的数据是重机控制的。 这个数据也正是重击想要给我们发送的数据。 所以这个时序叫做接收一个字节。 如果你自己写sd。 自己读还是da。 那还要通信干啥呢是吧。 这是这个问题。 就是你要明白我们是在通信通信是有时序的。 有些引脚的电平。 我们之前读和之后读读的值就是不一样的。 这个了解一下好。 到这里。 我们这个fc通信的六个基本单元就完成了。 我们现在可以来进行一下测试。 验证一下这些代码到底对不对啊。 那先把这六个函数和初始化函数放在头文件。 声明一下。 编译一下没问题啊。 然后在主函数里。 我们单独对买fc模块进行一下测试。 现金可录的一下。 买fc的头文件。 然后买iphone c1 d初始化一下ifc的引脚。 测试的方法呢就是p p t这里的时序结构图。 我们按照这个指定地址写。 和指定地址读的时序结构。 来拼接一下完整的时序。 看看实验现象是不是和我们想象的一样。 先看一下指定就是写哈。 在这里主机如果想开始一次传输。 首先需要调用start对应程序。 这里就是买iphone c start产生歧视条件。 开始一次传输之后呢。 根据协议规定。 起始之后。 主机必须首先发送一个字节。 内容是统计地址加读写位进行寻址。 对于程序这里就是买ifc sbt。 发送一个字节的内容是0x d00 x d0。 换成二进制。 就是1101万前七位统计地址。 1101000是m p u6050 的统计地址。 最后一位读写为零。 代表即将进行写入操作。 这样寻址就完成了。 接着继续发送一个字节之后。 我们要接收一下硬单位。 看看重击有没有收到刚才的数据对应程序。 这里就是买fc receive a c k返回值呢。 我们可以定义一个变量来接收一下。 看看这样我们判断这个a c k的值。 就知道重击有没有给我应答了之后继续接收。 进来之后。 我们要继续再发送一个字节。 写入寄存器地址。 这个我们等会儿再测试写入计算器的现象哈。 因为上小节讲计算器的时候说了。 这个芯片上电之后默认是睡眠模式。 我测试过哈。 睡眠模式写入计算器是无效的。 所以这个完整的时序先别急。 等会儿我们把读写函数封装一下。 再来测试这个功能哈。 那现在呢我们先测试一下。 硬打的功能是不是正常。 因为这里已经接收到应答位了。 所以后面这一段时序我们先不给了。 直接快进到停止。 那对应程序这里就直接来一个买iphone c stop之后。 我们用oled显示一下a c k看看是一还是零。 一行一列显示sk长度。 给个三。 这样这就是个测试重击。 给不给应答的简化时序。 目前持续的流程啊。 代入一下老师在课堂上课的场景。 解释一下。 就是主机起始。 也就是老师说所有人给我听好了。 我要点名了。 那这时下面的学生啊。 无论是睡觉的走神了。 还是说小话的。 都肯定立刻打起精神了。 等待老师的召唤。 然后主机寻址就是老师说p u6050。 你在不在。 我跟你说个事儿之后。 主机接收应答。 如果班里确实有这个人。 那m p o6050 必须在此时说。 我在对应硬打位就是低电平。 如果没有这号人。 那就没有应答。 应答位是默认的高电平啊。 一打之后主机应该就继续说话了。 但这里我目前啥都不说啊。 直接停止让这个同学坐下。 我其实啥都不想说。 就是看看你这个人在不在哈。 所以这个经典的时序。 你可以把它看成是点名时序。 就是看看有没有这号人的。 之后我们显示硬打位就是程序的内容编译。 下载看一下。 可以看到目前oled上显示的是零。 也就是应答位为零。 这说明我点名mp u6050。 他给我应答了。 现象没问题啊。 符合我们的预期。 然后程序中我们再测试一下。 把这个寻址改一下。 随便改一个。 比如0x a0。 那我点名0x a0 的设备。 我们总线上没有这个设备。 按理说就没有应答了。 编译下载看一下。 这时可以看出来。 显示的应答位是一符合我们的预期。 所以在程序这里。 我们可以利用这个点名的时序来完成一个功能。 就是重击地址的扫描。 我们可以用for循环把这个程序套起来。 便利一下所有的冲击地址。 然后把硬档位为零的地址统计下来。 这样就能实现扫描中线上设备的功能了。 这个功能有感兴趣的话可以自己试一下哈。 不过注意一下。 便利的时候只遍历前七位地址就行了。 最后一位要始终保持为零。 否则一旦你交出来。 总监控制权统计就会干扰你后续的便利。 这是这个功能啊。 那继续这个程序。 我们再测试一下。 通过a d0 引脚改名的功能。 目前我们把寻址改到0x d里下载看一下。 目前mp o应答为零。 给他回应。 然后我们找一根飞线给这个重击改下地址。 飞线一头接在ad 01角。 另一头接在高电平。 这时mp u6050 的重击地址。 就是1101001了。 对应班级里的学生哈地址就是学生的姓名。 老师点名的时候用的。 我们复位一下。 可以看到我们再用原来的110。 1000的名字叫它。 它就不理人了。 那在程序中我们修改选址。 用新名字1101001去调查试一下。 对应16进制为0x d2。 下载看一下。 改名之后我们用新名字去叫它。 它就可以回音了哈。 如果把飞线拔掉。 换回原来的名字呢。 复位他又不理人了。 在程序中改回0x d0。 下载他就又拟人了哈。 就是改名的实验现象。 目前我们这个芯片只有a d01 个硬件。 它就只能拥有总共两个名字。 如果有a d0 和d12 个硬件。 那就可以拥有总共四个名字。 如果有更多的可配置硬件。 那就有更多的改名机会啊。 当你需要一条总线挂载多个相同型号的设备时。 就可以利用这个改名的功能。 避免名字。 也就是重击地址的重复。 这是这个功能啊。 好。 那我们目前已经大体上验证了这个。 ifc时序的功能。 目前这个点名应答的功能是没问题的。 这说明硬件接线和这几个时序没问题啊。 接下来我们就继续来写。 建立在买iphone c模块之上的m p u6050 模块。 在hardware目录下新建一个模块。 名字叫po 6050。 快进一下。 模块已经好了。 先写一个初始化函数。 void mp u60501。 it void。 首先我们这个模块建立在买fc之上的。 所以我们这个模块要包含底层的函数。 先include一下买iphone c点下去。 初始化时先把底层初始化一下。 这个有点像类的继承之后。 我们在这上面。 我们先分装指定地址写和指定地址读的时序。 第一个word m p o6050 red rag。 指定地址写计算器参数是八位的。 计算机地址。 和八位的数据在这里面拼接这个时序。 第一个其实买iphone c start。 第二个发送一个字节。 by iphone c sbt字节的内容是0x d0。 统计地址加读写位。 那这里为了方便修改参数啊。 并且突出它是从机地址。 我们可以用宏定义替换一下这个数据。 define m p o6050 的重击地址。 替换为数据0x d0。 之后用这个宏定义来表示地址。 发送重击地址之后。 接收应答。 买ifc receive a c k这个函数会返回一个值哈。 应答位。 我们这里就不处理应答位了。 如果你想处理应单位呢。 可以在这里接收应答位。 判断一下。 如果没有应答。 就这么这么低。 但这个事后处理就比较麻烦了哈。 展开写的话会增加很多代码。 所以为了保证时序结构的清晰哈。 方便大家学习。 这里就不对。 返回直径判断了。 大家知道一下。 这里有应答位。 可以判断重击有没有收到数据就行了。 之后寻址。 找到重击之后就可以继续发送下个字节了。 第二个字节的内容就是指定寄存器地址。 这个季节会存在mp u6050 的当前地址。 指针里。 用于指定具体读写哪个计算器。 同样发送一个字节之后。 也得接收一下应答。 再之后复制一下。 继续发送第三个字节。 第三个字节就是指定。 我要写入指定计算器地址下的数据了。 然后接收应答。 最后买ifc stop终止这个时区。 这样就能实现指定地址写了。 大家可以对照ppt这里的流程啊。 和我们代码的流程是一对应的。 那如果你想指定地址写多个字节的话。 就可以用for循环把这两句套起来。 多执行几遍。 然后依次把一个数组的各个字节发送数据。 这个大家感兴趣的话。 可以自己课后完成一下这个进阶的任务啊。 这里就不再演示了。 好到这里。 我们指定就是写一个字节的时序就完成了。 接下来继续。 我们按照这个指定地址读一个字节的时序。 来完成一下读的函数返回值。 unit t8 杠t m p u。 6050瑞的rag参数只有一个指定读的地址。 在这里面对照一下这个时序图哈。 前面这一大部分和指定地址写是一样的。 指定的地址还没有来得及写。 所以程序中我们复制这一大段指定地址。 就是设置了m p u6050 的当前地址指针。 所以设置完地址之后。 我们要转入读的时序。 转入读的时序就必须重新指定读写位。 重新指定独显位。 就必须重新起始。 所以这里直接来个重复起始条件。 起始之后紧跟发送一个字节。 指定重击地址和读写位。 重启地址仍然是m p o6050 的地址。 但是我们这个0x d0 是写地址。 所以要在或上0x01 变成0x。 第一独显位为一。 这样就是指定了我接下来要读层级的数据了。 当然发送读指令之后。 别忘了还是要先接收应答的。 在接收应答之后。 总线控制权就正式交给重击了。 从机开始发送一个字节。 那主机就是调用买iphone c receive bt接收一个字节。 这个函数的返回值就是接收到的数据。 所以我们先定一个变量data。 然后把接收到的数据存起来之后。 根据协议规定哈。 主机接收一个字节之后。 要给从机发送一个应答。 买iphone c剩的a c k这里参数给零。 就是给重建的参数给一。 就是不给重建的。 上线前说过哈。 如果你想继续读多个字节。 就要给应答重击。 收到应答之后就会继续发送数据。 如果你不想继续读了。 就不能给重进行答了。 主机收回总线的控制权。 房子之后进入统计。 以为你还想要。 但你实际不想要的冲突状态。 那这里我们只需要读取一个字节。 所以就给一不给重进行单。 然后买i方c stop终止这个时序。 最后别忘了哈。 return data。 把读到的数据返回回去。 同样这里如果你想进阶为指定地址读多个子节。 可以用for循环把这两行套起来。 重复读取多次就能读取多个数据来。 当然要注意啊。 读取最后一个字节给非印的支线都给印的。 这个进阶的任务也留给大家。 课后完成了。 那这里指定地址读一个字节的时序就完成了。 对照一下ppt。 这里的时序结构是不是也都是一一对应的。 这个如果还没看懂的话。 可以再对照着详细研究一下。 好程序。 写到这里。 我们就可以进一步来进行测试了。 先把这三个函数放到头文件。 声明一下。 编一下没有问题啊。 回到主函数这些先删掉。 首先头文件这里我们就可以直接使用上层模块。 mp u6050 点去了。 然后这里po 60501 it。 在这个上层模块的一列车里面。 就已经调用了底层的买fc一例子了。 所以这次买fc的初始化是没问题的。 然后我们来调用读写计算器的函数试试看。 那每个计算器的地址和寄存器内数据的意义。 我们上小节的最后啊已经看过了。 现在就来读写他们试一下。 首先我们可以试一下。 读取这最后一个计算器芯片的id号验证。 看看对不对哈。 who m i接用器。 它是只读的。 地址是0x75。 内容是id号。 默认值是0x68。 回到程序啊。 读计算器。 我们可以调用mp u6050。 read rag参数是要读的。 计算器地址给0x75。 返回值是id号的内容。 我们用一个变量id存起来。 这样就能获取id号了。 最后显示一下id。 修hx蓝宝一行一列显示id变量长度为二。 下载看一下。 这时可以看到读出的id号是0x68。 这说明我们指定地址读一个字节的时序。 没问题啊。 另外有的芯片id号是0x98。 这个也没问题啊。 可能是批次或者其他什么原因。 id号有点不一样。 这个我从网上还没查到是什么原因哈。 不过影响不大。 知道一下就行了。 回到程序。 现在就验证了读计算器的功能没问题。 接下来验证一下写计算机的功能。 那要想写计算器呢。 首先需要解除芯片的睡眠模式。 否则写入是无效的。 睡眠模式是电源管理计算器一的这一位。 sleep控制的。 我们可以直接把这个计算器写入0x00。 这样就能解除睡眠模式了。 那这个计算器的地址是0x6 b。 所以程序这里我们使用po 6050 right re。 在这里第一个参数指定计算器地址0x6 b。 第二个参数是要写入的数据啊。 给个0x00。 这样就是在电源管理计算器一写入0x00。 解除睡眠模式啊。 之后我们再换一个计算器显示一下。 比如说在这里。 我们可以找一下这个采样率分屏计算器。 它的地址是0x19。 值的内容是采样分屏。 我们这里试一下。 地址是0x19。 只是可以先随便给一个哈。 比如0x aa。 那到底有没有写入成功呢。 我们在读计算机。 把0x19 地址下的数据读出来。 存到一个变量里。 我们就还放在id这个变量。 你看最后显示这个变量就是计算器。 0x19 地址下的内容了。 按理说它应该是我们刚写入的0x aa哈。 下载看一下。 可以看到显示0x a我们改一下再试试呢。 比如写入0x66。 下载读出来是0x66。 这就说明了读写均衡器都是没问题的。 其实这个程序啊。 目前我们是把mp u6050。 当成一个存储器来使用的。 写某个存储器。 读某个存储器。 其实读写真正的存储器芯片啊。 也是完全一样的逻辑。 如果你看过五一单片机的iphone z教程。 你就会发现。 到现在我们这个程序啊。 和那个读写at 20 c02。 存储器芯片是一样的流程。 计算器也是一种存储器啊。 只不过普通的存储器只能写和读里面的数据。 并没有赋予什么实际意义。 但是寄存器就不一样了。 计算器的每一位数据都对应的硬件电路的状态。 寄存器和外设的硬件电路是可以进行互动的。 所以程序到这里。 我们就可以通过寄存器来控制电路了。 那这些先删掉。 我们继续来写这个模块的程序。 首先在这里初始化之后。 我们还要再写入一些净水器。 对m p o6050 硬件电路进行初始化配置。 复制一下写计算器的函数啊。 放在这里。 初始化第一步。 配置电源管理计算器。 那在这里我们一般会用宏定义哈。 先把计算器的地址都用一个字符串来表示。 要不然每次都插手册二比较麻烦哈。 而且光写个数据的地址放这儿也不容易理解啊。 计算器如果比较少的话。 可以直接在这上面进行宏定义。 如果比较多的话。 我们可以再新建一个单独的头文件存放。 省得放在这里比较占地方啊。 所以我们在hardware右键再添加一个头文件。 名字叫po 6050 rag。 存放路径指定一下。 这里房子重复包含的固定格式也写一下。 在这里进行宏定义哈。 井号defi寄存器的名称。 然后对应的地址是哪个。 这个可以看一下手册哈。 把这个计算器的名称和地址搬到这里来。 这里为了节约时间。 我已经写好了哈。 在这里面就是这个样子的。 直接复制过来。 这个宏定义和手册是对应的哈。 比如电源管理计算器一地址是0x6 b。 就对应手册。 这里电源管理计算器一地址是0x6 b。 然后剩下的都是一样的操作啊。 大家可以自己写一下。 这里根据个人习惯呢模块的东西呀。 我一般都习惯加一个模块名字当前缀哈。 这个加不加都可以看你的喜好了。 然后呢有了这个定义。 我们就可以在这里引用。 先把计算器地址定义的头文件包含进来。 然后在下面先配置电源管理计算器。 一复制过来写的内容呢。 看一下手册。 这每一位的解释哈。 上一小节已经看过了。 不清楚的话。 可以再翻一翻手册后面的详细解释哈。 这里时间关系我就直接配了设备。 复位给您不复位睡眠模式。 给您解除睡眠循环模式。 给您不需要循环。 无官位给零即可。 温度传感器失能给你压不失能。 最后三位选择时钟。 给000选择内部时钟。 但上一小节说了哈。 他非常建议我们选择陀螺仪时钟。 所以我们可以给个001。 选择x轴的陀螺仪式中。 当然我测试看的话。 选择那个时钟啊。 影响并不大。 大家可以看着选。 所以这个计算器写入的数据就是0x01。 在这里给0x01。 编译一下。 没问题啊。 然后继续我们配置电源管理计算器二。 看一下手势。 前两位循环模式唤醒频率给零零。 不需要后六位。 每个轴的待机位全都给你哈。 不需要待机。 所以这个计算器写入的值就是0x00。 这里给0x00。 接下来继续。 我们配置上面这四个进气采样率。 分屏。 看一下手册。 这八位决定了数据输出的快慢值越小越快。 这个可以根据实际需求来哈。 我们给个零二至零九。 也就是十分平下一个配置计算器。 在这里外部同步全都给您。 不需要数字低通滤波器。 这个也是根据需求来哈。 我们可以给个110。 这就是最平滑的滤波。 所以这整个计算机的值就是0x06。 在这里给0x06 下一个陀螺仪。 配置净水器。 前面三位是自测死人哈。 这里手册写漏了。 我们就不自测了。 都给您满量程选择。 这个也是根据实际需求来啊。 我们就给幺幺选择最大量程。 后面三位五官位哈。 所以这个计算器就是0x18。 在这里给0x18 下一个加速度计。 配置计算器。 在这里自测给000满量程。 暂时也给最大量程了。 幺幺。 最后高通滤波器我们用不到给零零。 所以这个计算器的值也是0x18。 在这里给0x18。 这样初始化配置就完成了。 目前的配置主要是解除睡眠选择。 陀螺仪式中六个轴均不待机。 采样分屏为十。 滤波参数给最大。 陀螺仪和加速度计都选择最大量程。 这就是目前给的配置。 大家根据实际项目的需求哈。 可以对应更改。 那配置完之后。 输出的数据就存放在这里的数据进去里。 接下来我们想获取数据的话。 只需要再写一个获取数据寄存器的函数即可。 所以这里来个word po 6050 get data。 根据任务需求啊。 这个函数需要返回六个int 16杠t的数据。 分别表示x y z的加速度值和陀螺仪子。 但是c语言中函数的返回值只能有一个。 所以这里就需要一些特殊操作来实现。 返回六个值的任务。 多返回值函数的设计啊。 方法有很多。 第一种最简单的方法就是。 在函数外面定义六个全局变量。 子函数读到的数据直接写到全局变量里。 然后六个全局变量在主函数里进行共享。 这样就相当于返回来六个值。 这是一种比较简单且直接的方法。 比较适合用在规模比较小的项目中。 但这种方法不太利于分装哈。 那第二种进阶一点的方法是。 用指针进行变量的地址传递来实现多返回值。 这个方法在我之前指针教程里讲过哈。 不会的话可以再去看看。 然后第三种更进一步。 更高阶的方法。 就是用结构体对多个变量进行打包。 然后再统一进行传递。 这种方法就是stm 32的库函数里。 这里使用到的。 这里是结构体打包输入参数。 但是输出参数或者返回值。 也可以这样进行打包哈。 总之参数的传递方法有很多。 一般项目越大就越要考虑使用这些高级语法。 这样更有利于工程的管理哈。 那在这里呢我就使用第二种方法了。 用指针的地址传递。 所以在函数参数这里写上六个输出参数。 int 16杠t新a c c x int 16杠t。 新acc y int 16杠七。 新acc z复制一下哈。 然后改成jyx jy y jy l z。 这六个参数均是int 16杠七的指针类型。 之后我们会在主函数里定义变量。 通过指针把主函数变量的地址传递到子函数来。 子函数中。 通过传递过来的地址操作主函数的变量。 这样子函数结束之后。 主函数变量的值就是子函数想要返回的值。 就是使用指针实现函数多返回值的设计。 不会的话再看一下指针教程哈。 然后子函数中想要获取数据。 我们就要通过read rank函数读取数据进行器。 前面定义两个变量哈。 unit t。 八杠t。 读取高八位的值放在data h中。 读取低八位的值放在dl中之后。 高八位左移八位。 在货场第八位。 这是加速度g x轴的16位数据。 得到16位数据之后。 用指针引用传递进来的地址。 把读到的数据通过指针返回回去。 这样a c c x的值就完成了。 然后这里你可能会问哈。 这个dh是八位的数据。 它再左移八位会不会出问题啊。 这个经过测试呢是没问题的。 因为最终赋值的变量是16位的。 所以八位数据左移之后会自动进行类型转换。 移出去的位并不会丢失。 当然如果你不放心的话。 可以把这两个数据改为16位的哈。 这样就肯定没问题了。 另外因为手册里说过。 这个16位数据是一个用补码表示的有符号数。 所以最终直接赋值给int 16杠七也是没问题的。 这个问题说明一下哈。 接下来读取后续的数据。 同样的操作复制一下读取加速度。 y轴数据赋值给a c c y。 再复制一下读取加速度。 z轴数据赋值给a c c z。 然后陀螺仪的x y z轴也是一样。 复制一下这里计算器名字。 看一下jy x2 的h复制放在这里。 然后l。 这是jyx的数据。 g复制。 这个是图了。 以y轴。 最后一个这是陀螺仪z轴。 这样这个读取函数就完成了。 程序逻辑是分别读取六个轴。 数据进器的高位和低位拼接成16位的数据。 再通过指针变量返回。 那这里我们是用读取一个计算器的函数。 连续调用了12次。 才读取完12个计算器。 但实际上还有一种更高效的方法。 就是使用我们之前提到的iphone c。 读取多个字节的时序。 从一个基地址开始连续读取一片的计算器。 因为我们这个净水器的地址是连续的。 所以可以从第一个计算器的地址0x3 b开始。 连续读取14个字节。 这样就可以一次性的把加速度值陀螺遗址。 当然还包括两个字节的温度值啊。 都读出来了。 这样在时序上读取效率就会大大提升。 有兴趣的话可以自己写程序试一下啊。 那在这里我还是保留这种笨办法的操作。 这个也好理解一些哈。 好那我们来测试一下。 看看把这个函数放在头文件声明一下。 编译看看没问题啊。 然后主函数这里我们先定义六个变量。 int 16杠t a x a y a z gx g y g z。 这六个值分别用来接收xyz轴的加速度值。 和陀螺仪子。 之后在主循环里不断的读取数据。 调用mp o6050。 get data参数是六个指针变量。 我们要分别把这六个变量的地址传递进去。 所以变量放在这里。 别忘了每个变量前面加一个取地址的符号。 这样就能读取六个角的数据了。 然后用oled显示一下。 看看oled修三的number。 二行一列显示ax长度为五。 复制一下。 三行一列显示a y。 四行一列显示a z。 再复制一下234行的八列。 分别显示gx g y g z。 这样显示程序就写好了。 编译没问题。 下载看一下。 可以看到目前oled显示的六个数据。 并且不断在刷新。 晃动传感器数据也都有变化。 然后按照之前我们讲的。 加速度计和陀螺仪的模型啊。 大概验证一下这些数字含义。 首先这里左边三个数是x y z轴的加速度计。 我们按照之前说的一个正方形里面。 放置一个小球的模型来理解一下。 小球压在哪个面上。 就产生对应轴的输出。 目前这个芯片是水平放置。 对应正方体四个侧面应该不受理。 所以这里显示的xy轴数据基本为零哈。 小球压在底面上产生一个g的重力加速度。 这里显示的数据是1943。 这个数据对应的重力加速度值啊。 可以算一下。 目前初始化配置。 这里我们选择的满量程是最大的16g。 所以按比例算一下。 1943÷32768等于x除16g。 解得x就是测量值来计算器。 计算一下。 1943÷32768x16=0.95g。 即测得z轴的加速度值是0.95g。 这里标准的答案应该是一个g啊。 所以测量基本没问题。 然后再看一下这个板子上。 标的有x轴和y轴的示意图哈。 可能比较小。 大家可以自己看一下。 画的是纵向为x轴。 横向为y轴。 剩下一个z轴是垂直于芯片的那个轴哈。 这里没标。 那我们这样倾斜就应该是加速度的。 x轴两个面受力。 可以看第一个数据。 上清x轴正直下倾。 x轴负值没问题。 这样倾斜呢就是y轴的两个面受力。 这个大家可以自己实践观察一下。 这里可能看不太清。 让我们注意到这里无论怎么倾斜。 z轴加速度都是正直。 那如何让z轴出现负值呢。 我们知道在那个正方体和小球的模型中。 z轴代表上下两个面的受力。 下面受力是正直。 上面受力就是负值了。 所以要想让z轴输赋值。 得到上面一个面受力。 那显然我们把这个芯片翻过来。 这样这轴就是负值了。 这个大家自己时间观察一下哈。 那这些就是加速度大小的体现。 然后我们看一下陀螺仪。 这里右边三个数据为三个轴的角速度。 那我们这样转应该是绕z轴旋转。 陀螺仪z轴会输出对应的角速度。 这样转呢是绕y轴的转动图了。 以y轴数据变化。 这样呢就是绕x轴的转动。 陀螺仪。 x轴数据变化。 大家可以试一下。 具体每个轴旋转的角速度是多少。 也是按照我们刚才说的比例公式计算啊。 读取的数据图32768等于x除满量程。 解得x就是具体的角速度值。 那这些就是这个传感器。 测量各轴姿态数据的实验现象。 实验现象我们就演示到这里啊。 目前这个代码的任务也基本完成了。 我们最终把获取id号的代码也加上啊。 可以在这个位置再写个函数。 用int 8杠t m p u6050。 get id void。 在这里面应该就非常简单了。 直接return。 这里复制一下读取计算器的函数。 读取净水器。 净水器的地址是户外mi。 这个这样就能得到芯片的id号了。 我们把这个函数也放在头文件声明一下。 然后在主函数里调用。 先显示下字符串o i d修string。 一行一列显示id冒号。 定义一个变量uint 8杠t id。 然后id等于p u6050。 get id。 得到id号。 放在id变量里面。 在oid修hx number一行四列。 显示id长度为二。 这样就是显示id号了。 那编译一下没有问题啊。 下载看一下。 这里显示id号是16进制的六八没问题好。 以上就是本节课代码的全部内容了。 在这一节里我们用了多层的模块架构。 最底层iphone c协议层。 主要关注点是银角是哪两个什么配置。 持续什么时候高电平。 什么时候低电平。 这些协议相关的内容。 最后协议层之上是m p o6050 的驱动程。 主要关注点是如何读写计算器。 怎么配置。 净水器。 怎么读取数据。 这些驱动相关的内容。 最后就是主函数的应用层的。 在这里我们只需要调用get data函数。 得到数据就行了。 剩下的我们主要关注点是。 如何用这些数据来完成我们程序的功能设计。 当然我们目前的功能。 只是简单的显示一下数据哈。 就是分层的框架。 由了良好的分层结构。 我们在写每一层的时候。 就可以专注每一层的任务。 其他层的事情不需要管。 完成一层之后就尽量对这一层进行测试。 测试通过了再进行后续的代码。 这种编程方式啊。 大家之后可以再进一步研究。 研究好那本小节的程序部分。 到这里就结束了。 我们下一小节再见。
34. hello。 大家好。 本小节我们来继续学习iphone c通信啊。 那通过前面的课程呢。 我们已经了解了iphone c的协议规定和通信意义。 并且我们也用gpl口模拟的iphone c。 实现了读写mp u6050 的程序。 在这个过程中啊。 我们可以发现。 这个通信协议的时序是一个很重要的东西。 我们只要理解清楚了这个时序的意义。 就可以按照他协议的规定。 去翻转通信引脚的高低电平。 只要我们翻转产生的这个时序波形啊。 满足了通信协议的规定。 那通信双方就能理解并解析这个波形。 这样通信自然而然就实现了。 那之前的课程我们用的是软件fc。 手动拉低或释放时钟线。 然后在手动对每个数据未经判断。 拉低或释放数据线。 这样来产生这个波形。 这是软件ifc。 由于iphone c同步时序。 这每一位的持续时间要求不严格。 某一位的时间长点短点或者中途暂停一会儿。 持续一向都不大。 所以iphone c是比较容易用软件模拟的。 在实际项目中。 软件模拟的iphone c也是非常常见的哈。 但是作为一个协议标准。 iphone c通信也是可以有硬件收发电路的。 就像之前的串口通信一样。 我们先讲了这个串口的时序波形。 但是在程序中呢。 我们并没有用软件去手动翻转电平。 来实现这个波形。 这是因为串口是异步时序。 每一位的时间要求很严格。 不能过长。 也不能过短。 更不能中途暂停一会儿。 所以串口时序虽然可以用软件模拟。 但是操作起来比较困难。 我们之前的课程也没讲过软件模拟的串口哈。 所以就没有手动翻转电瓶这个操作。 另外由于串口的硬件收发器。 在单片机中的普及程度非常高。 基本上每个单片机都有串口的硬件资源。 而且硬件实现的串口使用起来还非常简单哈。 所以串口通信。 我们基本都是借助硬件收发器来实现的。 硬件串口的使用流程啊。 就是之前写程序演示的。 首先配置u s i t外设。 然后写入数据。 净水器低压。 这时硬件收发器就会自动生成波形发送数据。 最后我们等待发送完成的标志位即可。 这是硬件实现串口的方法。 那回到iphone c这里来。 iphone c也可以有软件模拟和硬件收发器自动操作。 这两种实现方式。 对于串口这样的异步时序呢。 软件实现非常麻烦。 硬件实现非常简单。 所以串口的实现基本上是全都导向硬件的。 而对于fc这样的同步时序来说。 软件实现反而简单且灵活。 硬件实现相比之下却并不能完全让人省心哈。 所以iphone c的实现软件模拟的情况还是非常多的。 但是考虑到硬件fc也有很多独有的优势。 比如执行效率比较高。 可以节省软件资源。 功能比较强大。 可以实现完整的多主机通信模型。 时序波形规整哈。 通信速率快等等。 所以硬件fc也是有相应的应用场景的。 如果你只是简单应用。 可以选择比较灵活的软件fc哈。 如果你对性能指标要求比较高。 就可以考虑一下硬件放c好。 到这里。 软件实现协议和硬件实现协议。 这两种方法的操作流程。 大家就应该了解了。 那进入本小节的正题。 我们来讲fc的硬件事件。 也就是s t m32 内部的i方c外设。 这一部分硬件fc的程序现象啊。 和之前软件fc的现象一样。 所以程序这里我就不演示了哈。 我们直接来看f c y4 的简介。 首先第一条s t m32 内部集成了硬件。 fc收发电路。 就像之前ui c a r t y设。 它是串口通信的硬件收发器。 这里fc的外设就是fc通信的硬件收发器。 有了硬件收发器之后。 就可以由硬件自动执行始终生成起始终止条件。 生成应答位收发。 数据收发等功能。 也就是由硬件电路来自动翻转引脚电平。 软件呢只需要写入控制禁用器c啊。 和数据进行器d啊。 就可以实现协议了。 当然为了实时监控时序的状态呢。 软件还得读取状态进入器s2。 来了解外设电路当前处于什么状态。 这就像是开车一样。 写入控制信用器c啊。 读取状态。 金容器s啊。 就像是观看仪表盘来了解汽车的运行状态。 有了这些计算器。 我们就可以完全掌控外设电路的运行了。 那我们s t m32 有库函数封装之后呢。 这个操作就更简单了。 调用函数。 给个参数库。 函数就能自动配置或读取各种计算器了。 然后继续有了这个iphone c外设的存在。 硬件自动实现时序就可以减轻cpu的负担。 节省软件资源。 另外由硬件来做这个事情啊。 可以更加专注持续生成的性能啊。 效率啊也会更高。 这是iphone c外设存在的意义。 就是用硬件电路实现fc通信。 然后接着看。 s t m32 的iphone c外设支持多主机模型。 支持七位或十位地质模式。 支持不同的通讯速度。 其中标准速度高达100 千赫。 快速高达400 千赫。 支持dma兼容sm bus协议。 这是硬件fc的功能指标啊。 那这些内容呢大家都只做了解即可汗。 不需要完全掌握。 因为这个放在协议还是比较庞大的。 这个硬件ifc呢作为一个专业户对吧。 它的设计指标非常高。 基本支持iphone c协议的所有规定。 但是我们在实际应用中啊。 往往只需要那个最简单最常用的应用领域。 也就是普通的一组多重模型。 七位地址模式。 所以如果你完全没学过fc通信。 想自己看这个参考手册学习要放c。 那基本是学不会的哈。 因为这个手册上来就是iphone c的完全体。 使用多组机的模型。 这里包括从发送重接收。 主发送主接收四种模式。 然后后面就一会儿是从模式。 一会儿是主模式。 一会儿几个模式互相切换。 还有七位弟子和十位地址等等。 总之设计的比较复杂。 这个手机啊只有你先把简单的fc通信学会了。 再来进阶的看。 这才容易理解。 所以我们本节的内容只要求掌握一组多重。 七位地址的iphone c。 对于多主机模型。 十位地址这些东西啊。 全都只需要了解即可。 但是为了方便大家理解后续的内容啊。 我这里也都大概的介绍一下。 我们来看一下。 首先多主机模型。 这个之前也介绍过哈。 ifc通信分为主机和从机。 顾名思义。 主机就是拥有主动控制中心的权利。 而冲击只能在主机允许的情况下才能控制中线。 在一组多重的模型下。 就是这样。 假设这是fc总线上面。 这个是唯一的主机。 下面这里可以挂载多个重击等等。 那这个过程就很容易操作了。 主机一个人掌控所有所有重击都得听他的话。 不存在什么权力冲突啊。 这是一组多重。 那进阶版的ifc呢还设计了多主机的模型。 对于多组机模型呢。 又可以分为固定多主机和可变多主机。 固定多主机啊。 就是这条总线上有两个或更多个固定的主机。 上面这几个始终固定为主机。 下面这几个始终固定为重积。 这个状态就像是在教室里。 讲台上同时站了多个老师。 下面坐的所有学生啊。 可以被任意一个老师点名。 老师可以主动发起对学生的控制。 学生不能去控制老师。 当两个老师同时想说话时。 就是总线冲突状态。 这时就要进行总线仲裁了。 仲裁失败的一方让出总线控制权。 那目前这种讲台上站多个老师的情况。 就是固定多主机啊。 然后是可变多主机。 这个模型的意思是假设这是ifc总件。 可以挂载多个设备。 总线上没有固定的主机和冲击。 任何一个设备都可以在总线空闲时跳出来。 作为主机。 然后指定其他任何一个设备进行通信。 当这个通信完成之后。 这个跳出来的主机就要退回到重击的位置。 这像是在教室里。 只有一堆学生。 没有老师默认情况下。 所有学生都是重击。 都不能说话。 当有某个学生想说话时。 就得跳出来变成主机。 然后指定其他任何一个学生进行通信。 通信完成后再做下变为重击。 当有多个学生同时跳出来时。 就是总线冲突状态。 这时就要进行总线仲裁。 仲裁失败的一方让出总线控制权。 那这种所有设备一视同仁。 谁要做主机。 谁就跳出来的模型就是可变多主机。 对于我们s t m32 的iphone c而言。 它使用的是可变多足节的模型。 虽然我们只需要一组多重啊。 没人跟s t m32 去正主机的位置。 但是s t m32 是按照。 可变多组级的模型设计的。 所以我们还是得按照谁要做主机。 谁就跳出来的思路来操作。 这是s t m32 f c的多主机设计。 了解一下。 那接下来继续看七位地址和十位地址的模式。 从我们之前的时序可以看到哈。 这里使用的是七位地址的模式。 也就是起始条件之后紧跟的一个字节。 必须是七位地址加读写位。 这种七位地址是最简单最常见的。 那很显然七位地址只有128种情况。 如果设备非常多。 那就不够用了。 如果一条总线必须挂载。 128个以上的设备。 那七位地址必然是不够用的。 另外如果有非常多的厂商都来申请fc的地址。 那也必然会有部分型号的芯片。 他们的地址是一样的。 对于不同芯片地址一样呢。 其实也好办。 因为地址的低位通常是可配置的。 前面都一样。 我配置后面不一样就行了。 只要你不在一个中天上挂载过多的设备就行。 另外即使确实需要很多设备条件允许的情况下。 也可以开辟多条iphone c总线。 所以地址的问题一般好解决。 当然在协议上分配更多的地址。 也是一种可行的方案哈。 那s t m32 的iphone z总线就支持十位抵制模式。 十位地址最多就有1024种可能了。 那所谓地址是如何设计的呢。 之前我们说了。 fc起始之后的第一个字节必须是寻址加读写位。 这一个字节只能有七位地址。 那我只需要再规定。 其次之后的前两个字节都作为选址。 这不就行了吗。 这就是十位地址的基本思路。 那第一个字节有七个空位。 第二个字节有八个空位。 按理说加一起是15位地址啊。 但是我们fc只有十位地址模式。 还有五位跑哪去了呢。 但是这五位当标志位去了。 因为你发送第一个字节之后。 谁知道你后面这个字节还是不是寻址呢。 所以这就需要在第一个字节写一个特定的数据。 作为十位寻址模式的标志位。 这个标志位就是11110。 也就是如果你第二个字节也是顺子。 那第一个字节的前五位就必须是11110。 你看这里前五位是11010。 就说明他是七位选择的。 如果前五位是11110。 那么这第一个字节剩下的两位。 和第二个字节的八位都作为顺子。 这不就是十位地址了吗。 当然11110开头的地址。 作为十位地址模式的标志位哈。 它是不会在七位地址模式下出现的。 这是七位地址和十位地址的区别。 大家了解一下几个。 再继续看。 支持不同的通信速度。 标准速度高达100 千赫。 快速高达400 千赫。 这个速度啊是协议规定的标准速度。 也就是说如果某个设备声称支持快速的fc。 那他就支持最大400 千赫的时钟频率。 当然作为一个同步协议。 这个始终并不严格哈。 所以你只要不超过这个最大频率多少都可以。 所以这个频率的具体值哈。 我们一般关注不多。 接着下一条支持dma。 这个在多字节传输的时候可以提高传输效率。 比如指定地址读多字节或写多字节的时序。 如果我想要连续读或写非常多的字节。 那用一下dma自动帮我们转移数据。 这个过程的效率就会大大提升。 当然如果你只有几个字节啊。 那就没必要用dma了。 这个是dma配合通信的应用。 然后继续是兼容sm bus协议。 这个sm bus是系统管理总线哈。 sm bus是基于fc总线改进而来的。 主要用于电源管理系统中。 sn bus和iphone c非常像哈。 所以s t m32 的fc外设。 就顺便兼容了一下sm bus。 这个了解一下即可啊。 我们主要学习的是fc。 那最后看一下我们这个型号芯片啊。 s t m32 f103 c8 t6 的硬件fc资源。 有fc一和fc 22个独立的fc外设。 可以看出来。 这里资源的限制。 也是硬件fc和软件fc的区别之一。 因为硬件fc必须要有硬件电路的支持。 所以硬件fc的资源是有限的哈。 比如我们这个型号的s t m32。 最多就只能有两路进加fc的总线。 但是对于软件iphone c资源一般没有很大的限制。 我们只需要复制一下代码。 就可以开辟一条新的iphone c总线。 所以软件fc只要代码能存得下。 基本上是想开几录就开几录。 没有资源的限制哈。 这是硬件fc和软件fc资源的差异好。 那这些就是s t m32 f c外设的简介。 那了解清楚了iphone c外设的用途和设计理念。 我们就来看一下这个iphone c外设的框图。 这里展示的就是s t m32 内部。 fc外设的结构图。 我们看一下。 首先左边这里是这个外设的通信引脚。 sda和s cl。 这是fc通信的两个引脚哈。 这个sm b alert是sm 80用的。 fc用不到不用管的。 那像这种外设模块引出来的引脚呢。 一般都是借助gpl口的复用模式。 与外部世界相连的。 具体是复用在了哪个gpu口呢。 还是查询这个引脚定义表哈。 在复用功能这两栏里找一下。 比如这里fc 2的s c l和sda。 就复用在了pb 10和pb 11这两个端口。 然后。 fc一的s scl和sda。 复用在了pp 6和p72 个引脚。 另外这里fc一的两个引脚啊。 还有重映射的机会。 可以重映射到pb 8和pb 92个引脚。 这就是硬件iphone c外设与gpl口的复用关系。 因为内部电路设计的时候啊。 这引脚就是连接好了的。 所以如果想使用硬件放c。 就只能使用它连接好的指定硬件。 不像软件放c那样哈。 零件可以任意指定硬件fc引脚就是固定的。 这几个不能任意更改。 所以硬件fc对银角的限制也比较大。 这个注意一下。 那银角看完我们继续看内部电路。 首先上面这一块是sda。 也就是数据控制部分。 这里数据收发的核心部分啊。 是这里的数据计算器和数据移位寄存器。 当我们需要发送数据时。 可以把一个字节数据写到数据景气低压。 当一位计算器没有数据移位时。 这个数据寄存器的值就会进一步。 转到移位寄存器里。 在移位的过程中啊。 我们就可以直接把下个数据放到数据计算器里。 等着了。 一旦签个数据一未完成。 下一个数据就可以无缝衔接。 继续发送。 当数据由数据进器转到移位寄存器时。 就会自状态计算器的tx e位为一。 表示发送计算器为空。 这是发送的流程。 那在接收时也是这一路输入的数据。 一位一位的从银角移入到一位进器里。 当一个字节的数据收起之后。 数据就整体从一位计算器转到数据进器。 同时自标志为2x n e表示接收计算器飞空。 这时候我们就可以把数据从数据进去读出来了。 这个流程和之前串口拉底是不是一样哈。 我们看一下。 串口整理。 数据收发也是由数据进气和一位进气两极。 实现的。 只不过串口是全双工。 这里数据收和发是分开的。 在fc这里是半双工。 所以数据收发案是同一组。 数据用器和移位寄存器。 但是这个数据进器和移位进器的配合。 设计思路都是异曲同工哈。 那有了这一块s d a的数据收发就可以完成了。 至于什么时候收。 什么时候发。 需要我们写入控制金属器的对应位进行操作。 对于歧视条件。 终止条件。 应答位什么的。 这里都有控制电路可以完成啊。 至于具体实验细节啊。 这里也没详细化。 大家知道有电路可以完成这些工作就行了。 那数据收发之后。 下面这里还有两个功能。 一个是比较器和自身地址计算器。 双地址计算器。 另一个是真错误校验计算和真错误校验计算器。 首先说一下这两块内容。 我们用不到两点即可。 那这里比较器和地址接入器。 这是重机模式使用的。 刚才说了。 s t m32 的f c。 是基于可变多主机模型设计的。 s t m32 不进行通信的时候就是重击。 既然作为宠姬。 他就应该可以被别人召唤。 想被别人召唤。 它就应该有重击地址吧。 从机地址是多少呢。 就可以由这个自身地址进入器制定。 我们可以自定义一个冲击地址。 写到这个计器。 当s t m32 作为重机在被寻址时。 如果收到的寻址。 通过比较器判断和自身地址相同。 那s t m32 就作为统计响应外部主机的召唤。 并且这个s t m32 支持。 同时响应两个重叠地址。 所以就有自称地址信用器和双地址接用器。 这一块。 我们需要在多主机的模型下来理解哈。 把角色转换一下。 stm 32作为重机才需要有这一部分。 当然我们只要求一组多重的模型。 s t m32 不会作为冲击。 所以这一块就不需要用汉。 然后右边这一块也是进阶的内容。 这是s t m32 设计的一个数据校验模块。 当我们发送一个多字节的数据。 真实在这里。 硬件可以自动执行crc校验计算。 cca是一种很常见的数据校验算法。 它会根据前面这些数据进行各种数据运算。 然后会得到一个自己的校验位。 附加在这个数据帧后面。 在接收到这一帧数据后。 s t m3 的硬件也可以自动执行校验的判定。 如果数据在传输的过程中出错了。 cr c校验算法就通不过。 硬件就会自校验错误标志为告诉你数据错了。 使用的时候注意点哈。 这个校验过程就跟串口的奇偶校验差不多。 也是用于进行数据有效性验证的哈。 当然这一块我们也不会用的。 所以也是了解即可。 那sda这一块。 我们就只需要掌握这个数据进器和移位寄存器。 配合的这部分就行了。 然后继续看下面s cl的这部分。 其实看着也没啥东西啊。 时钟控制是用来控制s cl线的。 至于控制的细节啊。 这里也没画。 你就把它当做是一个黑盒子就行了。 在这个时钟控制计算器。 写对应的位电路就会执行对应的功能。 然后控制逻辑电路啊。 也是黑盒子写入控制。 净水器可以对整个电路镜控制读取状态。 净水器可以得知电路的工作状态。 周时中断。 当内部有些标志位置一之后啊。 可能事件比较紧急。 就可以申请中断。 如果我们开启了这个中断。 那当这个事件发生后。 程序就可以跳到中断函数来处理这个事件了。 就是dma请求与响应。 在进行很多字节的收发时。 可以配合dma来提高效率。 这个也了解一下。 那这些就是这个fc外设的框图。 其实也没有很多东西啊。 大部分都是黑盒模型。 接着我们看一下这个基本结构图。 那这个结构图画的也是比较简单哈。 我们把这个图中用不到的东西去掉。 然后整理一下。 得到内部的简化结构。 就是这样。 首先移位进器和数据进器。 dr的配合是通信的核心部分。 这里因为fc是高位先行。 所以这个移位寄存器是向左移位。 在发送的时候最高位迁移出去。 然后是次高位等等。 一个s cl始终一位一次。 一位八次。 这样就能把一个字节由高位到低位。 依次放到sda线上了。 那在介绍的时候呢。 数据通过gpl口从右边依次一进来。 最终以841个字节就接收完成了。 只有gpl口。 这里使用硬件fc的时候。 这两个对应的gpl口都要配置成复用。 开漏输出的模式。 复用就是gpl口的状态。 是交由片上外设来控制的。 开漏输出。 这是iphone协议要求的端口配置。 之前也说过。 这里即使是开漏输出模式。 gpu口也是可以进行输入的哈。 然后s cl这里时钟控制器。 通过gpl去控制时钟线。 这里我简化成一组多重的模型了。 所以始终这里只画了输出的方向。 实际上前面这里如果是多主机的模型。 时钟线也是会进行输入的哈。 这个时钟的输入啊可以先不管。 然后继续sda的部分输出数据。 通过gpl输出到端口。 输入数据也是通过gpo输入的移位寄存器。 那这两个箭头连接在gpl的哪个位置呢。 我们看一下p p t最前面。 在这个位置复用开漏和推挽输出模式。 我们要使用ko输出。 所以这个p mos是没有的。 然后刚才看的一位计算器输出的数据通向gpo。 就接在了这个位置。 你看这里写的就是来自片上外设的。 复用功能输出对吧。 所以iphone c外设的输出啊就接到这里之后。 控制这个m4 的通断。 进而控制这个i o引脚是拉低到低电平。 还是释放选空。 然后对于输入部分可以看到。 虽然这是复用开漏输出。 但是输入这一路仍然有效。 l引脚的高低电平。 通过这里进入片上外设来进行复用功能输入。 所以iphone在外设通向gpl输出就接到了这里。 输入就接到了这里。 回到这个结构图。 这是gpl复用输出。 这是gpl复用输入。 这就是l o引脚。 这是这一部分。 然后数据控制器。 这是黑盒模型。 没啥说的。 最后还是有个开关控制。 也就是iphone c cmd啊。 配置好了就使人外设外设就能正常工作了。 这些就是这个iphone c外设的基本结构图。 接下来我们来看一下硬件方式的操作流程啊。 这两张图展示的是主机发送和主机接收的。 操作流程。 这个操作流程图就告诉了我们。 要想产生这样的iphone z时序。 啥时候该干些啥。 啥时候会产生啥事件。 我们写程序的时候啊。 也就是参考这个流程来写的。 所以还是要仔细分析一下的。 那在手册里是给出了重机发送。 重机接收。 主机发送。 主机接收四个流程图。 当然统计部分我们暂时不管哈。 所以这里只看主机发送和主机接收的流程即可。 我们先看一下主机发送。 当s t m32 想要执行指定地址写的时候。 就按照这个主发送器传送序列图来进行。 这里有七位地址的主发送和十位地址的主发送。 它们的区别就是七位地址。 其实条件后的一个字节是熏子。 十位地址。 其实条件后的两个字节都是裙子。 其中前一个字节啊。 这里写的是针头。 内容是五位的标志位。 11110+2位地址。 加一位读写位。 然后后一个字节内容就是纯粹的八位地址了。 两个字节加一起构成十位的数值。 这是十位地的选择模式啊。 了解一下。 当然我们主要关注七位地址的就行了。 七位主发送这个时讯栏流程是起始重击。 地址应答。 后面是数据一应答。 数据二应答等等。 这样来表示的。 最后是p停止。 因为安犯罪协议只规定了起始之后必须是寻址。 至于后面数据的用途啊。 并没有明确的规定。 这些数据可以由各个芯片厂商自己来规定。 比如m p o6050 规定。 就是选择之后数据一为指定寄存器地址。 数据二为指定寄存器地址下的数据。 之后的数据n啊。 就是从指定计算器地址开始依次往后写对吧。 就是一个典型的指定地址写的时序流程。 然后我们从头来看一下。 首先初始化之后。 总线默认空闲状态。 s t m32 默认是重模式。 为了产生一个起始条件。 s t m32 需要写入控制经期。 这个得看一下手册的计算器描述哈。 在这一位写一就可以产生起始条件了。 当起始条件发出后。 这一位可以由硬件清除。 所以只要在这一位写1s t m32。 就自动产生起始条件了。 就是我们刚才说的写入控制器。 之后s t m32 由从模式转为主模式。 也就是多主机模型下。 s t m32 有数据要发就要跳出来这个意思。 然后控制完硬件电路之后。 我们就要检查标志位。 来看看硬件有没有达到我们想要的状态。 在这里提示条件之后啊。 会发生1v5 事件。 这个1v5 事件你又可以把它当成是标志位哈。 这个手册。 这里都是用1v几这个事件来代替标志位的。 为什么要设计这个1v几1v几事件。 而不直接说产生什么标志位呢。 这是因为啊有的状态会同时产生多个标志位。 所以这个1v几事件啊。 就是组合了多个标志位的一个大标志位。 在库函数中也有对应的。 检查1v几事件是否发生的函数。 所以你就当成是一个大标志位来理解就行了。 下面这里解释1v5 事件。 sb是状态计算器的一个位哈。 表示它硬件的状态。 这时开车时看下仪表盘。 这个意思带手车这个状态计算器。 sr一中可以找到这一位。 这位之一代表起始条件已发送。 软件读取sr一进入机后。 也就是查看了这一位。 然后写数据进器的操作。 将清除该位写数据计算器。 dr就是我们接下来的操作啊。 所以按照正常的流程呢。 这个状态计算器是不需要手动清除的。 然后继续这个流程。 当我们检测起始条件已发送时。 就可以发送一个字节的重击地址了。 从机地址需要写到数据写dr中。 写出dr之后。 硬件电路就会自动把这一字节转到移位镜距离。 再把这一个字节发送到iphone z总线上之后。 硬件会自动接收应单位。 并判断。 如果没有应答硬件就会自应答失败的标志位。 然后这个标志位可以申请中断。 来提醒我们在选址完成之后会发生1v6 事件。 下面1v6 事件的解释啊。 就是a d d r标志位为一。 在手册中可以找到a d d r标志位。 在主模式状态下就代表地址发送结束。 大家继续看ev 6事件结束后是ev 8杠一事件。 下面解释1v8 杠一事件。 就是tx e标志位等于一一位进入其空。 数据进入器空。 这时需要我们写入数据进去dr进行数据发送的。 一旦写入dr之后。 因为移位寄存器也是空。 所以低压会立刻转到一未定期进行发送。 这时就是1v8。 4.1位计算器非空数据进去空。 这时就是一味进器正在发数据的状态。 所以流程这里啊。 数据一的时序。 就产生了这个数据进器和移位进器的配合哈。 要把前面这个结构记好。 就是发送的时候数据先写入数据进器。 如果一位进器没有数据。 再转到一位进器。 请发送这个流程要理解清楚。 否则这里写了啥。 一味借用其飞控数据进去空。 你可能就不知道是啥意思了哈。 那继续看。 在这个位置。 1v8 事件没有了。 对应下面这里写入dr。 将清除该事件。 所以按理说这个位置应该是写入了下一个数据。 也就是后面这个数据二。 在这个时刻就被写入到数据进入器里等着了。 然后接收一单位之后。 数据二就转入移位进去进行发送。 此时的状态是一位进去非空数据进去空。 所以这时这个1v8 事件就又发生了。 就这个位置数据二还正在以未发送。 但此时下一个数据已经被写到数据进去等着了。 所以这个时候1v8 事件消失之后。 应答产生1v8 事件写入数据进器。 1v8 事件消失。 按照这个流程来啊。 一旦我们检测到1v8 事件。 就可以写入下一个数据了。 最后当我们想要发送的数据写完之后。 这时就没有新的数据可以写入到数据进去了。 当一位计算器当前的数据一未完成时。 此时就是一位计算器空数据计算器也空的状态。 这个事件就是这里的1v8 杠二。 下面解释啊。 1v8 杠二是tx一等于一。 也就是数据进去空。 btf这个是字节发送结束标志位哈手册。 你可以看一下这里字节发送结束。 下面解释是在发送时。 当一个新数据将被发送。 且数据计算器还未写入新的数据时。 b tf标志位置一。 这个意思就是当前的移位寄存器已经移完了。 该找数据进去。 要下一个数据的。 但是一看数据进器没有数据。 这就说明主机不想发了。 这时就代表字节发送结束。 是时候停止了。 所以在这里当检测到ev 8杠二时。 就可以产生终止条件了。 产生终止条件显然应该在控制进入器里。 有相应的位可以控制啊。 手册这里控制净水器cr一中。 这一位十stop写一。 就会在当前字节传输或当前起始条件发送后。 产生停止条件。 那到这里一个完整的时序就发送完成了。 这整个过程看上去可能比较复杂哈。 操作和时间都比较多。 但是简单来说就是写入控制进去c啊。 或者数据进去d啊。 就可以控制时序单元的发生。 比如产生起始条件。 发送一个字节数据。 时序单元发生后检查相应的ev事件。 其实就是检查状态进入器s2 哈。 来等待时序单元发送完成。 然后依次按照这个流程操作。 等待操作等待等等等等。 这样就能实现持续了。 当然在程序中啊。 我们要扩展数。 不需要实际去配置净水器的。 所以这个过程会比想象中简单一些。 等我们写程序的时候再来进一步理解哈。 现在这个操作流程大家先有个印象就行好。 这就是主机发送的流程。 接着我们继续看主机接收的流程。 这里有七位主接收和十位主接收。 从这个七位主节奏的时序看。 这里时序的流程是起始从基地址加读接收应答。 然后就是接收数据。 发送应答。 接收数据发送应答。 最后一个数据给非印的之后终止。 可以看出来这个时序应该是当前地址读的时序。 指定机制读的复合格式啊。 这里没有给得。 需要我们自己组合一下。 然后下面十位地址的当前地址读呢。 就复杂一些了。 这里是起始发送针头。 这个针头里的读写位啊。 应该还是写的。 因为后面还要跟着发送第二个字节的地址之后。 继续发送第二个字节的八位地址。 这样才能进行寻址。 然后要想转入毒的时序。 必须再发送重复提示条件。 发送针头。 这是正常的读写位。 就是读的了。 因为发射毒的指令之后。 必须要立刻转入毒的时序。 所以这第二个字节的地址就没有了。 直接转入接收数据的时序啊。 这是十位地址的操作流程稍微复杂一些。 当然我们主要还是看七位地址的就行。 这里看一下。 首先写入控制净水器的start位。 产生起始条件。 然后等待1v5 事件。 下面解释和刚才一样哈。 1v5 事件就代表歧视条件已发送。 最后是荀子接收应答结束后产生1v6 事件。 下面的解释也和刚才一样哈。 1v6 事件代表寻址已完成。 这数据一。 这一块代表数据正在通过一位接器进行输入。 1v6 杠一事件。 下面解释是没有对应的事件标志。 只适于接收一个字节的情况。 这个1v6 杠一啊。 可以看到数据一其实还正在移位。 还没收到呢。 所以这个事件就没有标注位之后。 当这个时距单元完成时。 硬件会自动根据我们的配置。 把应答位发送数据如何配置。 是否要给印答呢。 也是看守这控制净水器cr一里。 这里有一位a c k一拿死人。 如果写一在接收一个字节后就返回一个应答。 写零就是不给应答。 就是硬档位的配置之后。 继续当这个时序单元结束后。 就说明一味进入器。 已经成功移入一个字节的数据一了。 这是一入的一个字节。 就整体转移到数据进去。 同时自2x n e标志位表示数据进去非空。 也就是收到了一个字节的数据。 这个状态就是1v7 事件。 下面解释是x n e等于一。 数据净水器非空读低压净水器清除该事件。 也就是收到数据了。 当把这个数据读走之后。 这个事件就没有了。 上面这里1v7 事件没有了。 说明此时数据一被毒走。 当然数据一还没读走的时候啊。 数据二就可以直接引入已未计算器了之后。 数据二一未完成收到数据二产生1v7 事件。 独特数据21v7 事件没有了。 然后按照这个流程就可以一直接收数据了。 最后当我们不需要继续接收时。 需要在最后一个时序单元发生时。 提前把刚才说的应档位控制进器a c k至零。 并且设置终止条件请求。 这就是1v7 杠一事件。 下面解释和1v71 样。 后面加了一句。 设置a c k等于零和十道补请求。 也就是我们想要结束了之后。 在这个时序完成后。 由于设置了ak等于零。 所以这里就会给出封印的。 最后由于设置到位。 所以产生终止条件。 这样接收一个字节的时序就完成了。 整体上流程和刚才差不多。 写入控制进气c啊和读取数据进去。 d r产生时序单元。 然后等待相应的事件来确保时序单元完成。 就是这个主机接收的时序流程。 好。 这些就是这个主机发送和主机接收的操作流程。 当我们夏小姐写程序的时候啊。 就对应这两个流程图来实现硬件fc的代码。 那接下来呢我们再看一下。 软件fc和硬件方c的波形对比。 这个图大家了解几个啊。 可以加深你对fc协议的理解。 这里是我用示波器抓取的。 软件fc和硬件fc的时序波形。 上面这个是软件ifc的波形。 可以看出这是一个指定地址读的时序。 我们看一下软件模拟的时序。 和硬件生成的时序有什么异同啊。 首先从引脚电平变化趋势上看。 这两个波形都是一样的。 对应的数据也都是一样的。 然后从时钟线的规整程度上看。 进阶fc的波形会更加规整。 这里硬件fc每个时钟的周期占空比都非常一致。 而软件放在这里呢。 由于操作引脚之后都加了延时。 这个延时有时候加的多。 有时候加的少。 所以软件持续的时钟周期占空比可能不规整。 不过由于i方这次同步时序。 这些不规整也没有影响哈。 然后还有就是这样说的。 sl低电平写。 高电平读。 虽然整个电瓶的任意时候都可以读写。 但是一般要求保证尽早的原则。 所以可以直接认为是excel下降演习。 上升研读。 这里看一下软件。 fc在下降延之后。 因为操作端口之后有些延时。 所以这里等了一会儿才进行写入操作。 后面的写作啊也是等了一会儿。 但在硬件这里数据写入都是紧贴下降沿的。 这里sl下降沿s d a立马就切换数据了。 后面也是这样的哈。 在读的时候。 我这里虽然绿线画在了高电平中间了。 但实际上读的时刻也是紧贴上升眼进行的之后。 在这个时刻就更明显了。 这里是应答结束重击。 在s cl下降眼立刻释放了sda。 但是软件fc的主机过了一会儿才变换数据。 所以这里就出现了一个短暂的高电平。 应答结束后。 s cl下降眼重击立刻释放sda。 同时主机也立刻拉低s t a。 所以这里就出现了一个小尖峰。 那在后面大家也可以同样进行对比哈。 硬件操作的fc。 包括上面这后面有些是统计的硬件操作的。 这些sda的数据变化。 都是在s cl的下降沿进行的。 而这些软件操作的iphone c波形。 可能就不是那么标准了。 当然还是因为iphone c同步时序的原因。 这些不标准的波形也完全不影响通信啊。 这也正是同步时序的好处。 可以容忍不标准的波形。 那这些就是软件和硬件波形的对比啊。 大家作为扩展部分了解一下好。 那本小节有关硬件方式的介绍就差不多了。 最后我们来看一下手册。 本小节的硬件fc的知识点。 对应手册的第24章fc接口。 这里前面是一些简介和主要特点哈。 ppt基本都介绍过。 大家可以再看看。 之后就是模式选择。 因为这个硬件。 iphone c是基于多主机的模型来设计的。 所以这里就有从发送器。 从接收器。 主发送器。 主接收器这四种模式。 下面写的是该模块默认的工作与重模式接口。 在生成提示条件后。 自动的从重模式切换到主模式。 当仲裁丢失或产生停止信号时。 则从主模式切换的重模式。 允许多主机功能。 这个应该就可以理解了吧。 周是通信流。 就是i方c协议的介绍。 然后是功能框图啊。 这个我们详细讲过之后。 就依次是对重模式和主模式的介绍了。 其中重模式包括重发送器和从接收器的流程。 这里重模式我们不做要求哈。 主要是主模式上面就有一些整体的介绍。 有一些细致的内容。 我可能没讲过哈。 大家可以再看看。 之后就是主发动机。 和主接收器的流程。 这个是写程序的依据。 得仔细分析一下。 将下面错误条件。 其中包括总线错误。 应答错误啊。 仲裁丢失啊。 过载欠载错误。 这些就是当时序没有按照正常的情况进行。 就会产生这些错误标志位。 进一步可以触发中断哈。 这是硬件的错误处理机制。 至于具体解释啊。 可以再看看这里的文字。 然后下面sm bus就是兼容的另一种中线。 这个暂时可以不看啊。 之后dma请求当进行多字节数据收发时。 可以配合dma提高效率。 这个需要用的话可以看看这里。 然后报错误校验。 这是硬件自带的crc校验功能。 需要的话也可以看看。 之后fc中断就是发生一些事件或错误时。 自标志位。 这个标志位可以申请中断。 总共有这个表里这么多事件可以触发中断。 需要的话可以开启对应的中断哈。 那最后就是iphone c的计算器了。 首先控制计算器。 这里面的v都是控制硬件电路运行的。 比如刚才看过的是否使能硬拿呀。 是否产生歧视。 终止条件等等。 这些控制电路运行的位。 都会放在控制计算机里面。 周四控制经期二。 自身地址接收器可以设置重模式下。 s t m32 自身的统计地址。 自身地址计算器二。 可以设置双地址模式的自身重击地址。 这个自身地址我们暂时用不到哈。 然后下面是数据计算器。 在进行数据收发的时候。 就是通过数据运算器来进行的。 数据进去。 背后还有一个移位进去进行配合。 这个是通信的核心部分啊。 之前都介绍过。 然后下面是状态进入器。 sr里面存的就是一些标志位。 标志电路状态。 这些可以再看看。 这是时钟控制进器。 这个是用来确定通信的s cl时钟频率的。 包括时钟的占空比啊和时钟分频系数。 这里会有一些公式。 但是我们有库函数啊。 库函数会自动帮我们计算这些参数。 所以这些公式就不需要我们再了解了。 之后t瑞士机问题。 这个不用了解。 然后最后就是计算器的总表了。 手册里就是这些内容好。 那到这里我们本小节的内容就全部结束了。 我们下一小节来学习硬件fc的代码部分。 那我们下一小节再见。
35. 大家好。 欢迎回来。 本小节我们来学习硬件iphone c的代码部分了。 那首先还是先看一下本节代码的经验图。 打开十杠二的图片。 这里展示的就是硬件fc读取mp u。 6050的经验图。 这个经验图和之前我们软件fc读写m p o。 6050的经验图是一样的。 这里也是哈v c c和jd接供电。 s cl接pb 10 sda gpb 11。 当然之前我说过。 软件iphone c的这两个通信引脚是可以任意更改的。 在程序中我们应该也有体会啊。 软件fc的引脚就是普通的开漏输出模式。 我们硬件接在哪个引脚上。 程序中就对应操作哪个引脚即可。 但是这里硬件fc通信引脚是不可以任意指定的。 我们需要查询这个引脚定义表。 来进行引脚规划哈。 这里可以看到如果使用硬件的fc 1。 需要接待pb 6和pb 7。 fc一可以重映射哈。 这样还可以更换为pb 8和pp 9。 但是在我们这个板子上。 pb 6789。 这四个引脚在板子的右下角被o r d占用了哈。 不太方便接线。 所以我们就继续查表。 可以看到这里硬件的iphone 12。 零件是pb 10和pb 11。 然后重映射这一栏没有找到iphone 12的重映射。 所以目前iphone 12只能选择pp 10和p 11。 并且这两个引脚也必须是s cl对应pb 10。 s da对应pb 11。 两者不能互换啊。 所以对应我们这个接线图。 s cl就接待了pp 10 sda接在pb 11。 这样才是硬件fc这个外设的正确接线。 如果你私自把引脚改到了其他位置。 那fc 2是无法操作的哈。 好这就是硬件fc的经验图。 然后看一下面包板。 这里硬件电路和上一个代码是一样的。 没有变化。 所以接线这里就不用改了。 这里为了方便啊。 我上一个软件fc的代码也选择了硬件fc的引脚。 那在这两个硬件上就既可以使用软件fc。 又可以使用硬件iphone c。 所以如果你之后画板子设计电路的时候。 不确定是使用硬件放c还是转接放c就可以。 这样我就干脆直接接在硬件fc的引脚上。 这样硬件fc软件fc想使用哪个都可以啊。 那不就留下来之后选择的余地了吗。 好接线图我们就看到这里。 接下来我们开始写代码。 那回到工程目录。 我们复制一下十杠一。 软件fc读写m p u6050 的代码。 从这个工程的基础上改改个名称叫十杠二。 硬件fc读写mp 26050。 打开工程。 先编译一下。 那在这个过程里。 我们最终的应用程哈。 也就是主函数的程序现象都是一样的。 软件fc和硬件fc的区别呢就在通信的底层。 也就是之前我们这里写的买iphone c.c这个文件。 这里面都是用程序手动翻转引脚。 也就是软件放c盘。 那我们有了硬件。 这些底层的东西就可以交给硬件来完成。 所以我们这个工程就不再需要这个。 买fc的模块了。 我们要把买iphone c这个模块移除工程。 把模块移除工程的步骤呢。 就是第一步在选项卡对应的文件这里。 右键把点c和点g的文件close掉。 第二步在工程数对应的文件这里。 右键把dc和dg的文件remove这里点四下。 这两个文件都移除。 这样我们就已经把模块移除了工程。 当然最后我们最好还是要到文件夹。 工程目录这里来打开hardware文件夹。 把这两个文件删掉。 保证工程数和工程目录里的文件一致哈。 这样有利于工程管理好。 回到qq软件。 这样最底层的买fc通信层就没有了。 我们到p u6050 点c这里来。 那这些原来调用买fc模块里面的代码。 目前就不存在了哈。 上面include的买fc点去这句删掉下面right right函数。 这里面先注释掉哈。 最后再删。 这样等会方便参考一下。 然后read rank函数里面这些也注释掉。 最后还有买fc elite也注释掉。 那目前注释的这些都是软件。 fc实现读写时序的相关代码。 所以接下来我们的任务就是。 利用硬件的iphone c外设来替换这些注释的代码。 实现相同的功能。 然后下面这里由于我们只替换最底层的通信层。 所以后面这些基于通信层的芯片。 配置和读取数据。 这些逻辑都不需要更改。 那看一下注释的这些代码。 我们的步骤就是第一步配置iphone c外设。 对iphone 12外设进行初始化来替换。 这里的买iphone 11 it。 第二步控制外设电路。 实现指定地址写的时序来替换这里的right r。 第三步控制外设电路。 实现指定地址读的时序来替换这里的redrug。 好。 现在程序的目的就清楚了。 接下来看一下p p t。 我们配置fc外设呢。 就参考上面这两张硬件电路的框图。 实现读写时序呢就参考下面这两张图。 主机发送和主机接收的流程图。 这样就行了。 那我们看一下这个基本结构图。 实际上配置iphone在外设也不难。 库函数的使用流程啊。 我们已经超过很多遍了。 这里也是一样。 第一步开启fc外设和对应gpl口的时钟。 第二步。 把iphone c外设对应的gpl口。 初始化为复用开漏模式。 第三步使用结构体对整个iphone c进行配置。 第四步iphone c c m d使能ifc。 这样初始化配置就完成了。 所以回到代码。 我们的目的有了。 接下来就是看一下库函数。 去寻找能实现我们想法的函数来展开library目录。 双击打开iphone c点缀的文件。 拖到最后看一下函数。 当然这里函数也是非常多啊。 我们目前只需要挑一部分重要的看就行。 那最前面的ditt edit struck的editor cmd。 这些函数都是老朋友了。 其中iphone c的初始化。 就靠这个iphone c一定的函数来完成参数。 第二个是初始化的结构体。 等会我们再详细分析。 使人或私人iphone c外设。 用iphone c c m d来完成。 这些都是常规操作哈。 然后下面我们要了解的函数是这个iphone c generate。 start。 生成起始条件。 调用一下这个函数就可以生成起始条件了。 其实这个函数执行的操作也很简单哈。 可以转到定义看一下函数内容。 就是如果new state不等于disable。 就把c r e计算器的start位置一。 否则把十start位清零。 start位的意义呢。 可以通过查看手册里的寄存器描述来了解。 这里可以找到start这一位。 start之一在重模式下就是产生起始条件。 在主模式下就是产生重复起始条件。 说白了就是这一位置一产生奇子条件。 那回过来继续看呢。 之后iphone c general stop这个就很明显了。 调用一下生成中止条件。 转到定义也可以看一下。 它里面其实就是操作cr一的stop位。 大部位在手册里也可以看到。 这里stop就是产生停止条件。 下面这里的解释啊。 可以提供库函数没体现出来的更多细节问题。 所以说如果你想对库函数实际执行的操作。 和可能产生的问题有深入了解。 还是得对照一下计容器来分析好。 那这就是这个函数就是设置stop位。 产生停止条件。 然后继续下一个fc ecology configure。 这个函数有啥用呢。 转到定义看一下。 可以看到啊。 这个函数就是配置c r e的a c k这一位。 那在手机里也可以找到这里。 a c k就是硬打死人。 就是s t m32 作为主机。 在收到一个字节后。 是给重击硬打还是给非应答呢。 就取决于这个a c k这一位在应答的时候。 如果a c k是一就给重进应答。 如果a c k是零。 就不给重击应答。 所以这里这个函数的意思也就很明确了。 就是配置在收到一个字节之后。 是否给重击应答。 然后继续往后下一个要学习的函数啊。 就是fc 3的data发送数据转到定义看一下。 实际上就是把data这个数据啊。 直接写入到低压禁用器。 那这个函数的意义呢看一下手册。 这里dr数据净水器用于存放接收到的数据。 或放置用于发送到总线的数据。 在发送机模式下。 当写一个字节至低压净容器时。 自动启动数据传输。 一旦传输开始。 也就是tx e等于e2。 发送电器空。 如果能及时把下一个需要传输的数据。 写入低压进去。 ifc模块将保持连续的数据流。 从这里可以看出两个信息啊。 一个是写入dr自动启动数据传输。 也就是产生发送一个字节的波形哈。 另一个是在上一个数据位传输的过程中。 如果及时把下一个数据放在dr里等着。 这样就能保持连续的数据流。 所以到这里升的data这个函数我们就理解了。 就是写数据到数据运气。 第二那继续看下一个函数。 fc receive data。 同样转到定义这个函数。 就是读取dr的数据作为返回值。 它的意思呢同样查看手势。 在接收器模式下。 接收到的字节被拷贝到dr净水器。 这时就是2x n e等于一接收机器飞孔。 那在接收到下一个字节之前读出数据进去。 即可实现连续的数据传送。 这里也能看出两个信息。 一个是接收一位完成时收到的一个字节。 由一位进器转到数据进器。 我们读取数据进去就能接收一个字节来。 另一个是你要在下一个字节收到之前。 及时把上一个字节取走。 防止数据覆盖哈。 这样才能实现连续的数据流。 所以这就是receive data。 这个函数的意义就是读取dr接收数据。 然后继续按下一个函数。 iphone c send 7 beat address。 这个是发送七位地址的专用函数啊。 转到定义看一下。 这里可以看出。 实际上address这个参数也是通过dr发生的。 只不过是他在发送之前帮我们设置了address。 最低位的读写位。 这里意思就是。 如果direction不是发送。 就把address的最低位之一也就是读。 否则就把这钻石的最低位清零。 也就是写。 所以我们在发送地址的时候啊。 可以用一下这个函数。 但如果你觉得不就是设置下最低位吗。 这么简单的操作就不用你库函数操心了。 我自己来就行。 那么也可以直接调用上面的send。 data函数来发送地址。 这也是可以的哈。 那这就是这个函数。 然后继续下面这些就不用看了。 其实后面就出现了一大段注释。 这个看着怪突然的。 实际上这里描述的就是fc的状态监控函数。 还记得我们上小节这里说的这个1v几1v几。 这个事件。 我说的是s t m32。 有的状态可能会同时至多个标注位。 如果你只检查某一个标志位。 就认为这个状态已经发生了。 可能不太严谨哈。 而如果你用get flag status 4函数读多次。 再进行判断。 有可能比较麻烦。 所以这里库函数就给了我们。 多种监控标志位的方案。 其中第一种叫做基本状态监控。 使用iphone c check event这个函数。 这个方式就是同时判断一个或多个标志位。 来确定1v几1v几。 这个状态是否发生。 和我们p p t这里的流程是对应的哈。 所以我推荐使用第一种方法来监控状态。 那这里有一大堆解释哈。 感兴趣的话可以自己再看看。 然后是第二种叫做高级状态监控。 使用iphone c get last event这个函数。 当然这个高级的方法实际上并不高级啊。 他就是直接把sr一和s2。 这两个状态计算器拼接成16位的数据扔给你。 二塔处理。 随便你看。 所以这个函数我们一般不用还了解即可。 然后最后第三种叫做基于标志位的状态监控。 使用iphone c get flag status这个函数。 那这个就是我们之前一直在使用的方法。 可以判断某一个标志位是否是一。 这是这三种状态监控的函数。 那下面这里就是这三个函数的声明呢。 其中get flag status是我们熟悉的方法。 check event是需要我们掌握的方法。 get last event了解即可。 然后下面四个就还是我们的老朋友哈。 读取标志位。 清标注位。 读取中断标志位。 清中断标志位。 这四个函数也不用多说啊。 好到这里我们这个库函数就看完了。 接下来我们来开始写硬件fc的代码。 那根据之前规划的流程啊。 首先是这里我们要对硬件fc进行初始化。 初始化第一步开启fc和gpu的时钟。 所以是二cc app一外设时钟控制。 这里注意啊。 fc一和fc 2都是a p p一的外设。 不要写错了。 参数转到定义。 看一下上面这里可以看到fc一和fc 2的参数啊。 我们使用的是iphone c2。 所以选择后面这个参数复制放到这里。 第二个参数你lab开启fc 2的时钟。 这样fc 2的时钟就打开了。 接着还有gpl的时钟也是一样。 r c c a p b2 外设时钟控制。 这里也是注意啊。 g p l是a p p2 的外设。 这两个的a p p总线并不一样。 当然我们还是转到定义看一下。 我们只要从函数这上面的注释里选参数。 这样a p p一还是a p p2。 这肯定搞不错对吧。 那这里g p l。 我们需要用的是pb 10和pb 11。 所以这里需要开启gpl b的时钟。 复制放到这里第二个参数以内。 这样就开启了gpl b的时钟。 开启时钟就完成了。 接着第二步。 我们需要把pp 10和p 11都初始化为。 复用开漏模式。 我们复制一下led这里的端口初始化代码哈。 放到这里。 那g p l mod这里是alt p p通用推广输出啊。 我们要改成a f o d。 这是复用开漏模式了。 至于为什么是复用开漏。 大家应该已经记住了吧。 开路这是f2 c协议的设计。 要求复用就是g p l的控制权要交给硬件外设。 我们这是硬件放谁。 那控制硬件的任务肯定得交给外设来做了。 如果是之前的软件要换c的话。 我们通过程序来控制硬件。 那就是通用开漏模式。 这个注意一下。 然后银角呢改成pin 10和pin 11。 下面初始化gp l b。 这样就把pp 10和p 11初始化为。 复用开漏模式了。 然后继续第三步初始化fc 2外设。 这里还是一样的套路哈。 我们调用fc一例的函数。 通过结构体来初始化分之二。 第一个参数fc x我们给f z2。 第二个参数配置结构体。 我就直接在上面写了。 其实写多了就能记下来的。 都是一个套路。 fc 1 it type define。 fc 1 it专科。 接着把结构体的参数啊全都引出来。 最后把结构体的地址传递给初始化函数。 接下来就还是熟悉的套路。 把结构体成员随便选选就行了。 挺简单吧。 这里我先给他简单的换个位置哈。 好我们来看一下第一个fc mod fc的模式。 这个参数填写啊。 大家不熟练的。 还是可以右键转到定义。 看一下解释和参数列表。 当然经过这么多集课程的训练啊。 我们早已是熟练功能对吧。 所以这里就采取更快的方法。 直接把结构体成员名复制放在后面。 按ctrl alt加空格快捷键提示参数。 然后再打一个下划线过滤一下。 这样参数列表就一目了然了。 可以看到可选参数有三个。 第一个是iphone c模式。 第二个是sm bus总线的设备。 第三个是sm bus总监的主机。 那这里我们用的是fc。 所以选择fc这个参数。 这样第一个参数就选好了。 然后这里额外说一个软件的小问题啊。 就之前有很多人跟我反映说。 这里按ctrl alt加空格。 快捷键不能显示这个代码提示框。 这样写代码就很不方便对吧。 这个问题之前我一直没遇到过哈。 现在换了个电脑。 换之后。 我也发现我这个代码提示框。 按快捷键死活都出不来。 最后求助万能的百度啊。 原来是这个快捷键和输入法的快捷键冲突的。 解决方法是在电脑右下角输入法这个图标上。 右键点击按键配置。 这里中英文模式切换的ctrl加空格。 这个选项默认是勾上了哈。 把这个勾去掉。 然后再在这个代码想要提示的位置哈。 按ctrl alt加空格。 应该就能出现提示框了。 如果你跟我是一样的情况。 可以试下这个方法好。 我们回到代码。 接着下一个参数。 时钟速度。 这个参数可以配置excel的时钟频率。 写一个数就行了。 数值越大。 s cl频率越高。 数据传输就越快。 转到定义。 看一下解释是。 这个参数必须是一个400 千赫以下的值。 看一下ppt啊。 这里简介说的是标准速度高达100 千赫。 快速高达400 千赫。 所以你要是写时钟频率。 在兹的范围。 i方c就处于一个标准速度状态。 如果你写在100 千赫到400 千赫的范围。 i方z就处于快速的状态。 那快速状态最大也只能有400 千赫。 所以这个数不能超过400 千赫啊。 那在程序这里呢。 我们可以根据实际项目的需求来制定啊。 比如5万就是50 千赫。 这个速度也不是很快哈。 如果你觉得不够。 可以再增加。 因为这个m p u6050。 也是支持最大400 千赫的时钟频率啊。 所以你可以最大加到400 千赫。 再大就不行了。 接下来下一个参数。 时钟占空比。 这个时钟占空比参数啊。 只有在时钟频率大于100 千赫。 也就是进入到快速状态时才有用。 在小于等于100 千赫的标准速度下。 占空比是固定的。 一比一。 也就是低电平时间比。 高电平时间约等于一比一哈。 那复制看一下参数列表。 这里时钟占同比有16比九和二二。 就是二比一哈。 16比九。 就是s cl时钟的低电平时间。 和高电平时间是16比九的比例关系。 二比一。 就是低电平时间和高电平时间是二比一的。 比例关系。 这个始终赞同比在之前的介绍中没有出现过哈。 按理说同步时序s cl。 高电平和低电平多长时间都应该没问题啊。 那这里为啥还要有占空比的参数呢。 其实这个占空比是为了快速传输设计的哈。 这里我用最终的程序代码做了个实验。 就是用示波器。 把各个时钟频率下的波形都装下来了。 首先是50 千赫哈。 这是一个数据帧。 最开始的模型上面是s cl。 下面是s d a。 可以清晰的看出来最前面这里是起始信号。 后面是数据传输数据位啊。 在s cl高电平比划一下1101万。 那目前s cl频率50 千赫处于标准速度。 所以这里占空比啊。 可以观察到低电平比高电平是一比一。 也就是50%占空比的方波。 这看上去都非常完美。 然后我们加大频率看一下。 这个图是100 千赫的波形。 100 千赫仍然是标准速度哈。 所以始终占同比仍然是一比一。 不过一个更重要的细节。 就是。 这里。 我们观察到s scl和sda的下降沿。 变化是非常快的。 但是在他们的上升眼就会像这样。 哎这个线它是缓慢上去的。 这是为什么呢。 其实也好理解。 按照我们之前的感知弹簧模型来解释。 你就明白了。 我们这个线就是一根杆子。 它是由一根弹簧默认拉到高电平。 当我们输出低电平时。 我们要用墙下来。 也就是无穷大的力。 用力把杆子拽下来。 那这时可想而知啊。 因为这个拽下来的利益非常大。 所以这个下降沿就非常的果断和迅速。 但是输出高电平呢。 我们是释放了杆子。 杆子通过弹簧拉回至高电平。 弹簧是个弱上了。 所以这里上升沿就有一个回弹的过程。 波形就会相对缓慢的上去啊。 那这个缓慢变化的上升眼有什么影响呢。 我们继续往后看。 下面一个图片是100 1000Hz的波形。 100 1000Hz和100 千赫频率差不多啊。 但是100 1000Hz就进入快速状态了。 这时iphone c会对s cl占空比进行调节。 低电平比高电平由原来的一比一。 变为大概二比一。 增大了低电平时间占整个周期的比例。 为什么要增大低电平的比例呢。 因为低电平数据变化。 高电平数据读取数据变化。 需要一定时间来翻转波形。 尤其是这个数据的上升点变化比较慢。 所以在快速传输的状态下。 你要给低电平多分配一些资源。 要不然低电平数据变化来不及。 你高电平数据读取也没用哈。 就像是我们的硬盘一样。 一般都是读取速度要大于写入速度啊。 所以要想快速转入给低电平的写入时间。 多分配点资源是合理的啊。 这是标准速度下时钟占空比接近一比一。 快速状态下时钟占空比接近二比一的原因。 接着继续看下一个图。 这个时钟频率是200 千赫。 由于时间轴尺度进一步缩小啊。 这时这个弯弯的上升眼就更加明显了。 比如这个时钟的低电平期间啊。 如果你不给他多分配一些时间。 他可能都来不及进行数据变化。 当然这个波形虽然是弯弯的哈。 但是整体上还是非常清晰的。 可以辨认出来。 最后我们继续看快速模式的极限速度。 400 千赫。 这时的波形就比较惨了哈。 可以看出这个时钟的高电平从这里开始释放。 s cl。 s cl还没完全回弹到高电平呢。 就立刻拉下来传输下一个数据来。 所以整个sl波形就变成三角形了。 这和我们想象的不太一样是吧。 我们想的是sl释放应该立刻回弹。 高难米。 谁会管。 这里还有个弯弯呢。 但是在快速的数据传输中。 这个弯弯就拖了后腿。 限制了iphone c总线的最大传输速度。 另外在下面这里可以看到啊。 s scl低电平期间。 数据变化也不是完全贴到下降沿的。 这也会有些延时。 所以这就更有必要。 在低电平多分配一些时间了哈。 好。 这些。 就是有关sl时钟频率和占空比的相关研究了。 给大家额外介绍一下。 然后我们回到程序。 那这里时钟频率和占空比。 大家就有更深的理解了吧。 然后这个快速模式下的占空比哈有两个参数。 16比九和二比一。 这两个参数其实很接近啊。 我们配置哪个都行。 那这里就选择二比一吧。 当然我们目前是标准速度。 占空比参数其实没用哈。 那继续看下一个参数。 a c k硬档位配置。 这个参数也是配置计容器的a c k v的。 和我们刚才库函数这里介绍的fc accology configure。 函数是一样的。 效果都是配置a c k v的。 用于确定在接收一个字节后是否给重新答。 那这里。 我们可以先给以内able哈。 默认是给英达的。 之后需要更改的话。 可以再用那个单独的函数修改。 然后下一个参数。 这个是指定s t m32 作为重机。 可以响应几位的地址。 我们复制看一下参数列表。 可以选择响应十位地址或响应七位的地址。 这是s t m32 作为重机模式才会用到的。 当然一般也都是七位地址。 我们选择七位即可。 然后最后一个参数自身地址一。 这个也是s tm 32作为重机使用的。 用于指定stm 32的自身地址。 方便别的主机呼叫他。 如果上一个参数选择了响应七位地址。 下面这里就给s t m32。 指定一个自身的七位地址。 如果上面选择了响应十位地址。 下面这里就填一个十位的地址。 当然还是那句话。 我们s t m32 暂时不需要做重击。 被别人使唤。 所以这个地址可以随便给一个哈。 只要不和总结上其他设备的地址重复就行了。 我们就给个0x00 吧。 那这样我们这个fc的初始化就完成了。 接下来最后一步fc c md fc 2。 你able只能安放在二。 这样整个i fc 2就初始化完了。 那这些代码呢是硬件放c的初始化。 我们就可以替换掉这个软件。 放c的初始化。 好。 到这里初始化替代的任务就完成了。 接下来我们继续来替换。 上面这两个函数里的内容。 首先是写计算器。 就是指定地址写一个字节的时序啊。 我们来用in加l f c的方法实现同样的功能。 让我们对照着上面的流程哈。 同时打开p p t。 也对照着这个主机发送的序列图来写程序啊。 显然第一步是生成起始条件。 这个快速我们刚才介绍过。 看一下复制这个iphone c general restart。 放在这里。 参数第一个fc 2。 第二个以内。 这样就能生成起始条件了。 这个general restart就替换软件fc的这个start函数。 另外软件fc的这些函数哈内部都有底类操作。 是一种阻塞式的流程。 也就是函数运行完成之后啊。 对应的波形也肯定发送完毕了。 所以上一个函数运行完之后。 就可以紧跟下一个函数。 但是下面这个函数呢。 包括之后的印加分之函数。 都不是阻塞式的。 这些硬件方程函数只管给计算器的位置至一。 或者只在dr写入数据就结束退出函数。 至于波形是否发送完毕啊。 他是不管的。 所以对于这种非主设置的程序啊。 在函数结束之后。 我们都要等待相应的标志位。 来确保这个函数的操作执行到位了。 那看一下ppt。 当起始条件的波形确实发出来。 会产生1v5 事件。 所以在程序中我们要等待1v5 事件的到来。 如何检查1v5 时间呢。 我们看一下转速。 这里要用到状态监控函数了。 我们使用第一种方法即可复制iphone c check ev。 放到这里。 参数第一个fc 2参数。 第二个就是指定要检查哪个事件。 转到第一。 看一下上面这一大片都是参数列表哈。 刚才说了。 我们要等待1v5 事件。 右边这里找一下1v5 事件。 就是这个参数库函数。 给这个1v5 事件还起了个名字。 叫做主机模式选择。 因为s t m32 默认为重击发送。 起始条件后变为主机。 所以1v5 事件也可以叫做主机模式。 已选择的事件。 那我们复制这个参数放到这里。 这样就是监测1v5 事件是否发动了哈。 然后再看一下返回值。 返回值是success。 表示最后一个事件等于我们指定的事件。 也就是指定事件发生了。 或者error就是表示指定事件没发生。 那在这里为了等待指定事件的发生。 我们需要套一个while循环。 这样加一个y。 如果检查1v5 事件不等于success。 就一直空循环等待。 否则就跳出循环。 这样就能实现功能了。 和我们串口拉力基本是一样的逻辑哈。 当然我们等会儿程序中还要加很多。 这样的while死循环。 等待这种while循环加多了。 一旦总线出问题了。 就很容易造成整个程序卡死哈。 所以我们需要设计一个超时退出的机制。 这个我们最后再来完善哈。 目前程序先这样。 我们继续。 其次。 条件发出后。 我们就要发送统计地址。 接收应答了。 看一下序列图。 这里也是指示我们发送地址结合应答哈。 所以在程序中我们需要发送重击地址了。 看一下函数。 发送从机地址就是发送一个字节。 直接向低压接容器写入一个字节就行了。 刚才说了。 这里深的data和s7 b的dress。 都可以完成这个功能。 当然我们给库函数一点面子。 就用它给我们提供的专用函数来完成复制。 放到这里。 第一个参数ifc 2。 第二个参数是统计地址。 我们把这个红利益的统计地址拿过来啊。 第三个参数是方向。 也就是重击地址的最低位读写位啊。 转到定义看一下这里。 如果选择transmitter发送。 他就给你的地址最低位清零。 如果选择receiver接收。 他就给你的地址最低位之一。 那么目前是要发送。 所以复制这一个放到这里。 这样重击地址就发送完成了。 然后接收应答。 这里并不需要一个函数来操作。 它。 在这个库函数中发送数据。 都自带了接收应答的过程。 同样接收数据也自带了发送应答的过程。 如果应答错误。 硬件会通过自标志位和中断来提示我们。 所以发送地址之后。 应答会就不需要处理了。 我们直接等待事件。 看一下ppt啊。 当地址发出接收应答位之后。 就会产生1v6 事件。 那在程序这里。 我们复制一下这一条等待事件的代码。 转到第一。 看一下1v6 事件。 这里有两个哈。 通过这个名字应该很容易区分。 上面这个是发送模式一选择。 下面这个是接收模式一选择。 目前我们是主机发送的时序。 所以显然要用上面这个1v6 事件复制。 替换到这里的事件。 这样就能等待1v6 事件了。 1v6 事件之后。 我们继续啊。 这里1v6 事件之后有个ev 8杠一事件。 这个1v8 杠一事件是告诉你。 你该写入di发送数据的。 我们并不需要等待这个1v8 杠一事件了哈。 在库函数里看一下这个参数列表。 这里也没有ev 8杠一事件的参数。 所以这时我们就是直接写入dr发送数据。 那看一下库函数。 复制iphone 13的data放到这里。 参数第一个fc 2参数。 第二个是一个字节的数据哈。 对照一下上面。 这时我们就应该发送这个reg的dress了对吧。 这个操作之后还是等待事件。 看一下。 这个时刻我们写入了dr。 dr立刻转移到移位寄存器进行发送。 此时波形产生。 我们写入dr后。 需要等待的是1v8 事件。 可以看出来1v8 事件出现的非常快。 基本是不用等的。 因为有两级缓存慢。 第一个数据写入第二弹会立刻跑到一位经济。 这时不用等第一个数据发完。 第二个数据就可以写进去。 等着了。 那在程序中我们写完dr之后。 还是要例行检查一下1v8 事件的复制一下。 转到定义。 这里是1v8 事件的参数。 它的名字是字节。 正在发送。 复制一下。 放到这里。 那根据我们的分析啊。 这个while循环应该不用等很久。 然后继续这里。 当等到了1v8 事件。 此时大概是在这个位置。 我们可以直接写入下一个数据。 所以程序中啊。 我们继续调用send data发送的内容啊。 就是上面这里的data之后。 同样是等待事件复制一下。 那由于我们这个data是最后一个字节。 发送完data之后就需要终止了。 所以最后等待的这个事件有所不同哈。 看一下。 当我们有连续的数据需要发送时。 在发送过程中。 我们需要等待1v8 事件。 而当我们发送完最后一个字节时。 需要等待的就是1v8 杠20点了。 什么时候会产生1v8 杠二呢。 下面这里解释是b tf标志位为一。 也就是一未完成的。 并且没有新的数据可以发的时候。 自b tf也就是一位八杠二。 就像是我们排队一样哈。 当我们这个队伍不进新人了。 并且把当前队伍里已经排着的人都消化完之后。 这才表示所有的人都已经服务完毕了对吧。 同理在这个时序的最后。 我们需要等待硬件把两级缓存。 所有的数据都清空才能产生终止条件。 那在程序中转到定义。 找到1v8 个二事件。 它的名字是字节已经发送完毕。 复制放到这里总结一下哈。 当我们需要发送多个字节的数据流时。 中间的字节写入dr之后。 需要等待1v8 事件。 也就是bt transmeeting最后一个字节写入dr之后。 需要等待1v8 到20点。 也就是bt transmit的就是流程啊。 那在transmit了之后。 我们就可以终止啊。 找价函数general return stop。 放在这里。 参数iphone z2 以内部终止时序。 这样我们就用链接方式的代码替换了上面软件。 iphone系列的代码。 两种方式产生的持续波形是一样的哈。 完成的任务也是一样的。 不过可以看出两者代码上的区别还是挺大的哈。 但是只要我们把iphone c协议理解了。 硬件外设也研究清楚了。 这些操作其实还是不难的哈。 好上面删掉。 那到这里我们这个写寄存器的函数就替换好了。 第二是下一个毒经气的函数。 那紫禁地是读经气呢。 上面这里复合格式的前面一部分。 和上面是一样的哈。 我们同样也复制一下。 从这里到这里复制。 然后下面粘贴。 这是复合格式指定地址的一部分。 接下来对着上面的代码哈。 在指定地址之后。 我们要生成重复起始条件。 所以复制这一条放在这里。 再来个起始条件。 但上面这个事件这里有个细节可以研究一下。 就是这个位置是用transmeeting。 还是transmitted的呢。 如果用transmeeting。 那实际这个事件发生时哈。 reg address的波形其实还没有完全发动完毕。 这时在直接产生重复提示条件。 会不会把这个数据截断呢。 那经过我的实测。 海其实并不会截断。 当我们调用起始条件之后。 如果当前还有字节正在移位。 那这个起始条件将会延迟。 等待当前字节发送完毕后才能产生。 所以上面这里用transmeeting还是transmitting的。 都没问题。 如果用transmeeting。 那下面重复起始条件之后将会等待。 如果用transmit的。 那等待就是在上面这里等波形全都发完了。 再产生重复起始条件。 那这里呢我们保险企业哈。 上面这里就还是用transmit的。 也就是按照设计要求来。 在数据里的最后一个字节。 还是等待transmit的比较好啊。 那么继续往后看。 这里提示条件之后看一下ppt。 接下来我们参考主机接收的这个序列图。 这里提示条件之后需要等待1v5 事件。 所以这里就直接复制这一条就完事儿了。 就要继续。 下一步还是发送从机地址。 不过这里的读写位就是读的方向了。 所以这里复制这一条。 把第三个参数改成receiver接收的方向。 那使用receiver的参数之后。 函数内部就自动把这个地址最低位置一。 就不再需要我们自己写一个或0x01 了。 这是不需要的哈。 那这之后还是等待事件。 我们看一下。 在选址之后。 我们也是等待1v6 事件。 复制一下这一角。 但是主机接收的1v6。 并不是主机发送的1v6 哈。 所以这个参数和上面这个并不一样。 我们转到定义看一下。 这里有两个1v6 事件。 现在是主机接收。 所以这时我们要用下面这个receiver mode。 select的复制啊。 放到这里。 这个注意一下。 不要搞错了哈。 接着我们继续进入到主机接收的模式之后。 就开始接收重新发的数据模型了。 看一下序列图。 在接收一个字节时。 有个1v6 杠一事件。 这个事件没有标志位。 也不需要我们等待。 它是适合接收一个字节的情况。 那么目前是要接收几个字节呢。 就是一个字节对吧。 我们是指定地址读一个字节。 所以在1v6 杠一时。 也就是1v6 事件之后啊。 我们要注意什么呢。 就是后面这里说的恰好在1v6 之后。 要清除响应和停止条件的产生。 也就是告诉我们啊。 在代码的这个时刻。 我们要把硬打为a c k至零。 同时把停止条件生成为10~5至一。 那你可能会问哈。 这时不应该是接收数据吗。 数据都没收到。 就要产生停止条件。 答案确实如此。 这里规定就是在接收最后一个字节之前。 就要提前把a c k至零。 同时设置停止为stop。 因为我们目前是接受一个字节。 所以在进入接收模式之后。 就要立刻sk至零。 stop之一。 为什么要这样设计呢。 我们看一下序列图啊。 这里如果你不提前。 在数据还没收到的时候给a c k之零。 那等持续到了这里。 数据已经收到了。 你再说我要自零。 我要给费用的。 这时是不是就晚了哈。 数据收到之前。 进档位就已经发送数据了。 你这时再给a c k至零。 那只能是在下一个数据之后给非印打了。 持续不等人哈。 所以在最后一个数据之前就要给a c k之零。 同时这里也建议我们提前设置stop中止条件。 这个终止条件也不会截断当前字节。 它会等当前字节接收完成后。 再产生终止条件的波形。 所以总结一下。 就是如果你是读取多个字节。 那直接等待1v7 事件读取dr就能收到数据了。 这样依次接收。 在接收最后一个字节之前。 也就是这里的1v7 杠一事件。 需要提前把sk置零stop之一。 如果你只需要读取一个字节。 那在1v6 事件之后。 就要立刻a c k之零1/12。 要不然你设置晚了。 实际上就会多一个字节出来。 那回到代码。 我们目前只需要读取一个字节。 所以在这个1v6 事件之后看一下。 关注复制到克劳累及config。 配置a c k v参数fc 2。 第二个给disable。 就是设置a c k等于零哈。 不给引导。 紧跟着继续复制genera ut stop配置停止位。 拆除ifc 2。 第二个给以内部就是设置stop等于一。 申请产生终止条件。 等这些做完之后看一下ppt。 我们在等待1v7 事件。 1v7 事件啊。 就是接收到一个字节后。 会产生在程序中复制等待事件的代码转到第一。 上面这里ev 7事件参数名是bt receive。 复制放到这里。 等ev 7事件产生后。 一个字节的数据就已经在dr里面了。 我们读取dr即可拿出这一个字节涨价函数。 复制receive data放到这里。 这个函数就是读取dr的参数放在二。 它的返回值就是第二个数据。 我们把它存到data变量里。 这样就完成了。 当然最后别忘了把a c k再自回一哈。 复制这一句。 到最后参数改成以内部。 为什么要这样做呢。 我们的想法是哈。 默认状态下a c k就是以给重建的。 在收最后一个字节之前。 临时把sk至零给费用的。 所以在接收函数的最后啊。 要恢复默认的a c k等于一。 这个流程是为了方便指定地址收多个资源啊。 所以我们现在程序中。 自始至终只有收一个字节的。 我们从来就没给过印的哈。 但是这个形式还是要写下的。 方便我们之后进一步改进代码。 这个说明一下哈。 到此这个指定地址收一个字节的函数就写完了。 这个逻辑看上去是不是比较绕哈。 尤其要注意。 这最后一个字节在接收之前要提前设置。 ac可以核实到不。 如果你要改进代码哈。 接受多个字节的话。 就可以把这十行用for循环套起来。 循环执行。 然后在接收前面字节时。 只执行后面两行。 再加个if啊。 如果技术到了最后一个字节if成立。 那就是四行全都执行。 这样就能完成指定地址读一个字节。 到指定地址读多个字节的升级了这个功能哈。 学有余力的同学可以尝试一下。 好现在我们这个读计算器的函数也转换完毕了。 上面的删掉。 这样整个代码由转加二放c到硬件。 放c的转变就完成了。 我们测试一下编译。 没问题啊。 下载看一下。 读取id 468。 下面是数据。 目前程序也是完全没问题的。 程序现象和转接fc的是一样的。 那程序到这里。 我们本节课的硬件放c就实现成功了。 最后我们来解决一下之前提的死循环的问题。 目前可以看到哈。 这个程序中出现了大量while死循环等待。 这种大量的死循环等待啊。 在程序中是比较危险的。 一旦有一个事件一直没有产生。 就会让整个程序卡死。 所以对于这种死循环等待哈。 我们可以给它加一个超时退出机制。 这个超时退出机制也不是写的很高大上哈。 说我用个定时器啊来计时退出。 这也没必要。 太麻烦了。 我们就用一个简单的计数等待就行了。 写法就是这样的。 比如我们对第一个死循环等待进行改进。 首先定义一个变量。 变量类型给大家哈。 uint 32杠提time out。 然后即使之前time out给一个比较大的数。 比如1万。 然后while的分号去掉这个循环体。 每循环一次。 time out减减。 if time out等于等于零。 以后是10000减到零了。 循环1万次了。 你问我咋还在循环呢。 吵死了。 我可等不及了。 在if里面可以使用break。 break是跳出循环的关键字。 就是强行打破while循环。 继续执行后面的代码。 当然你可以用return。 return是函数返回值的关键字。 同时它也能结束整个函数。 就是y我不循环了。 后面的代码我也不执行了。 直接跳出整个函数。 当然这个循环1万次到底花了多长时间。 不太好确定哈。 实际应该需要给多大的参数。 可以自己手动调值测试一下。 最终通过实验得到一个比较合理的计时值。 就是比较简单且常用的计时计时。 超时退出的机制啊。 那然后下面的每个while循环呢。 如果你不嫌麻烦的话。 可以把每个while循环都改成这样的形式。 当然我还是觉得这样改太麻烦了。 而且不美观。 所以我打算把这个check疑问的函数封装一下。 变成一个带有超时退出机制的weight疑问的函数。 那我可以在上面写word po 6050 wait。 疑问的参数呢转到这个定义哈。 把它的参数原封不动地复制过来。 函数里面呢先定义一个time out变量。 然后这一段都复制过来。 while等待事件参数。 把上面的形参传过来。 变成一个通用的等待函数啊。 里面是当计时为零return。 不过这里的return呢就只能结束这个子函数了。 原来外层的函数就没法直接return了。 这里就改成break吧。 这算是一个小缺点。 不过也不影响这样。 分装完之后。 原来的check一问全都替换成封装好的。 wait一问就行了。 这里不要了哈。 然后这样参数原封不动传给wet疑问的函数。 在v疑问的函数里面进行等待和超时退出。 这样就行了。 然后下面的等待哈。 我们全都可以这样来替换。 这样看着代码是不是更整洁一些呢。 结构比较清晰哈。 好我们再试一下。 下载看一下。 目前程序现象也是没问题的。 但是这个代码是有超时等待的。 可以防止意外卡死。 当然更进一步。 在实际项目中。 如果想让代码更加完善。 在这个超时退出的时刻啊。 就不能说是简单的break了。 这里还应该做一些相应的错误处理操作。 比如说打印错误日志啊。 进行系统的复位啊。 或者说如果项目涉及危险的机械结构。 就要评估一下是不是应该进行紧急停机的操作。 这样代码才会更加健全。 更加安全对吧。 那这些错误处理的内容呢。 大家可以在之后的实践中考虑一下好。 本小节硬件ifc的代码部分到这里就结束了。 我们下节再见。
36. hello。 大家好。 欢迎继续观看s t m32 入门教程。 本节课我们将继续学习下一个通信协议s p i。 s spi通信和我们刚学完的iphone c通信差不多哈。 两个协议的设计目的都一样。 都是实现主控芯片和各种外挂芯片。 之间的数据交流。 有了数据交流的能力。 我们主控芯片就可以挂载并操纵。 各式各样的外部芯片。 来实现一个功能更加强大的控制系统啊。 那本节课sbi通信的课程安排。 和上一节iphone c的也是一样啊。 我们先学习spi协议的软硬件规定。 先用软件模拟的s p i实现读写。 这个w25 q64 flash存储器啊。 之后我们再学习s t m32 中的spi外设。 再用硬件spi实现同样的功能好。 那我们先看一下本节课的程序现象。 本节课主要有两个代码。 一个是软件spi读写w25 q64。 另一个是硬件spi读写w r5 k64。 两个代码实现的效果也是一样的哈。 那先看一下这个软件spi读写w5 q64 下载。 看一下这里的w25 q64 呢。 是一个flash存储器芯片。 它内部可以存储八兆字节的数据。 并且是掉电不丢失的。 如果你之后的项目之外需要存储大量的数据。 就可以考虑一下外挂这个芯片来实现。 那在这里我们用四根s spi通信线。 把w25 k64 和s t m32 连接在一起。 s t m32 操作引脚电平。 实现s spi通信的时序。 进而实现读写存储器芯片的目的。 那在i o i d上。 我们可以看到测试程序的现象哈。 第一行显示的是id号。 m i d是厂商id哈。 读出来是0x e f d d是设备id。 读出来是0x4017。 这些id号都是固定的数值哈。 在手册里有写。 我们用spi读写id号。 就可以进行最简单的测试了。 如果读取id号和手册里一样。 说明spi通信基本没问题啊。 之后既然是存储器芯片。 我们肯定就是写几个数据再读出来看看。 对不对的。 这里第二行w写的内容是四个字节。 0x01020304。 然后第三行二就是读到的内容了。 显示出来可以看到也是0x01020304。 读出来和写入的一样。 这说明读写存储器芯片没问题啊。 当然更进一步的测试。 比如读写更多的数据啊。 写入的数据是不是掉电不丢失啊。 这些我们之后写程序的时候再来验证哈。 好程序线上就看到这里。 我们回到ppt来看一下spi通信。 第一条spi它的英文全称是这个哈。 字面意思翻译过来就是串行外设接口。 它是摩托罗拉公司开发的一种通用数据总线。 和前面方程一样啊。 他们都是通用的数据总线。 同时它们也都是用于主控和外挂芯片之间的。 通信应用领域。 非常相似啊。 当然fc和spi两者是各有优势和劣势的。 在某些芯片呢我们用fc更好。 在另一些芯片呢我们用s p i更好。 上一节我们学习fc的时候。 可以发现。 fc无论是硬件电路还是软件时序设计的。 都是相对比较复杂的哈。 硬件上我们要配置为ko外加上拉的模式。 软件上我们有很多功能和要求。 比如一根充电线兼具数据收发。 应答位的收发寻址机制的设计等等。 最终啊通过这么多的设计。 就使得iphone c通信的性价比非常高。 fc可以在消耗最低硬件资源的情况下。 实现最多的功能。 在硬件上无论挂载多少个设备。 都只需要两根通讯线。 在软件上呢数据双向通信。 定档位都可以实现。 如果把通讯协议比作是一个人的话。 那iphone c就属于精打细算。 思维灵活。 这类型的人。 既要实现硬件上最少的通讯线。 又要实现软件上最多的功能。 最终呢iphone c通过精心的设计。 也确实实现了这么多功能哈。 可以说是非常的优雅。 当然在这些优雅之中呢。 也隐藏了一个缺点。 就是我们上个视频说的。 由于iphone c开漏外加上拉电阻的电路结构。 使得通信线高电平的驱动能力比较弱。 这就会导致啊。 通信线由低电平变到高电平的时候。 这个上升沿耗时比较长。 这会限制fc的最大通讯速度啊。 所以fc的标准模式只有100 千赫的时钟频率。 fc的快速模式也只有400 千赫。 虽然还放在协议之后。 又通过改进电路的方式设计出来。 高速模式可以达到3.4兆赫兹。 但是高速模式目前普及程度不是很高哈。 所以一般情况下。 我们认为iphone c的时钟速度最多就是400 千赫。 这个速度啊相比较spi而言还是慢了很多的。 来了解完ifc的优势和缺点啊。 我们就来看一下spi。 在学习之前。 我简单概括几点。 sp i相对于iphone c的优缺点哈。 首先spi传输更快。 s p i协议并没有严格规定最大传输速度哈。 这个最大传输速度取决于芯片厂商的设计需求。 比如说我们这个w25 q64 存储器。 芯片手册里写的spi时钟频率啊。 最大可达80兆赫兹。 这比s t m32 f一的主频还要高哈。 其次s b i的设计比较简单粗暴。 实现的功能啊没有fc那么多。 所以学习起来s p i还是比fc简单很多的。 最后s p i的硬件开销比较大。 通信线的个数比较多哈。 并且通信过程中经常会有资源浪费的现象。 如果继续把通讯协议比作是一个人的话。 那s spi就属于富家子弟。 有钱任性这类型的人。 s p i说啊。 我不在乎我花了多少钱。 我只在乎我的任务有没有最简单最快速的完成。 这就是spi的风格好。 经过这么多的对比和铺垫啊。 大家对s p i应该就有了一个第一印象了吧。 那我们回到ppt。 现在开始研究s p i。 看一下第二条s p i有四根通讯线。 分别是s c k全称意思是串行时钟线。 mosi意思是主机输出重击输入。 m s意思是主机输入重击输出。 s s意思是重新选择。 这是spi通信典型的引脚名称哈。 当然在实际情况下。 这个名称可能会有别的表述方式。 比如啊s c k有的地方可能叫做s c l k。 c l k c k m o s i和m i s o。 有的地方可能直接叫做d o和d i s s啊。 有的地方也可能叫做n s s cs。 这些不同的名称都是一个意思哈。 大家了解一下。 那这里我就以s p i官方文档的名称为准哈。 在ppt里统一都用这几个名称来表示。 那这四个引脚的意义和作用是什么呢。 我们继续往后看。 s p i的基本特征是同步全双工。 首先这是同步时序。 肯定就得有时钟线了。 所以这个s c k硬件就是用来提供时钟信号的。 数据位的输出和输入啊。 都是在s c k的上升沿或下降沿进行的。 这样数据位的收发时刻就可以明确的确定。 并且同步时序。 时钟快点慢点或者中途暂停一会儿啊。 都是没问题的。 这是同步时序的好处。 那对照fc总线啊。 这个s c k就相当于fc的s c l。 两者作用相同哈。 之后sp是全双工的协议。 全双工什么意思。 就是数据发送和数据接收单独各占一条线。 发送用发送的线路。 接收用接收的线路。 两者互不影响啊。 所以这里moo si和mi so。 就是分别用于发送和接收的两条线路。 mosi线是主机输出重击输入。 如果是主机接在这条线上。 那就是mo主机输出。 如果是重击接在这条线上。 那就是si重击输入。 意思就是一条充电线。 如果主机接在上面配置为输出。 那重庆肯定得配置为输入啊。 才能接收主机的数据对吧。 主机和从机不能同时配置为输出或输入。 要不然就没法通信了。 所以这条mosi就是主机向从机发送数据的线路。 那同理。 下面这条m s就是主机重重击接收数据的线路。 这是传送工通信的两根通讯线。 那这两个通讯线呢加在一起。 就相当于fc总线的sda。 当然fc是一根线间距。 发送和接收啊。 是半双工。 这里p一根发送一根接收是全双工。 全双工的好处就是简单高效。 输出线就一直输出。 输入线就一直输入数据流的方向不会改变哈。 也不用担心发送和接收没协调好冲突了。 但是坏处就是多带一根线。 会有通信资源的浪费啊。 这是传送工。 然后继续下一条支持总线挂载。 多设备使用的是一组多重的模型。 spi仅支持一组多重哈。 不支持多组集。 这一点spi从功能上没有iphone c强大。 那fc实现一组多重的方式是在起始条件之后。 主机必须先发送一个字节进行寻址。 用来指定我要跟哪个重机进行通信。 所以iphone c这里要涉及分配地址和寻址的问题。 但是s p i表示你这太麻烦了。 我直接大手一挥。 再开辟一条通信线。 专门用来指定我跟哪个重新进行通信。 所以这条专门用来指定重击的通信线。 就是这里的ss重击选择线。 并且这个s可能不止一条哈。 s p i的主机表示我有几个重击。 我就开几条s。 所有统计一人一根都别想。 我需要找你的时候。 我就控制接到你那一根的ss线。 给你低电平。 就说明我要找你了。 给你高电平就说明我不跟你玩了。 那这样一来。 指定重击不就是动动手指就能完成的事了吗。 那还需要什么分配地址。 先发一个字节寻址的操作啊。 对不对。 那这就是spi实现一组多重指定重击的方式。 好处就是方便。 坏处就是得加钱。 那最后这里spi我没有写应答机制的介绍啊。 spi没有应答机制的设计。 发送数据就发送。 接收数据就接收。 至于对面是不是存在啊。 sp是不管的。 然后看一下下面的图片。 这些都是采用了spi通信的芯片和模块。 第一个图就是我们本课程使用的芯片。 型号是w25 q64。 是一个flash存储器哈。 这个模块的引脚呢。 可以看到和刚才说的并不一样哈。 这里c l k就是s c k d a和d o。 就是m o s i和m i s o。 那di到底是msi还是mi soo。 我们要看一下这个芯片的身份哈。 显然这个芯片接在s t m32 上。 应该是重击的身份。 所以这里的dna数据输入啊。 就是统计的数据输入。 si对应需要接在主机的mo上。 所以这里的di就是m o s i。 那另一个dio就是m soo了。 一般在这种始终作为统计的设备上啊。 可能会用di和dio的简写。 像s t m32 这种可以进行身份转换的设备。 一般都会把m o s i和mo全称写完整啊。 当然即使它简写了。 只要明确了他的身份是主机还是重击之后。 再辨别这两个硬件应该就好判断了哈。 那最后一个cs片选其实就是ss统计选择了哈。 然后进入下一个模块。 这个是利用spi通信的o i d屏幕上面的引脚。 也不是标准的名称哈。 所以这个模块要查一下手册。 在手册里有写的哈。 最后下一个这个是一个2.4g无线通信模块。 芯片型号是n2 f24 l01。 这个芯片使用的就是spi通信协议。 要想使用这个芯片来进行无线通信。 那就需要利用s p i来读写这个芯片。 然后最后一个图片就是常见的micro sd卡了。 这个sd卡官方的通信协议是s d i o。 但是他也是支持s spi协议的哈。 我们可以利用spi对这个sd卡进行读写操作。 那到这里。 我们这个spi通信的大体介绍就完成了。 接下来我们来看一下s p i的硬件和软件规定。 首先是硬件电路。 这个图就是s p i一个典型的应用电路。 我们看一下左边这里是s p i主机主导。 整个s spi总线。 主机一般都是控制器来做啊。 比如s t m32。 下面这里spi从机123。 就是挂载在主机上的重设备了。 比如存储器啊。 显示屏啊。 通信模块。 传感器等等等等。 左边s p i主机实际上引出了六个人通信线哈。 因为有三个重击。 所以s线需要三根。 再加s c k m o s i m s o就是六个人通讯线。 当然spi所有通信线都是单端信号。 它们的高低电平都是相对gd的电压差。 所以单单信号所有的设备还需要供地。 这里gd的线没画出来哈。 但是是必须要接的。 然后如果重击没有独立供电的话。 主机还需要再额外引出电源。 正极vcc给重机供电。 这两根电源线vcc和接力哈也要注意接好。 然后我们看一下这几根通讯线。 首先s k时钟线。 时钟线完全有主机掌控啊。 所以对于主机来说。 时钟线为输出。 对于所有重击来说。 时钟线都为输入。 这样主机的同步时钟啊就能送到各个统计了。 然后下一个m o s i主机输出重击输入。 这边左边是主机。 所以就对应m o主机输出。 下面三个都是统计。 所以就对应si统计输入。 数据传输方向是主机通过msi输出。 所有重机通过moo si输入。 接着下一个m s o主机输入重击输出。 左边是主机对应m i。 下面三个是重击。 对应s o数据传输方向是三个重击。 通过m so输出。 主机通过m so输入。 那到这里。 sc k m o s i m s o的连接方式我们就清楚了。 就是上面写的第一条。 所有s p i设备的s c k m o s i。 m s o分别连在一起。 就下面图示的这样。 所有的s c k连在一起。 所有的m o s i连在一起。 所有的m i s o连在一起。 每条线的数据传输方向哈。 这里都用箭头标出来了。 可以看一下。 应该都挺明确的。 之后我们继续看时钟和数据传输没问题了。 最后要解决的就是重机的选择问题了。 为了确定同期的目标主机。 就要另外引出多条s控制线。 分别接到各重机的s引脚下面。 这里有三个重击。 我们需要在主机另外引出三根s选择线。 分别接到每个重击的s s输入端。 主机的s线都是输出。 重击的s线都输入s线是低电平有效的哈。 主机想指定谁。 就把对应的s速度线至低电平就行了。 比如主机初始化之后。 所有的s都输出高电平。 这样就是谁也不指定。 当主机需要和比如重击一进行通信了。 主机就把s一线输出低电平。 这样重击一就知道主机在找我。 然后主机在数据引脚进行的传输外。 就只有重击一会响应。 其他重击的ss线是高电平。 所以他们都会保持沉默。 当主机和重击一通信完成之后。 就会把s一自回高电平。 这样重击一就知道主机结束了和我的通信之后。 主机需要和重击二和重击三通讯时也是同理。 需要找谁通信就自随的ss为低电平。 当然同一时间哈主机只能自一个s s为低电平。 只能选中一个重击哈。 否则如果主机同时选中多个冲击。 就会导致数据冲突。 就是spi实现选择统计的方式。 不需要像fc一样进行寻址。 是不是挺简单的。 然后我们继续看下一条。 输出引脚配置为推广输出。 输出引脚配置为浮空或上拉输入。 这是spi引脚的配置啊。 在下面图里。 输出引脚和输入引脚我都用箭头标出来了。 哪个是输出。 哪个是输入。 应该很好判断啊。 对输出我们配置推广输出。 推广输出啊。 高低电平均有很强的驱动能力。 浙江时的spi引脚信号的下降沿非常迅速。 上升沿也非常迅速。 不像i方c大于海。 下降眼非常迅速。 但是上升沿就比较缓慢了。 那得益于推换输出的驱动能力。 s p i信号变化的快。 那自然它就能达到更高的传输速度。 一般s p i信号。 都能轻松达到兆赫兹的速度级别哈。 然后这里fc并不是不想使用更快的推广输出啊。 而是iphone c要实现半双工。 经常要切换输入输出。 而且iphone c又要实现多主机的时钟同步。 和总线仲裁。 这些功能都不允许fc使用推广输出。 要不然你不小心就电源短路它。 所以fc选择了更多的功能。 自然就要放弃更强的性能了。 对于s p i来说。 首先s spi不支持多主机。 然后s spi就是全双工。 s p i的输出引脚始终是输出。 输入引脚始终是输入。 基本不会出现冲突啊。 所以s p i可以大胆的使用推广输出。 不过当然s p i其实还是有一个冲突点的。 就是图上的m i s o硬件。 在这个硬件上可以看到啊。 主机一个是输入。 但是三个重击全都是输出。 如果三个重击都始终是推满输出呢。 势必会导致冲突。 所以在s spi协议里有一条规定啊。 就是当重机的s s引脚为高电平。 也就是重击未被选中时。 他的msl硬件必须切换为高阻态。 高阻态就相当于鹰角断开哈。 不输出任何电瓶。 这样就可以防止一条线有多个输出。 而导致的电瓶冲突的问题了。 在s s为低电平时。 m i s o才允许变为投完输出。 这是s p i对这个可能的冲突做出的规定哈。 当然这个切换过程都是在重击里。 我们一般都写主机的程序。 所以我们主机的程序中啊。 并不需要关注这个问题好了。 有关spi的硬件电路。 我们就介绍到这里。 接下来我们来看一下这个一位示意图。 这个一位示意图是spi硬件电路设计的核心。 只要你把这个一位示意图搞懂了。 那无论是上面的硬件电路。 还是我们等会学习的软件。 时序理解起来都会更加轻松。 我们看一下spi的基本收发电路。 就是使用了这样一个移位的模型。 左边是s p i主机。 里面有一个八位的移位寄存器。 右边是s p i重机。 里面也有一个八位的移位寄存器。 这里一位计算器有一个时钟输入端哈。 因为s p i一般都是高位相应的。 所以每来一个时钟移位。 寄存器就会向左进行移位。 从其中的一位接收器也是同理哈。 然后呢一位计算器的时钟源是由主机提供的。 这里叫做波特率发生器。 它产生的时钟驱动主机的移位寄存器进行移位。 同时这个时钟也通过sk硬件进行输出。 接到统计的一位金容器里之后。 上面移位寄存器的接法是主机移位。 寄存器左边移出去的数据。 通过msi硬件输入的统计疑问。 计算器的右边。 从第一位进入器左边移出去的数据。 通过m i s o硬件输入的主机移位。 进入器的右边。 这样组成一个圈哈。 接下来我来演示一下这个电路如何工作。 首先我们规定啊波特率发生器始终的上升。 也所有移位定器向左移动。 移位移出去的位放在眼角上。 波特与发射器始终的下降。 眼引脚上的位采样输入的以为进器的最低位。 接下来假设主机有个数据。 10101010要发生的冲击。 同时重击有个数据01010101。 要发送到主机。 那我们就可以驱动时钟。 先产生一个上升沿。 这时所有的vr就会像这样往左移动一次。 那从最高位移出去的数据。 就会这样放到通信线上。 数据放到通信线上啊。 实际上是放到了输出数据。 净水器可以看到此时mosi数据是一。 所以msi的电平就是高电平。 m i s o的数据是零。 所以m i s o的电平就是低电平。 就是第一个始终上升沿执行的结果。 就是把主机和从机中移位寄存器的最高位。 分别放到m o s i和m s的通信线上。 这是数据的输出之后。 时钟继续运行。 上升沿之后。 下一个边缘就是下降沿。 在下降延时。 主机和从机类都会进行数据采样输入。 也就是moo si的一样。 会采样输入的重击。 这里的最低位。 msl的零会采样输入到主机这里的最低位。 这是第一个始终结束后的现象。 那始终继续运行下一个上升沿。 同样的操作。 一位输出。 这样的主机现在的最高位。 也就是原始数据的次高位输出的m o s i重击。 现在的最高位输出到m so。 随后下降。 沿数据采样输入msi数据到这里。 m s数据到这里。 周始终继续运行啊。 第三个时钟开始上升。 演你胃。 主机输出重击输出下降。 沿采样主机输入重击输入之后。 第四个时钟。 第五个时钟等等啊。 一直到第八个时钟都是同样的过程。 这里我们直接一步到位哈。 加速一下。 最终八个时钟之后我们看到什么现象啊。 就是这里原来主机的10101010。 跑到重击里了。 原来从机里的01010101跑到主机里来。 就实现了主机和从机一个字节的数据交换。 实际上s p i的运行过程就是这样哈。 s p i的数据收发都是基于字节交换。 这个基本单元来进行的。 当主机需要发送一个字节。 并且同时需要接收一个字节时。 就可以执行一下字节交换的时序。 这样主机要发送的数据跑到重机。 主机要从从机接收的数据跑到主机。 这就完成了发送。 同时接收的目的。 那你可能会问啊。 如果只想发送。 不想接收怎么办呢。 其实很简单。 我们仍然调用交换字节的时序发送。 同时接收。 只是这个接收到的数据。 我们不看它就行了。 那如果我只想接收。 不想发送怎么办呢。 同理我们还是调用交换自己的时序发送。 同时接收。 只是我们会随便发送一个数据。 只要能把重机的数据置换过来就行了。 我们读取置换过来的数据不就是接收了吗。 这里我们随便发过去的数据啊。 从机也不会去看它。 当然这个随便数据我们不会真的随便发啊。 一般在接收的时候。 我们会统一发送0x00 或0x f f。 就跟重击换数据好。 以上就是spi的基本原理。 总结一下就是spi通信的基础是交换一个字节。 有了交换一个字节就可以实现发送一个字节。 接收一个字节和发送同时接收一个字节。 这三种功能可以看出啊。 spi在只执行发送或只执行接收的时候。 会存在一些资源浪费现象。 不过全双工的东西啊。 本来就会有浪费的情况发生。 sbi表示我不在乎好了。 了解完这个移位示意图啊。 再看一下硬件电路。 是不是这三个硬件的功能哈。 就很容易理解了。 另外再加几根s重击选择线就是spi通信。 那硬件部分看完我们来看一下sp的时序。 只要你把刚才的一位示意图理解了哈。 spi时序其实也很简单。 我们看一下。 首先是s p i的起始和终止。 其中起始条件是s4 从高电平切换到低电平。 也就是左边这个图ss是低电平有效的。 那s s从高变到低。 这是通信的开始。 然后重置条件是ss从低电平切换的高电平。 就右边这个图s s从低电平变得高电平。 就是结束了重击的选中状态。 就是通信的结束。 那在重击的整个选中状态中。 s要始终保持为低电平。 这个是不是好理解啊。 就是s s低电平选中。 高电平未选中。 那低电平期间就代表正在通信。 下降沿是通信的开始。 上升沿是通信的结束。 这个相比较iphone z还是简单很多的。 这就是歧视条件和终止条件。 接下来就是数据传输的基本单元了。 这个基本单元就是建立在。 我们刚才说的一位模型上的。 并且这个基本单元啊什么时候开始移位。 是上正线移位还是下降沿移位。 spi并没有限定时哈。 给他我们可以配置的选择。 这样的话spi就给兼容更多的芯片。 那在这里s p i有两个可以配置到位。 分别叫做cp o l时钟极性和cp h a时钟相位。 每一位可以配置为一或零。 总共组合起来就有模式。 零模式一模式二模式三这四种模式。 当然模式虽然多。 但是它们的功能都是一样的。 在实际使用的时候。 我们主要学习其中一种就可以了哈。 剩下的模式你知道有这些东西可以配置。 如果到时候真的需要用。 再过来了解一下就行了。 那么先看一下模式一哈。 因为这个模式和我们刚才讲的一位模型。 是对应的。 我们看一下这个时序的基本功能。 是交换一个字节。 也就是刚在这里我们展示的现象。 这里cp o l等于零。 表示空闲状态时。 sc k为低电平。 下面可以看到在s s未被选中时啊。 s t k默认是低电平的。 然后c p h a等于一。 表示s c k第一个边缘移除数据。 第二个边缘移入数据。 但这句话也有不同的描述方式啊。 有的地方写的是c p h a等于一。 表示s c k的第二个边缘进行数据采样。 或者是s c k的偶数边缘进行数据采样。 这些不同的描述意思都是一样。 我这里为了照应刚才的一位模型哈。 我就写的是sk第一个边缘移除数据。 第二个边缘移入数据。 来看一下下面的时序图。 第一个ss重新选择。 在通信开始前。 s为高电平。 在通信过程中s始终保持低电平。 通信结束s恢复高电平。 这是s s信号。 然后最下面一个m s o啊。 这是主机输入重击输出。 刚才说了哈。 这里因为有多个重击输出连在了一起。 如果同时开启输出会造成冲突。 所以我们的解决方法是在s未被选中的状态。 重击的m i s o硬件必须关断输出。 即配置输出为高阻状态。 那在这里s高电平时m s用一条中间的线哈。 表示高阻态。 s下降沿之后。 重击的m s o被允许开启输出。 s s上证眼之后呢。 重击的m s o必须自回高阻态。 这是这一块的设计啊。 然后我们看一下一位传输的操作。 因为c p h a等于1s k第一个边缘移除数据。 所以这里可以看出来。 s k第一个边缘就是上升沿。 主机和从机同时移除数据。 主机通过m o s i移出最高位。 此时moi 3 i的电瓶。 就表示了主机要发送数据的b7。 重新通过m s o移出最高位。 此时m s o表示重击要发送数据的b7。 然后时钟运行产生下降眼。 此时主机和重击同时移动数据。 也就是进行数据采样。 这里主机移除的必须进入重击移位。 进入期的最低位。 重击移速的b7。 进入主机移位经期的最低位。 这样一个时钟脉冲产生完毕。 一个数据位传输完毕。 接下来就是同样的过程啊。 上层岩主机和从机同时输出。 当前一位进入器的最高位。 第二次的最高位就是原始数据的b6 对吧。 然后下降眼主机和从机移动数据b6。 传输完成之后。 始终继续运行。 数据依次移出移入移出移入最后一个下降。 沿数据b0 传输完成。 至此主机和重击就完成了一个字节的数据交换。 如果主机只想交换一个字节。 那这时候就可以自s为高电平结束通信了。 在s s的上升眼m o s i还可以再变化一次。 将m si制造一个默认的高电平或低电平。 当然也可以不去管它。 因为pi没有硬性规定mosi的默认点名。 然后ms so统计必须得自回高组态。 此时如果主机的m o为上拉输入的话。 那m soo引脚的电平就是默认的高电平。 如果主机mi so为浮空输入。 那m so引脚的电平不确定。 这是交换一个字节就结束了流程。 那如果主机还想继续交换之前呢。 在此时主机就不必把s s自回高电平台。 直接重复一下。 从这里到这里交换一个字节的时序。 这样就可以交换多个字节了。 就是s p i传输数据的流程。 是不是和我们之前这里演示的一位流程。 是对应的。 之后我们继续看一下模式零。 这个模式零和模式一的区别哈。 就是模式零的cp h a等于零。 模式一的cph a等于一在时序上的区别。 对比一下。 就这个模式零的数据一出一入的时机哈。 会提前半个时钟。 也要是相位提前了。 我们看一下模式。 零cpa等于零。 表示s k第一个边缘移入数据。 第二个边缘移除数据。 模式林在s c k第一个边缘就要移入数据。 但数据总得先移出才能移入对吧。 所以在模式零的配置下。 sk第一个边缘之前就要提前开始移除数据了。 或者把它称作是在第零个边缘移出。 在第一个边缘移入。 看一下时序。 首先ss下降沿开始通信。 现在s c k还没有变化。 但是s c k一旦开始变化。 就要移入数据了。 所以此时趁s c k还没有变化。 s下降原时就要立刻出发一位输出。 所以这里msi和m s的输出啊。 是对齐到s的下降沿的。 或者说这里把ss的下降眼。 也当作始终的一部分了哈。 那s s下降沿触发的输出。 s c k上单眼就可以采样输入数据了。 这样b7 就传输完毕之后。 sk下降沿移出b6。 sk上单眼移入b6。 然后继续下降沿移除数据。 上升沿移入数据。 最终在第八个上升沿时。 b0 位移入完成整个字节交换完成之后。 s ca还有一个下降沿。 如果主机只需要交换一个字节就结束。 那在这个下降沿时。 mosi可以自回默认电瓶或者不去管它。 m s o也会变化一次。 这一位实际上是下一个字节的b7 哈。 因为这个相位提前了。 所以下一个字节的b7 会露个头。 如果不需要的话。 s上证线之后重击m so自回高阻态。 这是交换一个字节就结束。 如果主机想交换多个字节的话。 那就继续调用从这里到这里的时区。 在最后一个下降。 沿主机放下一个字节的b7。 重击也放下一个字节的b7 sc可以上升演。 正好接着采用第二个字节的b c。 这样时序才能拼接得上对吧。 就是s p i交换一个字节模式零。 模式零和模式一的区别就在于。 模式零把这个数据变化的时机给提前了。 在实际应用中啊。 模式零的应用是最多的。 所以我们重点掌握模式零即可。 我们等会的讲解和后续的程序啊。 都是基于spi模式零来讲解的。 不过这里我感觉模式一是不是更符合常理啊。 但实际确实是模式零用的最多。 可能是s p i设计的时候。 为了兼容现存设备吧。 或者是模式林在实际应用时确实有什么优势。 或者因为模式零排在最前面。 大家都默认最前面的模式吗。 这个原因大家感兴趣的话可以调研一下哈。 这是模式零和模式一。 那了解完模式零和模式一。 下面的模式二和模式三就非常简单了。 其中模式零和模式二的区别就是。 模式零的c p u l等于零。 模式二的cp l等于一。 两者的波形就是sk的即兴取反一下。 剩下的流程上的东西啊完全一致。 然后模式一和模式三的区别也是。 模式一的cpu等于零。 模式三的cpu等于一。 两者的波形也是sk的即兴取反一下。 其他地方没有变化。 这是这四种模式。 然后最后提醒一下哈。 这个cp h a表示的是始终相位。 决定是第一个时钟采样移入。 还是第二个时钟采样移入。 并不是规定上升沿采样还是下降沿采样的。 当然在c p u l确定的情况下。 cp g a确实会改变采样时刻的上升沿和下降沿。 比如模式林的时候是sk上升沿。 采样一入模式一的时候是s k下降沿采样一路。 这个了解一下cpa j a决定是第几个边缘采样。 并不能单独决定是上升沿还是下降沿。 然后在这四种模式里啊。 模特林和模式三都是s k上升原材呀。 模式一和模式二都是s k下降沿采样。 这是时序基本单元哈。 我们就讲完了。 那最后就是看几个pi完整的时序波形。 当每个芯片对spi时序。 字节流功能的定义不一样。 在这里我是以我们本节课使用的芯片。 w25 q64。 它的时序为例。 经讲价。 spi对自己聊功能的规定。 不像iphone c来讲。 fc的规定一般是有效数据流。 第一个字节是计容器地址。 之后依次是读写的数据。 使用的是读写计算器的模型啊。 而在spi中。 通常采用的是指令码加读写数据的模型。 这个过程就是啊spi起始后。 第一个交换发送给重击的数据一般叫做指令嘛。 在从句中对应的会定义一个指令集。 当我们需要发送什么指令时。 就可以在起始后。 第一个之间发送指令集里面的数据。 这样就能知道统计完成相应的功能了。 不同的指令可以有不同的数据个数。 有的指令只需要一个字节的指令码就可以完成。 比如w5 k64 的写实能写诗能等指零。 而有的指令后面就需要再跟要读写的数据。 比如w5 q4 的写数据。 读数据等。 写数据指令后面就得跟上。 我要在哪里写。 我要写什么对吧。 读数据指令后面就得跟上。 我要在哪里读。 我读到的是什么。 对吧。 这是指令码加读写数据的模型。 在spi统计的芯片手册里都会定义好指令集。 什么指令对应什么功能。 什么指令后面得跟上什么数据这些内容啊。 等我们下一小节学习芯片的时候再具体分析。 那这里我简单的抓了几个指令的波形。 我们先来看一下这些波形是什么样的。 首先是s spi发送指令。 这个时序的功能是向s s指定的设备发送指令。 0x06。 指令0x06 到底是什么意思呢。 可以由芯片厂商自己规定。 在w25 q64 型面里。 这个0x06 代表的是斜视。 能我们看一下这个模型。 在这里我们使用的是spi模式。 零在空闲状态是s s为高电平。 s c k为低电平。 m o s i和m s的默认电平没有严格规定。 然后ss产生下降沿持续开始。 在这个下降沿时刻。 msi和mi so就要开始变换数据了。 msi由于指令码最高位仍然是零。 所以这里保持低电平不变啊。 m s o重庆现在没有数据发给主机。 营销电瓶没有变化。 实际上w5 k64 不需要回弹。 数据时手册里规定的是m so仍然是告诉他重击。 并没有开启输出啊。 不过这也没问题。 反正这个数据我们也不要看。 那这里因为s t m32 的m so是上拉输入。 所以这里mo呈现高电平之后。 s c k第一个上升沿进行数据采样。 我这里画了一条绿线哈。 从机采样输入得到零。 主机采样收入得到一之后继续第二个时钟。 主机数据仍然是零。 所以波形仍然没有变化。 然后这样一位一位的发送接收。 发送接收到这一位数据才开始变化。 主机要发送数据一下降点数据移出。 主机将一移出到m o s i。 m o s i变为高电平。 这里因为是软件模拟的时序啊。 所以m o s i的数据变化有些延迟。 没有紧贴s c k的下降沿哈。 不过这也没关系。 始终是主机控制的。 我们只要在下一个hk上升沿之前。 完成变化就行了。 然后sc跟上单眼数据采样输入在最后一位呢。 下降沿数据变化msi变为零。 上证言数据采样统计。 接收数据0s j k低电平是变化的时期。 高电平是读取的时期。 这一块是不是和fc差不多啊。 那时序sk最后一个上传言结束。 一个字节就交换完毕了。 因为写死人是单独的指令。 不需要跟随数据啊。 spi只需要交换一个字节就完事了。 所以最后在s k下降点之后。 s自回高电平结束通信。 那这个交换我们统计一下。 m o s i和m s o的电瓶。 总结一下。 就是主机用0x06 换来了重击的0x f f。 但实际上统计并没有输出啊。 这个0x f f是默认的高电平。 不过这个0x f f没有意义哈。 我们不用管。 那整个时序的功能就是发送指令。 指令码是0x06。 统计一笔对事先定义好的指令集。 发现0x06 是写死人的指令。 那重击就会控制硬件进行写死。 能这样一个指令从发送到执行就完成了。 就是发送单字节指令的时序。 最后看下一个。 我们再看一条指令。 这条指令是指定地址。 写功能是像s s指令的设备。 先发送鞋指令。 写指令在指定集中还规定是0x02。 随后在指定地址下写入指定数据。 因为我们这个w5 q64 芯片。 有八兆字节的存储空间。 一个字节的八位地址肯定不够。 所以这里地址是24位的啊。 分三个字节传输。 我们看一下时序。 首先s s下降沿开始时去这里。 m o s i空闲时是高电平。 所以在下降沿之后。 s c k第一个时钟之前可以看到啊。 m o s i变换数据由高电平变为低电平。 然后sk上针眼数据采样输入后面还是一样哈。 下降沿变换数据上升沿采样数据。 八个时钟之后。 一个字节交换完成。 我们用0x02 换来了0x f f。 其中发送的0x02 啊是一条指令。 代表这是一个写数据的时序。 接收到0x f f不需要看啊。 那既然是写数据的时序。 后面必然还要跟着写的地址和数据啦。 所以在最后一个下降沿时刻。 因为我们后续还需要继续交换字节。 所以在这个下降沿。 我们要把下一个字节的最高位放到msi上。 当然下一个字节的最高位仍然是零啊。 所以这里数据没有变化。 最后还是同样的流程交换一个字节。 第二个字节我们用0x12 换来了0x f f。 根据w25 q64 芯片的规定呢。 写指令之后的字节定义为地址高位。 所以这个0x12 就表示发送地址的。 23~16位周。 继续啊。 看一下交换一个字节。 发送的是0x34。 这个就表示发送地址的15~8位。 最后还是交换一个直接发送的是0x56。 这个表示发送地址的7~0位。 通过三个字节的交换。 24位的地址就发送完毕了。 统计收到的24位地址是0x123456。 那三位地址结束后。 就要发送写入指定地址的内容了。 我们继续调用交换一个字节发送数据。 这里的波形是0x55。 这个表示我要在0x123456 地址下。 写入0x55 这个数据。 最后如果只想写出一个数据的话。 就可以s至高电平结束统计了。 当然这里也可以继续发送数据。 sbi里也会有和i放在一样的地址指针哈。 每读写一个字节。 地址指针自动加一。 如果发送一个字节之后不终止继续发声的字节。 就会依次写入到后续的存储空间里。 这样就可以实现从指定地址开始。 写入多个字节了。 这就是s spi写入的时序。 由于s p i没有应答机制海。 所以交换一个字节后。 就立刻交换下一个字节就行了。 然后这条指令我们还可以看出啊。 由于整个流程我们只需要发送的功能。 并没有接收的需求哈。 所以mo这条接收的线路就始终处于挂机的状态。 我们并没有用到。 当然不同的芯片肯定有不同的规定啦。 我们这个存储器的容量大。 所以需要连续制定三个字节的地址。 如果容量小的话。 可能一个字节的地址就够了。 或者有的芯片会直接把地址融合到指令码里去。 这也是可以的哈。 至于具体怎么操作的。 还是得仔细分析一下手册。 那这个时序我们就看到这里。 接着下一个时区。 这个是指定就是读功能。 是向s指定的设备先发送读指令。 这里芯片定义0x03 为独子零。 随后在指定地址下读取统计数据。 我们看一下实际。 持续的玩法和支线都一样哈。 我们主要看一下这里交换的数据。 其次之后第一个字节主机发送指令。 0x03 表示我要读取数据了。 最后还是一样。 主机在一次交换三个字节。 分别是0x120 x34。 0x56。 组合到一起就是0x12。 3456代表24位地址。 最后这个地方就是关键点儿。 因为我们是读取数据。 指定地址之后。 显然我们就要开始接收数据啊。 所以这里三个字节的地址交换完之后。 我们要把重击的数据搞过来。 怎么搞过来呢。 我们还是交换一个数据。 来个抛砖引玉。 我们随便给重击一个数据。 但一般给f f就行了。 然后统计此时不传更待合适啊。 这次重击就会乖乖的把0x123456。 地址下的数据通过m s o发给主机。 可以看到这样的波形。 就表示紫晶地址下的数据是0x55。 这样主机就实现了指定地址读一个字节的目的。 然后如果我们继续抛砖引玉。 那么重机内部的地址指针自动加一。 从机械会继续把指定地址。 下一个位置的数据发过来。 这样依次进行。 就可以实现指定地址接收多个字节的目的了。 然后最后数据传输完毕。 s自回高电平持续结束。 当然时序这里也会有些细节哈。 比如由于m soo是硬件控制的波形。 所以它的数据变化都可以紧贴始终的下降沿哈。 另外我们可以看到m s o数据的最高位。 实际上是在上一个之间。 最后一个下降沿提前发生的。 因为这是spi模式零。 所以数据变化都要提前半个周期好。 那这就是w5 q64 规定的读时序了。 当然芯片还规定了很多其他功能的时序哈。 这个我们下小节再来分析。 不过再多的时序。 它们的格式都是大同小异。 都是起始交换交换交换停止。 我们只需要关注一下每个字节的功能定义。 就能很方便地利用spi控制设备了。 好了。 以上就是本小节的全部内容了。 我们本小节讲的是spi协议的软硬件规定。 并且也提前介绍了几个。 w25 q64 的指令和时序。 那我们下小节就来学习。 w25 q64 这个芯片的知识点。 它是如何存储数据的。 它总共有哪些指令。 以及如何利用ph读写数据。 那我们下下节再见。
37. 大家好。 欢迎回来。 本小节我们继续来学习spi通信。 这次我们学习的是使用了s spi通信的。 芯片之1w25 q64。 等一下简单安排呢。 首先我们还是先看一下ppt。 这里我用几张ppt整体的介绍一下这个芯片。 看完这个整体的介绍。 相信你对这个芯片就有了大致的印象了。 之后我们还是过一遍手册。 把里面的一些重点和细节问题再给大家讲一下。 这样再和上一小节spi的知识点结合起来。 我们就可以开始写程序来读写这个芯片了。 好那我们先看一下这里w5 k64 的简介部分。 第一条w5 q叉叉系列是一种低成本小型化。 使用简单的非易失性存储器。 这里w5 q叉叉系列呢包含了多种型号。 其中这个叉叉是一个数字。 比如下面写的4080163264等等。 不同的数字表示了这个芯片不同的存储容量。 同一个系列的这些不同型号。 它们的操作方法都是一样的。 只是容量不同而已。 那我们本套件使用的是w5 q64 这个型号。 它的容量是64兆beat。 也就是八兆bt。 如果你觉得这个容量太大了呢。 也可以换成w q3216 等等。 更换之后。 我们的硬件电路和底层驱动程序都不需要更改。 所以我们学会了其中一个型号。 在应用同系列的其他型号就很容易上手了。 然后我们继续看这个w5 q系列。 是一种低成本小型化。 使用简单的存储器。 低成本。 也就是说这个芯片一般也就几块钱。 它能提供的存储容量哈。 这里可以看出一般在造币的级别。 这个容量级别在手机电脑领域啊是很小的。 但在嵌入式领域还是非常大的。 但是之前我们五一单片机。 还学过一款比较经典的存储芯片。 就是a t20 c02。 它的容量一般是kb级别的。 那当然相比之下a t2 是c系列的芯片。 就更便宜一些了。 然后小型化。 这个大家都能看出来啊。 他就是这样一个八角的小芯片。 在电路板中比较省空间哈。 然后使用简单。 这就靠的是spi协议的设计了。 这个芯片是使用的spi串行通信。 通信引脚比较少。 协议也很简单。 那这个芯片的硬件接线也不麻烦啊。 就v c c建立计量电。 剩下的全都可以接gp i o。 基本不需要其他电路。 就是这个芯片的使用还是比较简单的。 那最后我们还可以看出来。 这个芯片是一种非易失性存储器。 存储器分为意识性存储器和非意识性存储器。 意识性存储器啊。 一般就是sram d ram等非意识性存储器。 一般就是一fp flash等。 他们最主要的区别啊。 简而言之就是存储的数据是否是掉电不丢失。 那非一次性存储器呢。 就是数据不容易失去的存储器。 由是数据掉电不丢失啊。 所以存储在这个芯片里的数据。 在断电重启后。 数据仍然保持原样。 既然数据是掉电不丢失的。 那你就可以根据这个特性来做一些应用了是吧。 比如说常应用于数据存储。 比如你s t m32 有些参数啊。 或者采集的数据想要掉电不丢失的保存。 那就可以写入到这个芯片里来。 然后智库存储这个可以应用到一些显示屏上啊。 比如我们这个o o i d显示屏或者lcd液晶屏。 你如果想在屏幕上显示汉字。 就得把汉字的点阵数据存起来哈。 当然简单的方法是。 把字库直接存在s t m32 内部。 这样适合少量汉字显示的情况。 如果汉字非常多。 再直接存在s t m32 中就不合适了。 所以我们可以用这个芯片来存储汉字。 字库的点阵数据。 在显示某个焊之前。 先读取芯片查询智库。 再在显示屏上显示对应的点阵数据。 然后固件程序存储。 这个就相当于直接把程序文件。 下载到外挂芯片里。 需要执行程序的时候啊。 直接读取外挂芯片的程序文件来执行。 这就是xp就地执行啊。 比如我们电脑里的b l o s固件。 就可以存储在这个w5 q系列的芯片里。 好这些就是这个芯片的特性和用途了。 当然我们本节只使用它。 最简单的数据存储功能哈。 那接着看下一家这个芯片的存储介质是loflash。 flash。 就是闪存存储器哈。 像我们s t m32 的程序存储器。 u盘。 电脑里的固态硬盘等使用的都是flash闪存。 闪存分为loflash和land flash。 两者各有优势和劣势哈。 适用领域不同。 这个感兴趣的话可以百度了解一下。 我就不展开说了。 大家知道我们这个芯片是loflash。 即可走下一条时钟频率。 我们这个芯片使用的是spi通信。 其中s p i的s c k线啊。 就是时钟线。 这个时钟线的最大频率是80兆赫兹。 这个频率相比较s t m32 是非常快的哈。 所以我们在写程序的时候。 翻转引脚就不用再加延时了。 即使不延时。 这个gpl的翻转频率。 也不可能达到80兆赫兹哈。 所以可以放心使用。 然后后面这还有两个频率。 分别是160兆赫兹。 括号这个是双重spi模式等效的频率。 320兆赫兹。 这个是四重sp模式等效的频率。 这个双重s p i和四重s p i。 大家了解一下即可啊。 我们本课程不会用到。 那他们是什么意思呢。 就是我们之前说的m o s i用于发送。 m o用于接收。 是全双工通信哈。 在只发或只收时有资源浪费。 但是这个w5 q芯片的厂商不忍心浪费啊。 所以就对s p i做出了一些改进。 就是我在发的时候。 我可以同时用m o s i和m s发送。 在搜的时候也可以同时用msi和m s接收。 msi和mi so同时兼具发送和接收的功能。 一个sc k中我同时发送或接收两位数据。 就是双重sp i模式啊。 那你一个时钟收发两位相比较。 一位一位的普通s p i数据传输率就是二倍了。 所以这里写的是在双重s p i模式下。 等效的时钟频率就是80兆赫兹的二倍。 就是160兆赫兹。 但实际上是这个频率哈。 最大还是80兆赫兹。 只是我一个时钟发两位而已哈。 然后四种sp i模式。 很显然就是一个始终发送或接收四位的。 等效的频率。 就是80x4=320兆赫兹。 在我们这个芯片里啊。 除了s spi通信硬件。 还有两个硬件。 一个是wp写保护。 另一个是厚的。 这两个硬件如果不需要的话。 也可以拉过来充当数据传输硬件。 加上msi和m s这个可以四个数据位同时收发了。 就是四重s p i。 其实这就有点并行传输的意思了哈。 串行是根据时钟一位一位的发送。 并行是一个时钟八位同时发送。 所以这个四寸spi模式。 其实就是四位并行的模式哈。 这个大概了解一下就行。 我们暂时用不到。 那最后我们来看一下。 不同型号对应的存储容量哈。 w5 q系列总共有这么多型号。 其中w5 q40 是四兆比特。 也就是四兆这么多的二进制位。 当然总量哈我们习惯以字节为单位。 一个字节对应八个二进制位。 所以它的实际容量是四兆b除八。 等于512k bet。 也就是512kb啊。 然后下面八零就是八兆比特。 除8=1兆bt。 下面16 3264128256就是16兆。 32兆六四兆。 128兆。 256兆单位都是beat哈。 对应到常用的已字节的单位就是都除八。 所以这个型号后面的数值啊。 除八就是存储容量。 当然这个四零和八零是例外哈。 得看成零四和零八。 这样才对。 然后这里括号写的是这个芯片。 使用的是24位的地址。 24位地址是三个字节啊。 因为我们在进行读写的时候。 肯定得把每个字节都分配一个地址。 这样才能找到它们对吧。 上小节讲时序的时候也提到过哈。 这里在指定地址时需要一次性指定三个字节。 24位的地址。 然后我们可以用计算器算一下。 24位的地址最大能分配多少个字节呢。 这里二的24次方等于这么多个字节数啊。 那除1024。 等于这么多kb。 再除1024=16兆b。 所以24位地址的最大寻址空间是16兆b。 那ppt中啊w5 q40 到q128。 使用三字节24位的地址都是足够的。 但是这个w5 q256 就比较尴尬了。 24位地址对于32兆b来说是不够的。 所以这最后一个型号比较特殊哈。 根据手册里描述。 w5 q256 分为三字节。 地质模式和四字节地址模式。 在三字节地址模式下。 只能读写前16兆b的数据。 后面16兆b3 个字节的地址够不着。 要想读写到所有存储单元。 可以进入四字节地址的模式。 这样就行了。 所以如果你需要使用w5 q256 这个信号。 要注意一下这个问题。 好到这里。 我们这个w5 q系列芯片的简介就讲完了。 接下来我们就来看一下这个芯片的硬件电路啊。 当我们拿到这个八角的芯片后。 怎么把它和s t m32 连接在一起呢。 我们看一下。 左边这个图是我们这个小模块的原理图啊。 右上角这个图就是这个芯片的引脚定义。 右下角这个表就是每个引脚定义的功能呢。 首先看一下引脚定义哈。 八角vs c4 角尖d。 这里是电源供电。 影角供电电压是2.7~3.6。 是一个典型的3.3伏供电设备啊。 不能直接接入5伏电压。 然后1号叫cs。 这个cs左边画了个斜杠。 代表是低电平有效哈。 或者这边cs上面画了个横线。 也是低电平有效。 那这里cs对应之前我们讲s spi的名称就是s。 意思是spi的片选引脚哈。 然后6号角c l k对应就是s c k。 是s spi的时钟线。 然后5号di对应m o s i是s p i。 主机输出统计输入。 2号d o对应mo是s p i主机输入重击输出。 这四个硬件就是s spi通信的四个硬件。 应该好理解。 然后这个芯片还有两个引脚。 3号wp。 他的意思是写保护配合内部的计容器配置哈。 可以实现硬件的协保护。 写保护低电平有效。 wp接低电平保护住。 不让写。 wp接高电平不保护可以写哈。 最后其二后的意思就是数据保持哈。 低电平有效。 这个用的不多哈。 了解一下。 就是如果你在进行正常读写时突然产生中断。 然后想用spi通信线去操控其他细节。 这时如果把cs自回高电平。 那时序就终止。 但如果你又不想终止总线。 又想操作其他细节。 这个可以厚的银价至低电平。 这样芯片就hold住了。 芯片释放总线。 但是芯片时序也不会终止。 它会记住当前的状态。 当你操作完其他器件时。 可以回过来哈。 后的自回高电平。 然后继续后者之前的死去。 相当于s spi总线进来一次中断啊。 并且在中断里还可以用s p i干别的事情。 这就是厚德的功能。 然后最后我们注意到这个d i。 d o w p和后的旁边都有括号。 写了l0 l1 l2 l3。 这个就对应我们刚才这里说的双重sp和四重p。 如果是普通的spi模式啊。 那括号里的都不用看。 如果是双重s p a。 那di和dio就变成i o0 和io 1。 也就是数据同时收和同时发的两个数据位。 如果是四种s b i。 那就再加上wp当做l2 后的当做l o3。 这四个硬件都作为数据首发硬件。 一个时钟。 四个数据位哈。 这个了解一下即可。 我们暂时不用好。 那这些就是芯片的所有引脚功能。 定义了之后。 看一下模块原理图。 这个u一就是w q叉叉的芯片。 g一是一个六角的牌真。 然后芯片的vcc电源正极啊。 通过vcc引脚标号接到排针6号角芯片。 gd电源负极。 通过gd编号接到排针3号角。 然后芯片spi通信的四个角。 就直接通过排针引出来就行了。 之后厚的和w p这两个都是直接接到的vcc呀。 低电平有效。 那都接到v c c就这两个功能啊。 我们都不用。 然后这个c一直接接到vcc和jd。 显然是一个电源滤波。 r一和d一也是直接接到vcc和jd。 显然是一个电源指示灯。 通电就亮。 那这些就是这个芯片的硬件电路了。 接线整体上也是非常的简洁哈。 vc界见地接3.3伏电源。 spi通信线。 直接接到s t m32 的s spi通信引脚。 hold和w p需要用的话。 就接到s t m32 的g p l o不需要用。 就直接接v c c。 然后电源指示灯和电源滤波哈。 这些都看需求加就行。 就是硬件接线。 那硬件电路看完。 我们再看一下w5 q64 的框图。 这个框图啊。 其实每个芯片都有哈。 也是我们理解每个芯片最直观的方式。 所以框图需要我们仔细分析。 我们看一下。 首先右上角这一大块。 描述的是存储器的规划示意图。 我们这个w q64 啊。 容量是八兆b。 如果不进行划分。 而只按照一整块来使用的话。 那这一整块的容量就太大了。 不利于管理。 而且后续哈我们设计的flash插图或者写入的时候。 都会有个基本单元。 我们得以这个基本单元为单位进行。 所以这里这一整块大蛋糕。 八兆b的存储空间。 就有必要进行一些合理的划分哈。 那常见的划分方式就是一整块存储空间。 先划分为若干的块block。 其中每一块在划分为若干的扇区。 赛克者。 对于每个扇区内部又可以分成很多页儿配给。 那我们看一下w5 q64 是怎么划分的呢。 首先这一整个矩形空间里是所有的存储器。 存储器以字节为单位。 每个字节都有唯一的地址。 这样说了哈。 w k64 的地址宽度是24位三个字节。 所以可以看到左下角第一个字节。 它的地址是000000h。 h代表16进制之后的空间地址依次自增。 直到最后一个字节。 地址是7f f f f f a区。 那最后一个字节为啥是7f开头。 不是f f开头呢。 因为24位地址最大寻址范围是16兆比。 我们这个芯片只有八兆比。 所以地址空间哈我们只用了一半八兆b的空间。 排到最后一个字节。 就是7f f f f f啊。 那这是整个地址空间。 从000000~7f f f f f。 然后在这整个空间里。 我们以64kb为一个基本单元。 把它划分为若干的块block。 从前往后依次是快零快一快二等等等等。 一直分到最后一块。 那整块蛋糕是八兆比。 以64kb为一块进行划分。 最后分得的快速呢就是八兆b除64k比。 可以计算器算一下。 八兆b乘1024=8192 k b啊。 除以64=128。 所以这里可以分得128块哈。 那块序号就是块零。 一直到最后一个是块127。 然后观察一下块内地址值的变化规律啊。 比如跨年的起始地址是000000。 结束地址是00f f f f之后快31。 其实是1f0000。 结束时1f f f f f之后的都观察一下。 可以发现在每一块内。 它的地址变化范围就是最低的两个字节。 每个块的其次地址是叉叉0000。 结束指叉叉f f f f。 这是块内地址的变化规律哈。 了解一下。 好到这里。 这一块大蛋糕我们就分好块的64kb为一块。 总共128块。 最后看一下左边这个示意图。 就是啊我们还要再对每一块进行更细的划分。 分为多个扇区sector。 这里的虚线看到没指向了右边的各个块。 也就是告诉你啊。 每一块里面都是这个样子的。 我们看一下。 那在每个块里。 它的起始地址是叉叉0000。 结束地址是叉叉f f f f在一块的。 我们在以4k b为一个单元进行切分。 一块是64kb。 我四kb一切总共欠了多少份呢。 就是64kb除四kb等于16分。 所以在每一块里啊。 都可以分为扇区零一直到扇区15。 观察一下地址规律啊。 可以发现每个扇区内的地址范围是叉叉叉。 000到叉叉叉f f f。 当然地址划分啊到扇区就结束了。 但是当我们在写入数据时啊。 还会有个更细的划分。 就是year配集。 也是对整个存储空间划分的哈。 当然你也可以把它看作在扇区里再进行划分。 都一样。 那页的大小呢是256个字节。 一个扇区是四kb。 以256个字节划分能分得多少分呢。 我们算一下。 4k b乘以1024=4096之间。 再除256=16页。 所以一个扇区里啊可以分为16页。 然后页的地址规律呢我们也看一下。 在这里哈每一行就是一页。 左边这里指了个箭头。 写的是页地址的开始。 右边这里也是两个箭头。 写的是叶电子的结束。 在一页中。 地址变化范围是叉叉叉叉零零到叉叉。 叉叉f f一类的地质变化哈。 仅限于地址的最低一个字节好。 这就是页的划分。 那这个存储器的地址划分啊。 我就讲完了。 这些划分的具体值大家可以不用来记哈。 但是我们需要记住的是一整个存储空间。 首先划分为若干块。 对于每一块又划分为若干扇区。 然后对于整个空间哈会划分为很多很多页。 每页256字节。 这个我们需要记住。 后面还会用到哈。 好然后我们来看左边左下角。 这是spi控制逻辑。 由是芯片内部进行地址锁存。 数据读写等操作。 都可以由控制逻辑来自动完成。 这个不用我们操心。 控制逻辑就是整个芯片的管理员。 我们有什么事只需要告诉这个管理员就行了。 然后控制逻辑左边就是s spi的通信硬件。 有wp后的c l k c s d n和d o。 这些硬件就和我们的主控芯片相连。 主控芯片通过spi协议。 把指令和数据发给控制逻辑。 控制逻辑就会自动去操作内部电路。 来完成我们想要的功能。 然后去看控制逻辑上面有个状态计算器。 这个状态计算器是比较重要的哈。 比如芯片是否处于盲状态。 是否写死能。 是否写保护。 都可以在这个状态进入器里体现。 这个我们等会看手册的时候再来分析。 然后上面是写控制逻辑和外部的wp引脚相连。 显然这个是配合wp硬件实现硬件写保护的。 然后继续右边。 这里是一个高电压生成器。 这个是配合flash进行编程的哈。 因为flash是掉电不丢失的。 如何实现掉电不丢失呢。 比如你点亮一个led表示一熄灭。 led表示零。 但如果整个系统电都没有。 那一和零就无从说起了。 所以要想掉电不丢失。 就让我们在存储器里产生一些刻骨铭心的变化。 比如一个led我给他加很高的电压。 那led就烧坏了。 我们用烧坏的led表示一为烧坏的led表示零。 然后再断电。 烧坏的led还是烧坏的。 有电没电它都是坏的。 这个烧煤烧坏的状态。 不受有电还是没电的影响啊。 所以它就是掉电不丢失。 那对于我们的非易失性存储器来说也是一样。 我们要让它产生即使断电也不会消失的状态。 一般都需要一个比较高的电压去刺激它。 所以这种掉电不丢失的存储器。 一般都需要一个高压源。 那这里芯片内部集成了高电压发生器。 所以就不需要我们在外接高电压了。 比较方便哈。 当然我这里只是举例。 简单描述一下掉电不丢失的存储原理啊。 至于flash的原理。 大家可以在例行研究。 然后继续看下面。 这里是e地址锁存计数器。 然后下面还有一个字节地址锁存计数器。 这两个地址锁存和记录器就是用来指定地址的。 我们通过spi总共发过来三个字节的地址。 因为一页是256字节啊。 所以一页内的字节地址就取决于最低一个字节。 而高位的两个字节就对应的是液体质。 所以在这里我们发的三个字节地址。 前两个字节会进到这个页地址所能进入系里。 最后一个字节会进到这个字节地址所成。 技术虚拟。 然后页地址通过这个写保护和行解码来选择。 我要操作哪一页。 字节地址。 通过这个链解码和256字节页缓存。 来进行指定地址的读写操作。 那就因为我们这个地址所存啊。 都是有个计数器的。 所以这个地址指针哈在读写之后可以自动加一。 这样就可以很容易实现从指定地址开始。 连续读写多个字节的目的了。 那最后右边。 这里有个256字节的液缓存区。 它其实是一个256字节的ram存储器啊。 这个稍微留个印象。 等会儿还会提到。 然后我们数据读写啊。 就是通过这个ram缓冲区域来进行的。 我们写入数据会先放到缓存区里。 然后在持续结束后啊。 芯片再将缓冲区的数据复制到对应的fly系列。 进行永久保存。 那为啥要弄个缓冲区呢。 我们直接往flash里写不好吗。 那这是因为哈。 我们的spi写入的频率是非常高的。 而flash的写入由于需要掉电不丢失。 留下刻骨铭心的印象。 他就比较慢。 所以这个芯片的设计思路就是你写入的数据啊。 我先放在一换成具体存在。 因为缓冲区是ram。 所以它的速度非常快啊。 可以跟得上s spi总线的速度。 但这里有个小问题啊。 就这个缓冲区只有256字节。 所以写入的时序有个限制条件。 就是写入了一个时序。 连续写入的数据量不能超过256字节。 然后等你写完了。 我芯片。 再慢慢的把数据从缓冲区转移到flash存储器里。 那么数据从缓存区转到flash里。 需要一定的时间哈。 所以在写入时序结束后。 芯片会进入一段忙的状态。 在这里它就会有一条线哈。 通过状态寄存器给状态接容器的busy位置。 一表示芯片当前正在搬砖呢。 很忙。 那在忙的时候。 芯片就不会响应新的读写时序了哈。 就是写入的执行流程。 然后我们读取数据呢。 虽然这里画的话应该也是会通过缓冲区来读句。 但是由于读取只看一下电路的状态就行了。 它基本不花时间。 所以读取的限制就很少了。 速度也非常快。 好了。 到这里我们这个芯片的框图就看完了。 这个框图有几个重点部分。 第一个是这整个flash的空间划分。 会划分为块扇区和叶。 第二个是s p i控制逻辑。 它就是整个芯片的管理员啊。 执行指令读写数据都靠它。 第三个是这个状态净水器。 它和盲状态斜齿轮斜保护等功能有关。 第四个是这个256字节的液缓存。 它会对一次性写入的数据量产生限制。 就是在整个框图。 那ppt的最后我们来看一下flash操作的注意事项。 这里列出了这么多flash写入和读取的要求。 还步骤还是比较繁琐的。 那你可能会有些疑惑哈。 不适合存储器吗。 我直接指丁丁写或者指点点的读。 然后他直接给我把数据存在对应的存储单元里。 不就行了吗。 为啥还要搞这么多的注意事项呢。 其实这是因为flash作为一种掉电不丢失的存储器。 为了保证掉电不丢失这个特性。 同时还要保证存储容量足够大。 成本足够低。 所以flash存储器会在其他地方。 比如操作的便捷性的做出一些妥协和让步。 flash的写入和读取并不像ram那样简单。 直接ram是指哪打哪。 想在哪写就在哪写。 想写多少就写多少。 并且ram是可以覆盖写入的。 比如原来ram里有个数据连x a a之后。 我直接再写入一个新的数据。 0x55。 那rap的数据就变成0x55 了。 这个特性是非常好的。 但是flash并没有这个特性啊。 总之flash的读写有很多要求。 其中写入的要求是非常多的。 需要我们掌握哈。 读取的要求就比较少了。 还是那个原因。 因为读取啊只是看一下电路的状态。 不对电路做出实质性的改变。 所以读取一般都比较快。 而且没有什么限制。 那我们看一下flash写入操作时需要注意些什么呢。 第一点写入操作前必须先进行写死人。 这个是一种保护措施。 防止你误操作的。 就像我们使用手机一样。 先解锁再操作。 这样可以防止手机在你裤兜里到处点点点对吧。 写死人的话。 我们就使用spi发送一个写死人的指令。 就可以完成了。 这个还是比号理解。 然后下一条米格数据位只能由一改写为零。 不能由零改写为一。 这个意思就是说啊。 flash并没有像ram那样的直接完全覆盖改写的能力。 比如在某一个字节的存储单元里面。 存储了0x aa。 这个数据对应的二进制位就是1010。 1010。 如果我直接再次在这个重组单元。 写入一个新的数据。 比如我再次写入一个0x55。 那写完之后。 这个存储单元里存的40x55 吗。 实际上并不是啊。 因为0x55 的二进制是01010101。 当这个01010101要覆盖原来的101。 01010时。 就会受到这里第二条规定的限制。 每个数据位只能由一改写为零。 不能由零改写为一。 你要问为啥会有这个限制。 那只能说是成本原因或者技术原因呢。 所以这里写入01010101之后。 依次来看啊。 最高位由原来的腰改写为零是可以的。 所以写出之后新的最高位就是零。 但是第二位原来是零。 现在我要改写成幺。 这是不行的。 所以写出之后。 新的第二位仍然是零周第三位要改写为零。 可以结果为零。 第四位零该线为腰。 不可以。 结果仍然是零。 那以这个规律进行下去。 0x aa在覆盖写入0x55 之后。 这个存储单元最终的数据是什么啊。 0x00 也就是八位全为零。 这就出现问题了对吧。 我们明明写出了0x55。 但是它实际存储的却是0x00。 这不就出圈了吗。 所以为了弥补这个只能一点。 不能0.1的缺陷。 我们就引出了第三条规定。 就是写入数据前必须先擦除。 擦除后所有数据位变为一。 在这里flash是有一个擦除的概念的哈。 擦除会有专门的擦除电路进行。 我们只要给他发送擦除的指令就行了。 那通过擦除电路擦除之后呢。 所有的数据位都变成一。 哎。 这样。 我们是不是就可以弥补第二条限制的缺陷了。 当我们写出一个数据之前。 无论原来存的是什么。 我直接给它擦除掉。 擦除之后所有的会变成一。 也就是16进制的f f。 这样我无论再写入什么样的数据。 就都可以正确的写入了。 比如0x55。 零呀。 零呀零呀。 零呀。 最高位有腰。 改写为零为零。 第二位写入的是叫虽然不能改写为腰。 但是擦除之后啊。 他原来就已经是妖了。 所以这时写入腰的数据位就不会出错了。 之后也是同理。 一和零都和我们写入的数据是对应的。 写入0x55 之后吧。 数据单元存的就是0x5。 没问题。 那总结一下就是flash中数据位为一的数据。 拥有单项改成零的权利。 一旦改写为零之后。 就不能反悔。 再改写成一了。 要想反悔就必须得先擦除所有的位。 先统一都变成一。 然后再重新来过。 这是flash改写的特性。 和写入数据前必须擦除的原因哈。 如果你说我非不查除。 直接改写。 这样的操作可以执行。 但是存储的数据啊极有可能是错的。 这个读一下。 那拆除之后所有的v变成一。 就是16进制的f f哈。 所以有时候你读取flash会发现数据全是f f。 那就说明这一段有可能是拆除之后。 还没有写入数据的空白空间在flash中啊。 f f代表空白。 而不是零零好。 那这个改写和擦除的注意事项我们就了解了。 接下来下一条擦除必须按最小拆除单元进行。 这个应该也是为了成本而做出的妥协。 就是说你写入前要进行擦除嘛。 这我知道。 所以如果我想在零零这个地址下写入数据。 那我就先把零零粒子擦除。 再写入数据到零零粒子不就行了吗。 但是这个方案有个问题啊。 flash的擦除有最小擦除单元的限制。 你不能指定某一个直接去擦除。 要擦就得一大片一起查。 一大片是多大一片呢。 那在我们这个芯片里啊。 你可以选择整个芯片大叔。 也可以选择按块擦除或者按扇区擦除。 然后再小就没有了。 所以最小的插组单元啊就是一个扇区。 刚才我们看了一个扇区是四kb。 就4096个字节。 所以你擦除最少就得4096个字节一起擦。 那你说我只想查出某一个字节怎么办呢。 这没办法。 你只能把那个字节所在扇区的。 4096个字节全都擦掉。 那你又说这个扇区其他的地方我还存的有数据。 怎么办呢。 这也没办法。 要想不丢失数据。 你只能先把4096个字节都读出来。 再把4096个字节的扇区擦掉。 改写完读出来的数据后。 再把4096个字节全都写回去。 这感觉是不是挺麻烦的哈。 但是如果你确实就像单独改写某一个字节。 那只能这样来操作。 当然实际情况下。 我们还有别的方法可以优化一下这个流程。 比如3年后。 我先把flash的数据读出来。 放到ram里。 当有数据变动时。 我再统一把数据备份到flash里。 或者我把使用频繁的扇区啊放在ram里。 当使用频率降低时。 我再把整个扇区备份的flash里。 或者如果你的数据量确实非常少。 只想存几个字节的参数就行了。 那直接一个字节占一个上车不就行了吗。 尽显奢靡之风啊。 总结下来。 为了弥补擦除存在最小单元的缺点。 我们需要在程序逻辑上做出一些设计啊。 那然后继续看下一条。 连续写入多字节时。 最多写入一页的数据。 超过页尾位置的数据会回到页手覆盖写入。 这个意思就是说啊你在写入的时候。 一次性不能写太多了。 一个写入时序最多只能写一页的数据。 也就是256字节。 为什么有这个限制呢。 这是因为在这里有一个液缓冲区。 它只有二boss 6。 直接为什么有缓冲区呢。 这是因为flash的写入太慢了。 跟不上s p i的频率。 所以写入的数据会先放在ram里暂存。 等时序结束后。 芯片再慢慢的把数据写入到flash里。 所以这里会有个限制。 每个时序最多写入一页的数据。 你再写多缓冲区存不下了。 如果你非要写。 那超过页尾位置的数据会回到页手覆盖写入。 另外啊。 我们这个页缓存区是和flash的页对应的。 你必须得从一起始位置开始写。 才能最大写入256字节。 如果你从页中间的地址开始写。 那写到页尾时。 这个地址就会跳回到页首。 这会导致地址错乱哈。 所以我们在进行多字节写入时。 一定要注意这个地址范围不能跨越叶的边缘。 否则会地址错乱。 那这是这一点的注意事项啊。 然后写入的最后一点就是写入操作结束后。 芯片进入盲状态。 不想用新的读写操作。 这个应该要理解。 刚才说了哈。 我们的写入操作都是对缓存区进行的。 等时序结束后。 芯片还要搬砖一段时间。 所以每次写入操作后啊。 都有一段时间的忙状态。 在这个状态下。 我们不要进行新的读写操作啊。 否则芯片是不会响应我们的。 要想知道芯片什么时候结束盲状态啊。 我们可以使用读状态计算器的指令。 看一下状态计时器的b这位是否为1b。 c位为零时。 芯片就不忙了。 我们再进行操作。 另外注意这个写入操作啊。 包括上面的插图。 在发出擦除指令后。 芯片也会进入盲状态。 我们也得等盲状态结束后才能进行后续操作。 好了。 以上就是flash写入操作的注意事项了。 这些注意事项大家都得牢记哈。 否则我们下下节的程序逻辑你又不太好理解了。 那然后继续看读取操作的注意事项。 这个就相对宽松很多了哈。 在读取时我们直接调用读取时序。 无需使能。 就这里的第一条插座不需要。 无需额外插座。 也是这三条和读取无关哈。 唯有一页的限制。 也就是这一条连续读取多个字节时。 想读多少就读多少。 不用担心地址错位或者覆盖的问题啊。 读取操作结束后不会进入盲状态。 但不能在盲状态时读取。 就是读取之后啊。 芯片不会盲。 可以立刻开始下降至零。 但是不能在盲状态时读取。 其实是这里的。 现在因为写入操作进入盲状态后。 不会响应新的读写操作。 所以我们在读取之前。 也要注意一下芯片是否处于盲状态。 等不忙的时候再读就可以了。 好到这里我们这个注意事项就讲完了哈。 看完之后是不是觉得有点麻烦是吧。 但是flash这种非易失性存储器啊。 目前的市场竞争力还是非常大的。 尽管它有这么多不方便。 但是这些不方便可以用软件来弥补。 而它的优点是其他存储器比不了的哈。 比如容量大。 价格低。 速度相比较ram是慢。 但是在非议实行总体器中。 flash是非常快的哈。 就像它的名字一样。 flash闪存如闪电一般的快。 好到这里。 我们ppt的知识点就看完了。 相信你对我们这个芯片也有了大概的了解了。 接下来我们还是看一下手册。 在手册里还有几个重要的知识点要说一下。 那么打开模块资料文件夹。 在这里找到w5 q叉叉的参考资料。 打开w5 q64 的手册。 这个手册如果你在资料链接里没找到的话。 可以再重新下载一下啊。 我又更新了一下资料。 我们来看一下。 首先是这个芯片的概述和特性。 这里有些关键的指标啊。 可以把它当成广告页来看看看它有什么优势。 这个大家自己再看看。 然后下面是芯片的引脚定义。 这个我们刚才讲过哈。 包括接线图啊。 也是非常简单直接的。 然后这一块是对芯片每个引脚的描述。 这个我都讲过哈。 还有不清楚的地方可以再看看。 这个位置之后是芯片的系统框图。 这个比较重要。 刚才也给大家详细分析过海。 接下来这里是s p i的操作。 比如标准s p i。 双重s p i。 四重s p i。 这样大家可以再看看。 当然双重sp i和四重s p i。 大家可以先不用管哈。 然后这一页描述的是写保护的逻辑。 我们暂时也不用写保护。 大家可以先随便看看。 然后从这里开始。 我还要提两个很重要的东西。 第一个是状态计算器。 第二个是s p i指令集。 先看一下状态计算器。 其实这个状态计算器应该叫。 控制及状态计算器啊。 它里面也有些控制位。 当然简单称呼就直接叫状态计算器了。 这里状态计算器总共有两个状态计算器。 一和状态计算器二。 其中比较重要的是珠海金属器。 一哈状态计算器一里有两个位是比较重要的。 这两个位在这里我标出来了哈。 第一位是我们刚才提到多次的b类。 下面有些描述哈。 大概意思就是当设备正在执行页编程。 页编程就是写入数据哈。 然后扇区擦除块。 拆除整片擦除或者写状态计算器指令时。 b站位置一。 在这期间设备将会忽略进一步的指令。 当然除了读障碍进气和擦除挂机指令。 然后是当编程擦除写状态进容器指令结束后。 b得清零来指示设备准备好了。 这是b得way。 然后下一位写死人所存位。 w e l在执行完写使能指令后。 w e l g一代表芯片可以进行写入操作啊。 当设备写私人时。 w e l v70。 那什么时候处于写诗人状态呢。 一是上年后芯片默认写诗人哈。 这个好理解。 在执行完这些指令之后。 其中包括我们发送的写诗能指令。 让他写10。 w e l就等于零。 其次页编程扇区擦除等等。 这些写入操作后。 w e l会等于零。 这表明哈当我们先写死人。 在执行写入数据操作后。 不需要在手动进行写诗人的哈。 因为写入操作后会顺便帮我们写诗人。 相当于有个顺手关门的操作。 同时这也表明啊。 我们在进行任何写读操作前都得来一遍邪四人。 一个斜齿轮。 只能保证后续的一条斜直零可以执行这个。 了解一下好。 有关状态计算器。 我主要提这两位哈。 其他的尾大家在自行查看。 主要就是一些写保护的功能。 还需要的话再来看看即可。 然后这里是状态接收器的示意图。 其中状态接收器一我们主要掌握最低的两位。 其他的这些危害暂时不用管。 之后这是一个写保护的配置表哈。 你想保护哪些存储单元。 就按这个表来操作。 好之后。 我们进入下一个重要部分。 就是指令集指令这个英文单词是instruction。 了解一下。 就是这个表写的是芯片id号。 其中厂商id是e f设备id。 如果你使用这两个指令来读。 就是幺六。 如果使用9f指令来读。 就是4017。 这个我们写程序的时候。 首先读取id验证一下spi是不是可行。 到时候就参考这个表来验证即可。 然后下面这个表就是s p i的指令集了。 这个指令比较多哈。 我们目前先只学习这里标记的指令就行了。 其中第一个是写死人。 指令码是零六。 要想发送斜视能指令哈。 我们就利用上小节学习的spi来操作。 先提示。 然后交换一个字节。 一个字节是发送方向。 发送0x06 指令就行了。 这个指令后续不需要跟数据。 所以直接停止。 这是一条写死人的指令。 然后下面写诗人在这里也是一样。 即使交换字节。 发送指令码。 零四终止就完成了。 之后读状态就记一。 我们需要起始交换字节。 发送指令码零五。 这是读指令。 所以后面有数据。 我们要继续交换字节。 通过交换读取一个字节。 那这个直接就是状态计算器的s7 到s0。 当然如果继续交换接收的话。 那芯片会不断的输出状态计算器一。 其中s01 是b的位。 s一是w e r v对吧。 这样子呢主要是用来查看盲状态的。 接下一个指令是一编程。 这个页编程就是写数据哈。 只是它有个256字节页大小的限制。 所以这里叫叶边程。 操作流程是其实交换字节发送指令零二。 然后继续交换发送地址的23~16位。 15~8位。 7~0位。 这三个字节用来指定地址。 再之后我们就可以写入数据d7 到d0 了。 这个数据写入到刚才指定的地址下。 如果继续交换写入的话。 后续的字节就从起始地址开始依次存储。 但是要注意叶的限制啊。 这是页编程指令。 就这点技巧就是擦除之零。 其中包括按64kb的块差数。 按32kb的块擦除。 按4k b的扇区擦除和整片擦除。 我们想少插点。 那就主要用扇区擦除即可啊。 使用方法是其次交换之间发送指令。 二零之后再交换发送三个字节的地址。 终止发送之后。 这个指定地址所在的扇区就会被整个查除。 当然这个地址是精确到某个字节的哈。 我们一般会把这个地址对齐到扇区的首地址。 这样表示擦除一整个扇区。 意识更加明确之后。 下面这里还有几个读完id号的指令。 我们主要用这个gd d e c i d。 操作流程是即使交换发送9f随后连续交换。 读取三个字节终止。 其中第一个字节是厂商id。 后两个字节是设备id。 这是读取id号的指令。 然后继续最后一个要看的指令是读取数据。 操作流程是即使交换发送指令。 零三之后交换发送三个字节的地址。 再之后就可以交换读取了。 这个数据就是这个地址下的数据。 如果继续交换数据。 后面数据就从指定制开始依次读存储的数据啊。 这个读取没有一的限制。 所以直接叫read data。 想怎么读都可以啊。 好以上就是这芯片的指令集了。 我们下小节编程写时序的时候啊。 就得看这个指令集和操作流程。 所以这一块需要多了解。 了解之后呢。 这个手册后续部分就对每条指令的详细解释了。 包括时序图啊。 这里也画出来了。 这里对每个指令都有详细的描述啊。 包括我们之前提到的各种注意事项。 这里也都有提。 那时间关系呢。 这里每条指令的详细解释。 我就不带大家一起看了哈。 大家听完我之前的讲解。 在课下好好看看。 应该是可以理解的哈。 然后下面的时序图可以看到。 和我们之前讲的s p i基本一致哈。 有几个区别呢。 就这里的d o。 按理说重庆应该通过dao。 把它回传的数据发过来。 但这是一个写入的指令。 确实不用回传数据。 所以这里d o始终保持高阻态。 这也可以哈。 然后这里有个mod 0。 又换了个虚线写着木的三。 这个意思是这个芯片可以兼容s p i的模式。 零和模式三为什么能兼容呢。 我们看一下ppt啊。 这里可以对比一下模式零和模式三。 可以发现他们都是下降沿溢出。 上层岩已入啊。 只是相位不一样。 我们可以规定在s下降沿。 或者s c k的第一个下降沿都输出比奇。 然后去移动数据都是在s c k的上升线开始。 这样是不是就可以兼容模式零和模式三了。 所以这里手这里就画了个虚线。 说你模式零和模式三都可以用。 我可以兼容哈。 当然我们一般选取实现的模式零就可以了。 所以虚线部分我们可以忽略不看。 就是持续的一些区别。 然后剩下的这些啊都是指令的。 具体介绍和注意事项。 大家可以自己慢慢看。 最后指令介绍完成之后。 就是电气特性的一些表。 比如这里给出来这个芯片的供电电压范围。 要在这个范围里才行。 最后还直接表。 然后这里有些参数啊。 可能会用到就是执行编程和擦除的时间。 比如我执行页编程的时间。 它的点心时间是0.7ms。 最大时间是3ms。 扇区查询的时间哈。 典型值30ms。 最快插图典型值是120和150ms。 最后一个整片查出这个时间最长哈。 典型值15秒。 最大30秒。 所以看出来这个flash芯片的写入时间哈。 一般情况下大概处于一个毫秒的时间级别。 然后后面就是这些时序的实践要求了。 最后是一些分装的尺寸信息啊。 就是这个手册的内容。 那到这里本小节课就结束了。 我们下一小节来开始写代码。 实现程序功能哈。
38. hello。 大家好。 本小节我们来正式开始写spi。 读写w5 k64 的代码哈。 这个视频我们主要使用软件。 pi的方式来实现功能。 那还是先看一下经验图。 打开软件spi读写w5 k64 的图片。 看一下左边这里是w5 k64 的模块。 我们把它插在面包板合适的位置。 然后vcc电源正极我们接到3.3伏供电。 空接地电源负极接到gd供电孔。 这样供电就接下了。 最后就是s spi的四根通讯线了。 cs d o c r k和d i。 因为我们目前是软件模拟的spi。 所以这四根线其实是可以接到s t m32 的。 任意gpl口啊。 接哪个都行。 软件模拟的通信端口灵活性高。 还那这里我是这样来接的。 cs片选接到pa 4 d重击输出。 接到pa 6 c lk时钟。 接到pa 5 di重新输入。 接到pa当然我这里引脚其实并不是任意选的哈。 我实际上是接待了硬件spi的硬件上。 这样的话软件spi和硬件spi都可以任意切换。 如果你也想留有切换的余地啊。 那接到硬件spi角上是最好的。 如果你只想使用软件spi。 那就没这个必要了。 好我们看一下面包板来接一下线。 首先把w k64 这个模块。 插到面包板合适的位置。 然后用面包板跳线vcc引到正极供电空。 金地引到负极供电供。 之后用飞线cs接到pa 4。 dio。 接到pa 6。 clk接到pa 5。 di接到pa 7。 这样接线就完成了。 然后通上电模块的电源指示灯点亮。 说明供电这块基本没问题啊。 好这样硬件电路我们就完成了。 接下来回到工程目录。 复制o l d显示屏的工程。 改个名字叫11杠一软件spi读写w5 k64。 打开工程。 这也删掉啊。 先编译一下。 那目前准备工作就完成了。 然后我们先规划一下程序的整体框架。 在这个过程里。 我们的规划和上一节iphone c的差不多。 我们先建一个买s spi的模块。 在这种模块里主要包含通信引脚。 封装初始化以及spi通信的三个拼图。 起始终止和交换一个字节。 这是spi通信程的内容。 然后基于s p i层。 我们再建一个w5 k64 的模块。 在这个模块里调用底层s p i的拼图。 来拼接各种指令和功能的完整时序。 比如写使能擦除页编程。 读数据等等。 所以这一块可以叫做w k64 的硬件驱动层。 最后在主函数里。 我们调用驱动层的函数。 来完成我们想要实现的功能。 这是程序的整体框架。 那我们首先在hardware目录下建立模块。 模块名称叫买spi。 流程加速一下哈。 好模块建好。 二话不说。 我们先来个初始化。 word y s p i elite void。 在这里面我们来初始化spi的通信引脚。 打开led.c啊。 复制一下这里的gpl初始化。 看一下接线图。 我们这里使用的是pa 4567这四个引脚。 所以开启时钟gp l a没问题啊。 之后银甲初始化应该选择什么模式呢。 我们看一下ppt。 这里输出引脚配置为推广输出。 输入引脚配置为浮空或上拉输入。 对于主机来说。 时钟主机输出和片选都是输出硬件。 所以这三个角是推广输出模式。 然后剩下一个主机输入啊。 是输入硬件。 所以这个角是浮空或上拉。 我们选择上拉输入就行了。 看一下经验图。 这个绿线是重击的du输出。 对应主机的pa 6就是主机输入。 所以银角配置p a6 为上大输入。 其他三个为推广输出。 这样就行了。 然后回到代码这里。 p4 听五。 再来个pin 7。 他们三个是推广输出。 数字化gpa没问题。 之后复制一下下面这四行。 gpl p6 模式是ipo上来输入初始化到g p l a。 这样引导初始化就完成了。 那接下来我们还像之前iphone 4那样哈。 把自引脚高低电平的函数都封装。 换个名字在这上面写。 首先是重击选择。 这个是输出硬件。 word买sp i w s s。 这里你叫cs也行哈。 目前cs这个名字用的也挺多的。 然后unit 8杠t beat value。 在这里面我们看一下接线cs对应的是ps 4引脚。 所以这里gpl db的g p l a gpl p4。 第三个参数把b value传进来。 然后强转为beat action类型。 这样这条写gpl的函数就换了个名字。 叫买s p i w s表示写s的引脚。 之后还有两个输出硬件。 我们复制一下。 第二个是sk。 第三个是moo si。 看一下接线c l k就是s c k r对应p a5。 d i就是m o s i对应p a7。 所以这里sk是pa 5。 mosi是p a7。 最后还有一个m soo是输入硬件。 ut 8杠t买s p i r m s o。 我的在这里面直接return gpl。 read input data bit gpa。 gpl p6。 这样这四个spi的通讯硬件哈。 我们就包装换好名字了。 当然你也可以用宏定义来完成相同的功能。 但是这里我用函数包装一下哈。 之后如果要移植到其他类型单片机里。 或者要加一个延时。 会方便一些。 那这里spi的速度非常快。 所以我们操作完引脚之后。 暂时就不需要加延时了哈。 那这是银角的分装。 我们就完成了。 然后下面初始化。 这里我们还有一个工作要做。 就是治一下初始化之后引脚的默认电平。 那在初始化之后。 我们的s s应该置为高电平。 默认不选中重击啊。 然后s c k我们计划使用s p i模式零哈。 所以默认是低验品之后。 m o s i没有明确规定哈。 可以不管m s o是输入文件。 不用输出电平啊。 这样初始化之后的默认电瓶就治好了好。 接下来我们来开始写spi的三个时序。 基本单元。 首先是起始信号。 word买sp i start。 我的。 看一下ppt起始信号。 我们直接把s至低电平就完事了。 所以这里时代的函数里就一句代码。 写s为零就行了。 之后中止信号。 看一下ppt呀。 就是s至高电平。 所以这里中指也很简单。 复制一下这个函数。 买s p i stop里面就是把s至高电平就行了。 至此我们三块拼图就完成两块了。 然后最后一块也是spi的核心部分。 就是交换一个字节。 看一下ppt啊。 这里交换一个字节。 总共有四种模式。 我们w q64 芯片支持模式零和模式三。 那我们一般选择实现模式零这一种就行了哈。 在程序这里来个函数。 new int 8杠七买sp swipe beat unit t。 八杠t bc。 这个better send是我们传进来的参数。 要通过交换一个字节的时序发送出去。 返回值是better receive。 是通过交换一个字节接收到的数据。 通过返回值传递给调用函数的地方。 函数名称我就直接叫交换字节了。 有的地方也叫right rebt。 就是读写一个字节也是一个意思啊。 之后函数内部我们先定义一个uint 8杠t。 better receive。 用于接收哈。 最后return better receive。 返回会去站在中间。 我们来实现时序。 看一下ppt。 在s下降眼之后。 我们开始交换字节。 所以我们目前处于这个位置哈。 那这里需要解释一下。 这里图上画的是ss下降沿和数据移出。 是同时发生的。 包括后面这个sk下降沿和数据溢出也是同时的。 但这并不代表。 我们程序上要同时执行两条代码哈。 当然这也做不到这里。 实际上他们是有先后顺序的。 是先s下降沿或s k下降沿。 再数据溢出。 这个下降沿是触发数据移出这个动作的条件。 先有了下降沿之后。 才会有数据移出这个动作。 它们有个因果关系啊。 对于硬件spi来说。 由于使用了硬件的移位寄存器电路。 所以这两个动作几乎是同时发生的。 而对于软件spi来说。 由于程序是一条条执行的。 我们不可能同时完成两个动作。 所以软件sp我们就直接躺平了。 直接把它看成先后执行的逻辑。 那这个流程就是先ss下降眼再移出数据。 在sk上升眼再移入数据。 在s k下两眼再移除数据。 你这个具有先后顺序的流程来执行。 这样才能对应一条条依次执行的程序代码对吧。 这个说明一下。 那看持续s s下降研之后。 第一步主机和从机同时移出数据。 就是主机移出我的数据最高位放到msi上。 重击移出它的数据最高位放到m s o上。 当然m s数据变化是重击的事。 不归我们管哈。 所以这里第一步是写mosi。 发送的位是bsd的最高位与上0x80。 当然这里要保证这个函数是非零即一的特征哈。 要不然你这个与0x80 之后。 要把数据位右移到最低位才行好。 然后继续看数据位置。 放好了。 第二步。 s k上升沿上升沿之后。 主机和重击同时移动数据当然还是一样。 重机会自动把这个b7 读走。 重机那边的引入不归我们管。 我们主机只需要读取m s的数据就行了。 所以程序这里就是写s c k。 唯一产生上升眼。 上层延时重机会自动把mosi的数据读走。 主机的任务就是在这个上升沿后。 把重击刚才放到msl的数据位读进来。 所以这里我们要读m i s o。 读到的数据是接收的最高位。 那么还是使用之前的做法啊。 better receive。 先附个初始值0x00。 如果读到m soo的数据位是一better receive。 或等于0x80。 这样就把最高位存在better receive里了。 然后看一下ppt时钟继续运行。 接着就是s k产生下降眼。 主机和重击移出下一位。 所以这里之后是写sk为零。 产生下降眼。 那在这个下载以后。 主机的任务是移除b6。 所以复制这一条。 与0x40 把次高位放到moo si上。 然后就进入循环了哈。 再下降眼移除下一位。 这是流程。 那显然这里用个化学环套起来就可以了。 先定义一个变量i。 a等于零。 a小于八。 唉加加循环八字。 把这四句进行循环。 每次发送接收的尾是0x80。 右移二。 加括号啊。 接收也是友谊。 爱。 下面直接删掉。 那这就是s p i模式零交换一个字节的时序了。 在函数结束时。 sc k40 对应p p t啊。 就处于这个位置。 所以我们循环八次就完整的产生了这个时序。 波形之后。 想继续交换字节。 可以想终止也可以啊。 然后这个程序我目前是用0x8。 0u1 i的方式依次取出better send的每一位。 或者依次给better receive的每一位之一。 可以看出啊。 这个0x80 又1i的作用。 就是用来挑出数据的某一位或者某几位啊。 或者换种描述方式。 就是用来屏蔽其他的五官位。 那我们就可以把这种类型的数据啊叫做页码。 所以这里演示的方法是。 通过掩码依次挑出每一位进行操作。 这是使用掩码的操作方式。 但这里的流程其实还可以进行一些优化。 就是使用ppt这里演示的移位模型。 我们对照这个移位模型的流程来完成程序设计。 设计方法给大家演示一下。 复制一下这个函数。 第一步移出数据。 我们直接这样输出最高位之后。 我们还要来一个better than的左移等于一。 那这两句加一起。 效果就是把better send的最高位。 移出到mos a贝塔肾的佐伊那一位。 它的最低位会自动补零啊。 最低位空出来了。 那我们之后再接收的时候。 就不需要better receive这个变量了。 直接如果接收到的是一。 就better su或等于0x01。 把收到数据放在better send的最低位。 然后下一个循环。 我们继续发送better send的最高位。 因为上一个循环已经向左移位了一次。 所以第二次的最高位就是原始数据的次高位。 之后数据左移。 第二次循环接收时。 因为左移了。 所以数据仍然放在最低位。 这样一次进行八次数据交换就完成了交换。 接收到的数据就存在better圣里。 最终return bcd就行。 这里就没必要再定义better receive了。 那可以看出这种方法是不是比上面的方法。 效率更高哈。 第一种方法使用源码依次提取数据。 每一位好处就是不会改变传入参数本身啊。 之后如果还想用better send。 可以继续使用。 第二种方法。 我们是用移位数据本身来进行的操作。 好处就是效率更高。 但是better肾的这个数据。 在移位过程中改变了for循环。 执行完原始传入的参数就没有了。 如果在这里想继续使用最开始传入的bcd。 那就没办法了。 然后第二种方法在实现思路上。 是不是更契合我们这个移位的模型哈。 他们基本是一一对应的。 那这里两种方法我都给大家演示了一下。 使用哪种都可以看你的喜好啊。 那我就保留第一种方法了。 然后最后我再给大家演示一下spi模式一。 模式二模式三的修改方法。 目前这里是模式零。 如果你想修改为模式一的话。 看看p p t模式一。 这里是s s下降眼之后。 先s c k上层眼再移除数据。 再s k下降眼再移入数据。 所以我们只需要对程序的相位进行一些小修改。 就能换成模式机了。 怎么改呢。 ss下压眼。 西安sk上升眼再移除数据。 在s c k下降眼再移入数据。 这样是不是就完事了。 就是s p i模式一的流程是不是很简单。 周五spi模式二和模式三就更简单了。 比如现在这里是模式一改成模式三。 s p i模式一和模式三的区别啊。 就是时钟极性不一样。 所以就把s c k即兴翻转一下就行了。 就是所有出现sk的地方零改成一。 一改零。 零改成一。 那现在就是sp 2模式三是不是也很简单。 然后s p r模式同理。 就是在模式零的基础上把所有s c j0 改成一。 一改成零就行了。 就是spi的四种模式怎么改。 就给大家演示好了。 那么撤回一下。 现在回到最开始演示的模式零哈。 我们本代码使用的是sp i模式零。 如果你需要用别的模式。 就在这个基础上进行一下小修改。 改变相位。 就是把这两条代码提前一下。 改变极性。 就是把s c k0.一一点。 好到这里。 sp i的通讯层代码我们就写完了。 之后我们把下面这四个函数啊。 放在头文件声明一下。 这次函数一个初始化三个s spi时序。 基本单元是外部可调用的哈。 编译看一下没问题啊。 然后接下来我们就按照计划继续写下一个模块。 在s spi通讯层之上。 我们要建立w5 q64 的驱动程。 在海德怪右键哈金建模块叫做w5 q64。 然后加速一下。 那模块建好。 我们先来个初始化y的w25 k641 lit。 y的作为s p i上层的w5 k64 模块。 它的初始化显然要调用底层的。 买s p i一利。 特先把底层输入化好。 这个上层才能正常工作啊。 当然要调用底层的函数。 也别忘了包含。 买sp i的头文件。 那由于这个w k64。 也不需要再初始化其他东西了。 所以初始化这里我们只需要调用一个mysp i。 e it就行了。 这几个不好说啊。 编译看一下有没有问题啦。 有错误看一下。 所以这个地方写错了哈。 改一下。 好现在没问题了。 之后呢。 我们就可以来实现业务代码了。 也就是拼接完整的时序。 这个我们要参考一下手册。 主要参考的部分就是这个指令集的表格。 比如我们先实现这个获取id号的时区。 先把id号读出来看看对不对。 以此验证底层的spi协议写的有没有问题啊。 从这个表格可以看到。 读取id号的时序就是其实先交换发送指令。 9f随后连续交换接收三个字节停止。 那我咋知道哪个是交换发送。 哪个是交换接收呢。 这个下面这里写了哈。 圆括号括起来的就是我们需要交换接收的数据。 这里这三个字节都是括起来的。 所以这三个字节都需要我们交换接收。 另外通过业务逻辑啊。 我们应该也可以很容易地看出来。 哪个是需要接收的哈。 你都发去读取id号的指令了之后该干啥。 不是很明显吗。 那连续接收三个字节。 第一个字节是厂商id。 表示了是哪个厂家生产的。 后两个字节是设备id。 其中设备id的高八位表示存储器类型。 低八位表示容量好。 id号的读取方法和意义清出来。 我们回到代码y的w5 k64 瑞的id。 由于我们计划这个函数是有两个返回值的哈。 所以我们还是使用指针来实现多返回值。 原来的返回值就不要了。 在这里写上两个输出参数。 一个是u int 8杠t新md输出八位的厂商id。 另一个是uint 16杠t新dd。 输出16位的设备id。 在这里面啊。 拼接时序首先要开始一条时序啊。 显然要调用y s p i start s引脚。 至低开始传输之后。 先交换发送一个字节9f。 所以调用mysp i swap b参数是交换发送的。 给0x9 f返回值是交换接收的。 但是这里接收的数据没有意义哈。 所以返回值就不要了。 那我们这条代码就是抛玉引砖对吧。 抛过去是9f代表读id号的指令。 那重新收到读id号的指令后。 他就会严格按照手册里约定的规则来。 下一次交换。 就会把id号返回给主机了。 所以我们再来一次买spi swap bt参数。 我要给重庆一个东西。 此时我的目的是接收。 所以给它抛的东西就没有意义哈。 我们可以随便给他抛一个垃圾。 但一般为了体现数值啊。 我们会给个0x f f。 这个f f没有意义啊。 他的目的就是给对面有意义的数据置换过来。 置换之后这个返回值就是我们想要的id号了。 第一个置换回来的是厂商id。 我们把它存在mad指向的变量里。 这样厂商id就收到了。 那我们这条代码就是抛砖引玉了对吧。 给他抛一个垃圾。 它返回一个有用的数据之后。 根据手册啊。 我们再交换一次。 收到的就是设备id的高八位了。 所以我们复制一下这一条。 再抛一次砖。 它返回的是设备id的高八位。 我们把返回值存在dd指向的变量里。 当然这里说明一下。 虽然我们连续调用了两个相同的函数。 但是它们的返回值并不是一样的。 你别说啊。 我这连续调用了两个一模一样的函数。 它的返回值肯定是一样的。 这个想法不对哈。 因为我们是在通信。 通信是有时序的。 不同时间调用相同的函数。 它的意义就是不一样的哈。 这个注意一下。 然后继续之后我们再复制一下。 第三次交换。 根据手册的规定哈。 这时返回的是设备id的低八位。 我们也把它存在dd里。 当然要想把两次的读取。 分别放在d i d的高八位和低八位。 我们需要在第一次读取之后。 新dd左移等于八。 把第一次读到的数据运到dd的高八位去之后。 第二次读取需要变为或等于不能直接写等于哈。 否则高八位就又至零了。 这样我们的两个id号就读好了。 最后持续结束。 我们来个myspi stop。 这样获取id号的时序就拼接完成了。 是不是也不难理解。 就是起始交换交换交换最后停止。 至于交换每个字节的意义啊。 查一下这个指令表就很容易理解了。 那我们写到现在可以来进行一下测试。 看看写的目前的代码都对不对啊。 我们把这两个函数放到头文件声明一下。 编译看一下没问题啊。 然后回到面点c。 先include一下w5 k64 的头文件。 然后初始化w5 k64 edit。 之后定义两个从iid号的变量。 unit 82 t md unit 16杠题。 d it接着调用w25 q64 z的id。 把两个变量的地址传递进去。 等函数执行完id号我们就拿到了。 最后显示一下o i d show hx number。 以16进制显示一行一列。 显示md长度为二。 再来一个哈。 一行八列显示dd长度为四。 这样就行了。 编译下载测试一下。 可以看到屏幕上显示了两个数。 厂商id是e f。 设备id是4017。 让我们看一下手册。 这个数对不对呢。 在这上面有写id号哈。 其中厂商id是ef没问题。 设备id我们目前使用的是9f指令。 所以读出来是4017也没问题啊。 这说明我们的程序写到这里。 现象都是符合预期的。 如果你在这一步不能正确的读取id号。 那说明你之前写的代码是有问题的哈。 或者硬件接线有问题。 再仔细对照检查一下。 走一步撤一步。 确保之前的代码没问题。 再往后写。 这样写程序心里才有底。 对吧好。 那我们继续来写程序。 接下来我们的任务就是把这个指令吉利标。 黄色的这些指令时序给实现出来。 那这个指令比较多哈。 每个指令都对应一个指令码。 如果你总是在程序里直接像这样写个数字。 那意义就不太明显。 可读性不可。 别人看到你这个程序。 也不知道9f到底代表啥意思。 所以我们的做法和上届m p u。 6050的寄存器地址一样。 我们把每个指令码也用宏定义替换一下。 那指令比较多哈。 我们还是单独建一个头文件存放一下。 新建一个头文件。 名字叫做w5 k64 i n s。 存放在hardware文件夹里。 固定部分快速写一下。 在这里面大家可以根据手册。 把这所有的指令名称和指令码抄过来。 当然这里我也是提前写好了哈。 就是这个样子。 define宏定义。 将每个指令名称替换为对应的指令码。 那我们全选复制过来。 这样指令替换就做好了。 上面这些啊。 就依次对应这个指令表里的每个指令。 另外下面我还多定义了一个叫做dummy beat。 它表示0x f f。 意思就是我们在接收时交换过去的无用数据啊。 那这些就是指令集的宏定义。 先编一下。 没问题啊。 接下来w k64 点c里。 先include的w5 k64 i n s的头文件之后。 这里的重数字。 我们就可以替换为对应的字符表示了。 比如0x9 y f我们就可以替换为这里对应的。 基于d e c a d e复制放到这里。 这样我们就一眼看出来这是读id的指令了。 之后的0x f f是无用的数据啊。 我们使用这里对应的dummy be替换到这里。 这样代码的意义就更明显一些。 好我们继续来一次实现这些指令的时序。 首先是write ellb。 写死人。 这个指令很简单啊。 只需要发送一个指令码零六就行了。 那在这里我们可以定义函数y的w5 k64。 write label void。 在这里面就很简单了。 第一步start起始。 第二步交换。 发送一个字节。 这里芯片规定的就是s p i。 起始之后的第一个字节都是指令码哈。 我们要发送的指令呢就是这里的right elabel。 放到这里。 这个指令后续不需要跟任何数据啊。 所以直接十stop。 这样就完成了。 我们只要调用一次这个函数。 就可以向w5 q64 发送一次写使能指令哈。 然后我们继续下一条指令是读状态计算器。 一指令码是零。 五方法指令码就可以接收状态接器了。 当然我们读状态接收器的主要用途啊。 就是判断芯片是不是盲状态状态接收器。 一每一位的定义啊。 在前面这里有说明。 我们要读取它的最低位b类。 看看是不是还是一一表示芯片还在忙。 零表示芯片不忙呢。 另外我们最好要实现一个等待bz为零的函数。 这样更符合我们的需求对吧。 我们调用一下这个函数。 要是busy为一就进入等待。 等函数执行完了。 b z肯定就是零了。 然后我们再看一下下面的指令。 详细介绍这个读状态计算器一或二的介绍二。 这里画的是起始之后先发送指令码。 在接收状态净水器之后。 如果你持续不停。 还要继续接收的话。 这个芯片就会继续把最新的状态进器发过来。 也是这里写的状态计算器可以被连续读出。 这个连续读书的特性。 就方便我们执行等待的功能哈。 具体做法就是在这里来个函数。 void w5 k64。 weight busy void。 这个函数我们就直接叫wait busy啊。 就是等待busy为零的意思在里面先start。 然后发送指令。 指令码是这里的读状态计算器一。 随后我们发送大米bet接收数据。 返回值是状态监视器一。 我们把它与上0x01 用解码取出最低位。 如果它等于等于0x01。 就是b类为一。 这时候我们进入while死循环进行等待。 但这里前面的计算通过括号避免优先级的问题。 那这样如果b z为一。 就会进入循环。 再次读出一次状态。 进入器继续判断。 直到b z为零。 跳出循环。 这是利用连续读书状态计算器。 实现等待bz的功能。 最后我们来个stop终止时序。 当然这里如果你觉得死循环等待。 在意外的情况下。 可能会导致程序卡死啊。 我们还是可以来个time out unit 32杠t time out。 循环之前给time out付个初始值。 这个初始值可以自己实测一下哈。 稍微给大点。 比如10万。 然后在while循环里每循环一次time out减减。 如果time out的质检到离。 不等了。 在break之前。 你也可以跳到自定义的错误处理函数啊。 这个看你的需求加就行。 好这里我们这个等待忙的函数就写好了。 我们调用这个函数。 如果不忙。 函数就会很快退出。 如果忙就会卡在函数里面等待。 等不忙了就会退出。 最后继续下一个。 我们来写这个页编程的函数。 格式是先发送一个指令码。 零二。 再发送三个字节的地址。 最后发数据。 这里的数据是发送方向的哈。 之前这里说括号表示接收数据。 所以这个应该是打错了。 不应该画括号的。 然后看一下详细介绍。 上面有一堆描述。 我们应该都讲过哈。 大家有时间自己看一下。 主要看一下下面的时序。 这里画的是先发送指令。 然后连续发送三个字节。 就是24位地址哈。 之后继续发送data bt 1 data bt 2 data bet 3。 最大是data bt 256。 如果继续发。 它就会覆盖这里的data bt 1。 这是注意事项。 那在代码这里来一个y的w5 k64 配置program。 它的参数根据业务逻辑哈。 u int 32杠t address。 c语言没有24位数据类型。 所以定义32位的就行啊。 之后unit t8 杠t。 如果我们只想指定地址写一个字节。 就是data这样就行。 但是我们一般存储的东西比较多哈。 每次都调用存储一个字节。 效率太低了。 所以我们可以传递一个数组。 da r数组我们得通过指针传递数据类型。 定义为指针哈。 最后再加一个unit t16 杠t。 count表示一次写多少个。 至于如何使用指针传递数组。 还不会的话。 可以看看我们指针教程哈。 另外由于这个页编程。 它一次性写入数据的数量。 范围是0~256。 所以count要定义为16位的。 如果你只定义为八位的。 那只能从0~255。 这样当你需要写入256个数据时。 就会出问题啊。 然后函数内部拼接时序先start再发送指令。 指令码是这里的配置。 program放到这里之后。 我们还要继续交换发送三个字节的地址。 所以再复制三遍。 地址是高位字节先发中啊。 所以第一次发的是address 3个字节里的最高位字节。 那我们直接把address右移16位。 如果地址是0x123456。 右移16位。 就是0x12 的。 就是最高位的字节。 然后第二次我们把address右移八位。 如果地址是0x123456。 右移八位就是0x1234。 但是交换字节函数只能接收八位数据。 所以高位舍弃哈。 实际发送0x34 就是中间的字节。 第三次我们直接把address放里面。 如果地址是0x123456。 舍弃高位。 实际发送0x56 哈。 就是最低位的字节。 这样连续发送24位地址就完成了。 看一下手册啊。 根据指令规定地址发完。 就可以依次发送写入的数据了。 我们复制继续交换发送。 第一次写入的是data瑞的第零个数据。 第二次协助的是data瑞的第一个数据。 这样依次来进行即可。 在指定地址开始写入多个字节。 那我们要写入count的数据。 显然来个循环就再合适不过了。 先定义变量u int 16杠t i之后。 i等于零。 a小于count唉。 加加循环count 4。 每个循环我交换发送一次对应data瑞索引为i。 这样是不是就行了。 这些不用哈。 最后写完来个stop。 这样配给program时序就实现完成了。 我们调用这个函数给一个指定的起始地址。 再给要写入的数组和数量。 它就能帮我们写入数据了。 那接着继续看下一个我们来实现擦除的功能。 这里有四个擦除的选项。 我就只显示扇区参数啊。 其他的参数都是非常类似的。 应该好理解。 那要执行扇区差除。 需要先发送指令二零。 再发送三个字节的地址就行了。 这样指定地址所在的整个扇区就会被查出。 我们来写一下word w5 k64 sector insese unit。 三二杠t adrise。 只需要指定一个24位地址就行了。 在这里面先起始。 发送指令。 指令码选择这里的sector与日子四kb之后。 指定地址啊。 直接复制这三条就行了。 最后停止。 那这个函数就完成了。 调用这个函数指定地址所在扇区就会被擦除。 接着继续这个读id号的写过来。 另外这里大家注意到这边有很多这样的大米。 也就是无用数据啊。 但这里写了。 当米留给他发个f f就行了。 它范围值也是无用。 数据。 相当于抛砖引砖了。 发送和接收的数据都是没有意义的。 他这么干。 有的情况是为了内部电路延时做准备的。 就是交换几个无证数据。 相当于有一段延时。 当然我推测也可能是通过大米的这段时序啊。 给内部电路产生一些额外的。 始终也可以做一些准备工作哈。 或者是其他原因。 咱也不用管。 总之见到这个大米流。 按规定交换一个无用数据就行了。 这个说一下周继续。 我们最后一个指令就是read data。 读取数据流程是交换发送指令。 零三再发送三个字节地址。 随后转入接收就可以依次接收数据了。 看一下详细介绍。 这里持续可以看到啊。 之前d o一直是高阻态。 在发生完三个字节地址后。 d o开启输出。 此时主机就可以接收有用数据data 21了。 在接收时di的波形是叉叉叉。 表示这个数据无所谓哈。 这是抛砖引玉之后。 如果你连续接收多次。 那就是data 2 data 23等等。 读取没有256字节限制。 可以跨页一直连续读。 让我们写一下程序y的w5 k64。 read data参数呢其实和我们前面这个是一样的。 直接复制过来。 只不过是我们这个读取数据的数组是输出参数。 读到的数据。 通过数组输出。 前面这个写数据的数据是输入参数要写的数据。 通过数组输入这个了解一下。 那我们这个读取数据没有页的。 现在所以读取的count范围可以非常大。 16位数据最大6535可能不够狠。 我们改成32位的类型。 这样就没问题啊。 然后这个函数的内容啊。 前面一段和之前的一样。 我们复制一下。 从这里到这里复制放在这里。 这个i的类型也改成32位的。 之后。 开始发送指令指令码。 看一下。 复制这个read data放到这里之后。 指定24位地址。 然后根据协议规定啊。 从这里开始我们就要开始读了。 怎么读呢。 我们就是复制这一条抛砖引玉的代码。 发送f f置换回有用的数据。 它的返回值就是读到的数据。 我们把它放到data re定理一个位置。 之后复制复制继续读。 是不是就该放到一位置和二位置了。 这样一次来进行。 在每次调用交换读取之后。 存储器芯片内部地址指针自动自增啊。 依次返回指定地址。 开始往后线性区域地址下的数据。 在s t m32 里。 我们肯定也是把这一个个的数据流。 一直存在一个线性地址的数组里对吧。 那这个过程我们还是套一个for循环。 for i等于零。 a小于count哎。 加加循环count字。 每次循环读取一个字节。 一次放在dr的第二个位置。 这样就能想读多少读多少了。 下面删掉。 读完之后来个stop。 这样读取数据的时序就完成了。 我们调用这个函数。 给个指定的起始地址。 再给接收读取数据的数组和数量。 它就能帮我们读取数据了。 那到这里我们基本的函数就写完了哈。 编译看一下没问题。 最后在这每一条时序写完之后。 我们还可以做一项工作。 来方便我们之后的使用函。 就是p p t这里的注意事项。 第一条。 写入操作前必须先进行写死人。 在我们这里涉及写入操作的时序。 有扇区擦除和页编程。 既然每次泄露之前都必须得斜势能。 那我们直接在这个函数前面。 就自带一个斜势能吧。 省得我们再在每次调用的时候。 加写死人的代码呢。 方便一些。 那么就复制上面的斜势能函数。 放在这个扇区。 擦除前面。 然后页编程前面也自带一个斜视。 能这样之后我们再调用写入的函数。 就不用再额外调用。 写死了啦。 然后上下节讲过。 这个显示人仅对之后跟随的一条时序有效。 一条时序结束后会顺手关门。 所以我们在每次写书之前都加一条斜时。 能写完之后就不用再写诗人了。 这是写死人的操作。 之后。 还有一个要做的就是这里的写入操作结束后。 芯片进入盲状态。 所以我们可以在每次写操作时序结束后。 调用一下wait busy。 当然这里还涉及一个四弦等待。 还是事后等待的考虑。 我们可以选择在每次写入后。 都等b z70 呢再退出。 这样是最保险的。 函数结束后。 芯片肯定是不忙的状态。 这是事后等待。 就是写作后立刻等待。 不忙了再退出。 另外我们还可以选择视前等待。 就是写入时序结束后啊。 我们不进去等待。 而是在每次操作之前就在这个位置进行等待。 我们只要在每次写入之前。 等一下b z不忙的时候再写入就没问题了。 这是事前等待。 就是写入前先等待。 等不忙了再写入。 这两个的区别就是啊事后等待。 最保险在函数之外的地方。 芯片肯定是不满的状态。 四前等待效率会高一些。 因为你写完之后不等程序可以执行其他代码。 要正好利用执行其他代码的时间。 来消耗我等待的时间。 说不定我下一次事前等待的时候。 时间被执行。 其他代码耗过去了。 我就不用等了。 最后一个区别就是事后等待。 只需要在写入操作之后调用。 而事前等待。 在写入操作和读取操作之前都得调用。 因为在忙的时候读取也是不行的。 所以如果采取事前等待。 那么读取操作之前也得等等。 这是两种等待方式的区别哈。 大家可以根据自己的喜好和需求。 选择事前等的还是事后等待。 那这里我就选择事后等待哈。 复制一下这个wait a busy函数。 在页编程之后执行。 等待之后扇区擦除也来个时候等待。 那最后读取数据是事前事后都不用等待。 因为每次耗时操作之后。 我们都已经等过了。 所以调用read data时肯定不会忙。 好。 到这里。 我们整个驱动模块就写好了。 接下来我们来进行一下测试哈。 那把最后三个函数放到头文件里。 声明一下。 斜视能和等待王的哈。 就不用外部调用了。 编译一下没问题。 然后到主函数来执行测试。 我们先定义两个数组。 一个是array rat。 要写入的数组里面可以给一些数据哈。 0x010 x020 x030 x04。 这里给四个数测试一下就行。 然后再来个数据。 用int 8杠七和read read读取的数组。 我们给四个内容。 主函数里面固定的一些字符串先写一下啊。 o o i d show string。 一行一列显示m d冒号三空格啊。 d d冒号复制一下。 再来两个二行一列显示w冒号代表写的数据。 三行一列显示arm号代表读的数据。 写si d号的位置。 挪一下m i d放在五列。 dd放在12点下载看一下。 现在是这个现象啊。 然后我们执行写入测试。 我们要在零零位置开始写。 那写之前先擦除上车。 我们调用这个sector is放到这里。 参数指定地址啊。 给个0x000000 表示第零个地址。 这里地址虽然精确到某个字节了哈。 我们还是最好把它对齐到扇区的起始地址。 上下节。 这里我们总结了扇区地址的规律。 每个扇区的地址都是叉叉叉。 000到叉叉叉f f f。 所以只要末尾三个16进制数是零。 它就肯定是扇区的起始地址。 这里后面三位是扇区内的地址。 这三位无论怎么变。 它都是在一个扇区里的。 所以后面三位你随便写。 擦除的都是同一个扇区啊。 但一般我们最好指定扇区起始地址来擦除。 这样意义更明确啊。 那继续擦除之后。 我们可以开始写入了。 来一个配置program。 其次地址我们给个0x000000 写入数组。 我们把array write传进去。 写入数量是四个字节。 这样写入就完成了。 写完之后我们再给它读出来。 来一个read data。 起始地址给0x000000 读取数组。 我们把array read传进去。 读取数量也是四个字节。 这样读写测试就写好了。 我们显示看一下oled修hx number。 二行三列显示arrewrite。 零长度为二。 复制一下。 六列显示arreact。 一。 九列显示arrewrite。 22点显示arrewrite 3。 这样写入数据就显示完成了。 然后再来一遍。 放到3号arrewrite。 改成array read。 显示一下读取到的数据。 如果读写操作没问题的话。 那读取到的数据应该也依次为零。 x01020304。 我们编译下载看一下。 可以看到啊。 第二行写入1234。 第三行读取也为1234。 没问题。 我们改一个数据试一下。 比如写入数组改成a1 b2 c3 d4。 下载看一下。 读出a1 b2 c3 d4。 没问题啊。 这证明我们的读写基本没问题。 接着我们进一步来进行测试啊。 首先验证掉电不丢失。 我们把这两条擦除和写入的代码注释掉。 先编译下载。 一边。 现在只有读取数据。 目前还是a1 b2 c3 d4。 我们断电重启。 可以看到独具的人为a1 b2 c3 d4。 说明数据是掉电不丢失的。 之后。 我们再验证一下flash擦除之后变为f f的特性。 我们解除擦除的注释。 只擦除不写入。 看一下下载。 可以看到读取的数据全是f f。 说明flash擦除之后变为f f之后。 我们再验证一下flash只能一写零。 不能零选一的特性。 我们解除这个注释啊。 先写入aa bb cc dd下载看一下。 这是有擦除的写入哈。 写入什么。 读出什么数据不会出错。 咱们继续测试。 注释掉这里的擦除。 我们尝试一下。 不拆除。 直接改写会发生什么现象呢。 原来这里写入的是a a b b c c d d。 我们想直接改写为55667788。 会发生什么呢。 下载看一下。 可以看到我们写入55667788。 读出来的却是00224488。 是不是就出错了。 那aa直接改写为五五。 为什么会变成零零。 我上小节已经解释过了。 最后面这三个数据为什么是这三个数。 这个留给大家自己验证呢。 实际上如果不执行查询二。 读取的数据等于原始数据按位与上写入的数据。 大家可以验证一下。 那通过这个实验我们就知道了。 写入数据前必须擦除。 否则直接覆盖改写的数据啊。 大概率是错的。 最后我们再来验证一下。 写入数据不能跨页的现象。 这个注释解释啊。 上下要点。 这里我们也研究了页地址的规律啊。 页地址的范围是叉叉叉叉零零到叉叉叉叉f f。 所以这里最后两个16进制数是页内地址。 前面四位是液离子。 我们可以给最后两位f f。 这是一页的最后一个地址。 从最后一个地址开始写。 看看能不能成功跨越到下一页的。 0x000100 之后读取数据啊。 也从f f开始读编译下载看一下。 这次可以看到写入55667788。 读书的却是55f f f f f f。 这说明写入数据并没有跨页哈。 这个五五协助的地址。 0f f后面的六六并没有跨越到下一个地址。 100。 而是返回第一页的页数。 000呢又因为读取是能跨越的。 所以读到的这三个f f是第二页的数据。 第二页是它所拉的没有写入。 所以默认是f f。 那我们再把读取改到第一页的起始位置。 零零看一下之前写入的后三个字节。 是不是在第一页的起始位置啊。 编译看一下。 可以看到果然这三个字节是在第一页这里。 这些步骤啊。 画个图表示。 就是比如这是存储器的存储空间。 第一页开始地址是零零。 第一页结尾地址是f f。 第二页开始地址是100。 我现在从第一页的最后一个字节f f开始写。 连续写入四个字节。 第一个数据五五肯定是在指定位置的。 关键就是下一个世界。 由于地址f f到100。 这之间跨越了页边沿。 这个存储器是不能跨页写入的。 所以下一个数据不是按照地址连续的关系。 写到1000。 而是会回到第一页的。 页数也是零零位置。 开始写。 这里667788这样来执行的。 这是页编程的注意事项。 不能跨页写入。 如果你确实有一个很大的数字要连续写入啊。 那就只能自己从软件上分批次进行协助了。 就是先计算你的数组总共需要跨多少页。 然后该擦除的擦除。 最后再分批次一页一写。 这个操作可以封装成一个函数哈。 之后调用封装的函数就可以跨页连续写入了。 这个功能就留给大家自己进阶完成了啊。 那本了解我们的代码部分到这里就要结束了。 这个代码呢先恢复成我们最开始演示的样子哈。 好那我们本小节就到这里。 下一小节我们来开始学习s t m32 的硬件。 spi。 外设。 用硬件spi的方式来实现同样的功能哈。 那我们下一小节再见。
39. 大家好。 欢迎回来。 本小节我们来继续学习spi通信啊。 这次我们学习的是硬件spi。 跟之前fc的思路一样哈。 大家应该已经有经验了。 软件s p i就是我们用代码手动翻转电平。 来实现时序。 硬件spi就是使用s t f3 r内部的s spi。 外设来实现时序。 两种实现方法各有优势啊。 软件实现主打的是方便灵活。 硬件实现主打的是高性能。 节省软件资源。 来看一下ppt spi外设简介。 第一条s t m32 内部集成了硬件。 spi收发电路。 可以由硬件自动执行时钟生成数据收发等功能。 减轻cpu的负担。 就是硬件电路自动生成时序啊。 不用我们自己手动翻转电瓶。 节省软件资源。 这个就不用多说了哈。 然后下面这些是s t m32 内部。 s spi外设的一些功能和技术参数。 其实手册里介绍这些功能还是比较繁杂的哈。 这是因为硬件电路不像软件那么灵活。 硬件电路一带设计出来。 它的功能基本上就定死了。 之后只能通过一些开关电路啊。 数据选择器等等来微调电路的运行。 不像软件那样啊。 我们缺少功能。 只需要去copy代码就行。 所以s t m32 设计时。 就要考虑最全面的应用场景。 把各种可能的结构都设计出来放在了。 以免你用的时候找不到啊。 那这样就会导致外设电路的结构和知识点。 非常多。 而且有很多功能我们基本上很少用到哈。 所以sdmi 2我们要使用主线加分支的学习方法。 我们先把最常用最简单的主线知识点给贯通。 给他学会了。 然后再逐渐细化。 在实践中去慢慢探索这些分支哈。 这样学习起来才是比较容易的。 所以大家在看手上学意思啊。 有一些感觉非常偏又非常难的知识点。 可以先不必深究。 先把主线任务学习好。 其他的可以之后再研究哈。 好那我们来看一下功能参数。 第一条可配置八位或16位数据帧。 高位先行或低位先行。 这里我们spi最常用的配置就是八位数据中。 高位限行。 那16位数据帧是什么意思呢。 我们可以看一下这个spi的波形。 这里可以看到哈。 每次交换的数据都是八个bit。 这就是八位数据帧。 八位数据帧是最常见的哈。 我们通信一般都是以字节为单位。 一个字节就是八位。 那tm 32还可以设计成16位的数据帧。 就是我们可以在dr写入一个uint。 幺六杠t类型的数据。 这样他一次性就可以发16位。 有的是两个字节。 在这个波形上看啊。 16位数据帧的波形。 应该是和发两次八位数据是一样的。 我们一般用八位即可啊。 16位的用的很少。 然后还有就是高位线性和低位限行。 在s p i里基本上都是高位限行的哈。 比如这里的我想发0x34。 把它转换为二进制。 就是00110100。 左边是数据高位。 右边是数据低位。 在产生波形时啊。 数据是由高位到低位依次出现的。 这就是高位限行。 我们s spi和i phone c都采用了高位线性的策略。 与之不同的是串口。 串口是低位线性的哈。 我们看一下波形。 比如这里是发送0x55 的波形。 0x55 转为二进制。 是01010101。 左边是数据高位。 右边是数据低位。 在产生波形时。 数据由低位到高位一次出现。 所以这里的波形按从前到后是1010。 1010。 在看它对应的数据时。 要从右往左看。 0101。 0101对应0x55 啊。 这样才对。 之前有人说我这个图画错了哈。 这里并没有画错。 低位先行。 要反过来看这个注意一下。 然后我们回到spi继续来看下一条时钟频率。 就是s k波形的频率。 一个s k时钟交换一个beat。 所以时钟频率一般体现的是传输速度啊。 单位是赫兹或者b每秒。 那这里的时钟频率是fpcl k。 除以一个分频系数。 分配系数可以配置为二或四或86。 32 64。 128。 256。 所以可以看出来。 spi的时钟其实就是由pcl可以分屏得来的。 p c l k就是外设时钟。 a p p2 的p c l k就是72兆赫兹。 a p p一的p c l k是36兆赫兹。 比如我们的s p i一啊。 是a p p2 的外设。 pcl k等于72兆赫兹。 那它的spi时钟频率最大就是只进行二分频。 72兆除2=36兆赫兹。 像我们之前fc的频率啊。 最大就只有400k赫兹。 所以这里s p i的最大频率比fc啊快了90倍。 然后这里频率有些注意事项哈。 一是这个频率数值并不是任意指定的。 它只能是p c r k。 执行这些分屏后的数值就只有这八个选项。 最低频率是pcl k的256分屏。 二是s p i一和s p i2。 挂载的总线是不一样的。 spi一挂载在a p p2 p c l k是72兆。 s p r2 等等。 挂载在a p p1 p c l k是36兆。 所以同样的配置。 spi一的时钟频率要比spi 2的大一倍。 这个注意一下。 那这就是时钟的配置将继续啊。 支持多主机模型组或重操作。 这个spi多主机模型啊。 只做了解即可。 和之前fc一样。 手册里也有大量篇幅介绍了。 多组机或者重击模式。 写的还是比较复杂的。 不过这些我们用的都很少啊。 我们只学习spi做主机的情况就行了。 然后下一项可精简为半双工或单工通信。 这些也是为了照顾特殊情况设定的。 就是我们正常的spi是两根数据线。 一根m o s i用于主机发送。 一根m s o用于主机接收。 这是全双工半双工。 就是如果我们去掉一根数据线。 只在其中一根线上分时进行发送或接收。 这是半手工的通信。 节省一根通讯线啊。 弹弓就是如果我们直接去掉接收的数据线。 在发动线进行自发的数据传输。 那就是单工通信只发模式。 如果直接去掉发送的数据线。 在接收线进行只收的数据传输。 那是单工通信只收模式。 这也是s t m32 对s p i进行了一些改动哈。 可以为特殊情况提供硬件支持。 不过既然我们选择了spi。 正常情况下应该发挥它传送功能优势对吧。 所以这些经典模式我们一般不用大家了解即可。 接着是支持dma。 这个是让dma来帮我们自动搬运数据的哈。 如果我们需要快速传输大量的数据。 那使用dma就比我们手动操作更高效。 但少量数据的话就没必要了。 然后最后是兼容iphone s协议。 这个fs是一种音频传输协议啊。 它和fc的区别还是挺大的。 不要搞混了。 iphone x和iphone c除了名字差不多。 都是飞利浦公司提出的外。 其他地方基本上是完全不一样的。 fs是一种数字音频信号传输的专用协议。 大概的应用场景哈。 我简单介绍一下。 大家了解即可。 比如这是我们的主控芯片。 芯片里面存了一首音乐的数据。 这个数据其实就是一个点一个点的电压数值哈。 是数字信号。 如果我们要把这个音乐给播放出来。 就得外挂一个音频解码器。 这个音频解码器实际上就是dac数模转换器啊。 他负责把数字信号转换成模拟信号。 然后输出的扬声器把音乐播放出来。 那我们把数字信号发送到dac的这条线路。 数据怎么发。 每位数据的定义是什么。 持续该怎么产生。 传输速度是多快。 这些配置啊都可以制定一个标准。 这个标准就是数字音频传输协议。 那iphone s就是其中一种。 这是ifs应用的领域。 主要用来传输数字音频信号。 那因为这个iphone s和s p i还是有些共。 同的特性啊。 所以s t m32 就把s p i和ifs做到了一起。 有些电路可以共用。 最大化利用资源。 然后手册里spi这一章哈。 也是有一半的内容都在介绍iphone s。 这个大家知道fs是什么东西就行了啊。 感兴趣的话可以看看。 我们暂时用不到好。 那这些就是s spi外设大概的技术参数了。 功能虽然很多。 但是后面这些哈都只了解即可。 最后看一下我们这个型号。 s t m32 的spi资源。 s t m32 f103 c8 t6。 硬件spi资源有s p i一和s p i2。 其中s p i一是a p p2 的外设。 s p i2 是a p p一的外设。 这个开启时钟的时候需要注意一下。 另外如果要计算sc k时钟频率的话。 也要注意一下这个问题。 剩下其他的操作基本上没有区别啊。 那简介我们就看到这里。 接下来看一下spi的框图。 那先整体看一下这个图啊。 我们可以大致把它分成两部分。 左上角这一部分就是数据计算器和移位进器。 打配合的过程。 这个和串口iphone c那里的设计思路。 都是异曲成功的哈。 主要是为了实现连续的数据流。 一个个数据前仆后继的一个效果。 然后剩下右下角这一部分。 就是一些控制逻辑的进容器的哪些位控制。 哪些部分会产生哪些效果。 这个可以通过手册的计数器描述来得知啊。 至于执行细节。 这里也没详细化。 我们就知道功能就行了。 那我们接着来详细看一下每部分的功能。 首先左上角核心部分就这个移位寄存器。 右边的数据低位一位一位的从m o s i移出去。 然后ms so的数据一位一位的移入到左边的数据。 高位显然因为净水器应该是一个右翼的状态。 所以目前图上表示的是低位线型的配置。 对右下角有一个lsb force的控制位。 这一位可以控制是低位先行还是高位先行啊。 手册里进器描述可以查一下哈。 这里lsb first的真格式给您先发送m s b。 m s b就是高位的意思啊。 给一先发送l s b l s b就是低位的意思啊。 那ppt这里目前的状态lsb force的应该是一啊。 低位先行。 如果l s b first给零高位显形的话。 这个图还要变动一下。 就是一位进入器变为左移输出。 从左边移出去输入。 从右边移进来。 这样才符合逻辑对吧。 然后继续看左边这一块。 这里画了个方框。 里面把msi和mi so做了个交叉。 这一块主要是用来进行主从模式引脚变换的。 我们这个spi外设可以做主机。 也可以做统计。 做主机时这个交叉就不用。 msi为mo主机输出。 m so为mi主机输入这主机的情况。 如果我们s t m32 作为重机的话。 m o s i vs i重击输入。 这时他就要走交叉的这一路啊。 输入的一位计算器。 同理m s o v s o重击输出。 这时输出的数据也走交叉的这一路输出到m s。 但这里如果这样理解没错的话。 这个箭头可能是画错方向了哈。 应该是往下走的。 这样才符合逻辑哈。 那这就是这个交叉的作用。 简而言之就是主机和从机的输入输出模式不同。 如果要切换主机和重击的话。 线路就需要交叉一下。 当然如果我们始终做主机的话。 那这个交叉就不用看了哈。 那这一块电路从这里到这里。 是不是就和我们前面讲的一样哈。 这里主机里就这样的结构。 这里画的是高位线性啊。 所以高位输出的m y s i m s o输入的低位。 然后还可以看到msi主机是输出。 重击是输入。 m so主机是输入。 重击是输出。 如果你主机要变为重击。 那显然msi和mi so要交叉一下。 就是这一部分内容。 然后回过来继续看。 接下来上下两个缓冲区。 就还是我们熟悉的设计哈。 这两个缓冲区实际上就是数据计算器低压。 下面发送缓冲区就是发送数据用期。 t d i上面接收缓冲区就是接收数据进去。 2.2和窗口拉底一样哈。 t dr和r d r占用同一个地址。 统一叫做dr写入dna数据。 从这里写入到t d r。 读取dr数据。 从这里从2d r读出数据。 计算器和移位进器打配合。 可以实现连续的数据流。 具体流程就是比如我们需要连续发送一批数据。 第一个数据写入到t d r。 当以为计算器没有数据移位时。 gdr的数据会立刻转入移位进器。 开始移位。 这个转录时刻绘制状态。 计算器的tx e为一。 表示发动机容器空。 当我们检查tx e之一后。 紧跟着下一个数据就可以提前写入到t d r里。 后者了。 一旦上个数据发完。 下一个数据就可以立刻跟进。 实现不间断的连续传输。 然后移位寄存器。 这里一旦有数据过来了。 它就会自动产生时钟将数据移。 数据在移出的过程中。 miso的数据也会移入。 一旦数据已出。 完成数据移入是不是也完成了。 这时移入的数据就会整体的从一位计算器。 转入到接收缓冲区。 2.2。 这个时刻会自状态接容器的rx n e为一。 表示接收计容器非空。 当我们检查x n e之一后。 就要尽快把数据从2d r读出来。 在下一个数据到来之前。 读出r d r就可以实现连续接收。 否则如果下一个数据已经收到了。 上个数据还没从r d r读出来。 那r d r的数据就会被覆盖哈。 就不能实现连续的数据流了。 这是一微镜器配合数据用器。 实现连续数据流的过程。 简而言之就是发送数据先写入t d r。 再转到移位。 定期发送。 发送的同时接收数据。 接收到的数据转到2d r。 我们再从2d r读取数据数据。 净水器和移位净器配合。 可以实现无延迟的连续传输。 这是这一块的设计思路。 是不是和之前串口fc的都差不多的意思啊。 当然这三者也是有一些区别的哈。 比如这里sp全双工发送和接收同步进行。 所以它的数据计算器发送和接收是分离的。 而移位寄存器发送和接收可以共用啊。 然后看一下前面iphone c的框图。 这里因为fc是半双工。 发送和接收不会同时进行。 所以它的数据电器和移位寄存器。 发送和接收都可以是公用的。 最后再看一下窗口的框图。 这里串口是全双工。 并且发送和接收可以异步进行。 所以这就要求它的数据用气。 发送和接收是分离的。 一位精气发送和接收也得是分离的。 就是这三个通信协议在这一块的设计啊。 设计理念相同。 但是执行的细节是不同的。 好我们回到pi这里。 继续来看这个框图。 左上角就讲完了。 左上角这一块是比较重要的哈。 它是s spi通信的核心部分。 体现了发送和接收的执行流程。 也是我们写程序的依据哈。 所以需要重点掌握。 然后接下来我们看一下右下角这些内容。 这就是一些控制逻辑的。 我们看一下。 首先是波特率发生器。 这个主要就是用来产生sk始终的。 它的内部主要就是一个分频器。 输入时钟是p c l k72 兆或36兆。 经过分频器之后输出到s k引脚。 当然这里生成的时钟。 肯定是和移位寄存器同步的啦。 每产生一个周期的时钟移入移出一个beat。 然后右边c r一计算器的三个v b20 b r1。 b r2 用来控制分屏系数。 从这里可以看一下。 这里b r2 到零是波特率控制这三位协助。 下面这些值。 可以对p c r k始终执行2~256的分。 屏。 分屏之后就是s c k始终。 所以这一块就对于来之前这里说的时钟。 频率是f p c l k的2~256分屏。 那这就是波特率发生器的部分。 接着后面这些通信电路和各种计容器啊。 都是一些黑盒子电路。 如果你要具体研究。 可以看一下这些位的计算器描述。 我挑几个重点的讲一下。 比如lsb force的刚才说过。 决定高位限行还是低位先行。 s p e是s p s人。 就是s p c m d函数配置的v哈b2。 配置波特率。 就是sk时钟频率m i s t r配置主从模式。 一是主模式。 零是从模式。 我们一般用主模式c p u l和cp ha。 这个之前讲过啊。 用来选择spi的四种模式。 然后这里sr状态计算器。 最后两个tx e发送计算器。 空2x n e g o计算器非空。 这两个比较重要啊。 我们发送接收数据的时候需要关注这两位。 最后cr 2接入器就是一些死人位了。 比如中断使能d ma死人等。 然后剩下的一些位用的不多啊。 大家可以在自行研究。 那最后这里还有一个n s s引脚。 s s就是重新选择哈。 低电平有效。 所以这里前面加了个n。 这个n和s s。 和我们想象的统计选择可能不太一样哈。 我们想象的应该是用来指定某个重击对吧。 但是根据手册里的描述。 我也研究了一下这里的n s s设计啊。 可能更偏向于实现这里说的多主机模型。 总的来说啊。 这个m s s我们并不会用到s硬件。 我们直接使用一个gpo模拟就行。 因为s s引脚很简单。 就是一个高低电平就行了。 而且多重击的情况下。 s s还会有多个。 这里硬件的n s s也完成不了。 我们想要的功能哈。 那这个n s s是如何实现多主机切换的功能呢。 我简单介绍一下啊。 大家听一听就行。 不用掌握。 假如这里有三个s tm 30设备。 我们需要把这三个设备的n ss全都连接在一起。 首先这个n ss可以配置为输出或者输入。 当配置为输出时啊。 可以输出电平告诉别的设备。 我现在要变为主机。 你们其他设备都给我变重击。 不要过来捣乱。 当配置为输入时。 可以接收别设备的信号。 当有设备是主机拉低n s s后。 我就无论如何也变不成主机了。 这就是它的作用。 然后内部电路的设计啊。 当这里这个s s o e等于一时。 n s s作为输出硬件。 并在当前设备变为主设备时。 给n s s输出低电平。 这个输出的低电平啊。 就是告诉其他设备。 我现在是主机了。 当主题结束后。 s s o e要清零。 n s s变为输入。 这时输入信号就会跑到右边这里。 这个数据选择器s s mv决定选择哪一路。 当选择上面一路时是硬件n s s模式。 也就是说这时外部如果输入了低电平。 那当前的设备就进入不了主模式了。 因为n s s低电平肯定是。 外部已经有设备进入了主模式。 他已经提前告诉我他是主模式了。 我就不能再跟大家抢了。 当数据选择器选择下面一路时。 是软件管理n s s输入n s s是一还是零。 由这一位s s i来决定这个多主机的模型啊。 举个例子就是n s输入就是留了个小辫子。 一旦我的小辫子被别人揪住了。 我就只能乖乖听话。 所以我可以把所有人的小辫子接在一起。 谁要当主机就先跳出来。 从自己的小辫子输出低电平。 揪住其他所有人的小辫子。 这时其他所有人都得乖听话了。 如果这时其他人也想跳出来做主机呢。 他就会发现自己的小辫子被别人揪住了。 那他就做不了主机了。 只能先乖乖听话。 就是这个nas实现多主机的思路。 但这个设计是n s s。 作为多重机选择的作用消失了。 揪出所有人的小辫子之后。 主机发送的数据就只能是广播。 发送给所有人的打。 如果想实现指定设备通信。 可能还需要再加入寻址极致哈。 所以实现起来还是比较复杂的。 但我自己其实也没试过这种玩法。 这里是根据我看手册的理解。 我觉得应该是这样玩的哈。 实际使用的话可能还有很多事情要考虑。 不过还是pi。 最多的情况还是一组多重或者一组一重啊。 我们掌握一组多重就行。 多主机的情况了解即可好。 那这个s p i框图我们就讲完了。 这个图。 我们需要重点掌握一位进器和数据计算器。 这部分。 然后波特率发生器和部分重要的机容器。 也理解一下。 最后n s s引脚实现多主机了解即可。 我们暂时用不到。 那看完了详细的框图。 我们再看一下。 这里我总结了一个简化结构吧。 这个结构我把上面这个框图。 无关的东西都去掉了。 这样看起来是不是就更容易理解哈。 大致看一下其中核心部分。 当然就是这个数据容器和移位运用器啦。 这里发送和接收我直接叫做发送数据运算器。 t dr和接收数据运用器二dr了。 因为我觉得这样表示更清晰哈。 之前串口框图里也是这样表示的哈。 但是spi控图这里。 它又叫发送缓冲区和接收缓冲区。 命名可能不太统一哈。 因为这个手册可能是多个人分工写。 最后整合到一起的。 所以有时候我就发现手册不同的章节。 描述手法和词汇可能都不一样。 但是大家要有自己的判断哈。 知道他们其实是一个东西就行。 然后这里移位计算器。 我画的是左移高位移出去。 通过g p i o到m o s i。 从m o s i输出。 显然这是s p i的主机对吧。 之后引入的数据从m i s o进来。 通过gp i o到移位寄存器的低位。 这样循环八次。 就能实现主机和重击交换一个字节。 然后t d r和r d r的配合。 可以实现连续的数据流啊。 这刚才和之前的课程已经分析过很多次了哈。 另外t dr数据整体转入一未进七的时刻。 至tx e标志为一位计算器。 数据整体转入二dr的时刻。 至2x n e标志为t d r。 t x e r d r i x n e这几个词再记一下。 等会儿会经常提到的。 别搞混了。 然后剩下的部分波特率发生器。 产生时钟输出到s c k引脚。 数据控制器呢就看成是一个管理员。 它控制着所有电路的运行。 最后开关控制就是s p i c m d初始化之后。 给个以label使人整个外设。 另外这里我并没有画ss统计选择硬件哈。 这个硬件我们还是使用普通的gp l o来模拟。 即可。 在一组多重的模型下。 gp l o模拟的ss是最佳选择。 好那这就是spi的系统光图和简化的结构了。 我们在写代码的时候。 会用一个结构体来统一配置这些部分。 比如高位限行还是低位限行啊。 cpu l和cpa ja选择cpu模式。 主机还是手机。 时钟频率是多少等等等等。 这些参数。 用一个结构体统一配置旋转参数就行了。 所以代码部分应该是不复杂的哈。 那初始化部分解决之后。 我们就要来看一些运行控制的部分呢。 如何来产生具体的时序呢。 什么时候写dr。 什么时候读dr呢。 这是我们接下来学习的知识点。 读写dr产生时序的流程。 我们主要看这两个时序图即可。 第一个是主模式全双工连续传输。 这个图演示的是借助缓冲区数据前仆后继。 实现连续数据流的过程。 但是这个流程稍微比较复杂哈。 也不太方便分装。 所以在实际过程中。 如果对性能没有极致的追求。 我们更倾向使用下面这个非连续传输的示意图。 这个非连续传输使用起来更加简单。 实际用的话只需要四行代码就能完成任务了。 那参考网上别人的代码呢。 基本上都是非连续传输的方式。 我们课程也使用非连续传输的代码。 非连续传输的好处就是容易分装好理解好用。 但是会损失一丢丢性能。 连续传输呢传输更快。 但是操作起来相对复杂。 那我们来分别具体分析一下哈。 先看一下主模式全双工连续传输的意图。 首先第一行是s c k死中线。 这里c p o l等于一。 c p h a等于一。 示例使用的是spi模式三哈。 所以s c k默认是高电平。 然后在第一个下降沿m o s i和mi so。 已出数据之后上升沿引入数据。 依次这样来进行。 那下面第二行是msi和mi so输出的波形。 跟随s c k始终变化啊。 数据位依次出现。 这里从前到后依次出现的是b0。 b11 直到b7。 所以这里示例演示的是低位先行的模式啊。 实际s p i高位线型用的多一些。 这个知道一下。 但对我们理解时序影响也不大哈。 最后第三行是tx e发送进入器空标志位。 波形是这样的。 等会儿再分析。 下面继续看。 是发送缓冲器括号写入s p i d。 实际上就是这里的t d啊。 然后b s y busy是由硬件自动设置和清除的。 当有数据传输时。 ba至一。 那上面这部分演示的就是输出的流程和现象。 然后下面是输入的流程和现象。 第一个是mi so msi的输入数据。 最后是i x n e接收数据。 运气非空标志为。 最后是接收缓冲器读出s p i d i。 显然就是这里的2d2 了。 好了解完各个信号的定义了。 我们来从左到右依次分析啊。 首先s至低电平开始持续这个美化。 但是必须得有的。 在刚开始时tx为一。 表示t d r空可以写入数据开始传输啊。 然后下面指示的第一步就是软件写入0x f1。 至s p i d r。 0x f一就是要发送的第一个数据之后。 可以看到写入之后t d r变为0x f1。 同时tx e变为零。 表示t d r已经有数据了。 那此时t d r是等候区一位运动器。 才是真正的发送区。 移位寄存器。 刚开始肯定没有数据啊。 所以在等候区t dr里的f1。 就会立刻转入一位正企开始发送。 转入瞬间至tx e标志为一。 表示发送计算器空。 然后一位计算器有数据了。 波形就自动开始生成。 当然我感觉这里画的数据波形。 时机可能有点早哈。 应该是在这个时刻。 b0 的波形才开始产生。 在这之前数据还没有转入移位进器呢。 所以感觉b0 出现的可能过早了。 不过这个也不影响我们理解哈。 大家知道这意思就行好了。 这样数据转入移位寄存器之后。 数据f一的波形就开始产生了。 在一位产生f一波形的同时。 等候区t d r是空的。 为了一位完成时。 下一个数据能不间断的跟随。 这里我们就要提早把下一个数据写入到tdd。 等着了。 所以下面只是第二步的操作。 是写入f一之后。 软件等待tx一等于一。 在这个位置。 一旦t d r空了。 我们就写入f2 至s p i d i写足之后。 可以看到t d r的内容就变成f2 了。 要是把下一个数据放到t d r里。 后者之后的发送流程也是同理哈。 f一数据波形产生完毕后。 f2 转入移微动器开始发送。 这时tx一等于一。 我们尽快把下一个数据f3 放到gdd等着。 就是这里的操作软件等待tx一等于一。 然后写入f3 之d啊。 写入之后t d r变为f3。 最后在这里如果我们直向发送三个数据啊。 f3 转入移位寄存器之后。 tx一等于一。 我们就不需要继续写入了。 tx e之后一直是一。 注意在最后一个tx一等于一之后。 还需要继续等待一段时间。 f3 的波形才能完整发送完。 等波形全部完整发送之后。 b的标志由硬件清除。 这才表示波形发送完成的。 那这些就是发送的流程。 然后继续看一下下面接收的流程。 s p i s全双工发送的同时还有接收。 所以可以看到在第一个字节发送完成后。 第一个字节的接收也完成了。 接收到的数据一是a1。 这时一位计算器的数据整体转入2d r。 2d r随后存储的就是a1。 转入的同时按x n e标志位也是一。 表示收到数据了。 我们的操作是下面这里写的软件。 等待2x n e等于1=1表示收到数据了。 然后从s p i d r也是2d r读出数据a1。 这是第一个接收到的数据结束之后。 然后当下一个数据二收到之后。 x n e重新制。 我们监测到x n e等于一时就继续读出r d r。 这是第二个数据a2。 最后在最后一个字节时序完全产生之后。 数据三才能收到谁数据删。 直到这里才能读出来。 然后注意啊。 一个字节波形收到后。 一位计算器的数据自动转入r dr。 会覆盖原有的数据。 所以我们读出r d r要及时。 比如a一这个数据收到之后。 对此你也要在这里把它读走。 否则下一个数据a2 覆盖一。 就不能实现连续数据流的接收了。 这是整个发送和接收的流程。 这个连续数据流啊对软件的配合要求较高。 在每个标志位产生后。 你的数据都要及时处理。 配合得好。 始终可以连续不间断的产生。 每个字节之间没有任何空隙啊。 传输效率是最高的。 如果你对传输效率有非常高的要求。 那就要好好研究这个连续数据流传输啊。 但是我们入门的话。 可以先不用这个。 因为这个操作比较复杂。 而且数据的位置交叉比较多。 比如在这个位置。 我们发送数据一。 按理说交换字节发送的。 我们就想看一下接收的是什么对吧。 但在这里接收的数据一直到这里才能收到。 而在这之前。 我们就要把发送的数据二写入到tdr了。 所以它的流程并不是我们想象的发送数据一。 接收数据一。 发送数据二。 接收数据二。 这样依次交换。 而是发送数据一。 发送数据二之后接收数据一。 然后再发送数据三。 接收数据二。 发送数据四。 接收数据三。 这个交换的流程是交错的。 对我们程序设计不太友好啊。 总之如果你对效率要求很高。 就研究下这个。 否则的话。 我们更推荐下面这个非连续传输。 非连续产出啊。 对于程序设计非常友好。 只需要设行代码就可以完成。 那它是怎么执行的呢。 我们来看一下。 这个就是非连续传输发送的示意图。 下面这里只有发送的一些波形哈。 接头部分的波形没画出来。 但是我们也可以想象得到接头是什么样子的。 等会儿我也会给大家展示一下接收的波形啊。 那我们看一下这个非连续传输和连续传输。 有什么区别呢。 首先这个配置还是s spi模式。 三sk默认高电平。 我们想发送数据时。 如果检测到tx一等于一了。 t d r为空。 就软件写入0x f一至s p i d r。 这时t d r的值变为f1。 tx一变为零。 目前移位寄存器也是空号。 所以这个f一会立刻转入移位进器。 开始发送波形产生。 并且tx自回一。 表示你可以把下一个数据放在tdr里后着了。 但是现在区别就来了。 在连续传输到这里。 一旦tx z等于一了。 我们就会把下个数据写到t dr里。 后者这样是为了连续传输数据衔接更紧密。 但是刚才说了。 这样的话。 流程就比较混乱。 程序写起来比较复杂。 所以在非连续参数这里。 dx e等于一了。 我们不着急把下一个数据写进去。 而是一直等待。 等第一个字节持续结束。 在这个位置持续结束了。 是不是意味着接收第一个字节也完成了。 这时接收的i x n e会之一。 我们等待rsn一至一后。 先把第一个接收到的数据读出来之后。 再写入下一个字节数据。 也就是这里的软件。 等待tx一等于一。 但是较完写入0x f2 至s p i t r。 教完写入t t r后。 数据二开始发送。 我们还是不着急写数据三。 等到了这里。 先把接收的数据二收着。 再继续写入数据上。 数据删。 持续结束后。 最后再接收数据三。 置换回来的数据。 你看按照这个流程的话。 我们的整个步骤就是第一步等待tx g为一。 第二步写入发送的数据是t d r。 第三步等待二次ne为一。 第四步读取rdr接收的数据之后。 交换第二个字节。 重复这四步。 第一步等待tx e为一。 第二步写作发送的数据是t d r。 第三步等待2x n一为一。 第四步读取r d r接收的数据之后。 交换第三个字节也是同理。 那这样我们就可以把这四部分装到一个函数。 调用一次。 交换一个字节。 这样程序逻辑是不是就非常简单了。 和之前软件spi的流程基本上是一样的。 我们只需要稍作修改。 就可以把软件spi改成硬件spi。 这个我们下一小节再来演示啊。 这是非连续传输的流程。 那非连续算出缺点。 就是在这个位置没有及时把下一个数据写入tt。 后者。 所以等到第一个字节时序完成后啊。 第二个字节还没有送过来。 那这个数据传输就会在这里等着。 所以这里时钟和数据的时序啊。 在字节与字节之间会产生间隙。 拖慢了整体数据传输的速度。 这个间隙在s k频率低的时候影响不大。 但是在s k频率非常高。 时间隙拖后腿的现象就比较严重了。 比如我这里用示波器看了一下。 不同sk频率间隙的影响。 结果。 这里有四个波形。 它们的s j k分频系数分别是264。 128。 28 56。 先看一下最慢的哈。 256分屏。 这个sk频率是72兆。 除26。 大概280k图示上面是sk信号。 这里使用spi模式零二。 所以默认低电平。 下面是s4 信号。 低电平表示选中重击。 这个波形是s p i。 非年计算出交换五个字节的时序。 主要看一下sc k线。 这里连续交换了五个字节。 但是你几乎看不出字节与字节之间的间隙对吧。 因为这个时钟频率比较慢。 间隙时长也不大。 所以在这个比较慢的波形看来。 间隙对它的影响就可以忽略了。 之后呢我们加快时钟看一下波形。 下一个图是128分米。 s k频率大概560k。 这时就更明显的看出来字节之间的间隙了吧。 字节和字节之间并不是严丝合缝的。 这会降低整体的字节传输速度。 但是从这个比例上看啊。 这一点点间隙也可以忽略不计的。 但是之后我们继续加快时钟。 下一个图64分屏htk频率大概一兆多点。 因为频率增大。 时间尺度缩小。 这样看来间隙就更加明显了。 然后进一步加快时钟频率呢。 六四分屏后面还有30 26 842分屏。 s k频率会越来越大。 我们直接看一下最快的二分屏。 最后一张图啊。 这个sk时钟频率是72兆。 除2=36兆。 频率非常快了哈。 已经超过这个示波器的采样频率。 所以每个字节的始终已经看不完整了哈。 但是哪里在传输。 哪里是间隙还是可以区分的。 这里可以看到间隙所占的时间比例。 已经是数据传输的好几倍了。 这时再忽略间隙就不合适了吧。 如果你忽略了间隙。 那计算一下二分屏的数据传输速率。 应该是256分屏的128倍。 当你实测一下。 它肯定达不到这么高。 为什么。 因为这个二分屏虽然干活效率高。 但他每干一个时间。 单位就要休息好几个时间单位。 这怎么能达到它所生成的效率呢是吧。 所以通过看这个波形我们就清楚了。 如果你想在极限频率下。 进一步提高数据传输速率。 也是追求最高性能。 那最好使用连续传输的操作逻辑。 或者还要进一步采用dma自动转运。 这些方法效率都是非常高的哈。 否则的话我们使用非连续删除集合四行代码。 完成任务。 简单易理解。 那有关sp i的配置和操作流程。 我就讲到这里。 最后我们还是惯例啊。 简单看一下软硬件波形对比。 这里上面是软件模型。 下面是硬件模型。 这些和fc的转移下波形对比啊。 其实都是差不多的。 首先他们的数据变化趋势肯定是一样的。 采样得到的数据也是一样的。 区别。 就是硬件波形。 数据线的变化是紧贴s c k边缘的。 而软件波形数据线的变化在变延后有一些延迟。 实际上我们还可以发现哈。 iphone c所描述的s c l低电平期间数据变化。 高电平期间。 数据采样和s p i所描述的s t k下降。 沿数据移出上升。 沿数据移入最终波形的表现形式啊都是一样的。 无论是下降沿变化还是低电平期间变化。 它们都是一个意思啊。 下降眼和低电平期间。 都可以作为数据变化的时刻。 只是硬件波形一般会紧贴边缘。 软件波形一般只能在电瓶期间。 当然无论是哪种方式。 最终都不会影响数据传输。 不过软件波形如果能贴近边缘。 我们还是贴近边缘。 为何啊。 否则如果你等太久。 比较靠近下一个边缘的。 那数据也容易出错。 对吧好。 有关spi外设的ppt。 我就讲到这里主要是两部分。 前面是光头结构。 主要用于初始化配置。 后面是时序流程。 主要用于控制数据传输。 那最后我们还是来看一下手册。 手册。 第23章是spi的知识点。 这里简介写的是啊。 在大容量产品和互联型产品上。 spi接口可以配置为支持spi协议。 或者支持iphi c音频协议。 s spi接口默认工作在s p i方式。 可以通过软件把功能从spi模式。 切换到iphone x模式。 在小容量和重量产品上不支持iphone x音频协议。 我们这个c8 t6 芯片是重量的产品。 所以也没有ifs。 然后下面这些是spi和方案式的主要特征啊。 大家可以看看。 建设框图这个我们仔细分析过啊。 下面是一些介绍。 结合之前的分析。 大家可以课下再看看这个n s s角管理呢。 大家看不懂的话。 不必深究。 我们使用g p i o模拟这个引脚。 也不用这个功能哈。 然后始终相位和时钟极性。 这个和我们最开始讲s p i那里是一样的。 这个图演示的其实就是s p i的四种模式啊。 c p u l时钟即兴决定空闲状态。 s c k的默认电平。 c p h a始终相位绝对是第一个边缘开始采样。 还是第二个边缘开始采样。 这个图大家可以对照我们前面讲的再看看。 然后下面spi的重模式我们用的不多。 暂时不用学习。 最后总模式我们需要用到这里。 是主模式的配置步骤。 但是它都是系统性的描述方式。 实际配置我们用库函数的初始化结构体来配置。 最终实现和自己效果一样。 而且库函数更容易理解哈。 数据发送和接收过程。 就数据容器和移位寄存器的配合过程。 另外tx e2。 x n e这两个重要的标志位也得理解清楚。 只要这个过程清楚了。 这里的文字理解起来就容易多了。 这是这一块。 接后面配置。 pi为单工通信。 这个标题。 英文手册里写的意思是配置spi为半双工通信。 这里直接写的是弹弓。 可能是翻译错了哈。 那下面这些就是对spi进行一些裁剪了。 把标准的传送公。 spi变为一条时钟线和一条双向数据线。 这其实就是半生公开。 或者一条直通线和一条单向数据线。 就是单攻。 所以这些是s p i插件功能的描述。 当然我们用的也非常少了。 了解即可。 之后数据发送与接收过程。 这里分类非常多哈。 但是我们只需要看主模式全双工的部分就行。 其他的基本用不到。 那后面这个图就是我们ppt介绍的啦。 主模式全双工模式下连续传输。 如果你追求极限频率。 就使用这个流程来写程序啊。 这后面这些其他杂七杂八的模式。 都不太需要看的。 最后这里是非连续传输发送的流程。 这个我们也介绍过。 我们写代码就用这种比较简单的方式来写。 这也足够满足大多数情况了。 然后下面是cr c计算。 这个是可以在数据流后面加个c r c降压码。 用于确定数据有没有传输出错啊。 这个我们也不用哈。 感兴趣的话看一下。 接下来状态标志位t x e x n e。 这两个我们提了很多次了吧。 大家应该也清楚了。 然后关闭spi这个了解即可。 利用dma的sb i通信也了解即可。 如果你追求效率的话。 再来研究一下dma。 最后错误标志和中断这些需要用的话。 也可以看看好line s p i的功能描述。 差不多就是这些。 这里开始就是m s的描述了。 我们不用看。 最后再大概看一下计算器描述。 第一个控制计算器cr一就是用来配置电路的哈。 我们初始化结构体。 也主要就是用来填充这些位的。 高位在前的配置啊死人。 波特率主模式。 sp i模式都通过写控制计算器来进行。 然后控制净水器cr 2是一些中断式的。 也适用于配置电路的。 然后下面是状态监控器。 sr有这么多标志位。 重点是tx e和xn e。 第二次数据容器低压。 这里写了数据计算器对应两个缓冲区。 一个用于写发送缓冲。 就是我们说的t d r。 另一个用于读接收缓冲。 就是我们说的2.2写操作。 将数据写到发送缓冲区。 读操作将返回接收缓冲机体的数据。 这是数据用期之后。 crc多项式计算器。 这个我们不用。 最后还是cc的两个计算器。 我们也不用。 然后后面是fx的接器啊。 最后是金属器的。 总比这个计算器我们就看完了。 来到这里。 本小节课程也就结束了。 我们下一小节来开始写硬件spi的代码。
40. 哈喽欢迎回来。 本小节我们来学习硬件spi的代码部分啊。 先看一下本次代码的经验图。 我们打开11杠二。 硬件spi读写w5 k64 的图片。 看一下。 这个是硬件spi的截图。 线路的连接呢和之前软件spi的是一样的。 因为之前软件spi的接线。 也是放在了硬件spi的引脚上。 所以这里线路就不用变化了。 当然软件spi的引脚可以任意选择。 而这里硬件spi的引脚就不能任意选择了。 硬件spi引脚怎么选择呢。 我们还是得看一下这个引脚定义表。 但凡涉及s t m32 内部硬件外设的硬件。 基本上都得参考这个表哈。 不能任意选择。 因为硬件没有软件那么灵活对吧。 那在这个表默认复用功能这一栏。 我们找一下s p i相关的硬件。 首先这里可以看到s p i一的相关硬件。 s p i一的n s s复用在了p a s。 s p i e的s c k复用在了p a5。 m s o复用在了pa 6。 msi复用在了p7。 所以如果你想使用s p i一这个外设。 就得把相应的通讯线接在pa 4567。 这四个硬件。 当然这个n s s啊上小姐说过。 我们一般可以继续使用软件模拟的方式来实现。 所以n s s没必要必须接待ps 4啊。 其他三个引脚的话就必须得是p a567 了。 这就是s p i一的引脚分离关系。 接下去看下面这一块是spi 2的硬件。 其中spi 2的n s复用在了pb 12。 s c k是pb 13。 m s o是pb 14。 m o s i是pb 15。 所以如果你要使用sp 2的外设。 就必须得选这些硬件。 这是p2 的引脚复用关系。 最后在重定义这里。 我们还可以看到s p i e r还可以引叫重定义。 如果你spi一原来的pa 567。 这些硬件正好被别的资源占用了。 那你就可以考虑把spi一的引脚。 从定义到这个位置。 从定义之后spi一的n s转移到pa 15。 sk转移到pb 3。 m so转移到pb 4。 msi转移到pb 5。 这是从定义的功能。 可以在引脚资源冲突的情况下。 转移外设复用的引脚。 当然这里还要提醒一下这个pa 15。 pb 3。 pb 4。 这里并没有加粗。 因为他们默认情况下。 是作为g tag的调试端口使用的。 如果要使用他们原本的gp i o功能。 或者是使用重定义的外设引脚功能。 都需要先解除调试端口的复用。 否则gpl或者外设引脚都不会正常工作。 解除调试端口的方法在视频六杠四那节讲过。 不会的话可以再看看啊。 好了。 这些就是s p i一和p2 引脚的复用情况。 我们计划使用s p i1。 所以s c k j p a5 m s o j p a6。 m o s i j p a7 n s s可以接ps 4啊。 当然也可以接到其他位置。 那看一下接线图。 这里p a5 是s p i e的s c k。 我们接到cl k0 件。 p6 是m s o。 我们接到d o硬件。 p7 是m o s i。 我们接到d i硬件。 这几个硬件一定要结对哈。 一一对应。 互相也不要搞混了。 然后cs我们就接到p4。 这也是可以的。 最后vcc和jd接电源给模块供电。 就是接线图。 然后看一下面包板。 这个接线和之前的软件s p是一样的。 我已经接好了哈。 这里就不再演示了。 好到这里。 硬件线路部分我们就完成了。 接下来就是软件程序。 我们回到工程文件夹。 复制一下软件。 还是pi的工程。 改一下名字叫11杠二。 硬件spi读写w k64。 我们还是在软件pr的基础上更改哈。 来打开工程。 先编译一下。 没问题啊。 然后我们的任务就是修改底层的这个。 买s p i.c文件。 把这些初始化和时序的执行步骤。 由软件实现改成硬件。 实现之后。 基于通信层的这些业务代码。 我们不需要进行任何更改哈。 因为这些部分只是调用底层的通信函数。 来实现功能。 具体通信是怎么实现的。 这个地方是不用管的。 所以我们把底层的实现由软件改到硬件。 也是不会影响到上层代码的。 这是代码隔离分装的好处。 然后由于这个spi的硬件实现。 我们计划使用非连续传输的方案。 这个方案非常简单哈。 也容易分装。 所以我们还是保留这个y s p i的模块。 直接在这里更改代码即可。 像上一节fc的代码。 我们是直接把买fc的模块移除了对吧。 那模块是不是要移除。 是分成独立呢。 还是都放在一起。 每一层代码都有哪些东西啊。 这个得看你对工程的规划。 还有你的喜好了。 那这里我觉得保留这个mysp i的模块。 是非常方便的。 所以我就在这里直接进行修改了。 那如何修改呢。 我们看一下。 首先s s引脚我们还是使用软件模拟。 所以这个写s的函数留着。 然后下面这三个软件读取spi通信引脚的函数。 我们就可以删掉了。 之后买s p i初始化。 这里我们可以全都删掉。 替换为s spi外设的初始化。 当然我们删到这里就行了。 上面这些等会还能用到。 先留着。 省得等会儿再写的。 接着软件写s s引脚。 产生起始和停止信号的这两个可以留着。 最后交换字节函数里面的内容我们全都删掉。 这样软件spi操作时序的部分我们就删掉了。 接着我们写上硬件spi的代码就行了。 硬件spi的代码实际上就是两个部分啊。 第一部分在这里写上spi外设的初始化代码。 第二部分在这里写上s spi外设操作时序。 完成交换一个字节的流程。 这是我们的任务。 那这我清楚了。 我们看一下ppt。 看一下这个pi基本结构。 对于s p i初始化的流程。 我们分为几步啊。 第一步开启时钟。 开启s p i和gp i o的时钟哈。 第二步初始化gpl口。 其中s c k和m y。 s i是由硬件外设控制的输出信号。 所以配置为复用推挽输出。 m o是硬件外设的输入型号。 我们可以配置为上拉输入啊。 因为输入设备可以有多个。 所以不存在复用输入。 这个东西直接上来输入就行。 普通gpl口可以输入。 外设也可以输入。 最后还有s s引脚。 s s是软件控制的输出信号。 所以配置为通用推广输出。 就是gpl口的初始化配置。 然后第三步配置spi外设这一块。 使用一个结构体选参数即可。 调用一下s p i e it这里面的各种参数啊。 比如八位16位数据帧。 高位限行。 低位限行spi模式。 几主机还是手机等等等等。 就都配置好了之后。 第四步开关控制。 调用s p s m d给s p s能即可。 这是初始化的流程。 输入完之后。 我们参考这个时序来执行运行控制的代码。 这样就能产生交换字节的时序了。 这些插座涉及的具体函数呢主要就是写低压。 读低压和获取状态标志位这些。 那p p t看到这里。 下一步我们就是看一下库函数了。 s p i y设相关的库函数。 就这个s p i.c和s p r点去了。 那打开s p i点去看一下最后的函数声明。 这些就是spi的管束。 当然这里有很多函数都带了个iphone s。 因为s spi和iphone 4是共用的一套电路对吧。 那么不用i方式。 就当它不存在就行了。 然后依次看一下这个函数。 我们应该都已经很熟悉了。 比如s p i iphone 4 d6 恢复缺省配置。 s p i e it初始化。 s p i struck 1 itt结构体变量除以外。 xp s m d外设使能。 s p i f s i t configure。 中断时能s p i f s d m a c m d d m a s呢。 这些不用多说了哈。 比较重要的两个函数是s p i e it。 初始化和s p i s t m d外设使能。 然后继续下一个s p i f s3 的data。 这个函数实际上就是写dr数据进去啊。 转了定义可以看一下。 他把参数传进来的这个data赋值给dr。 就是写数据到发送数据进器t d r对吧。 然后下一个s p i iphone s receive data。 这个实际上就是读d啊。 数据进去也可以看一下s p i的低压读出来。 直接通过return返回。 所以返回值就是接收数据器r d r对吧。 好。 这是这两个写dr和读dr的函数。 接着下面这些就是一些啊。 比如n s s引脚的配置。 data size就是八位或16位数据帧的配置。 然后crc校验的一些配置。 半双公司双向线的方向配置。 这些函数呢我们都用的很少哈。 了解即可。 然后最后四个函数就还是老朋友。 获取标志位和清除标志位的函数。 我们主要会用到get flag status。 来获取tx g和xn e标志位的状态。 再配合写dr和读dr的函数。 这样就能控制时序的产生了。 好库函数就看到这里。 那目前铺垫的工作就完成了。 我们来开始写程序。 首先是初始化函数里面的代码。 第一步是开启时钟。 我们要开启s p i和gp i o的时钟。 目前使用的gp i o都是a端口啊。 所以开启gp l a的时钟没问题。 之后我们计划使用s p i一这个外设。 s p i一也是a p p2 的外设。 所以可以复制一下这一行对应的外设哈。 按ctrl alt加空格提示一下。 选择这里的s p i1。 这样第一步开启时钟就完成了。 接着第二步配置相应的gpu口。 首先s重新选择硬件是p4 对吧。 我们计划还是使用软件模拟。 所以这里pa 4我们还是配置为通用推广输出。 接着复制一下下面这几行。 下一步是sk和m o y si。 这两个是外设控制的输出。 我们要配置为复用推挽输出。 看一下引脚。 定义s c k和m o s i分别是p a5 和p a7。 所以代码这里我们选择p5。 在货上。 p7 这两个硬件要选择af p p。 也就是复用推广输出。 然后再复制一下这几行。 最后一个硬件是m soo。 要配置为上拉输入模式。 看一下硬件定义。 im so是pa 6硬件。 所以这里选择p6 营销模式。 选择ipu上拉输入模式。 来到这里。 我们gpo的模式就配置好了。 这个模式种类还是比较多的哈。 大家不要搞混了。 这是初始化的第二步。 初始化gpio。 接着第三步初始化spf外设这个函数名称啊。 写多大就能记住了对吧。 我就直接写了。 初始化肯定就是s p i一例了。 参数第一个我们指定spi一参数。 第二个是初始化结构体。 我们在上面定义结构体变量。 结构体类型比s p i e it type def变量名。 给个spi 1。 it是structure之后把结构体成员全都引出来。 最后把结构体的地址传递给初始化函数。 让它帮我们根据结构体的参数。 来自动配置相应的计算器。 这是spi初始化的步骤。 那这个结构体变量的顺序我们也调整一下哈。 当然这个顺序可以随意。 我就是根据功能调一下位置。 方便观看好。 依次来看一下第一个s spm的选择。 spi的模式。 这个参数决定当前设备是s p i的。 主机还是重击啊。 把参数取值列出来。 你肯定就知道了。 复制一下成员名放在后面。 提示一下参数。 再打个下划线。 可以看到master指定当前设备为主机。 此类指定当前设备为重机。 那我们肯定是选择主机啦。 这是s spm的之后。 s spi direction。 这个是什么意思呢。 我们把参数列表弄出来就好理解了。 还是同样的方法提示一下参数。 可以看到有这些参数啊。 当然最后两个值。 其实并不是这个结构体的参数啊。 是和别的函数的参数重名的。 可选的参数有四个。 分别是单线半双工的接收模式。 单线半双工的发声模式。 双线全双工和双线的直接收模式。 可以看到啊。 这个参数是用来配置s p i裁剪引脚。 这个功能的。 那当然我们使用最多的就是标准模式。 双线全双工。 所以选这个参数即可。 这下面两个data size配置八位还是16位数据帧。 first beat配置高位限行还是低位先行。 这个最常用的就是八位数据帧。 高位限行。 所以配置就很简单了。 同样的操作。 data size选择八bit 8位数据帧。 first b。 选择m s b高位线性。 那这两个参数就配置好了。 然后下面一个波特率预分频器。 这个可以用来配置sk时钟的频率参数。 看一下。 这里有这么多分屏系数。 分别是248 16。 32 64。 128。 256。 这八种分频系数我们上节节也讲过啊。 pcr k的频率除分频系数。 就是sk的时钟频率分配系数越大。 s c k使用频率越小。 转速越慢。 这个可以根据你的实际需求来选害。 那我们这里就选一个慢一点的参数。 比如128。 目前s c k的时钟频率就是72兆赫兹。 除128。 大家可以算一下。 大概是500多千赫。 当然我们这是spi一的外设。 所以是72兆赫兹除以128计算频率。 如果你是sp 2的外设。 同样的参数就得是36兆赫兹。 除以128计算频率的。 因为s p i一是a p p2 的外设。 s p i2 是a p p一的外设。 这个注意一下。 那这就是时钟频率。 然后下面两个参数。 cp u l和cp h a这两个就比较熟悉了吧。 这是用来配置s p i模式的。 我们还是看一下参数列表。 c p o l时钟即兴参数有两个。 一个是亥默认高电平。 一个是漏默认低电平hi其实就是cpl等于一。 no其实就是cpl等于零。 那我们计划选择s p i模式。 零啊。 空弦默认是低电平所选择low这个参数。 然后cph a始终相位看一下。 这里也是两个参数。 一个是一edg就是第一个边缘开始采样。 一个是2g就是第二个边缘开始采样。 一二级就是cpa等于零啊。 二二级就是cpj等于一。 可以发现这些s p i的设备啊。 都只喜欢说第几个边缘采样。 而不说第几个边缘输出数据啊。 当然我便于理解说的是第一个边缘移出。 第二个边缘移入这里。 我说的移入啊。 就相当于他们说的采样是一个意思。 大家注意理解啊。 那这里我们选择spi模式零。 c p h a等于零。 所以选择一二级。 这个参数就是spi 4种模式的选择。 当然这里选择模式零和模式三都可以啊。 我们目前选择的是模式零。 然后下一个s p i n s看一下参数。 这里有hard硬件n s s模式和soft的软件n s模式。 那n s s引脚。 我们计划是使用gpl模拟这个外设的。 n s s引脚。 我们并不会用到哈。 所以这个参数一般选择软件ss就行了。 这个不用过多关心。 然后最后一个参数是crc校验的多项式。 这里参数需要我们填一个数。 填多少都可以。 反正我们不用。 我们就填他给的一个默认值七就行了。 这个也不用过多了解哈。 好到这里。 我们这个结构体的参数就选好了。 其实可以看到。 大多数的参数都是一些常用的配置。 基本上是不用改的。 需要改的可能也就这三个吧。 s c k使用频率和s p i的模式。 所以这个初始化应该也不难理解吧。 那初始化结束。 我们就是第四步。 使人spi外设。 我们调用s p i c m d函数参数spi 1 lab。 这样spi外设就准备就绪了。 当然开启s p i之后啊。 我们还要做一个事。 就是调用一下这个mysp。 写s默认给ss输出高电平。 默认是不选中重击的。 这样我们整个spi初始化函数就写好了。 就是这么多内容。 那处理完之后。 s p y设就绪。 我们就可以来完成这个交换自己的函数了。 当我们调用这个交换自己的函数。 硬件的s p r外设。 就要自动控制s c k m y。 s i m s o这三个硬件来生成时序了。 怎么生成呢。 我们看一下ppt这个图。 上海人也说过啊。 通常情况下就四步。 第一步等待tx e为一。 发送计算器为空。 如果发送进去不为空。 我们就先不要着急写。 所以代码这里第一步就是调用函数。 这里的spi fs。 get flag status。 放到这里。 参数spi 1。 第二个看一下定义。 这里显然我们要检测spi iphone s flag。 tx e放在这里。 那样实现等待tx e的效果。 我们就还是套一个while循环。 如果读取tx标志位。 它不等于set while条件为真。 进入循环等待。 这样就能实现等待tx为一的功能呢。 另外这里你也可以写等于等于reset。 或者后面什么都不写。 函数前面加个非号。 这些写法都行啊。 都可以实现功能。 那这个while循环呢。 只要s spi外设电路不损坏。 基本上是不会一直处于卡死的状态。 因为只要tdr有数据。 它也会自动转到一位进气。 开始发送。 过一会儿肯定就发完了。 不会受外部电路影响。 所以这个while循环一直卡死的概率不大。 我们就不加超时等待的机制了。 当然你要是不放心加一下超时等待。 那也是完全没问题的好。 那等待tx e唯一的代码就是这样。 第二步看一下ppt。 我们就执行这里的软件写入数据至s p i d。 如何写入数据呢。 我们刚才才看到扩展数对吧。 显然是调用这里的s p i f s sd哈。 放到这里。 参数第一个s p i。 第二个是要写入到dr。 也就是t d r的数据。 t d r是要发送的数据对吧。 所以显然我们要把这个better thing的参数传进去。 传入better肾之后。 better肾的写入到tdr之后。 贝塔肾的自动转入移位助器。 一旦以为进期有数据了。 持续波形就会自动产生这个波形生成啊。 不需要我们再调个什么函数。 说让他开始传输的。 我们只管写入数据到t t r之后。 转移到移微镜器生成波形啊。 这过程是自动完成的。 它自动生成之后。 better剩的这个数据就会通过msi。 一位一位的移出去。 在mosi线上就会自动产生这个发送的时序波形。 然后由于我们这个是非连续传输啊。 所以持续产生的这段时间。 我们就不必提前把下一个数据放到t d r里的。 这段时间我们就直接实等过去就行。 那该等到什么时候。 这一个字节的时序才会完成呢。 这个我们可以注意到哈。 在发送的同时。 m so还会一味进行接收。 发送和接收是同步的。 到这里接收一位完成了。 是不是也就代表发送一未完成了。 接收一位完成时会收到一个字节数据。 这时绘制标志位i x n e。 所以第三步我们只需等待2x n e出现就行了。 回到代码复制这一条等待标志位。 等待的标志位是rx n e等rx n e为一了。 表示收到一个字节。 同时也表示发送时序产生完成了。 那既然二次e等于一了。 显然第四步就是读取dr。 从2d里把交换接收的数据读出来。 所以代码我们就是调用函数s p i。 iphone s receive data。 读取dna放到这里。 参数是s p i1。 这个函数有个返回值。 返回值就是rdr接收的数据。 我们直接return。 把这个置换接收的数据。 通过这个返回值输出数据。 这样通过硬件spi交换一个字节的程序。 是不是就写完了。 总共四步。 第一步等待tx t为一。 第二步且发送的数据是t d r。 一旦tdr写出数据来。 持续就会自动生成。 第三步等待i x n e为e发送完成。 即接收完成i x n e至一。 第四步读取rdr接收的数据。 就是置换接收的一个字节。 这样简单的四步就完成了spi一个字节的交换。 在这里面我们并不需要像软件sp i那样哈。 手动给s c k m o s i至高低电平。 也不用关心怎么把数据一个个取出来。 这些工作硬件电路会自动帮我们完成。 另外还有一个注意事项。 就是这里的硬件spi必须是发送同时接收。 要想接收必须得先发送。 因为只有你给t d写东西才会触发时序的生成。 如果你不发送。 只调用接收函数。 那时序是不会动的啊。 然后还有一个注意事项。 就是tx和x n e是不是会自动清楚的问题。 因为我在手册这个图上啊。 看到这里写的是tx标志。 由硬件设置。 并由软件清除。 下面2x n e写的也是由硬件设置。 有软件清除。 这个有软件清除就比较迷惑啊。 是不是要求我们在标注位置一之后。 还需要我们手动调用cdr flag函数清除呢。 实际上这个并不需要我们手动清除哈。 我们可以参考一下手册。 在状态标志这一节。 这里写了发送缓冲器空闲标志txt。 此标志为一时。 表明发送缓冲器为空。 可以写下一个待发送的数据进入缓冲器中。 当写入spi dr时。 tx标志被清除。 所以在程序这里啊。 我们等待tx e标志字一之后。 不需要再手动调用一个可莉亚flag函数。 清除tx一标志。 为了因为写入dr时。 会顺便执行清除tx e的操作。 而我们下一代码就正好是写入dr。 所以这个标志位不需要我们手动清除了。 然后x n e标志位也是一样。 读pi数据定器可以清除此标志。 在程序这里等待r自n e为一之后。 下一个操作就正好是读第。 所以i x e标志位也不需要我们手动清除了。 这一个功能。 其实之前的串口和iphone c都是一样的哈。 写入dr顺便要清除tx e。 读取dr顺便要清除i x n e。 程序中不需要我们额外手动清除这些标志位的。 这个理解一下。 因为这个还是tm 32中啊。 大多数标志位其实都还是需要我们手动清除的。 比如中断标志位。 进中断之后必须得清除。 否则中断就会一直进入。 导致主程序不能执行啊。 而少部分标志位在执行顺序操作的时候。 可以顺便清除这个可以方便我们操作啊。 至于哪些标志位可以顺便清除。 这个还是得仔细看一下手册好。 这就是这个程序我们其实就已经写完了哈。 整体看下来应该也还好理解吧。 那我们就来验证一下。 看看这个代码能不能和软件spi一样。 仍然实现读写w5 k64 的功能编译。 下载看一下读取id 2 ef 4017。 下面写入1234。 读取也是1234。 这说明我们硬件spi也是完全没问题的。 好到这里。 我们这个硬件spi的程序啊就修改完成了。 这小节的任务还是比较轻松的哈。 那么s p i的课程到这里也就全部结束了。 我们下节课再见。
41. 哈喽大家好。 欢迎继续观看s t m32 入门教程。 现在我们的课程已经来到了第12节啊。 这一节我们要讲的主要内容是rtc实时时钟。 对应手串是第16章的位置。 实时钟这个东西啊本质上是一个定时器。 但这个定时器是专门用来产生年月。 日时分秒这种日期和时间信息的。 所以学会了s t m32 的rtc。 你又可以在s t m32 内部。 拥有一个独立运行的钟表。 想要记录或读取日期和时间。 就可以通过操作rtc来实现。 那rtc这个外设呢比较特殊。 它和备份净水器b k p电源控制。 p wr这两张的关联性比较强啊。 在rtc这一章。 bkp和pw也会经常来串门。 所以我们这节就把b kp和r t c放在一起讲。 这样整体思路会比较清晰啊。 p w电源控制我们下一节再讲。 然后我们这一大截我计划是分三个小节来讲。 第一小节我会单独讲一下时间戳这个东西。 这也是个蛮有意思的知识点哈。 想要使用我们这款s t m32 的rtc。 学习时间戳的知识点还是非常必要的。 之后第二小节我们就学习bkp和rtc。 外设的结构。 最后第三小节就写代码来完成程序现象了。 就是课程安排好。 那先看一下我们最终的程序现象。 本节一共有两个4g代码。 12杠一读写备份计算器。 也就是读写b k p 12杠二实时时钟。 就是oled显示年月日时分秒了。 先看一下第一个代码下载看一下。 这里我们要在s t link上。 再引出一根3.3伏的电源。 接到v bt引脚。 这根线就模拟一个电池的电源哈。 一般情况下vbt是电池供电口。 需要接备用电池。 但是我们目前套件里没有电池啊。 所以就直接引出一根3.3伏电源线了。 也是一样的效果。 那看一下显示屏。 这个程序的目的是。 在b k p备份进器写入两个数据。 然后再把它们读出来。 显示一下目前w是写的内容啊。 我们还没有写入数据。 二是读的内容默认读出来都是零。 然后我们可以按一下这个按键。 这时就在两个备份净器中分别写出来。 12345678之后。 读出来也是12345678。 写入和读书是一样的。 没问题。 那继续按按键。 我们会改变数据再写入进去。 下面读出来和写入一样都没问题。 其实b kp备份进器。 和上一节学的flash存储器类似。 都是用来存储数据的。 只是flash的数据是真正的掉电不丢失。 而bkb的数据是需要v bt引脚。 接上备用电池来维持的。 只要vb a t有电池供电。 即使s t m32 主电源断电。 b k p的值也可以维持原状。 那我们试一下。 拔掉s t m32 板子。 最下面这个主电源的正极硬件。 现在s t m3 断电。 但是v b t有电可以维持b kb的数据啊。 再次上线后。 在没有写数据的情况下。 直接读出bkb。 它的数据和断电之前是一样的。 这说明b k p的数据。 在主电源断电后得到了保持。 并且在系统复位后可以按下复位键。 bkb的数据也不会复位。 那如果我们把vbt的电池断电。 再次拔掉。 主电源重新上电。 bkb的数据就清理了。 因为b k p本质上并不能完全掉电。 不丢失啊。 它的数据需要v bt引脚提供备用电源来维持。 这就是bkp备份计算器的特性。 如果你的s t m32 接了备用电池。 那b k p可以完成一些主电源掉电池。 保存少量数据的任务啊。 这是第一个代码的现象。 其实备份计算器和vb a t引脚的存在。 更多的是为了服务r t c的。 所以我们接着看第二个代码。 实时时钟下载看一下。 就是实时始终的现象。 把这个线插回去吧。 第一行是日期。 目前是给的一个测试时间哈。 2023年1月二日。 第二行是时间。 目前是零时零分这些表。 第三行是时间戳的秒计数器。 目前是16亿多。 这个什么意思。 等会就来学习啊。 第四行是rtc预分频器的计数值。 这个先看一下就行哈。 用途我们写代码的时候再研究。 这是我们这个时时钟的显示。 当然实时时钟光有显示还不够。 为了保证时间不出错。 它还要有其他特性。 首先是复位。 既然你的计时。 总不能每次复位都重新设置时间吧。 我们按一下复位键。 可以看到时间会继续运行。 不会复位。 然后实时时钟在系统主电源断电后。 他还要继续运行。 就像我们手机一样。 关机后里面的时钟还必须要继续走。 要不然时间就错了是吧。 所以只要在v b t接上了备用电源。 我们再断开系统组电源。 然后插上可以看到时间数据不会丢失啊。 并且在主电源断开的时间里。 rtc会继续走时。 不会因为主电源断电而暂停。 这是rtc实时时钟的程序现象。 可以发现rtc这个复位和主电源掉电后。 数据不丢失。 就是借用bkp来实现的。 所以rtc和b k p关联程度是比较高的。 就是实时时钟的程序现象。 另外在这里我还要提几个。 我测试程序的时候遇到的硬件bug哈。 首先是有的芯片我给主电源断电后。 vb a t的电源还会微弱的给整个系统供电。 这导致我主电源拔掉后。 电源指示灯和oled屏幕还会微弱的亮着。 这是一个问题啊。 当然这个问题其实也不影响最终的实验现象。 然后是还有的芯片在进行rtc实验时。 会出现rtc晶振不起振的情况。 这会导致程序卡死。 在等待真正起正的地方。 这个问题我还没找到完美的解决方法。 但是在学习过程中。 也是可以有一些替代方法可以使用的哈。 所以这些问题先给大家提个醒。 替代方法。 我们后续写代码的时候再说啊。 好那程序现象我们就看到这里。 接下来回到ppt。 我们来看一下时间。 戳这个知识点。 在这一小节我将会介绍时间戳是什么东西。 为什么要使用时间戳来计时。 然后ugc和gmt是什么东西。 这一块就是一些科普性质的知识点哈。 然后就是时间戳底的表。 计数器和日期时间数据如何互相转换。 这涉及到c语言中的time点。 去这个官方函数库。 这里我会在d e v c加加这个软件里。 一调用这些函数来给大家演示它们的用法。 所以我们本小节的任务有两个。 一是了解时间戳它到底是什么东西。 二是会使用c语言time点序里面的这些函数。 进行时间戳各种形式数据的转换。 那本小节的内容呢。 其实是计算机领域的一个通用知识点哈。 不特别用在s t m32 中。 所以学完本小节。 你之后在其他地方说不定也能用得到哈。 好那我们来看一下。 首先第一页ppt。 这里介绍的是unix时间戳。 ux时间戳最早是在ux系统使用的。 所以叫unix时间戳。 之后很多由unix演变而来的系统啊。 也都继承了unix时间戳的规定。 目前linux windows安卓这个系统。 他们底层的计时系统啊。 都是使用的尤里x时间戳。 所以在我们现在计算机世界的底层哈。 unix时间戳还是在扮演着重要的角色的。 来看一下第一条unit x时间戳。 英文是unit time step。 它的定义是从u t c或gmt。 的1970年1月一日零时零分零秒开始。 所经过的描述。 不考虑论秒。 这里大家可能有些疑问啊。 第一ut c gmt这个是什么东西。 第二闰年闰月这些我们听的比较多哈。 但是这个闰秒是个什么东西呢。 这两个知识点我们在下一页ppt来讲解哈。 现在这句话我们简单理解一下。 意思就是时间戳是一个计数器数值。 这个数值表示的是一个。 从1970年1月一日零时零分零秒开始。 到现在总共所经过的描述。 所以时间戳这个计时系统啊。 和我们常用的年月日时分秒。 这个计时系统有很大差别。 年月日时分秒计时系统是每60秒定位一次。 即为一分钟。 每60分钟定位一次即为一小时。 之后继续进位就是日月年了。 而实践戳计时系统就比较简单粗暴了。 它定义1970年1月一日零点整为零秒之后。 就只用最基本的秒来计时。 永不敬畏。 60秒就是60秒。 100秒就是100秒。 1000秒。 1万秒。 你一秒。 无论这个数有多大。 我都不进位。 始终都只用秒来计时。 所以从1970年记到现在。 这个时间戳的秒数已经非常大了。 目前这个秒数已经来到了16亿这个数量级了。 对于人类来说。 这个16亿秒肯定是又难记又难理解。 但是对于计算机来说。 一个永不敬畏的秒。 无论是存储还是计算都是非常方便的。 所以时间戳在计算机程序的底层应用非常广泛。 时间戳的表计数器和日期时间可以互相转换。 在计算机的底层。 我们使用秒计数器的计时需要给人类观看时。 我们就转换为年月日时分秒这样的格式就行了。 那使用这样一个很大的描述来表示时间。 有很多好处啊。 第一就是简化硬件电路。 我们在设计rtc硬件电路的时候。 直接弄一个很大的秒寄存器就行了。 不需要再考虑什么年月日计算器啊。 定位啊。 大月小月平年闰年这些东西的。 对于硬件电路设计来说是非常友好的。 第二就是在进行一些时间间隔的计算时。 非常方便。 比如1月1号八点到3月1号18点之间。 间隔了多少小时啊。 这个如果用年月日时分秒来计算的话。 需要考虑的东西就比较多了。 但如果用表计数器来算的话。 我们只需要把两个时刻的秒数相减。 再除一个小时的描述就可以。 很快计算两个时刻的间隔了。 第三就是存储方便存储。 描述一个比较大的变量就行了。 存储年月日时分秒的话就得很多变量了。 那当然使用表计由器来表示时间也有坏处啊。 就是比较占重软件资源。 在每次进行表记录器和日期时间转换时。 软件都要经过一通比较复杂的计算。 这会占用一些软件资源哈。 那这就是使用时间戳到一些好处和坏处。 然后我们继续看下一条。 时间戳存储在一个秒计数器中。 秒计数器为32位或64位的整形变量。 那计算机为了存储这样一个永不敬畏的描述。 这个数据变量类型还是要定义大一些对吧。 这个变量类型在不同系统中定义是不一样的哈。 在早期的ux系统中。 这个描述大多是用32位。 有符号的整形变量来存储的。 32位有符号数。 所能表示的最大数字是二的32次方除二。 再减一。 大家可以用计算器算一下啊。 这个数是21亿多。 这其实是有溢出风险的。 因为目前到2023年了。 时间戳已经寄到16亿了。 再过一些年。 32位有符号数就存不下这么大的数字了。 那根据计算。 32位有符号数的时间戳。 会在2038年的1月19号溢出。 到时候采用32位。 有符号数存储时间戳的设备。 计时系统就会因为数据溢出而出错。 这可能会导致很多不健全的计算机程序崩溃啊。 这是2038年危机。 大家感兴趣的话。 可以网上搜一搜。 那当然随着操作系统和设备的更新换代啊。 目前的手机。 电脑等设备。 基本上都已经采用64位的数据来存储时间。 戳了64位的时间戳。 能存储的时间范围非常非常的大。 总之对于人类来说完全可以高枕无忧了。 最后我们本集s t m32 中的i t c。 可以看下手册。 可以看到它核心的计时部分。 是一个32位的可编程计数器。 这说明我们这款s t m32。 它的时间戳是32位的数据类型。 32位的时间戳。 这表示我们这个s t m32。 也会在2038年出现bug吗。 实际上并不会啊。 因为根据我的研究。 这个时间说。 在s t m32 程序中定义的其实是无符号的。 32位。 无-2。 32位。 最大数值是二的32次方减一计算一下啊。 要到2106年才会溢出。 虽然不是高枕无忧啊。 但是有生之年八成是不用担心好。 这就是时间戳的存储格式和溢出风险的分析。 接着看下一条。 世界上所有时区的秒计由器相同。 不同时区通过添加偏移来得到当地时间。 这个我们知道地球上不同精度。 它的时间是不一样的。 穿过英国伦敦的经线。 我们把它叫做本初子午线。 这个位置的时间是一个时间标准。 我们时间托儿所说的。 1970年1月一日零时零分零秒。 也是指的伦敦时间的零时零分零没有。 那其他地方呢可以分为24个时区。 每天差一个时区啊。 时间就要加或减一个小时。 我们处理不同时区的方式是。 所有时区共用一个时间戳的秒计数器。 也就是在伦敦表接收器是零。 在北京也是零。 然后根据不同时区。 我们再添加小时的偏移即可。 比如秒计数器的零对应伦敦时间的零点。 那中国使用北京时间处于东八区的位置对吧。 对于北京的时间就是八点。 这是时间戳对不同时区的处理方式。 那最后看一下下面这个图哈。 总结一下上面的知识点。 图中这个箭头代表的是一个时间轴。 在这个时间轴上我们要定义一个起点。 时间戳从这个起点开始计时。 这个起点是人为规定的哈。 当时的设计者选择了伦敦时间的。 1970年1月一日零点。 对于1970年之前的时间。 时间戳是无法表示的。 那时间戳有两种表现形式啊。 一种是它的基本形式。 由此永不敬畏的秒直由器从零开始一直往后。 每过一秒加一个数。 另一种就是秒计器经过计算。 翻译出来的日期和时间了。 比如零秒对应伦敦时间。 1970年1月一日零点。 然后秒救器一直gg。 比如记得这个11秒的时候。 就对应伦敦时间2001年9月九日。 一时46分40秒。 那我咋知道11秒对应这个日期时间呢。 这背后要经过一些比较复杂的计算哈。 比如先算1年有多少秒。 得到现在是哪1年。 然后再算一天有多少秒。 得到现在是1年的第几天。 然后再计算现在是几月几号。 最后再计算是几时几分几秒。 这里面还需要考虑大月小月。 平年闰年这些特殊情况。 所以可以想到这个计算是非常麻烦的。 但是好在这个计算步骤是固定的。 而且c语言官方已经帮我们把程序写好了。 这是我们等会儿要学的time点器这个模块。 这里面就有现成的秒救器。 转换日期时间。 日期时间转换表计器这些函数。 所以这里我们只要会调用tab点去的函数。 就可以知道资源表。 计数器和日期时间的对应关系了。 至于计算步骤。 我们不用过多了解哈。 感兴趣的话可以自行研究。 那有了tab点虚拟的函数。 这个秒计数器的计算就非常简单了。 比如1672588795。 这个描述调用函数与计算对应的伦敦时间。 就是2023年1月一日15:59。 55秒。 那最后一行在伦敦时间的基础上。 得到北京时间就比较简单了。 每隔秒接收器对应的伦敦时间。 再加上八个小时。 就是对应的北京时间。 就是这个ud x时间戳整个的设计思路哈。 最后可以给大家推荐一个网站工具。 比如在百度直接搜索unix时间戳。 然后就可以看到很多这个时间戳。 在线转换工具哈。 我们打开这个网站里面。 就有别人做好的转换工具。 比如这里显示的是我现在这个时刻。 对应的秒记录器就是这么多秒啊。 然后第二行时间戳就是秒置6g。 你输入多少秒点转换。 它就能告诉你对应的北京时间是多少。 下面第三行你输入一个日期时间点转换。 它就能告诉你对应的表计数器是多少。 但是这里好像只能转发北京时间哈。 比如给个零秒。 因为是北京时间。 它对应的就是八点。 这个我们也应该清楚是怎么回事对吧。 就是这个时间戳在线工具代写代码的时候啊。 可以参考这个工具来进行验证。 这个了解一下好时间拖的基本知识点。 我们就了解这么多。 接下来第二页ppt。 这里主要就是两个科普的内容哈。 我们来了解一下gmt u t c是什么东西。 为什么会有闰秒这个现象。 首先看一下gmt。 它的英文全称是这个哈。 翻译成中文意思就是格林尼治标准时间。 当然也有的地方叫做格林威治标准时间。 或者格林威治平均时间。 这些都是一个意思啊。 这个格林尼治是个地名。 位于英国伦敦啊。 所以如果你对格林尼治这个名字不熟悉。 可以简单理解它就是伦敦标准时间。 格林尼治这个地方呢有个天文台。 来确定地球的自转和公转。 所以继续看格林尼治标准时间。 就是一种以地球自转为技术的时间计量系统。 它将地球自转一周的时间间隔。 等分为24小时一次确定即使标准。 那可以看出啊。 这种计时方法非常符合我们的直觉。 一天的定义就是地球自转一周。 然后一天等分24小时。 在等分60分钟。 再等分60秒。 这样就能确定时间基础了。 当然我这里是简单的理解。 具体过程可能会更复杂一些。 那gmt呢是以前全球计时的时间标准。 大家都遵循gmt的标准。 不同时区再加上对应的小时偏移。 这样全球各地的时间就能确定下来了。 但为什么说gmt是以前的时间标准呢。 这是因为gmt有一个棘手的问题。 就是地球自转一周的时间其实是不固定的。 由于潮汐力啊。 地球活动等原因。 地球目前是越转越慢的。 那你再根据一天的时间来定义时间基准。 这个时间基准就是在不断变化的。 比如你把一天等分为24小时。 对应的描述。 地球越转越慢。 那你定义一秒的时间是不是也就越来越长啊。 一个不固定的时间基准对科学研究影响非常大。 比如我们说光速是多少米。 每秒帧数是多少米。 每秒前提是一秒到底是多长。 必须是一个恒定不变的量。 所以说未来时间的定义更标准哈。 科学家又提出了新的计时系统。 叫做ut c。 英文全称是这个中文名称叫做协调世界时。 协调世界时。 是一种以原子钟为基础的时间计量系统。 它规定设133原子。 这样这样这样所持续的时间为一秒。 原子钟是当前计时最精确的装置。 上千万年才误差一秒。 所以使用原子钟提供的时间具有定义明确。 恒定不变这些好的特性。 也就是使用原子钟计时。 一秒到底是多长。 我们就可以定死了。 那最初我们确定了这个参数啊。 它定义一秒的时长。 是和1970年的gmt保持一致的。 那现在问题又来了。 我们以一个恒定不变的秒来计时。 但是地球自转越来越慢。 这样记下去。 即时的一天和自转的一天就会出现偏差。 时间长一些。 可能中午12点太阳就不是最高的位置。 或者时间再长一些。 即时的白天黑夜就会和现实的白天黑夜颠倒。 这是我们不能忍受的。 虽然说地球自转变慢的过程非常缓慢。 误差大到白天黑夜颠倒。 那得很久很久了。 但是科学家对精度的极致追求不能容忍。 哪怕一秒的偏差。 所以在原子钟计时系统的基础上啊。 我们得加入闰秒的机制。 来消除计时一天和地球自转一周的误差。 闰秒的操作流程就是当原子钟计时一天的时间。 与地球自转一周的时间相差超过0.9秒时。 ut c会执行闰秒。 来保证其计时与地球自转的协调一致。 所以钟表哈就是计时标准是恒定不变的。 但是地球越转越慢。 误差超过0.9秒时。 我的计时系统就多走一秒来等一下地球的自转。 比如上一次钟表的时刻是。 北京时间。 2017年1月一日七时59分59秒。 在下一秒时始终会出现七时59分60秒。 一分钟总共是61秒。 这是闰秒的操作。 肯定的时间标准。 加上润表机制的设计。 就能保证u t c既满足科学家研究的需要。 又满足人类生活的需要。 这是协调世界时的设计思路。 u t这一次限行的时间标准哈。 它比g m t更加严谨。 但是润表机制的设计啊。 可能也会造成一些程序bug。 所以大家要有这个准备。 就是一分钟可能会出现61秒的情况。 那在平时的生活中啊。 大多不会追求极致的严谨。 所以这时gmt和ut c可以看成是一样的。 像我们手机电脑的时间设置的啊。 可能就是说我们当前的北京时间是gmt加八。 或者u t c加八。 这都是可以的。 这也说明我们使用的是东八区的时间好。 这是ut c和gmt的介绍。 还有润表机制产生的原因。 那再看实验出的定义啊。 u t c或gmt的。 1970年1月一日零时零分零秒秒。 实际上就是格林尼治的当地时间。 由是伦敦时间不考虑润表。 说明目前这个时间戳对润表没有适应性啊。 每次产生六秒时。 时间拖的时间和国家授时中心的标准时间。 就会产生一秒的偏差。 这个了解一下。 那时间抽到的基础知识大家都清楚了。 接下来就是实践部分。 我们来学习时间戳中。 秒计数器和日期时间如何进行相互转换。 这时候我们需要用到time点序模块。 c语言的time.g模块。 提供了时间获取和时间戳转换的相关函数。 可以方便地进行秒计由器日期。 时间和字符串之间的转换。 使用还是非常方便的。 直接调函数减参数就行了。 在tab点区里主要有以下这么多函数。 但并不是全部啊。 还有两个不太重要的函数。 我没列出来。 如何去学习这些函数呢。 其实网上也有很多的教程啊。 比如这里。 菜鸟教程里就有这个模块的讲解和例子。 下面这些函数呢我们都可以来点击学习的哈。 大家自学的时候都可以去网上搜索相关资源哈。 其实我自己也是从这里学到的。 那回到ppt重要的函数呢。 我给大家演示一下。 在函数中又主这三个最有重要。 其中gm time就是秒计数器转换为gmt。 格林尼治日期时间的函数。 local time 90秒就由器转化为当地日期时间的函数。 这个logo time啊。 就是在gm time的基础上加个死去的偏移。 所以这两个函数是非常相似的。 然后下面make time。 就是日期时间转换为表计数器的函数。 这个就只有当地的时间。 有了这三个函数。 我们就可以进行时间戳的转换了。 那先看一下下一页ppt啊。 这个图就清晰地显示了每个函数的作用。 就是在各种数据类型之间进行转换。 为了明白函数的用途。 我们首先得清楚这三种数据类型都是什么意思。 首先看一下表计数器数据类型。 它的数据类型名叫做time杠t tegrt。 是什么类型的。 我们可以结合程序来看一下。 那打开d e v c加加这个软件。 这是一个最简单的c语言工程啊。 大家使用任何一种c语言编译器都可以的。 那运行目前程序的现象是打印。 hello好。 我们在这个工程玩一玩time点去的相关函数。 为了使用这个模块。 我们首先就是井号include time。 点去添加一下头文件之后。 我们可以定义一个全局变量。 数据类型名是刚才说的表计数器。 数据类型。 time下划线t变量名我们可以任意起一个哈。 这里就叫做time下划线。 z n t表示它是一个秒计数器。 tab杠t其实是一个type define重命名的类型啊。 我们右键到定义可以看到这里定义的。 如果不是特别声明。 我们要用32位的表决器类型。 那么默认情况下time杠七就是time 64杠七。 然后上面time 64杠t实际上就是int 64。 所以这里time gt实际上就是int 64类型。 是一个64位有符号的整形数据。 所以可以看出啊。 这里的程序使用的是64位的秒接器。 不用担心溢出问题啊。 这是time杠七。 数据类型。 可以用来存储时间。 戳充那个一直自增的描述。 然后继续看下一个数据类型是日期时间。 数据类型类型名是struct tm。 那在程序中我们可以定义struct的tm。 这两个词组合在一起。 代表一个结构体类型。 命哈。 然后结构体变量名我们可以制定一个。 比如time下划线。 date表示日期时间。 这个tm结构体我们也可以在time点区里找到定义。 在这里哈。 strike的tm它是一个分装的结构体类型。 结构体的成员有这么多。 依次看一下tm second表示表取值范围0~59。 tm minute表示分钟取值范围0~59。 tm hour表示午夜开始的小时取值范围。 0~23。 tm monday表示一个月的几号取值范围1~31。 tm month表示从1月开始的第几个月取值范围。 零到11。 如果是1月。 它的值是零。 2月只是一一。 直到12月只是11。 所以这个参数只加一才是我们所说的月份啊。 tm e表示从1900年的第几年。 所以这个参数值加上1900。 才是我们所说的年份。 另外注意啊。 这个年份的偏移是1900。 我们时间戳的起点是1970。 这两个年份不一样啊。 注意一下。 所以这个参数最小值就应该是七零。 然后tm weekday表示从周末开始的星期几。 零表示周末一表示周一。 二表示周二一直到六。 表示周六。 t m e2 d表示从1月1号开始的第几天。 取值范围0~365。 这个参数我们平常用的不多哈。 最后一个tm 1 dt表示是否使用下令时。 正一表示使用夏令时。 零表示不使用限定时。 -1表示不知道夏令时这个东西啊。 欧美地区的大部分国家。 还有其他地区的少部分国家都还在使用。 我国最初也使用了一段时间啊。 但现在我国已经不用限定时了。 所以我们对夏令时这个东西可能比较陌生。 夏令时简单来说。 就是为了鼓励大家夏天的时候早睡早起。 节约用电而设计的。 感兴趣的话。 大家可以自己再研究哈。 这里就不给大家详细介绍了。 好那这个日期时间结构体我们就了解了。 它里面就是这样一个个表示年月。 日时分秒星期等内容的数据。 当然这个结构体的定义啊。 在形式上和我们s t m32 库函数里的方法。 有所区别。 我们s t m32 中使用的是type define。 struck。 花括号新名字这样的形式定义的。 这里没有使用type define。 而是在花括号前给结构体起了个名字叫tm。 这样在使用的时候。 数据类型名就是两个词struck的tm。 然后跟着的是变量名。 这样的方式也是可以的哈。 和我们s t m32 库函数里的方式是一样的。 效果。 这个大家了解一下。 那这就是日期时间结构体的内容。 我们就清楚了。 接下来最后一个是字符串。 数据类型类型名字恰新就是恰行数据的指针。 用来指向一个表示时间的字符串。 这个等会儿给大家演示啊。 在程序中我们可以定义恰新。 这是类型名。 变量名。 制定一个time下划键h t r。 这样就行了。 好三种数据类型我们就准备好了。 接下来我们来使用函数。 尝试一下数据类型的转换。 可以看到哈。 这些函数中大量的出现了指针的操作。 不熟记指针操作的话。 建议再看一下我空间里的指针教程啊。 要不然你不容易理解这些函数的用法。 我这个教程里日常推销指针教程啊。 其实像这些官方的模块真的是遍地时指针。 我自己写程序的话。 为了方便理解。 一般用指针还是比较少的。 但耐不住别人都用指针啊。 所以指针大家还是要好好学学的。 那看一下函数。 首先第一个time状是获取系统时钟。 它的返回值是time杠t。 表示当前系统时钟的秒记录器值参数是time gt新。 这是一个输出参数啊。 输出的内容和返回值是一样的。 所以这个函数可以通过返回值获取系统时钟。 也可以通过输出参数获取系统时钟。 在这个图中。 time函数就是这个位置用来获取当前时间的。 这个函数在电脑里啊。 可以直接读取电脑的时间。 但是在s t m32 里是用不了的哈。 因为s t m32 是一个离线的逻辑系统。 他也不知道现在是啥时间啊。 在程序中我们调用实验一下。 在这里调用time函数参数。 不需要的话。 可以给long返回值。 就是当前时间类型是time杠t。 我们可以把它赋值给刚才定义的变量。 time杠c n t。 这样就得到了时间。 那时间对不对呢。 我们可以print f打印出来。 这里2%d变量是time杠cnt。 运行。 看一下。 得到当前时间戳的描述是这么多。 对不对呢。 我们复制一下这个数。 然后在这个在线工具验证一下。 秒计数器值填进去转换。 可以看到实践和我们当前系统的北京时间。 是一样的哈。 这说明我们获取的时间是正确的。 那这个获取时间的函数。 我们还可以用输出参数来获取。 就这样哈。 time参数给time杠cnt的地址。 这两句话的效果是一样的。 运行一下也是没问题的。 另外我们还可以手动给它一个数值。 比如time gc nt等于。 我们就用p p t的这个值做例子哈。 这个值对应的是伦敦时间的15点。 北京时间23点。 那复制过来放到这里。 就相当于我们手动给了一个时间。 我们就用这个时间来测试。 那有了秒具器之后。 我们接着把它转化为日期时间的格式。 所以继续看函数。 第二个gm time将秒计数器的值转化为隔离。 理智也是伦敦。 时间。 参数是cos time gt。 新秒救器指针类型是输入参数返回值。 struck的t r m型是日期时间。 结构体指针类型。 在这个图里。 它的作用就是这里秒救器转换为日期时间。 在程序中啊。 我们实验一下。 这里调用gm time参数是time gt新。 所以我们把上面这个time杠cnt的地址传进去。 根据传进去的数值啊。 函数内部就会经过一通计算。 返回值就是日期时间了。 返回值是dg t m新。 如果我们直接把这个结构体变量放在这里。 这样就是指针跨级赋值哈。 等号右边是地址。 等号左边却是一个变量。 这是不行的。 解决方法有两个。 一个是在右边函数的返回值加上新取内容。 这样等号左右就都是变量了。 结构体变量之间互相赋值没问题啊。 或者右边不加新定义的变量。 我们定义为指针类型。 这样等号左右都是指针。 结构体指针之间互相赋值也没问题。 这两种方法都是可以的哈。 那我就使用第一种方法。 这样来就行了。 好这样我们的转换实际上就已经完成了哈。 我们打印看一下。 复制一下print f打印的变量是time杠date。 这是一个结构体变量哈。 我们用点取结构体成员。 首先看一下这个e啊。 然后复制几份。 在这个软件里可以按ctrl加空格提示成员。 最后一次看一下月。 分表最后可以再看一下星期一。 这样就行了。 边运行啊。 可以看到目前转换的日期。 时间是123年5月一日。 15时59分55秒。 星期零。 这个星期六就是星期天啊。 上面的联合月目前是不对的。 因为刚才说了哈。 程序这里定义过年是从1900年经过的年数。 月是从1月经过的月数。 所以我们要得到正确的年份。 那需要在这里连加上1900的偏移。 月加上一的偏移。 这样再试一下。 可以看到哈。 目前这个描述对应的伦敦时间是。 2023年1月一日15时59分55秒。 星期天。 这与我们ppt这里给定的伦敦时间是一致的哈。 那这天是不是星期天呢。 我们可以查日历看一下。 可以看到这一天确实是星期天啊。 没问题。 那这就是gm tab表计由器转换伦敦时间的函数。 第二继续看第三个local time转换当地时间。 这个函数和gm time的使用方法是一样的。 在这个图中呢。 它的作用和gm time也是一样的哈。 只是local time会根据时区自动添加小时的偏移。 在程序中我们要想转换为本地时间。 直接把这个函数名由gm time改成local time就行了。 在函数内部会根据当前电脑的设置。 自动判断我们处于哪个时区。 然后把时间添加时区片以后输出出来。 我们运行看一下。 可以看到现在的时间是2023年1月一日。 23时59分55秒。 local time函数判断。 我们在东八区就自动把时间加上八个小时。 输出显示是23点。 这与我们ppt这里给定的北京时间是一致的。 这就是gm time和local time。 我们就玩明白了。 接下来继续学习下一个函数。 make time就是上面两个函数的逆过程呢。 它是将日期时间转化为秒计数器。 当然梅克代传入的日期时间啊。 需要是当地的。 在这个图中可以看到。 make time就是刚才两个转换的逆过程。 那还是写程序试一下。 调用make time函数参数是日期时间结构体指针。 我们可以把刚才转换过来的日期。 时间结构体的地址传进去之后。 这个函数就会经过一通计算哈。 给我们返回对应的表计数器的值。 我们就还存在这个time杠cnt里。 这样就行了。 最后还是打印出来看一下现象。 这里掉了个分号看一下。 首先给定的是这个描述。 转换当地时间后是23点的。 这个日期时间之后。 根据这个日期时间再转换回秒数。 可以发现最终的秒数和最初的描述是一样的。 这说明这个make time。 我们给它传入当地时间是正确的。 那如果我们把这个local time改成gm time。 看一下。 这时最终的描述就和最初的描述不一样了。 这说明make time不是依据伦敦时间来进行的。 就是make time函数的现象。 另外再说明一下这个make time的参数。 前面并没有加const。 实际上这个参数即使输入参数也是输出参数。 它内部的工作过程是这样的哈。 日期时间结构体里面有年月日时分秒。 星期等数据。 但是仅通过年月日时分秒。 就足以算出秒计数器了。 你填的信息参数实际上是不作为输入参数的。 相反这个函数在算从描述的同时。 还会顺便算一下当前年月日是星期几。 然后回填到结构体里面的信息之中。 所以使用这个函数给定一个年月日。 我们可以很方便的计算。 对应的是星期几。 这个功能大家可以自己试一下。 我就不再演示了。 实际上这个time点区里面重要的部分。 我们就已经讲完了。 也就是秒计数器和日期时间计算比较麻烦哈。 我们需要用这些现成的函数。 下面这三个函数。 实际上就是把时间转化为字符串。 表示这个比较简单的。 我们不用它的函数也能很方便的操作。 如果你需要用的话。 我们也演示一下使用方法。 比如这个c time就把秒计数器转换为字符串。 使用默认的格式。 下面a s c time。 差不多就是把日期时间转化为字符串。 使用默认的格式对应这个图。 它们的作用就是。 分别把上面两个类型的数据转化为恰。 新格式的字符串。 具体是什么效果呢。 我们试一下就知道了。 在这里调用c time参数是t杠t新。 我们把这个time gc nt的地址传进去。 返回值是恰新的字符串。 我们用上面这里定义的变量来接它。 这样就行了。 我们可以print f打印出来。 直接把字符串传进去运行。 看一下最后一行输出的就是日期和时间。 sunday。 星期天加量为1月1号。 23时59分55秒。 2023年。 这就是默认的时间格式啊。 但这个格式是西方国家的习惯。 我们中国一般不用这么奇怪的格式哈。 所以这个函数我们用的不多。 然后a s c time实际上也是同样的效果啊。 只是它的参数不一样而已。 复制一下。 这里要用asc time参数。 要给time gd。 这样就进来看一下。 最终这两个函数运行的效果是完全一样的。 这两个函数了解即可。 最后我们再来试一下最后一个string format time。 这个函数就比较高级了。 它的作用和上面两个一样。 但是可以自定格式。 在这个图中。 它的作用和a s c time是一样的。 我们在程序中验证一下。 调用string format time。 它总共有四个参数。 前面两个参数需要传入一个字符。 数组和数组长度。 第三个参数需要给定指定的格式字符串。 第四个参数把time gdate算进去就行了。 所以我们首先定义一个恰行数组名字就叫t版。 长度给个50。 然后下面这里先把数组t传进去。 再把数组长度50传进去。 第三个参数需要指定格式。 怎么指定呢。 这里需要参考个表。 我们可以参考这个菜鸟教程啊。 点开这个函数可以看到这就是格式定义。 实际上就类似于print f第一个参数的格式。 字符串了。 左边是占位符格式。 右边是解释和实例。 比如我们想起小时就是百分号。 h分钟就是百分m秒就是百分s。 其他这些格式大家都可以一尝试哈。 在程序中第三个参数给个字符串。 我们想这样显示。 先显示小时2%h来一个杠。 再显示分钟。 来个杠再显示秒。 这样指定格式就行了。 然后最后一个参数。 我们就把time gdate的地址传进去。 格式完之后。 我们print f打印一下t。 可以看到它就按照我们指定的格式。 来打印字符串了。 小时杠二分钟杠表这个2%。 什么是单位符号。 打印时会替换为后面时间的具体值。 其他的符号会保留原始内容。 打印的字符串。 通过前两个参数到指定的一个数组里。 就是这个函数的作用好到这里。 我们这个time点区的部分重要函数就讲完了。 然后剩下tab点区里还有几个函数没讲到。 大家可以在这个菜鸟教程里自行学习哈。 主要就是这个可lock函数。 可以用来计算程序执行了多长时间。 然后地方的time可以计算两个时间之间的差值。 其他的函数啊好像都提到过。 但最重要的函数还是local time和make time。 这两个。 这是整个time点区里最复杂的函数。 也是我们s t m32 的rtc程序会用到的。 所以这两个重点掌握其他的了解即可啊。 那本小节的两个任务我们就完成了。 一个是了解unix时间戳。 另一个是会进行时间戳不同数据类型的转换。 这是本小节的内容。 那么下小节再见。
42. 大家好。 欢迎回来。 本小节我们来学习bkp和r dc的外设部分。 接下来我们会先学习bkb的相关知识点。 然后再学习rtc的知识点。 当然我们本节的重点是rtc。 所以b kb这部分内容比较少。 要求也不高啊。 大家知道b k b是什么。 然后会读写这些数据进器就行了。 之后r t c的部分呢就需要我们重点掌握了。 这个等会再细讲哈好了。 我们先来看b k p的部分。 首先看一下简介。 bk p英文是backup registers。 翻译过来是备份计算器或者叫后备计算器。 然后b k b的用途啊。 就是可用于存储用户应用程序数据。 b k b就是一些存储器哈。 可以存储自定义的数据。 想存啥就存啥。 然后b k b存储器的特性就是。 当v dd电源被切断。 它们仍然由vb a t为此供电。 当系统在待机模式下唤醒。 或系统复位或电源复位时。 他们也不会被复位。 这里的v dd就是系统的主电源。 供电电压是二点到3.6伏。 v bt就是备用电池。 电源供电电压是1.8~3.6伏。 可以看一下引脚定义图哈。 这里标红色的部分就是供电引脚。 下面这三组v dd和v s s。 123是内部数字部分电路的供电。 这一组vd d a和vs s a。 是内部模拟部分电路的供电。 那这四组以vdd开头的供电都是系统的主电源。 在正常使用s t m32 时。 这是主供电。 全部都需要接到3.3伏的电源上。 最后上面再还有一个硬件。 vbt就是备用电池供电硬件。 如果要使用s t m32 内部的bkp和idc。 这个引脚。 就必须接备用电池。 用来维持b kp和r d c。 在v d d组电源掉电后的供电。 当然这里备用电池只有一根正极的供电硬件。 接电池时。 电池正极接到vbt电池。 负极和主电源的负极接在一起共力就行了。 然后看一下我们最小系统板的原理图案。 这里可以看到v b t引脚。 直接通过排针引出来了。 这个引脚就位于我们板子右上角的地方啊。 引脚标号是vb或者vb a t。 另外这里可以看出来。 如果不接电池的话。 vbt引脚是悬空的。 当然s t m32 参考手册里建议的是。 如果没有外部电池。 建议v b t引脚接到v dd啊。 就是vb t和主电源接到一起。 并且再连接一个100蜡法的滤波电容。 这手册里的建议大家要是自己设计电路的话。 可以注意一下这个问题啊。 好。 那这样这个v d d组电源和vb a t备用电源。 我们就清楚了。 来回答ppt v b t的作用就是当v dd断电时。 b k p会切换到vb at供电。 这样可以继续维持bkp里面的数据。 如果v dd断电。 v bt也没电了。 那b k p里的数据就会清零。 因为bkp本质上是ram存储器啊。 没有掉电不丢失的能力。 然后后面一句的意思是。 待机唤醒或者复位时。 bkb的数据保持原样。 这个特性是显然要有的哈。 要不然你说你v dd掉电保持数据。 结果v dd以上电复位。 你数据也跟着清楚了。 那掉电保持就没有意义了。 就是bkb存储器的特性。 我们上小节也演示过他的实验现象对吧。 那接着看下面几条。 这个b k p还有几个额外的功能。 当然这些功能大家了解即可啊。 我们本节暂时不涉及。 第一个是tempo引脚产生的侵入事件。 将所有备份净容器内容清除。 temper是一个接到s t m3 外部的引脚哈。 它的位置可以看一下引脚定义。 这里可以看到pc 13杠temple gui tc。 也就是pc 13 temple i dc。 这三个功能共用一个引脚引脚位置啊。 就是v b a t旁边的2号引脚。 这个temper injure是一个安全保障设计啊。 比如如果你做一个安全系数非常高的设备。 设备需要有防拆功能。 然后b k p里也存储了一些敏感数据。 这些数据不能被别人窃取或者篡改。 那你就可以使用这个temple引脚的侵入检测功能。 设计电路时。 temple硬件可以先加一个。 默认的上拉或者下拉电阻啊。 然后引一根线到底的设备。 外壳的防拆开关或触点。 别人一拆开你的设备。 触发开关就会在temple件产生上升沿或者下降沿。 这样html就检测到侵入事件了。 这时b kb的数据会自动清零。 并且申请中断。 你在中断里还可以继续保护设备啊。 比如清除其他存储器数据。 然后设备锁死。 这样来保障设备的安全。 另外主电源断电后啊。 侵入检测仍然有效。 这样即使设备关机也能防拆。 就是temple侵入检测的功能。 大家了解一下。 然后下一条rtc硬件输出rtc校准时钟。 rtc闹钟脉冲或者秒脉冲。 rtc一角刚才看过了哈。 也是在pc 13这个位置。 这是rtc时钟输出的功能。 i t c的校准时钟。 闹钟或者秒脉冲的信号。 可以通过i t c引脚输出。 其中外部用设备测量rtc校准时钟。 可以对内部rtc微小的误差进行校准啊。 然后闹钟脉冲或者秒脉冲可以输出出来。 为别的设备提供这些信号啊。 这是rtc时钟输出的功能。 因为pc s3。 temple和r t c这三个引脚共用一个端口啊。 所以这三个功能同一时间只能使用一个。 接下去看存储rtc时钟校准计算器。 这个可以配合上面这个校准时钟输出的功能。 结合一些测量方法。 可以对i t c进行校准。 那这两个功能实际上就是r t c的配置啊。 我觉得放在r t c那个外设的地方。 应该比较合适。 当然r t c和b k b关联程度比较高哈。 设计者目前就是把这两个r d c的功能。 放在b k p里了。 这个大家知道一下。 那b kb的介绍和基本功能。 就上面这些。 最后看一下bkb中用户数据的存储容量。 在中容量和小容量设备里。 b k p是20个字节。 在大容量和互联型设备里。 b k p是84个字节。 我们使用的c8 t6 是中容量设备。 bkb就是20个字节。 所以可以看出bkb的容量其实非常小哈。 一般只能用来存储少量的参数。 那这就是bkb的简介。 我们就介绍到这里。 下面看一下b k p的基本结构。 这个图中橙色部分我们可以叫做后备区域。 b k p处于后备区域哈。 但后备区域不只有b k p。 还有r d c的相关电路也位于后备区域。 html后备区域的特性就是当v dd组电源掉电时。 后备区域仍然可以由vb a t的备用电池供电。 当v d d组电源上电视呢。 后备区域供电会由vb a t切换到v d d。 也是主电源有电时啊。 v b a t不会用的。 这样可以节省电池电量啊。 然后bkb是位于后备区域的b k p里。 主要有数据进气控制。 进气状态进器和r tc时钟校准净器这些东西。 其中数据容器是主要部分啊。 用来存储数据的。 每个数据电器都是16位的。 也就是一个数据电器可以存两个字节。 那对于重量和小量的设备里面有dr 1 dr 2。 一直到dr 10。 总共十个数据计算器。 那一个计算器存两个字节。 所以容量是20个字节。 就是上面这里说的20字节哈。 然后对于大容量和互联型设备里面。 除了d r一到dr 10。 还有d r 11。 d r 12。 一直到dr 42。 总共42个数据净水器容量是84个字节。 就上面这里说的84字节。 然后bkb还有几个功能哈。 就下面这里的轻度检测。 可以从pc 13位置的temple引脚。 引入一个检测信号。 当temple产生上升沿或者下降沿时。 清除bkb所有的内容。 以保证安全。 时钟输出。 可以把r tc的相关时钟。 从pc 13位置的rtc引脚输出数据供外部使用。 其中输出较准时钟时。 再配合这个校准计算器。 可以对idc的误差进行校准哈。 好以上。 这些就是b k p这个外设的结构和功能内容。 总体来说也不是很多哈。 大家了解一下。 那接下来我们就继续来学习这个rtc外设。 还是先看一下简介。 rtc英文全称是real time clock。 中文意思就是实时始终。 然后在s t m32 中啊。 rtc是一个独立的定时器。 可为系统提供时钟和日历的功能。 i dc实时时钟外。 一般就是指提供年月日时分秒。 这种日期时间信息的计时装置。 之前我们五一单片机学过ds 1302这个芯片。 d41302 是外置的rtc芯片啊。 这个芯片可以独立计时。 我们需要设置时间或读取时间。 就通过通信协议向他发送或接收数据来完成。 那在我们tf 3内部有这个tc的外设。 所以s t m32 可以在内部。 直接实现rtc的功能。 这样就不用在外挂r d c芯片了。 当然rtc芯片所必要的软件。 比如备用电池啊。 rtc晶振啊。 这些东西就要接到s t m32 上了。 那接着看下一条。 rtc和时钟配置系统处于后备区域。 系统复位时数据不清零。 v dd断电后可借助vbt供电继续走时。 这个特性就和之前bkp的一样的吧。 为了保持始终能一直连续运行不出错。 在主电源断电后。 i t c走时肯定不能停下来。 在系统复位时。 rtc实现值肯定也不能复位。 那为了实现这些功能呢。 vb t接上备用电池就是必须的了。 主电源断电后。 vbt的电池可以继续维持b kp和r tc的运行。 就是这一点就下一条32位的可编程计数器。 可对应ux时间戳的秒计数器。 这一点可以对照这个框图来理解哈。 可以看到这里负责计时的装置。 只有一个32位的秒计时器。 如果你没学过我们上一小节讲的unix时间戳。 可能就会非常疑惑了对吧。 你想这不是一个实时时钟外设吗。 那年那月那日呢。 小时呢。 分钟呢。 我之前学习ds 1302的时候。 那里面可是有一堆机器的什么年月日时分秒啊。 各种日期时间的信息都一目了然。 写入对应计算器就是修改时间。 读取对应计算器就是获取时间。 然后到这里你咋就只给我一个秒了。 这让我怎么用是吧。 初学者看到这可能会有这个疑问。 另外整个手册里也都没有提到。 时间戳这个东西啊。 所以如果你不了解时间戳相关的操作。 那确实不太好用这个i d c。 但是我们经过上小节的学习啊。 应该一眼就能看明白了。 这个是什么意思。 显然这个32位可编程计数器。 就对应的是时间戳里的秒计数器。 在读取时间时。 我们先得到这个秒数。 然后使用time点序模块里的local time函数。 就能立刻知道年月日时分秒的信息了。 在写作时间时。 我们先填充年月日时分秒信息。 到struck tm结构体。 然后用make time函数得到描述。 再写入到这个32位计数器即可。 这样操作。 这个秒计数器的思路是不是就很清晰了。 那得益于时间戳的设计啊。 这个硬件电路就得到了极大的简化。 你看要想实现年月日时分秒的计时。 我们只需要一个32位的秒注入器即可。 什么年月日小时分钟的机容器啊。 都不需要再设计了。 硬件也不再需要考虑大月小月。 平年闰年这些特殊情况的。 直接一个秒一直加就行了。 这无疑极大地简化了硬件电路的设计。 那当然硬件简化了。 压力就来到了软件这边。 我每次读取和写入秒计由器时。 都要进行时间戳的转换。 这需要消耗一定的软件计算资源。 就是这个32位可编程计数器的设计。 接下来就看这里的下一条。 20位的可编程预分频器。 可适配不同频率的输入时钟。 这可以继续对照下面这个图来理解啊。 这里32位的秒计数器显然一秒要自增一次。 所以这个地方驱动计数器的。 始终需要是一个1Hz的信号。 但是实际提供给rtc模块的时钟啊。 也是这里的r t c c l k一般频率都比较高。 所以显然我们需要在这之间加一个分频器。 给rtc clk降一降频率。 保证分频器输出给计数器的频率为1Hz。 这样计时才正确的对吧。 那为了适配各种频率的i t c c r k呢。 这里就加了一个20位的分屏器。 可以选择对输入时钟进行1~2的20次方。 这么大范围的分屏。 这样就可以适配不同频率的输入时钟。 就是这个可编程分离器的作用。 接下来最后一点可选择三种rtc时钟源。 分别是h s e始终除以128。 通常为八兆赫兹除以128。 通常为32点七六八千赫兹。 这个是固定的40 千赫啊。 这三个时钟可以选择其中一个。 接入到这里的tc clk。 那这三个始终都是什么意思呢。 我们可以看一下之前定时器这里讲过的。 rc c始终数。 这个图就是整个芯片的时钟系统。 整个芯片可以有四个时钟圆。 右下角写了哈。 h s e高速外部时钟信号。 h s i高速内部时钟信号。 l si低速内部时钟信号。 l o s e低速外部时钟信号。 这时钟字母啊。 你要记住h开头是高速。 l开头是低速。 e结尾是外部。 i结尾是内部高速低速。 内部外部一组合就是四种情况。 这里高速时钟一般供内部程序运行。 和主要外设使用。 低速时钟一般供rtc看门狗这些东西使用。 那对于我们本节的idc呢。 我们可以看到这一块。 这里指向的箭头通往i t c。 就是i t c c l k啊。 i t c c l k有三个来源。 第一个是o s c引脚接的h s e外部高速金正。 这个金针是主金针哈。 我们一般都用的八兆赫兹。 八兆赫兹进来。 通过128分屏可以产生rtc cl k信号。 为什么要先128分屏呢。 这是因为这个八兆赫兹的主金正太快了。 如果不提前分屏。 直接给rt c cl k。 后续即使再通过r d c的20位分频器。 也分不到1Hz这么低的频率啊。 所以八兆赫兹提前先进行128分屏。 后续20位的分屏器再进行一个适当的分屏。 就可以输出1Hz的信号给计数器了。 这是第一路来源h s e的时钟。 然后中间这一路始终来源是l s外部低速竞争。 我们在o s c32 这两个硬件。 接上外部低速晶振。 这个晶振产生的时钟。 可以直接提供给r d c c r k。 这个o s c32 的金针。 是内部r d c的专用时钟。 这个金正的值也不是随便选的哈。 通常跟r dc有关的竞争都是统一的数值。 就是32点七六八千赫兹。 为什么选择这个数值呢。 一方面是30 2000Hz。 这个值附近的频率。 是这个晶振工艺比较合适的频率。 你要说非要做一个1Hz的晶振。 那可能是做不出来或者做出来了。 但体积很大。 性能很差。 另一方面是32768。 这是一个二的次方数。 二的15次方等于37 六八。 所以32点七六八千赫兹。 即32768Hz。 经过一个15位分频器的自然溢出。 就能很方便地得到1Hz的频率。 自然溢出的意思就是设计一个15位的计数器。 这个计数器不用设置技术目标。 直接从0g到最大值。 就记得32767。 积满后自然溢出。 这个溢出信号就是1Hz自然溢出的好处。 就是不用再额外设计一个技术目标了。 也不用比较旧系是不是寄到目标值。 这样可以简化电路设计啊。 所以目前在r t c电路中啊。 基本都是清一色的。 32点七六八千赫兹的晶振。 你只要看到32点七六八千赫兹的晶振。 他八成就是提供给rtc的。 这是第二组。 最后看d364 中。 原来自于lsi内部低速rc振荡器。 lsi固定是40 千赫啊。 如果选择l si当做i t c h l k。 后续再经过40k的分屏。 就能得到1Hz的记录始终了。 当然内部的i c增长器。 一般精度没有外部晶振高。 所以l o s i给i t c c。 l k可以当做一个备选方案。 另外l y s i还可以提供给看门狗。 这个了解一下之后。 我们讲看门狗的时候再说。 那这三个时钟源呢。 我们最常用的就是中间这一路。 外部32点七六八千赫兹的晶振。 提供r t c c r k的时钟。 第一个原因就是中间这一路。 32点七六八千赫兹的晶振。 本身就是专供rtc使用的。 上下这两路其实是有各自的任务啊。 上面这一路主要作为系统主时钟。 下面这一路主要作为看门狗时钟。 他们只是顺带可以备选。 当做r d c的时钟。 正不占星的时钟。 我们自然很少用它了。 另外一个更重要的原因就是。 只有中间这一路的时钟。 可以通过v bt备用电池供电。 上下两路时钟在主电源断电后是停止运行的。 所以要想实现rtc组电源掉电继续走时的功能。 必须得选择中间这一路的rtc专用时钟。 如果选择的是上下两路时钟。 主电源断电后时钟就暂停了。 这显然会导致走时出错。 所以这三路始终我们主要选择中间这一路。 上下两路。 在特殊情况下可以作为备选方案。 就是这三路始终的介绍和选择问题。 那回到这里。 这个idc的简介我们就讲完了。 接下来我们来看一下这个rtc的框图。 看一下这个rtc外设具体是怎么设计的。 先整体上划分一下哈。 左边这一块是核心的分屏和计数计时部分。 右边这一块是中断输出使能和nvc部分。 上面这一块是app一总线读写部分。 下面这块是和pw关联的部分。 意思就是r dc的闹钟可以唤醒设备。 退出待机模式。 然后在图中我们看到有灰色填充的部分啊。 都处于后背区域。 这些电路在主电源掉电后。 可以使用备用电池维持工作。 另外这里还写了这些模块。 在待机时都会继续维持供电。 其他未被填充的部分就是待机时不供电。 有关睡眠停机待机在低功耗相关的内容哈。 我们下节选p wr的时候再来细讲。 这里先了解一下就行。 然后我们依次详细看一下。 首先看分屏和技术计时部分。 这一块的输入始终是r t c c r k。 这刚才说过r t c c l k的来源。 需要在r c c里进行配置。 可以选择的选项是这三个。 我们主要选择中间一路。 那因为这三路时钟频率各不相同。 而且都远大于我们所需要的。 1Hz的秒计数频率。 所以r d c4 l k技能。 首先需要经过r t c预分频器进行分屏。 这个分屏器由两个计算器组成。 上面这个是重装载兼容器r d c p i l。 下面这个rtc div手册里叫做余数计算器。 但实际上这一块跟我们之前定时器。 实际单元里的机器升级和重装值r是一样的。 作用可能是右边已经有一个计数器c nt了。 所以这个名字就比较奇怪。 叫做余数据用器。 但实际上它还是计数器的作用啊。 分屏器其实就是一个计数器。 记几个数。 溢出一次就几分屏对吧。 所以对于可编程的分屏器来说。 需要有两个计数器。 一个计算器用来不断的技术。 另一个计算器我们写入一个技术目标值。 用来配置是几分屏。 那在这里上面这个pll就是技术目标。 我们写出六。 那就是七分品。 写九那就是十分品。 因为就是指包含了零哈。 所以重装值写入几就是几加一分屏。 这个和定时器代理是一样的。 然后下面这个div就是每来一个。 始终记个数的用途了。 当然这个div计数器啊是一个质检计数器。 每来一个输入时钟。 div的值自检一次。 质检到临时再来一个输入时钟。 div输出一个脉冲。 产生移除信号。 同时d v从p i l获取重装值。 回到重装值继续质检。 举个例子。 比如i t c l。 k数始终是32点七六八千赫兹。 即32768Hz。 未来分屏之后得到1Hz。 pll就要给32767。 这个数值是始终不变的。 d i v可以保持初值为零。 那在第一个输入时钟到来时。 div就立刻移除。 产生溢出信号给后续电路。 同时div变为重装值32767。 然后第二个输入时钟div质检变为32766。 第三个时钟diy变为32765。 之后一直这样来一个数。 始终自检一次。 直到变为零。 然后再来一个输入时钟就会产生一个溢出信号。 同时d v回到32767。 以此往复循环。 这样的话也是每来32768个输入脉冲。 计数器溢出一次。 产生一个输出脉冲。 这是32768分屏呢。 分屏输出后的时钟频率是一个值。 提供给后续的秒计由器好。 然后看一下技术基础部分。 这一块就比较简单了。 32位可编程计数器。 r t c c n t就是计时最核心的部分。 我们可以把这个计由器看作是unix。 时间戳的秒接由器啊。 这样截图time点区的函数就可以很方便地得到。 连月日时分秒了。 然后在下面这里。 这个i t c还设计的有一个闹钟进器。 rtc a l2。 这个l2 也是一个32位的进器。 和上面这个cnt是等宽的。 它的作用顾名思义啊。 就设置闹钟。 我们可以在hl 2写个描述设定闹钟。 当cnt的值跟l2 设定的闹钟值一样时。 也是这里画了等号啊。 如果他俩值相等。 就代表闹钟响了对吧。 这时就会产生idc alarm闹钟信号。 通往右边的终端系统。 在中断函数里你可以执行相应的操作啊。 同时这个闹钟还兼具一个功能。 就下面这里的闹钟信号。 可以让s tx 2退出待机模式。 这个呢就可以对应一些用途啊。 比如你设计一个数据采集设备。 需要在环境非常恶劣的地方工作。 比如海底啊。 高原深井这些地方。 然后要求是每天中午12点采集一次环境数据。 其他时间为了节省电量。 避免频繁换电池。 芯片都必须处于待机模式。 这样的话。 我们就可以用这个rtc自带的闹钟功能。 定一个中午12点的闹钟。 闹钟一响。 芯片唤醒。 采集数据完成后继续待机。 这样是不是就可以完成这个任务了。 另外这个闹钟值是一个定值哈。 只能想一次。 所以如果你想实现周期性的闹钟。 大家每次闹钟响之后都需要再重新设置一下。 下一个闹钟时间。 就是这个闹钟和闹钟唤醒的一个用途。 那继续往右看。 这是中段部分的。 在左边这里有三个信号可以触发中断。 第一个是rtc second秒中断。 它的来源就是c n t的输入时钟。 如果开启这个中断。 那么程序就会每秒进一次r t c中断。 第二个是i d c overflow溢出中断。 它的来源是c n t的右边。 意思就是c n t的32位计数器。 计满溢出来会触发一次中断。 所以这个中段一般不会触发。 我们上一节说过啊。 这个c n t定义的是无法数。 到2106年才会溢出。 所以这个中段在2106年会触发一次。 如果你想程序更完善一些。 可以开启这个中段。 到2106年就是一出。 为了避免不必要的错误。 你可以让芯片罢工。 然后提示当前设备过了。 请及时更换。 但在2006年之后啊。 这个s t m32 的rtc就不太好用了。 到时候或许可以通过打补丁的方式继续运行。 或者直接淘汰32位的时间戳。 这个问题就留给后人解决吧。 来继续看下面第三个idc alarm闹钟中断。 刚才说过。 当计数器和闹钟值相等时。 触发中断。 同时拉钟信号。 可以把设备从待机模式唤醒好。 这是这三个中断信号。 中断信号到右边这里。 这一块就是中断标志位和中段输出控制。 这些f结尾的是对应的中断标志位。 ie结尾的是中断使能。 最后三个信号通过一个或门汇聚到nvc。 中断控制器。 这个地方是不是漏画了一根线啊。 中间这个应该也是要通过货门的哈。 好这是右边的中断部分。 然后上面这部分app一总线和app一接口。 就是我们程序读写计算器的地方呢。 读写计算器可以通过app一总体来完成。 另外也可以看出啊。 i dc是app一总线上的设备。 最后下面这一块退出待机模式。 还有一个wake up硬件。 闹钟信号和wake up硬件都可以唤醒设备。 wake up硬件可以看一下截图案。 就这里pa 0的位置它兼具唤醒的功能。 这个我们下一节再学习好。 到这里。 我们这个idc外设框图就已经全部了解清楚了。 接下来看一下我这里给的基本结构。 再总结一下以上内容吧。 rtc的核心部分如图所示。 最左边是rtc clk始终来源。 这块需要在r c c的配置三个时钟。 选择一个当做c c cl k之后。 dc clk先通过预算明细对时钟进行分屏。 余数计算器是一个质检计数器。 存储当前的计数值。 重装计算器是技术目标。 决定分屏值分屏之后得到1Hz的秒计数信号。 通向32位救器。 一秒自增一次。 下面还有个35的闹钟子。 可以设定闹钟。 如果不需要闹钟的话。 下面这一块可以不用管。 然后右边有三个信号可以触发中断。 分别是秒信号。 计数器。 溢出信号和闹钟信号。 三个信号先通过中断输出控制进行中断。 使能死人的中断才能送交n o c。 然后向cp u申请中断。 在程序中我们配置这个数据选择器。 可以选择始终来源配置。 桶装净水器可以选择分频系数。 配置32位救器。 可以进行日期时间的读写。 需要闹钟的话。 配置上车为闹钟值即可。 需要中断的话。 先允许中断。 再配置n v i c。 最后写对应的中断函数即可。 这是r t c y c的主要内容。 我们就讲到这里。 那s t m32 内部的设计清楚了。 外部的一些电路也还是需要的。 为了配合s t m32。 r t c外部还是需要有一些电路的哈。 在最小系统电路上。 外部电路还要额外加两部分。 第一部分就是备用电池。 第二部分就是外部低速晶振。 我们来看一下。 首先备用电池供电部分。 我这里给了两个参考电路啊。 第一个是简单连接。 就使用一个3伏的电池负极和系统供电正极。 直接接到s t m32 的vb t硬件。 这样就行了。 这个供电方案非常简单哈。 参考来源是s t m32 的数据手册。 在5.1.6供电方案。 这里就给出来。 这个图。 图上画的就是。 直接建一个1.8~3.65的电池。 到vbt就行了。 另外也可以看到啊。 在内部是有一个供电开关的。 当v dd有电时。 开关拨到下面。 后备电路有v dd供电。 当v dd没电时。 开关拨到上面。 后备电路由vb d供电。 然后vbt供电的设备啊。 在这里写了。 v bt供电的后备电路有30 2000Hz振荡器。 rtc唤醒电路和后备计算器。 那这就是根据数据手册里设计的。 vb at供电方案。 这个设计非常简单。 一般来说也没问题。 然后我这里还给了第二种方案是推荐连接。 这种连接方法是。 电池通过二极管d一向v bt供电。 另外组电源的3.3伏。 也通过二极管d2 向v bt供电。 最后vb at再加一个。 0.1微法的电源滤波电容。 这个供电方案的参考来源是。 s t m32 的参考手册。 在这个4.1.2电池备份区域。 这一节有这样描述啊。 大家可以都看看。 其中有几个建议。 一个是在这些这些情况下。 电流可能通过vd d和vbat之间的内部二极管。 注入到vbat。 如果与vbt连接的电源或者电池。 不能承受这样的输入电流。 强烈建议在外部。 v bt和电源之间连接一个低压降的二极管。 另一个是如果在应用中没有外部电池。 建议v bt在外部连接到vd d。 并连接一个100纳法的陶瓷滤波电容。 所以综合这两条建议啊。 我们可以设计出右边的推荐链接。 电池和主电源都加一个二极管。 防止电流倒灌。 v b t加一个0.1微法的电源滤波电容。 0.1微法就是100纳法。 如果没有备用电池。 就3.3伏的主电源供电。 如果接了备用电池。 3.3伏没电时。 就是备用电池供电。 这是根据参考手册设计的推荐电路啊。 如果你只是进行实验。 那使用左边的简单连接就行了。 如果你要换板子设计产品。 那还是推荐使用右边的链接。 这样更保险啊。 好这是vbt供电部分。 然后继续看一下右边的外部低速晶振部分。 这是一个典型的晶振电路了。 这里x一是一个32.7。 六八千赫兹的rtc晶振。 这个阶段不分正负极。 两端分别接在o s c32 这两个硬件上。 然后进这两端再分别接一个启动电容到jd。 这个电路的设计。 参考来源还是s t m32 的数据手册。 在5.3.6外部时钟源特性。 这里有参考电路啊。 使用一个晶体或陶瓷谐振器。 产生的低速外部时钟。 下面这里就是典型电路。 晶振是32点七六八千赫兹。 cl一和cl 2上面这里写了哈。 对于cl一和cl 2。 建议使用高质量的五批发到十。 五批发之间的磁介电容器。 所以对于硬件电路的设计啊。 但还是得多看看手册。 手册。 看多了自然就会了。 所以在这里我给出的晶振电路是这样的。 起征电容给的是十皮法。 这是这两块电路。 最后看一下右边的图片啊。 这个备用电池。 我们一般可以选择这样的3伏纽扣电池。 型号是cr 2032。 这是一个非常常用的纽扣电池型号啊。 另外注意这个纽扣电池印制的这一面是正极。 这里也有个正号标注啊。 另一面比较小的那个电极是负极。 这个别搞错了。 然后32点七六八千赫兹的晶振。 我们可以选择这样的一个金属壳柱状体的晶振。 这个竞争也是比较常见哈。 大家拆开钟表电子表。 基本上都能找到这样一个软件。 这是32点七六八千赫兹的晶振。 真正的全称是石英晶体振荡器啊。 所以我们常说的石英钟啊。 名称就来源于这样一个软件。 然后下面这个是我们的最小系统板。 这个板子自带的有rtc晶振电路。 这里这个黑色的软件写的有32.768k。 这个也是一种样式的r d c晶振啊。 然后旁边这个金属壳柱状体是八兆赫兹的。 外部高速晶振。 不过我们这个板子没有自带备用电池。 v b a t硬件。 直接通过右上角的这个端口引出来了。 如果需要备用电池的话。 可以接在这里。 或者直接把3.3伏的主电源接在这里。 也能实现功能啊。 好以上就是这个i t c的硬件电路部分。 最后我们再看一些这个idc的一些操作注意事项。 这些注意事项都是从手册里复制过来的文字哈。 写程序的时候需要注意这些问题。 我们依次看一下。 首先第一条执行以下操作。 将使人对bkp和r dc的访问。 设置r c c a b b1 e2 的p w r。 e n和b k p音。 使人p w r和b k b时终设置。 pwr c r的dbp只能对bkp和r tc的访问。 这几条就提醒一下正常的外设。 第一步开启始终就能用了。 但是b k b和r t c这两个外设呢。 开启稍微复杂一些。 首先要设置c c a b b一英二。 这个实际上就是开启app一外设的时钟啊。 要同时开启pwa和b k p的时钟。 对于rtc来说并没有单独开启始终的选项。 然后我们还要设置pwcr的db p尾来。 只能对bkp和r tc的访问。 这个调用p wr的库函数开启一下就行。 所以总结一下。 就是如果你要使用b k p或者r t c。 都要先执行这两步。 第一步开启p w和b k p的时钟。 第二步使用pw使人bkb和rtc的访问。 这个我们在初始化的时候需要注意一下。 按照这个流程来就行了。 之后下一条如果在读取r d c计算器时。 i tc的app一接口曾经处于静止状态。 这软件首先必须等待。 rtc cl计算器中的rsf寄存器同步标志。 被硬件之一。 这一步对应代码里的一个库函数就是idc。 等待同步。 一般在刚上线的时候调用一下这个函数就行了。 为什么要有这一步呢。 可以看看这个图。 在这里会有两个时钟。 pcl k一和i t c c l k。 pc 2 k一在主电源掉电时会停止。 所以为了保证r t c组电源掉电正常工作。 r t c里的机用器。 都是在r t c c l k的同步下变更的。 当我们用p c lk驱动的总线。 去读取rtc c l k驱动的计算器时。 就会有个时钟不同步的问题。 rtc净水器只有在rtc clk的上升一点更新。 但是p c lk一的频率36兆赫兹。 远大于r t c c l k的频率30 2000Hz。 如果我们在a p p一刚开启时。 就立刻读取rtc进器。 有可能rtc就用器。 还没有更新到a p p e总线上。 这样我们读到的值就是错误的。 通常来说就读取到零哈。 所以这就要求我们在a p p e总线刚开机时。 要等一下i t c c l k。 只要i t c c l k来一个上升沿。 rtc把它的计算器的值同步到app e总线上。 这样之后读取的值就都是没问题的了。 这是设计细节的一个问题啊。 当然我们其实也不用管那么多了。 只需要在初始化时调用一个。 等待同步的函数就行了。 那我们继续看。 必须设置idc cl计算器中的cnf位。 使r d c进入配置模式后。 才能写入r d c p l。 i t c c n t r t c l r进去。 这一条其实比较简单哈。 就是i d c会有一个进入配置模式的标志位。 把这一位置一才能设置时间。 其实这个操作在库函数中。 每个写计数器的函数。 它都自动帮我们加上了这个操作。 所以我们就不用再单独调用函数。 进入配置模式了。 然后最后一条对rtc。 任何计算器的写操作。 都必须在前一次写操作结束后进行。 可以通过查询r d c c r计算器中的rt off状态。 为判断r t c计算器是否处于更新中。 仅当rt off状态会是一时才可以写入tc进器。 这个操作也是调用一个等待的函数就行了。 跟我们之前读写flash芯片是类似的。 就写作之前要等待一下。 如果上一次的写作还没完成。 你就别急着写下一次了。 或者说每次写入之后。 你要等待rt 2为一。 只有t2 为一了才表示写完成。 为什么要有这个操作呢。 其实还是因为这里的p c l k1。 和i d c c l k时钟频率不一样。 你用pc 2 k一的频率写入之后。 这个值还不能立刻更新到i t c的计算器里。 因为rtc计算器是由rtc clk驱动的。 所以pc 2 k一写完之后。 得等一下dc c2 k的时钟。 i t c c r k来个上单眼。 只更新到rtc金容器里。 整个写作过程才算结束了。 这个操作。 了解一下。 在代码里由是调用一个等待函数的事。 那这些就是操作这个rtc的一些注意事项。 其实都是一些细节问题。 这个我们写代码的时候会再给大家提一下的。 现在大家先知道有这么个事儿就行了好了。 有关b k p和i d c的知识点。 我就讲这么多。 最后还是照例看一下手册啊。 本节课涉及手册的内容主要是第五章。 备份禁用器b k p和第16章14中i t c。 先看一下b kb的内容啊。 手册里对b kb的介绍还是非常少的。 总共就是一页多点。 后面就是计算器描述了这么点内容。 大家可以全都再仔细看一看的。 请问上面这一段是b kb的简介。 最后这几句就是我们ppt注意事项的第一条啊。 初始化第一步要先开启pwa和b kb的时钟。 在使能对b kb和r t c的访问。 下面这些是bkb的特性和轻微检测的具体描述。 大家可以再看看之后rtc校准建筑。 rtc校准时钟输出和校准计算器的功能。 可以对i t c进行校准啊。 关于rtc校准和如何提高精度。 请再查看这个文档计划。 下面就是计算机描述了。 首先备份数据。 用期一到十。 总共十个。 每个数据运气都是16位的。 可以在这里存储自己的数据啊。 然后rtc时钟校准净器里面可以配置。 输入时钟的选择和校准值。 下面是控制计算器。 主要用来配置轻雾检测的功能。 轻微信号的低频极性和是否开启轻雾检测功能。 之后。 控制状态计算器里面是一些标志位等。 最后就是存储器印象的总。 比尔里面dr 11直到dr 10还是在一起的。 中间是一些控制净水器的。 最后额外的还有dr 11。 一直到dr 42。 后面这一块是大容量和互联型设备才有的。 那这些就是b k p的内容。 bkb还是比较简单的哈。 也没有很多东西。 那我们再看一下idc。 前面是一些简介。 最后这里也写了哈。 它的开启流程和b k p那里是一样的。 最后这是一些主要特性。 我们基本也都提到过啊。 后面是一些功能描述。 还有系统框图。 这个我们都仔细分析过。 大家可以再研究研究复议过程。 两段话看一下之后读取rtc净水器。 这个刚才注意事项里说过。 这是对这个问题的详细描述。 大家可以再看看。 当然我们需要做的就是在i p p一开启时。 调用一个等待同步的函数就行了。 然后下面是写i t c的注意事项。 这个也是我们刚才说的写入时的注意事项。 大家看看下面这个标志的设置。 有些时序图啊。 其实就是对rtc工作流程的一个描述。 我们可以稍微看一下。 这里面涉及的细节还是非常多的。 这里的例子是p2 等于三。 alarm等于四。 p2 就是p r l2 分频器的重装值。 p2 等于三。 就对r t c c l k进四分别看一下。 这里第一行是pr里面的值。 正在自检。 当然重装值应该是始终不变的啊。 所以这个质检应该是余数计算器d i v。 可以看到div 32103210。 这样不断自检。 当它击到零之后。 下一个值变为重装值。 同时触发一个秒脉冲。 每个秒脉冲下面的c nt机油器自增一次。 可以看到这个cnt至尊的时刻。 是秒脉冲的下降眼。 所以c nt至尊相比较。 分屏器重装的时机是慢了一个。 i t c l k始终的之后c nt一直增加增。 直到c nt为四。 这时c nt等于闹钟子。 那么闹钟信号的触发时机呢是在这个时刻。 就是c n t等于四期间的最末尾。 和这个秒信号的上升沿是一起的。 然后最后一个闹钟标志位。 也会在此时刻至一挂起。 如果开启了闹钟中断程序。 就会进入中断函数。 在终端函数里有软件清除这个闹钟标志位。 就是rtc里面工作的一些细节。 然后下面还有一个溢出的死去图。 这里cnt已经寄到非常大的值了。 f f f f f f f b马上就要记满了之后。 继续g g f c f d f e f f记满之后。 在这个时刻产生over flow溢出信号。 最后溢出标志位之一。 如果开启了溢出中断。 就进入中断函数。 那这两个时序其实和我们之前讲的rtc。 工作流程是一样的哈。 就时序图体现的细节更多。 这个了解一下之后。 就是rtc的计算器描述了。 首先控制计算器高位。 这是一些中断。 允许位控制计算器低位。 这是一些标注位等等。 这里我们发现这个rtc和b kp的计算器啊。 其实都是16位的。 你看这一个进气明明就是32位的。 被他强行拆分为两格了。 一个高位。 一个低位。 这个应该是为了简化电路设计哈。 对于这些不是那么重要的外设。 就没有必要再上32位的中线了。 16位的总线足够用了。 设计也会简单一些。 所以这里的计算器就都是16位一个的。 那接着看。 这是预分频器。 重装载计算器。 这个分屏器是20位的。 所以高16位只有四个有用。 再和下面低16位组合到一起。 就是20位的重装值。 下面预分别器余数计算器。 这里四位和下面16位就是20位的质检救器。 然后计数器计数器cnt高速六位加低次列位。 这就是核心的32位计数器了之后。 闹钟计算器高16位加低16位。 这32位的闹钟子。 最后是rtc计算器的一个总表。 就是rtc的内容来到这里。 我们本小节的内容就全部结束了。 下一小节我们来开始学习。 bkb和r t c的代码部分。
43. 哈喽大家好。 本小节我们来开始写代码哈。 然还是先看下经验图。 看一下12杠一的图片。 这是读写BKP程序的接线。 右下角是OID显示屏PB1引脚。 这里接个按键用于控制。 这些都是老演员了哈。 然后在板子的右上角。 这个vb引脚。 或者叫vb d赢家是备用电池的供电脚。 在实际应用的时候需要备用电池的话。 这个角一般都是接着三伏的纽扣电池。 备用电池的接法。 在我们PPT的这里也给出来了两种参考电路啊。 按照这个接就行。 那我们这里进行实验的话。 可以直接从s st link引出一根3.3伏的供电。 接到这个vb d硬件。 这样也可以啊。 毕竟我们在他家里也没有配纽扣电池。 然后这里注意一下。 这供电一定要从这个3.3伏的阴角印出来。 从引脚标号上看。 这两个7号和8号角都是3.3伏供电。 你不要紧。 成下面这两个五伏的了。 微变器是不支持五伏供电的。 这个注意一下好。 这就是这个读写BKB程序的接线。 接着下一个RTC程序的接线图。 我们也一起看一下吧。 可以看到这里接线其实都是一样的。 vb叫接3.3伏备用电源就行。 当然ITC这个程序我们暂时没用到按键。 然后i DC的外部低速晶振上小姐说过啊。 这个IDC晶振电路板上自带的就有。 所以RTC晶振部分我们接线就不用管了。 就是这两个程序的界线图。 来看一下面包板。 我们接下线路。 首先我们在PB1接个按键。 然后我们找出一根公对母的杜邦线。 一头接在板子右上角的vb at银角。 另一头接在s t link的3.3伏电源输出口。 这个注意啊。 一定不要接到五伏的供电硬件了。 好这样硬件接线我们就完成了。 之后我们回到工程文件夹。 复制一下OLED显示屏的代码。 改个名字叫12杠一读写备份计算器。 打开工程再删掉。 编译一下。 那接下来我们就要规划一下。 我们这个程序应该怎么写对吧。 目前我们想要实现的就是简单的读写。 BKP的功能。 所以大体的步骤就是先初始化。 然后写DR再读。 第看看写进去的和读出来的是不是一样。 这样就行了。 那有关BKP的代码其实是非常少的。 所以这里暂时就不再对BKP进行封装了。 我们直接在主函数里演示一下它的功能就行。 BKP的初始化步骤也是非常简单的。 我们看一下PPT。 最后这里的注意事项。 BKB的初始化步骤就是这两句就行了。 第一步开启PWW和BKP的时钟。 第二步使用PWA的一个函数。 只能对BKP和IDC的访问。 然后写入数据的话。 BKP有个写入的函数读取数据。 BKP也有个读取的函数。 就是我们的大体思路。 接下来我们就来看一下BKP相关的库函数啊。 我们打开BKB点去玩。 到最后看一下。 这也是BKP所有的库函数。 我们一看一下第一个bkp d it恢复缺省配置。 这个函数我们也是有一个用途的。 就是手动清空pk p所有的数据运气。 你看如果有备用电池的话。 BKB的数据主电源掉电不清零。 上电复位也不清零。 他就没有清零的时候。 那如果我们确实想要清零的话。 该怎么办呢。 这时就可以调用一下这个函数。 这样所有BKP的数据都会变零。 当你把所有的BKB数据。 运气手动一个个全部写入零也是可以的啊。 这是恢复缺省配置函数的用途。 b k p temporpin level configure和temple pin command。 显然这两个函数是用于配置temple。 侵入检测功能的。 temple pin level configure可以配置tempo引脚的。 有些电平就是高电平触发还是低电平触发。 tempering command就是是否开启天无检测功能。 如果需要侵入检测的话。 要先配置temple有效电平。 再使人轻入检测功能就行了。 最后bk p i t很fire中断配置就是否开启中断。 B k p rtc output confire。 这是时钟输出功能的配置。 可以选择在RTC硬件上输出时钟信号。 输出ITC校准时钟。 RTC闹钟脉冲或者秒脉冲之后。 B k p set rt c calibration value。 设置ITC校准值。 这个其实就是写入ITC校准净水器。 那以上这函数就是我们上一小节说的。 BKP附加的一些小功能。 这些功能了解即可哈。 我们暂时不用。 那下面两个就是读写BKP的重点函数了。 B k p write backup register。 写备份定系。 第一个参数指定你要写在哪个DR里。 第二个参数就是要写入的数据了。 这是一个16位的整形数据。 然后bkp read backup register。 读备份。 这种器参数指定要读哪个DR返回值。 就是DR里存的值。 这两个函数非常直观。 好理解吧。 最后四个函数。 老朋友这个不用解释。 那这些就是BKP的所有函数。 我们就清楚了。 之后我们还要再看一个个数。 找一下PW2点去看一下数。 这是PWRY4的库函数。 PWRY设。 我们下节再讲。 现在我们主要关注一个函数。 就这个pwi backup excess command。 备份进器访问死人可以看一下定义啊。 这个函数的内容就是设置PWRCR。 计算器里的dB p为。 这也对应了我们PPT这里写的。 设置PWRCI的dB p。 使人对BKP和RDC的访问。 所以这一步我们就调用PWM的这个函数就行了。 好函数看完我们就可以来开始写代码了。 首先是BKP的初始化。 看PPT初始化。 第一步开启PWA和BKP的时钟。 所以代码这里开启始终还是老朋友函数。 R c c a p p1。 这两个都是APP1的外设啊。 然后外设时钟控制第一个参数cc a b b1外设。 找一下PW。 第二个参数以label开启PWR的时钟之后。 复制一下PW删掉哈。 提示一下选择BKP。 这样开启始终就完成了。 接下来PPT里的第二步。 使人对BKP和RDC的访问。 我们找一下刚才才看的函数啊。 PW不备份访问控制放到这里。 参数new state给able就行了。 这样初始化就完成了。 是不是很简单。 接下来我们只需调用这里的写函数。 写入读函数读出就完事了。 比如说我们调用显函数放到这里。 参数可以转到定义。 看一下第一个参数BKPDR。 这个参数可以是BKPDRX。 其中X可以是1~42。 其中一个数字。 所以我们复制这个BKPDRX放到这里。 然后呢X可以替换成1~42之间的数字。 当然只有大容量和互联型才有42个D哈。 我们目前这个中容量的芯片DI的范围是1~10。 注意不要写超了。 比如我们给个BKPDR1。 指定第一个DR之后就是要写入的数据了。 这是UINT16杠T类型的数据。 我们随便给一个0X1234。 这样就是BKP的写入。 那写入对不对呢。 我们读出来看看就知道了。 读取BKP。 我们用这个读取的函数复制放到这里。 读取哪个DR呢。 我们就读刚才写入数据的DR。 一读取的值作为返回值返回出来。 我们用OID显示一下。 看看OID修hex number。 一行一列显示的数据是上面这个函数的返回值。 数据长度为四。 这样简单的测试程序就完成了。 我们下载测试一下。 下载看一下。 这里OLED显示的是1234。 这说明我们初步的测试是没问题的。 那这个数据是不是可以在主电源掉电的情况下。 由备用电池维持呢。 我们继续测试。 在程序中我们把这条写入的代码注释掉。 我们不在BKP写入数据。 直接读取。 看一下现象下载看一下。 目前直接读取BKP数据还是1234。 因为我们目前芯片是没有掉电过啊。 所以BKP的数据是保持原样的。 然后按复位键。 数据仍然是1234。 说明复位是不会清空BKP的。 最后再测试。 我们把主电源断电。 再重新插上。 可以看到数据仍然是1234。 这个数据就是有备用电源维持的了。 那最后测试我们把备用电源拔掉。 主电源再断电。 重新上电。 可以看到BKB的数据就清零了。 这说明如果没有备用电源。 主电源断电后。 BKB的数据是维持不了的。 这符合我们的实验预期哈。 这是我们对BKP进行了测试好了。 最后我们就完善一下这个程序。 让它跟我们最开始演示的一样哈。 首先我们定义两个数组。 一个用于写入。 一个用于读出数据类型。 用int压六杠七数字名和rewrite。 数据可以随便给两个哈。 0x12340 x 5678。 下面用int胶热杠TBURREAD。 速度长度给二。 这是用于存放写入和读取数据的数组啊。 那在OID初始化之后。 我们也显示两个字符串。 OID修string。 一行一列显示W冒号表示后面是写入的数据。 复制一下。 二行一列显示二冒号表示后面是读取的数据。 则是这一部分。 之后按键修改数据的功能也是需要的。 这样测试才更全面对吧。 那我们把按键的功能也拿过来。 先INQUOTE一下之前写的K点去之后。 定义存放键值的变量。 new INT8杠7k number。 然后按键初始化。 在这里。 k edit到这里。 我们在准备工作就完成了。 接下来我们在主循环里实现功能。 首先是按下按键。 我们要变更一下数据。 在写入的BKB中。 所以是k number等于k get number获取代码。 if可以。 number等于等于一按。 你按下。 这时我们可以变换数据。 再写入到BKP里。 变换数据呢我们就来个bur。 加加。 和rewrite1加加。 把这两个数据都自增一次。 写入BKB呢就是之前这里的函数。 我们把AI write0的数据写入到DRE里。 把ARREWRITE1的数据写入到第二列。 我们同时写入两个。 这样说明读写多个DI也是没问题的。 那写完之后我们可以显示一下写入的值。 OID修hex number。 一行三列显示ARREWRITE0长度为四。 然后再来一个一行八列显示ARREWRITE1。 这个就是看一下写入的数据哈。 那读取数据呢。 我们就直接在if外面主循环里不断的读取。 刷新显示。 这样数据一旦有变化。 我们就能第一时间知道啊。 所以我们在这后面来个BKB读取DR。 一把它放到array ray的邻里。 复制一下。 再来个BKB读取DR2。 放到array raid1里。 最后调用YD显示一下。 复制一下。 我们放在第二行显示的数据换成aria read。 然后上面这两行没用了。 删掉啊。 这样我们这个比较完善的测试程序就写好了。 大概整理一下程序思路哈。 程序最开始是初始化和两个用于指示的字符串。 显示。 最后这三句就是BKB的初始化了。 然后主循环里循环执行的部分是先获取件码。 如果按键按下。 我们就变换一下测试数据。 把测试数据分别写入到BKB的DR1和DR2。 再在OLED显示一下我们写入的数据。 这是按键按下的操作。 最后在没有按键按键时。 我们也不断的读取BKP的DR1和DR2。 刷新显示的OID上。 看一下当前BKB的数据是什么。 这是测试程序的逻辑。 那现在试一下看看。 目前W后面什么都没显示。 所以目前我们还没有写入。 这时读出来的数据是00000000。 那么按下按键数据变换写入数据。 可以看到写入的是12355679。 因为第一次写读之前就已经自证那一次。 所以第一次写入就是自增一次。 之后的数据是12355679哈。 不是数组默认的12345678。 如果你想第一次是12345678。 那可以先写入再自增对吧。 然后下面可以看到读取的数据和写入。 1212355679。 然后继续变换数据。 写入和读取的都是一样的。 之后主电源掉电再重新上电。 目前上电后还没有写入。 读取的值是掉电前最后一次写入的数据。 这是这个程序现象啊。 测试没问题好。 那有关BKB的实验。 我就讲这么多。 大家知道BKB的特性会读写BKP就行了。 那接下来我们来学习下一个代码。 RTC实时时钟回到工程文件夹。 我们还是复制一下id的代码。 改一下名字。 12杠二实时时钟打开工程。 直接删掉。 编译一下。 那对于RTC的代码。 我们就新建一个模块给它分装一下哈。 这里快速建立一个模块。 在system右键RTC就放在system目录下吧。 模块名称叫买RTC存储位置放在system文件夹里。 后面的步骤快进一下。 这里模块建好也还是先写一个初始化函数。 word买rtc it y的。 在这里面我们来对RTC外设进行初始化。 老规矩啊。 我们还是先来梳理一下步骤。 看一下。 不管数。 首先初始化流程我们参考PPT这个基本结构图。 初始化第一步和BKB一样。 在使用这个RTC外设之前。 我们同样得执行注意事项的第一点。 开启PW和BKB的时钟。 使能BKP和RTC的访问。 这个代码和BKP初始化那里是一样的。 之后第二步启动RTC的时钟。 这里我们计划使用LOSE作为系统时钟。 所以我们要使用RCC模块里的函数。 开启LSE的时钟。 这个LOSE始终啊为了省电。 默认是关闭的。 所以LOSE需要我们手动开启。 要不然用不了之后。 第三步配置RTCCLK这个数据选择器。 指定LOSE为ITCCLK。 这一波的函数也是在cc模块里的。 第四步。 先别急着往后看。 我们要执行一下注意事项。 这里的操作就是调用两个等待的函数。 一个是这里的等待同步。 另一个是这里的等待上一次操作完成。 这两个函数照例调用一下。 就进来之后。 第五步我们需要配置这个预分频器。 给PL重装电容器一个合适的分屏值。 以确保输出给计数器的频率是一赫兹。 接着第六步配置CNT的值。 给这个RTC一个初始时间。 再之后呢。 如果你需要闹钟的话。 可以配置闹钟值。 需要中断的话。 可以配置中断。 这部分就是配置ITC的步骤啊。 那可以发现因为这个ITC比较简单。 所以库函数并没有使用结构体来配置。 然后ITC也没有ITCCMD。 这样弹数开启始终就能自动运行了。 不需要最后再启动一下的。 这是初始化流程。 那流程记录了。 我们就来看一下库函数展开library目录。 首先我们要看一下RCC点。 去看几个ICC时钟配置的函数。 在这个RCC库函数里找一下。 我们可以看到这几个函数。 这几个就是和ITC始终相关的函数。 其中i c c l s e configure。 配置LS外部低速时钟。 启动LSE始终就调用这个函数。 i c c l si command配置LSI内部低速时钟。 如果你出现了外部时钟不起正的情况。 也可以使用这个内部时钟来进行实验啊。 I c a r d c c l k config。 ITCCLK配置这个函数。 用来选择RTCCLK的时钟源。 实际上就是配置PPT的这个数据选择器。 I c c i t c c r k command。 启动ITCLK这个就是在调用上面这个函数。 选择时钟之后。 我们还需要调用一下这个command函数。 使人一下。 这样才行哈。 这是这是个函数。 另外我们本节还需要用到最后这个ICC。 get flag status函数。 获取标注位。 因为这个LSE始终啊。 不是说你让它启动它就能立刻启动的。 调用这个启动时钟的函数之后。 我们还需要等待一下标志位。 等RCC有个标注位。 l s e ride至一之后。 这个时钟才算启动完成工作稳定。 这个也要注意一下。 那有关于RCC时钟部分的函数。 我们就了解这么多。 接下来我们继续看R7C点一句。 划到最后看一下函数。 第一个RTCITCONFIG配置中断输出。 第二个rtc enter configure mode。 进入配置模式。 转到定义。 这个函数就是自cl的CNF为一进入配置模式。 对应PPT注意事项。 这一条必须设置ITCCIL计容器中的cf位。 使ITC进入配置模式后才能读写这些计容器。 然后继续rtc exit configure mod。 退出配置模式。 就是把cf v70下一个rtc get counter。 获取CNT计数器的值。 显然读取时钟就靠这个函数。 i DC set count写入CNT接收器的值。 显然设置时间就靠这个函数。 i t c set prega写入预分频器。 这个词会写入到预分频器的PL重装进容器中。 用来配置预分频器的分频系数。 Rtc set up lab。 写入闹钟子。 需要配置闹钟的话。 用这个函数r DC get divider。 读取域分明器中的div余数应用器。 余数计算器是一个质检计数器啊。 获取余数定器的值。 一般是为了得到更细致的时间。 因为4T技术间隔最短就是一秒。 如果你要更新的时间。 比如分秒厘秒毫秒。 那就得靠这个div余数器来实现。 I dc wait for last task。 等待上次操作完成。 转到定义。 看一下函数内容。 就是循环直到RT off状态位为一。 对应PPT注意事项的这一条。 等待前一次写操作结束。 继续看rtc wait for synchro。 等待同步。 函数内容是清除RSF标志位。 然后循环直到RSF为一。 对应PPT注意事项的这一条。 等待RSF至一继续。 后面四个函数就是和标志位相关的函数了。 好到这里。 相关的函数我们就看完了。 接下来我们就正式来写程序。 回到买RTC1例函数里来。 我们按照刚才讲的步骤来初始化。 第一步。 开启PWA和BKP的。 始终只能BKP和RTC访问。 和BKB的初始化一样哈。 这里快速写一下。 好第一步实战部分完成之后。 第二步开启LSE始终并等待LSE始终启动完成。 这里我们调用ACC里的LSDCONFIG函数放在这里。 参数转的定义。 这里有三个。 l s e bypass表示LSE始终跑路。 时钟跑路的意思就是不要接近任。 直接从OSE。 三二杠in这个硬件输入一个指定频率的信号。 这样也可以当做使用员哈。 不过用的不多。 我们直接接进正是比较方便的。 所以启动外部LSE金正。 我们就用第二个参数cc lse2放到这里。 接下来我们需要等待LSE启动完成。 这时我们调用这里的cc get flag status。 获取标志位。 在这里获取哪个标志位呢。 转到定义上面。 找一下这个i c c flag。 L o s e ready。 表示LSE振荡器始终准备好了。 所以我们要用这个参数放在这里。 当然这只是获取一次标志位的状态。 我们要实现等待标志位为一的功能。 那就需要套一个while循环了。 while循环读取标志位。 如果标注位不等于set。 或者说等于等于reset。 那就死循环等待。 这样就行了。 至于是不是要加超时等待。 这个就看你的个人考虑的哈。 这是第二步。 目前就是这两行。 接下来第三步选择rtc cl k时钟源。 这里我们调用这个acc rtc clk configure。 函数放在这里。 参数看一下定义。 这里有三个参数。 分别是LSELYSI和HS除以128。 这个和PPT这里的三个时钟源是对应的。 目前我们使用IOS时钟。 所以选择r c c i t c c l k sours。 LSE放到这里。 这样始终选择就完成了。 当然选择完时钟之后。 我们还是一定要用这个RCC。 R t c c r k command。 只能一下始终。 所以函数放到这里。 参数给label使人一下。 这样ITCCRK始终部分就配置了。 接着根据初始化步骤。 我们要调用两个等待的函数。 一个是等待同步。 一个是等待上一次写入操作完成。 这两个函数我们刚才都看过哈。 在RTCD区里先调用等待同步的函数。 放到这里参数没有啊。 再调用等待上一次操作完成。 放到这里参数也没有。 我们转到第一看一下。 它里面是自带的。 有一个while死循环等待功能。 上面这个函数里面也是while等待啊。 所以这里我们直接调用函数。 就可以实现等待的效果。 这两个代码是一个安全保障措施啊。 房子因为时钟不同步造成bug。 等待同步就是程序员刚开始的时候调用一下。 等待上次写入操作完成。 当然在这之前。 我们其实也没有写入过ITC接口器啊。 所以正常情况下是不用等的。 这两行你要是不写。 他一般也没啥大问题。 当然写了之后对程序也没有任何影响。 所以一般初始化的时候就加一下。 防止意外。 好让我们继续进行。 下一步之后。 我们就可以配置预分频器了。 找一下函数。 我们要用这个rtc set prescott放到这里。 参数是分明值。 目前分离器的输入始终是LOSE。 LSE的频率是32.7681000赫兹。 也就是32768HZ。 显然进行32768分屏就是一赫兹了。 所以这里分频系数。 我们要给32768-1减一。 是因为就职包含零哈。 那因为我们这个函数是对PL计算器进行的。 写操作。 根据PPT的注意事项。 写操作之后。 这个值并不是立刻生效的。 我们最好等待一下写操作完成。 所以在这次写入之后。 我们再调用一下RTC等待的函数。 这个等待函数我们可以在每次写入操作之后。 调用词。 也可以在每次写入操作之前的调用词。 或者写入之前之后都调用词。 这样更保险啊。 总之就是用这个等待函数。 把写入操作隔开就行了。 就这一点。 然后我们还注意到这个注意事项。 不是还有一条。 必须要先设置cf位进入配置模式之后。 才能写入PL等级容器的吗。 那我们这个代码写入预分频器。 要不要进入配置模式呢。 答案是有。 但是代码不用我们写。 转到定义。 看一下。 这两行。 就是把我们传输参数写入到PIL接容器。 在这之前。 库函数自己就调用了进入配置模式的代码了。 加了之后也自带了退出配置模式的代码。 然后上面set counter也自带了进入和退出的代码。 下面slam也有这些。 所以进入和退出配置模式的代码。 不用我们再额外调用了。 那回到这里配置预分频器。 这一步我们就完成了。 接下来我们在初始化的时候。 给它设置一个初始时间。 设置时间我们要调用哪个函数呢。 显然是这个rtc set count放到这里。 这里要给他一个32位的表计数器。 那我们就使用PPT里的这个例子哈。 也是这里的。 2023年1月1日的这个这个描述复制一下。 放到这里。 用于设定初始时间。 但这一步不是必须的哈。 你要是不预测时间。 身体默认为零。 tab点虚拟的函数解析出来就是1970年呗。 那在这个写入相T操作结束后。 我们同样得调用一下等待的函数。 好到这里。 我们RTC初始化的步骤就完成了。 出怪到这里后。 CD的值就会从这个秒数开始。 以一秒的时间间隔不断自增。 我们读取CD就能获取时间了。 那写到这里。 我们就可以进行初步测试了。 我们把这个出函数放到头文件里。 声明一下编译看一下。 没问题啊。 之后到主函数里进行测试。 测试的目的。 就是看一下CNT有没有按照预想的效果。 进行自增。 我们现在已经可录了一下。 买RTC点去。 最后买RTC1it初始化。 接着我们就可以在while。 主循环里不断读取CNT的值。 读取CNT。 我们调用这个rtc get counter放到这里。 参数不需要返回值。 是CNT的值。 我们直接用OLED显示一下。 Oled show number。 一行一列显示CNT长度给12。 这个数比较大。 要够显示才行。 这是初步的测试程序编译下载看一下。 看下明白板。 目前可以看出这里确实显示了一个数字。 并且从我们预设的数值开始不断支撑。 支撑的间隔是一秒。 这说明我们的程序测试是成功的。 当然我实测有些板子这个现象确实是有问题。 就是RTC晶振启动不了。 如果ITC竞争不起征。 这个程序就会卡死。 在这个位置。 一直等待l s e ride标注位。 这样的话实验现象就是OID什么也不显示。 因为程序在初始化的时候就卡死了。 那如果IDC晶振确实启动不了。 为了观察到实验现象。 我们可以备选内部低速机振。 LOSI程序修改方法。 就是首先l o s e configure改成lsi command参数。 给label启动。 LSI下面等待标志位改成l o s i ready。 然后配置时钟源改成LOSI。 因为LSI是四十千赫兹。 所以预分屏改成40000。 这样我们就把RDCCLK由LOSE。 切换到了LOSI。 这样试一下。 下载看一下。 这样时钟也是能正常运行的哈。 只不过目前的IDCC。 LK的时钟源是LYSI。 如果你确实是外部始终启动不了的话。 可以这样改一下代码关现象。 但是至于如何让外部竞争启动呢。 这个可能得从硬件上进行一些研究。 海目前我们这个套件也不方便动这个板子的。 所以大家有条件的话可以自行研究。 这是RTC初始化配置的部分。 那我们这个代码呢就先撤销。 还原成LSD的代码。 当然这个代码在每次复位时都会重置时间哈。 这个问题我们最后再来解决。 现在我们先继续写后续的部分。 接下来我们要做的就是写两个函数。 一个是设置时间。 一个是读取时间。 这里程序我计划是这样写哈。 读取时间我们就把读到的秒数转换为年月日时。 分秒。 放到一个全局数组里。 设置时间。 我们就把全局数组的年月日时分秒转换为秒数。 再写入到CND。 这个操作。 和五牙单片机教程那里的程序是一个思路哈。 这样做程序便于理解一些。 如果你C语言玩的比较溜。 可以定义一些结构体存储时间。 再用一些结构体指针啊。 传参。 这都是可以的。 那这里在上面我先定义一个全局的数组类型。 给unit16杠T数组名叫买rtc time。 数组里面分别存放的是年月日时分秒连。 二零23月1日一时23分59秒55。 因为这个年2023。 超过了英特尔82T数据的范围哈。 所以我们直接整个数组都定义成16位的。 稍微浪费一点空间哈。 之后我们调用设置时间的函数。 就把这个数组的时间刷新到RTC外设里。 调用读取时间的函数。 就把ITC外设的时间刷新到这个数组里。 另外再额外提一个注意事项啊。 就这个时间值如果是个位数。 你最好不要在前面说。 我对齐一下。 在前面补个零。 这样行不行呢。 目前看着是没问题的。 但是在C语言中一定要谨慎在数据前面加零。 因为C语言有个坑哈。 就是以零开头的数字是八定制。 所以这里写的零一实际上是八进制的一。 当然八进制的一和十进制的一是一样的。 但是如果你写的时间是23.9分。 你觉得这样不好看。 我要写成23.09分。 这就有问题了。 你看他会报个错误。 意思就是在八进制中数字九是无效的。 所以我们在写C语言程序中。 十进制数前面千万不要随意补零。 虽然在数学上前面补零是没问题的。 但是在C语言中前面补零的数字是八进制。 都会造成bug。 再举个例子啊。 如果我在程序中写个if。 123等于等于0123。 这个衣服会不会成立呢。 如果你理解了我刚才说的注意事项。 那应该知道这个if是不成立的。 之前五幺单片机教程里啊。 有个密码锁的程序。 很多人留言说设置的密码不能以零开头。 一旦以零开头。 程序就不能判断正确密码了。 那就是这个原因好。 那我们回到这个程序继续来写。 站在下面首先来一个word买rtc set time word。 在这里面我们要把数组的时间转化为表述。 提到CNT中。 所以这就需要用到time点序列函数了。 我们在这上面先包含头文件银库洛的time点。 去编译器内置的库啊。 我们一般用尖括号。 当然有井号也完全没问题啊。 要写好之后。 我们先右键打开time点去这个文件。 看看。 这个文件和我们之前DEVC加加软件里的。 有些区别哈。 看一下。 首先这里time杠T它的定义是按sn int。 Unsigned int。 在STM32里就是无符号32位。 整形之后是DK的TM结构。 体力的秒范围是0~60。 括号写的是0~60。 允许偶尔的room秒哈。 然后这些函数的用法也有些变化。 其中这个time函数本来是用来获取系统时钟的。 但是在STM3里没有系统时钟。 或者说我们的RTC本身就应该是系统时钟。 所以在RTC程序里。 这个time函数用不了哈。 然后还有一个问题是STM32。 他也不知道当前处于哪个时区。 所以这个gm time和local time就没有区分了。 目前这个程序的做法是弃用这个gm time。 只用note time来实现表计器转换日期时间的功能。 并且logo time始终都是临时区。 伦敦时间。 然后上面这个madam也始终都是零时区。 如果你要换时区的话。 自己再加偏移就行。 这个也不麻烦。 总之这个time点序列函数不知道你是哪个时区。 所以就只能都以临时区来转换了。 那看完这个模块。 我们就可以上手了。 在这里先定义两个变量。 一个是time杠T变量名叫time杠CNT。 另一个是STRUCTTM变量名叫time gd。 之后我们把数组的时间填充到time gdate里。 也是time gdate。 点TME它等于买rtc time数字的第零个数据。 复制一下。 tm month等于第一个数据。 TMMONDAY等于第二个数据。 tm hour等于第三个数据。 tm minute等于第四个数据。 tm second等于第五个数据。 这样我们就把数组的数据填充到结构体里了。 当然其中年我们要减去一个偏移。 1900月我们要减去一个一。 这样才对。 之后下一步就是调用函数。 max参数是STRUCTTM新。 所以我们把time gdate的地址传进去。 返回值是time杠T。 所以我们赋值给time杠CNT。 日期时间到秒数的转换。 我们就完成了。 最后一步就是把指定的描述写入到CNT里了。 所以调用函数rtc set counter参数。 把TGCNT传进去。 这样时间就设置完成了。 最后别忘了写入计算器之后。 要等待一下操作完成。 就是这个函数的全部流程主要就是三步。 第一步。 把我们数组指定的时间填充到刷个TM结构体里。 第二步使用make time函数得到描述。 第三步将描述写到ITC的CNT中。 就是设置时间。 接着我们继续写读取时间的函数。 来一个word买rtc read time y的。 这里面。 我们同样先定义秒进游戏和日期时间的变量。 之后的流程是不是和上面是反过来的哈。 第一步。 rtc get counter读取CNT的描述。 存储的time杠CNT。 第二步使用local time函数。 得到日期时间参数是cost time gt新。 所以把time杠CNT的地址传进去。 返回值是strong的TMC。 所以我们先取内容。 然后再复制给time gd。 最后第三步。 我们把time gdate的日期时间转移到数组里。 其实不转移到数组里也可以哈。 你要是会用结构体。 直接使用它这个STRUCTTM也行。 那我们转移一下。 降低使用难度哈。 我们复制一下这一段。 然后把等号左右反过来就行了。 数组第零个数据。 它应该等于TME加上1900数组。 第一个数据等于tm month。 加上一宿主。 第二个等于MONDAY数组。 第三个等于our数组。 第四个等于MIT数组。 第五个等于second。 这样读取时间的函数我们就完成了。 现在我们就可以进行测试。 那先把这两个函数放在头文件声明一下。 另外这个全局数组啊。 我们也拿过来声明为外部可调用。 这个做法其实就是使用全局变量传参对吧。 后面这些可以不要。 然后变量声明要加一个x turn。 当然单个的变量必须要加x turn。 数组的话我试了一下。 不加也行好。 那头文件就是这些东西。 编一下没问题。 接下来到主函数。 我们来进行测试。 先把静态的字符串显示一下。 O i d show string。 一行一列显示date。 冒号叉叉。 叉叉杠叉叉。 杠叉叉复制一下。 二行一列显示个time。 冒号叉叉。 冒号叉叉。 冒号叉叉。 复制一下。 三行一列显示一下CNT当前的描述哈。 然后主群管理先调用买rtc read time。 调完之后。 CNT计数器对应的时间值就会刷新到。 买rtc time数独立了。 接下来我们直接读取全局数组进行显示就行了。 所以一行六列显示by rtc time的第零个长度为四。 复制一下。 一行11列显示time1月长度为二。 一行14点显示time2日长度为二。 二行六列显示time3小时长度为二。 二行九列显示time4分钟长度为二。 二行12点。 显示time5秒长度为二。 最后再来一个。 我们在三行六列显示一下CNT的值哈。 这里就直接调用rtc get counter了。 长度给十好编译。 下载看一下。 目前显示的是第一行日期2023年1月1日。 第二行时间16点。 第三行表述目前是PPT示例的这个数。 在这个程序中。 我们调用的是local time当地时间。 但是他这个当地时间都默认的是临时区的。 伦敦时间。 也是这里的15.59的时间。 调用make time也是伦敦当地时间转换与描述。 那回到程序。 目前我们还没有调用set time函数。 所以这个数组里的时间是没有用到的。 如果我们想初始化的时候。 把这个数组里的时间放到ITC里。 顺便验证一下set time函数的功能是不是正常。 我们可以在这里。 把原来这个设置时间的代码去掉。 然后直接调用一个买rtc set time。 这样的话是不是就在初始化的最后。 把它们数组给定的时间写入到RT CD了。 那这里有个报错。 是因为在这个C文件里。 函数的定义在函数调用的后面。 解决方法就是把下面这个函数放到帝王的前面。 声明一下。 或者在这个文件里包含自己的买RTC点。 去偷文件也行啊。 总之保证在每个点CN文件函数调用的前面。 有对应的函数定义或者声明即可。 好。 这样我们就在初始化的时候设定了数组的时间。 如果你在程序中途想设置时间的话。 流程就是先修改数组的数据。 然后再调用set time函数。 这样就行了。 那看一下现在程序的现象。 可以看到目前就说我们数组给定的时间。 23.59分。 并且之后时间日期的定位哈都是没问题的。 那现在我们就实现了一个计量伦敦时间的钟表。 如果你不关注秒计由器和日期。 时间的对应关系的话。 那直接用这个伦敦时间的钟表记北京时间。 也是完全没问题的。 但是如果你要保证完全符合时间戳的规范。 让我们这个时间变成一个真正的北京时间。 那在程序中我们还要进行时区的偏移啊。 怎么加呢。 其实也很简单。 比如读取时间的函数。 这里秒计数器转换的是伦敦的日期时间。 我们要变成北京时间。 就可以在读取数据的小时后面加上八。 表示东八区的北京时间。 但这样直接加八肯定是不行的。 要考虑进位的问题啊。 要不然20点加八就变成28点了。 所以在小时后面直接加八比较麻烦。 那我们就可以考虑读取描述之后。 在这里加上八个小时的描述。 偏移八个小时。 对应8×60乘60。 这么多秒我们都有秒数。 加八个小时之后再转换为日期。 就不用再管键位的问题了。 非常方便。 同理在写入时间的时候。 这里我们要对应减去八个小时的描述。 这样就实现了时区的转换。 并且我们现在这个钟表更加严谨。 符合时间图的规范编译。 下载看一下。 可以看到时间是23.59分。 对应的秒数后面是88795。 这样就和我们PPT这里写的。 北京时间与时间戳的对应关系是一致的。 这才是一个真正意义上的北京时间的中标。 如果你不加时区偏移。 而是通过增大伦敦时间来计量背景时间也可以。 但是那样秒计数器和北京时间就对应不上了。 好有关时区偏移的部分我们就清楚了。 接下来我们还要完成一个刚才遗留的问题啊。 就从目前每次复位时间都会重置。 这显然是不行的哈。 那在程序中时间重置的原因。 就是我们每次复位后都调用了初始化函数。 在这个初始化函数里。 我们自己手动给它的时间充值了。 所以说这个初始化代码我们要有判断的去执行。 当系统完全断电。 不用电池也断电了。 我们就执行这个初始化。 当系统只是主电源断电。 备用电池没断的话。 我们就不需要执行这个初始化了。 那怎么样才能知道系统是完全断电了。 还是只有主电源断电呢。 这就需要用到我们刚才学的BKP的。 我们可以在BKP里随便写个数据。 如果上电检测这个数据没清零。 是不是表示备用电池是存在的。 ITC也可以继续运行。 这样商店的时候就不用再初始化重置时间了。 如果上天检测这个数据清零了。 就表示系统完全断电过。 这样就需要重新输入啊。 那16月了我们就可以来写代码了。 首先在这里我们加个if。 如果BKP读取禁用器。 随便指定一个。 比如BKPDRE。 他的数据不等于随便指定一个数据当标志位。 比如0XA5A五。 那我们就把后面一大块。 初始化代码全都放到括号里。 那第一次上电时或者系统完全断电之后。 BKBDR1默认是零。 if成立。 执行初始化。 抽出来之后。 我们就要写入BKPDRE自标注位了。 在这里来个BKP写进容器。 BKBDR1写入一个0XAV5。 这样就是数字化之后。 DRE4A五A五。 下次读到四。 这个数就说明初始化过了。 并且中途备用电池没断电。 这样就不用再重复初始化了。 避免时间重置。 那在最后我们还要加个else。 如果已经初始化过了啦。 我们不用出法。 但这两条等待的代码我们最好也调一下。 防止意外哈。 那这样我们这个防止重复。 初始化和时间重置的代码就完成了。 主要思路就是建筑BKP的特性。 随便写入一个数当做标志位。 现在我们再测试一下编译下载啊。 看看。 这时我们再按复位。 可以看到时间继续运行。 不会重置。 断掉组电源。 时间仍然继续运行。 当然如果完全断电。 BKBDRE的数据自动清零。 这时再上电就会重新出租啊。 RTC重置时间了。 这是目前程序的现象。 最后我们再来演示一下余数计算器吧。 在主函数里。 字符串在第四行显示一个div下面复制一份。 在四行六列显示一个rtc get divide。 这样看一下。 可以看到最后一个div正在快速的质检。 质检的范围是32767~0。 div为之前一轮CNT秒数加一。 有了这个数。 我们就可以对秒数进行更细的划分。 获取分秒厘秒毫秒这些参数了。 怎么转换成这些参数呢。 比如我们要转换为毫秒。 一秒等于1000ms。 所以我们要把32767~0这个变化范围。 线性变换转换到0~999。 这个范围怎么变呢。 回答代码我们可以先用32767减div。 这样范围就是0~32767了之后。 对这个值进行缩放。 除以32767再乘999。 为了防止丢失小数。 我们在这里加个点零啊。 变为浮点运算。 这样就行了吧。 我们看一下编译下载看一下。 可以看到这里最后一个值变化范围。 就原来的32767~0。 转换成了0~999表示毫秒。 就是获取div的一个用途。 你想得到什么范围。 就对这个值进行线性变换即可啊。 那么程序中就撤销一下哈。 目前保留显示原生div的代码好。 有关这个程序的内容。 我们就全部讲完了。 本节课程到这里也就结束了。 我们下节再见。
44. Hello。 大家好。 欢迎继续观看STM32入门教程。 这一节我们来学习STM32的PWW电源控制。 其中我们重点学习的主要就是。 这里设计的三种低功耗模式啊。 睡眠模式。 停机模式和待机模式。 低功耗模式的目的呢简单明了。 就是省电。 这对于一些使用电池供电。 又需要长时间待机的设备十分重要啊。 所以我们本节课的任务就是学习电源控制部分。 看看如何配置这些低功耗模式。 让STM32在空闲时能够尽可能的节省电量。 好了。 先看一下本节课最终的程序现象。 本节课总共有四个程序。 分别是13杠一修改主频。 13杠二。 睡眠模式加串口发送加接收。 13杠三。 停止模式加对射式红外传感器。 G43杠四待机模式加实时时钟。 因为低功耗模式的代码都不是很多哈。 所以多给大家演示几个玩玩。 那我们先看一下第一个程序。 修改主频。 修改主频不属于三种低功耗模式啊。 但是也是降低STF2功耗的一种方法。 这个代码非常简单。 就是初始化显示一下system call clock这个变量。 这个变量指示了当前主频频率之后。 主循环以一秒为周期显示running再清除。 那我们下载看一下程序现象啊。 目前可以看到第一行system clock。 系统主频是36兆赫兹。 第二行我们让它以一秒为周期显示。 但现在实际上是两秒的周期。 这是因为系统主屏。 正常情况下是72兆赫兹啊。 现在我们降频到36兆赫兹。 所以运行时间就是原来的二倍。 那在这个程序的哪个部分。 我修改了主频呢。 答案是在system s t m32F。 10X点C这个文件里。 system这个文件里面就是用来配置始终的。 在110上这个位置。 它给我们预留好了配置时钟的红利一。 我们只需要将其中一个宏定义解除注释。 就能直接配置系统的主频。 非常简单。 目前看到我是把36兆的红解除注释了。 所以目前主频就是36兆。 这个文件在我改之前默认是72兆。 如果我们这样把72兆解除注释。 把36兆注释掉。 这样系统组名就是72兆了。 想配置为其他的频率也是同理。 先把原来的注释掉。 再解除对应频率的注释即可。 是不是非常简单。 我们编译下载看一下。 可以看到目前显示主频是72兆。 running闪烁的周期是一秒。 这是默认主频72兆的正常现象。 那就是修改主频这个程序的现象。 有关这个SX文件的详细解释啊。 还有配置主屏的更多玩法。 我们写程序的时候再来介绍。 接着继续看第二个程序。 睡眠模式加串口的发送和接收。 那这个程序就是从串口那一节。 直接复制过来的啊。 这个代码的功能就是当收到一个字节时。 中断触发自标志位。 主循环查询到标志位时读取数据。 并用串口发送数据。 在这个功能后面。 我又新加了一段代码。 这个就是用来配置睡眠模式的关键代码。 实际上就这一句哈。 WFA执行完这一句。 芯片进入睡眠。 睡眠的目的是。 如果STMI二一直没收到数据。 那这个主循环也会一直查询标注位。 这是无意义的耗电操作。 那不如我们就让它睡眠。 收到数据后自动退出睡眠模式。 执行编任务后呢。 继续睡眠。 这样在空闲时芯片一直在睡眠。 可以降低系统功耗。 那么下载看一下。 另外还要重点提醒一下。 芯片在三种低功耗模式下。 是没法直接再下载程序的。 你看现在是下载成功的。 如果直接再点下载。 就会提示报错。 正因为芯片现在在睡眠哈。 不会理你调试端口了。 解决方法也很简单。 需要我们有一些操作。 第一步我们按住复位键不放。 第二步点下载按钮。 第三步及时松开复位键。 这样就能下载成功了。 在我们本节三种低功耗模式下。 都需要这样下载程序。 大家注意一下。 另外如果你不小心禁用了调试端口。 其实也可以这样来解决哈。 好了继续看程序现象。 目前是串口发送加接收。 我们按照串口来接的接线。 接好串口。 然后打开窗口。 随便发送一个数据。 可以看到SM32成功接收并回传的这个数据。 这个现象和没使用睡眠模式的是一样的。 但是细节就在于看下第二行。 只有在我们发送数据时刻。 OID才会显示一次running。 在空闲时芯片一直都在睡眠。 这样就是在不影响程序功能的前提下。 使用睡眠模式节约电量。 就是这个程序的功能。 现在就看第三个程序。 停止模式加对射红外G4。 这个程序是在之前外部中断那一节的代码。 基础上修改的类似的操作。 这里我加入了running的指示。 可最后进入停止模式的代码。 那下载看一下下载的操作是按住复位键不放。 点下载再松手线下看一下。 每次挡一次。 执行一次。 记次也显示一下running。 在没有外部中断信号时。 STM32处于停止模式。 可以省电。 就是第三个程序的现象。 最后我们来看一下第四个程序。 待机模式加14时钟。 这个程序是在实时时钟的基础上。 加入了待机模式。 目前这个程序我使用的是LOSE。 外部低速时钟啊。 如果你没有RTC竞争或者RTC竞争不起。 正也可以使用LOSI内部低速时钟。 LSI在待机模式下可以继续工作。 然后在这个位置可以加入唤醒后要执行的功能。 在进入待机模式之前。 可以关闭各个外部连接的模块。 以最大化省电。 我目前是用oled clear模拟了一下哈。 那这个程序会用实时时钟设定闹钟。 每隔一段时间会自动唤醒一次。 这里我演示的是每隔十秒唤醒一次。 唤醒之后执行一遍程序任务。 然后继续待机。 那看一下程序现象。 按住复位键不放。 下载再松手看看现象。 复印一下。 可以看到OID上显示了当前时钟和闹钟。 随后进入待机。 然后等一会儿。 闹钟触发之后自动唤醒一次。 设定新的那种执行程序功能之后继续待机。 等待下一次唤醒。 这是使用RTC和闹钟。 配合待机模式的自动唤醒程序。 非常适合那种需要每隔一段时间操作一次。 空闲时间又需要最大化省电的设备。 好了程序现象我们就看到这里。 接下来我们回到PPT看一下PWR的理论部分。 首先PWW因为是power control。 意思是电源控制。 PWR就是power的缩写。 那PWW的作用就是负责管理STM。 三二内部的电源供电部分。 可以实现可编程。 电压监视器和低功耗模式的功能。 PWR有一部分是硬件的介绍啊。 就是告诉你内部供电电路的结构是啥样的。 这些是设计硬件电路时要考虑的。 暂时不涉及程序。 设计程序的功能主要就是两个。 一个是可编程电压监测器。 另一个是低功耗模式。 下面继续看可编程电压监测器。 简称PVD。 它可以监控v dd电源电压。 当v dd下降到PVD阈值以下。 或上升到PVD阈值之上时。 PVD会触发中断。 用于执行紧急关闭任务。 这个功能预想的场景应该是使用电池供电。 或者对安全要求比较高的设备。 如果供电电压在逐渐下降。 在电压过低的情况下。 可能会导致内部或外部电路。 发生不确定的错误啊。 为了避免不确定的因素。 在电源电压低于设定的阈值时。 我们可以主动出击。 提前发出警告。 并且关闭比较危险的设备。 这是这个PVD的设计。 不过PVD这个功能不是我们本节课的重点哈。 我们暂时也不演示代码。 大家了解即可。 后续需要的话可以再研究。 然后看最后一条低功耗模式。 这是本节课的重点内容哈。 低功耗模式包括睡眠模式。 Sleep。 停机模式。 stop和待机模式。 stand by英文大概记一下。 前面两个应该都很熟悉。 主要记一下stand by表示待机模式。 这个在很多其他芯片里都有出现哈。 然后继续低功耗模式的作用。 就是可在系统空闲时降低STF2的功耗。 延长设备使用时间。 尤其是像一些用电池供电的设备。 对空闲时候的耗电量是有极大要求的。 比如数据采集设备啊。 车钥匙。 遥控器。 报警器等等。 这些产品都有个特点。 就是在他们的生命周期里。 绝大部分时间都是空闲状态。 但是我们知道。 单片机程序一旦开始正常运行的状态下。 程序永远都不会停下来。 所以主程序的最后一般都是个死循环。 即使需要空闲。 让程序停下来。 那也得来个空循环。 让程序一直转圈卡住。 但是程序运行就会耗电。 空循环的耗电量也是很大的。 比如遥控器如果不用它的时候。 程序一直空循环。 那么用不到几天电池就没电了。 这显然是不行的。 所以说对于这些设备。 我们需要这样的低功耗模式。 在空闲状态时关闭不必要的硬件。 比如直接把CPU断电或者关闭始终。 这样才去自然就不会运行了。 但在低功耗模式下。 我们也需要保留必要的唤醒电路。 比如串口接收数据的中断唤醒啊。 外部中断唤醒。 RTC闹钟唤醒等等。 在需要设备工作时。 STM32能够立刻重新投入工作。 这样才行。 如果你只考虑进入低功耗。 而不考虑唤醒STM321睡不醒。 那不就跟直接断电没区别了吗。 所以低功耗模式我们要考虑关闭哪些硬件。 保留哪些硬件以及如何去唤醒。 当然关闭越多的硬件设备越省电。 唤醒就越麻烦。 这也是这三种低功耗模式。 在设计时所区分的地方。 那简介就看到这里。 接着我们看下一页。 看一下这个电源框图。 这个图就是SNP2内部的供电方案。 其中有些部分我们之前也已经了解过了。 现在再来看看。 整体上看这个图可以分为三个部分。 最上面是模拟部分供电。 叫做VDDA。 中间是数字部分供电。 包括两块区域。 VDE供电区域和1.8伏供电区域。 下面是后备供电。 叫做vb a t。 依次看一下VADDA供电区域。 主要负责模拟部分的供电。 其中包括AD转换器啊。 温度传感器啊。 复位模块PLL锁相环。 这些电路的供电正极是VDDA。 负极是vs s a。 其中AD转换器还有两个人参考电压的供电脚。 叫做VREF正和VREF负。 这两个角在银角多的型号里会单独引出来。 在银角少的型号。 比如我们这个C8T6。 VREF正和VREF负。 在内部就已经分别接到了VDDA和vs sa了。 然后看中间部分的供电。 这一块由两部分组成。 左边部分是v dd供电区域。 其中包括IO电路。 待机电路。 唤醒逻辑和独立看门狗。 右边部分是v dd。 通过电压调节器降压到1.8伏。 提供给后面这一块的1.8伏供电区域。 1.8伏区域包括CPU核心。 存储器和内置数字外设。 可以看出来STM32内部的大部分关键电路。 CPU存储器和外设。 其实都是以1.8伏的低电压运行的。 当这些外设需要与外界进行交流时。 才会通过IO电路转换到3.3伏。 所以我们从外部看。 好像STFR内部全是3.35。 但实际上它内部的CPU。 外设等都是以1.8伏供电运行。 使用低电压运行的。 主要目的是降低功耗啊。 电压越低。 内部电路运行的功耗就相对越低。 当然我们其实也不用了解这么多哈。 主要是记住CPU核心。 存储器和数字外设都属于1.8伏供电区域。 而待机电路唤醒逻辑等属于VDD供电区域。 他们的位置要清除。 然后这个电压调节器。 它的作用是给1.8伏区供电。 因为我们后面会提到这个1.8伏区域。 和电压调节器。 要知道市场大家继续看。 最。 下面就是我们上一节提到的VBT。 后备供电区域了。 其中包括LOSE32K晶体振荡器。 后备计算器RCCBDCR计算器。 和RDCRCCBDCR是RCC的净水器啊。 叫做备份域控制。 净水器也是和后背区域有关的计算器啊。 所以也可以有vb at供电。 然后这里有个低电压检测器。 可以控制这个开关VDD有电时由VDD供电。 VDD没电时由VBAT供电。 好。 那这些就是这个电源框图的介绍了。 大家需要了解的是。 STM32内部由哪几部分供电区域。 以及每部分供电区域里都有啥。 就是这个框图的内容。 然后继续看下两个图。 分别是上电复位和掉电复位。 还有可编程电压监测器这两个内容了解即可哈。 我快速讲一下。 首先是上电复位和掉电复位。 这个意思是当VDD或者VDDA电压过低时。 内部电路直接产生复位。 让STM32复位组不要乱操作。 这个复位和不复位的界限之间。 设置了一个40毫伏的迟滞。 电压大于上限。 POS解除复位。 小于下限。 pd复位。 这是一个典型的迟滞比较器啊。 设置两个阈值的作用。 就是防止电压在某个阈值附近波动时。 造成输出也来回抖动。 下面的复位信号reset是低电平有效的。 所以在前面和后面电压过低时是复位的。 中间电压正常的时候不复位。 那这个电压上限和下限具体是多少伏呢。 还有这里解除复位。 还有个滞后时间是多久呢。 这些参数可以看一下STM32数据手册。 在5.3.3。 内嵌复位和电源控制模块特性里有这个表。 这里写了上电或掉电复位阈值下降。 沿也是PDR掉电复位的阈值下限。 典型值是1.88伏上升眼。 由是POR上电复位的阈值上限。 典型值是1.92伏。 1.92-1.88。 就是迟滞的阈值40毫伏。 所以如果忽略此次的话。 简单来说就是大于1.9伏上电。 低于1.9伏掉电。 然后最后一行就是t i s t temple。 复位持续时间典型值是2.5ms。 就是这个上电复位和掉电复位。 知道一下就行了。 也不需要我们操作啥的。 然后下面这个是可编程电压监测器。 简称PVD。 他的工作流程和上面这个差不多哈。 都是监测v dd和VDDA的供电电压。 但是PVD的区别就是。 首先它这个阈值电压是可以使用程序指定的。 可以自定义调节调节的范围。 可以看一下数据手册。 在这个表的上面就是PVD的阈值配置。 PLS计算器的三个位。 可以选择右边这么多的阈值。 因为这里也同样是迟滞比较。 所以有两个阈值可选范围是。 2.2伏到2.9伏左右。 PVD上限和下限之间的迟滞电压是100毫伏。 可以看到PVD的电压是比上电掉电。 复位的电压要高的。 画个图就是3.3伏是正常的供电。 当这个电压降低在2.9伏到2.2伏之间。 属于PVD监测的范围。 可以通过PVD设置一个警告线之后。 再降低到1.9伏。 就是复位电路的检测范围。 低于1.9伏。 直接复位住。 不让动的就是这两个电压监测的工作任务。 那当然PVD触发之后。 芯片还是能正常工作的。 只不过是电源电压过低。 该提醒一下用户了。 所以看一下下面这个PVD输出。 这个是正逻辑哈。 电压过低时为一。 电压正常值为零。 这个信号格局申请中断。 在上升沿或者下降延时触发中断。 一是提醒程序进行适当的处理。 另外这个PVD的中断申请啊。 是通过外部中断实现的。 我们可以看一下外部中断这一节。 这个图可以看到PVD输出的信号。 是跑到这里来了。 所以如果要使用PVD的话。 记得要配置外部中断。 然后下面这里还有DC。 这个是RTC的闹钟信号啊。 也有借到外部中断。 其实RTC自己是有中断的。 那为啥还要借到外部中断。 这个等会就知道了。 因为低功耗模式设计的是只有外部中断。 可以唤醒停止模式。 其他这些设备也想唤醒停止模式的话。 都可以通过借道外部中断来实现。 其后面这两个USB和ETH。 也都只有他们的wake up唤醒信号。 接过来的目的也是为了唤醒停止模式。 这个了解一下好这两个电压监测的内容。 我就讲这么多。 接着我们来看看本节课的重点。 低功耗模式。 这个表是低功耗模式一栏。 其中对三种模式进行了详细的对比哈。 我们看一下第一列就是有哪几种模式。 第二点是如何配置。 才能进入我们想要的模式。 第三点是对于这些模式进入之后。 如何去唤醒。 也是模式的退出化。 毕竟我们肯定也不向着他一睡不醒啊。 该干活的时候还是要醒来干活的。 最后三列是每种模式对电路的操作。 关闭了哪些东西。 就有哪些电路不能用了。 保留了哪些东西。 就是哪些电路还是正常工作的。 这些我们要清楚。 那依次来看一下。 首先低功耗模式有三种。 睡眠停机和待机。 这三种模式从上到下关闭的电路越来越多。 对应的从上到下是越来越省电。 同时从上到下也是越来越难唤醒的。 这符合我们的尝试哈。 睡得越深。 关得越多越省电。 越难叫醒。 首先看一下睡眠模式。 这是浅睡眠哈。 就相当于打了个盹儿。 如何进入呢。 这里写了直接调用WFA或者WFE即可进入。 这两个东西是内核的指令哈。 对应库函数里也有对应的函数。 直接调用函数即可。 其中WFI的意思是wait for interrupt。 等待中断。 意思就是我先睡了。 如果有中断发生的话。 再叫我起来。 所以对应的唤醒条件是任意中断。 调用WIFI进入的睡眠模式。 任何外设发生任何中断时。 芯片都会立刻醒来。 因为中断发生了。 水醒来之后的第一件事一般就是处理中断函数。 然后下面WFE意思是wait for event。 等待事件对应的唤醒条件是唤醒事件。 这个事件可以是外部中断。 配置为事件模式。 也可以是死人的中断。 但是没有配置NVS。 一调用WFE进入的睡眠模式。 产生唤醒事件时会立刻醒来。 醒来之后一般不需要进中断函数。 直接从碎的地方继续运行。 这是WFI和WFE的作用相同。 点是调用任意一个之后。 芯片都进入睡眠。 不同点是WFI进入的得用中断唤醒。 WFE进入的等事件唤醒。 最后看一下睡眠模式对电路的影响。 对1.8伏区域时钟的影响是CPU时钟关。 对其他时钟和ADC始终无印象。 对VDD区域始终的影响是无。 对电压调节器的操作是开。 所以睡眠模式对电路的影响。 就是只把CPU始终关了。 对其他电路没有任何操作。 CPU始终关了。 程序就会暂停。 不会继续运行了。 CPU不运行芯片功耗就会降低。 另外这里还可以看出。 关闭电路通常有两个做法。 一个是关闭时钟。 另一个是关闭电源。 关闭时钟。 所有的运算和射击时序的操作都会暂停。 但是计算器和存储器里面保存的数据。 还可以维持。 不会消失。 关闭电源就是电路直接断电。 电路的操作和数据都会直接丢失。 所以关闭电源比关闭时钟更省电。 这个表里的这两点。 就对1.8伏区域和VDD区域的始终控制。 然后这个电压调节器刚才看了。 它实际上就是1.8伏区域的电源。 如果电压调节器关。 就代表直接把1.8伏处于断电。 这个了解一下好。 睡眠模式我们就清出来它关的东西很少。 就只是把CPU使用管了。 程序暂停运行。 计算器的数据都还在。 它唤醒条件也是比较宽松。 任何的风吹草动。 CPU都会醒来开始干活。 所以睡眠模式相当于大佬打了个盹儿。 身体还在工作。 在省电程度上评级为一般省电。 然后就看第二个停机模式。 如何进入停机模式呢。 首先sleep deep位设置为一。 告诉CPU你可以放心的水进入深度睡眠模式。 另外PDD这一位用来区分它是停机模式。 还是下面的待机模式。 PDDS等于零进入停机模式。 PDDS等于一进入待机模式。 所以想要进入停机模式。 PDD要事先设置为零。 之后。 LPD用来设置。 最后这个电压调节器是开启。 还是进入低功耗模式。 RPDS等于零电压调节器。 开启LPDS等于一电压调节器。 进入低功耗。 最后当我们把这些way提前设置好了。 最后再调用WFA或者WFE芯片。 就可以进入停止模式了。 然后停止模式的唤醒音。 因为这个模式下芯片碎得更深。 关的东西更多。 所以唤醒条件就苛刻一些。 是任意外部中断。 刚才睡眠模式是任意中断。 所有外设的中断都行。 现在停止模式。 要求就是只有外部中断才能换新的。 其他中断唤醒不了。 刚才我们还提到了PVDITC闹钟。 USB唤醒EDH唤醒借到了外部中断。 所以这四个信号也可以唤醒停止模式。 因为这里并没有区分WFI和WFE。 其实也可以想象得到。 WFI要用外部中断的中断模式唤醒。 WFE要用外部中断的事件模式唤醒。 这是对应的哈。 最后看停止模式对电路有哪些操作呢。 首先关闭所有1.8伏区域的时钟。 这意思就是不仅CPU不能运行的外设也运行不了。 定时器。 在定时的会暂停。 串口收发数据也会暂停。 不过由于没关闭电源。 所以CPU和外设的寄存器数据都是维持原状的。 之后下一个HSI和HS的振荡器关闭。 既然CPU和外设时钟都关了。 那这两个高速时钟显然也没用了对吧。 所以HSI内部高速时钟和HSE。 外部高速时钟会关闭。 当然他没提到的。 LSI内部低速时钟和LS外部低速时钟。 这两个并不会主动关闭啊。 如果开启过这两个时钟还可以继续运行。 最后电压调节器。 这里可以选择是开启或者处于低功耗模式。 刚才说了。 这个电压提示器是由这个LPDS未控制的。 这个开启和低功耗模式有啥区别呢。 其实区别也不大。 电压切换器无论是开启还是低功耗。 都可以维持一代八伏区域。 计算器和存储器的数据内容。 区别就是低功耗模式更省电一些。 同时低功耗模式在唤醒时要花更多的时间。 相反电压调压器开启的话就是更耗电一些。 唤醒更快了。 那这些就是停止模式的介绍。 主要操作就是把运行的高速时钟都关了。 CPU和外设都暂停工作。 但是电压调节器并没有关。 存储器和计算器数据可以维持原样。 它的唤醒条件比较苛刻。 只能通过外部中断唤醒。 所以停止模式相当于整个人都罢工了。 脑子不工作。 身体也不工作。 只有有人用外部中断过来敲我。 我才会醒来干活。 在省电程度上。 平均位移非常省电。 最后我们看第三种待机模式。 进入的话和情景模式差不多。 首先sleep deep也是自一即将深度睡眠。 然后PDD之一表示即将进入待机模式。 最后调用WFI或者WF就可以进入待机模式了。 然后看一下唤醒条件。 普通外设的中断和外部中断都无法唤醒。 待机模式。 待机模式只有这几个指定的信号才能唤醒。 第一个是wake up引脚的上层岩。 wake up引脚。 可以看一下引脚定义。 这里PA0杠wake up只是来wake up引脚的位置。 就是pa0的位置。 这个继续。 第二个是RTC闹钟事件。 这个我们的示例代码和上一节RTC提到过哈。 RTC闹钟可以唤醒待机模式。 应用场景就是芯片每隔一段时间自动工作一次。 第三个是NRST引脚上的外部复位。 意思就是按一下复位键。 它也是能唤醒的。 最后一个IWDG独立看门狗复位。 这个了解一下就行了。 开门口我们最后介绍好。 可以看出待机模式。 只有这指定的四个信号能唤醒。 其他信号都唤醒不了。 唤醒条件最为苛刻。 之后。 待机模式对电路的操作基本上是能关的。 全都关了。 1.8伏区域的时钟。 关闭两个高速时钟。 关闭电压调节器关闭。 这意味着1.8伏区域的电源关闭。 内部的存储器和净容器的数据全部丢失。 但是和停止模式一样。 它并不会主动关闭LSI和LSD两个低速时钟。 因为这两个时钟还要维持。 TC和独立开门口的运行。 所以不会关闭。 这是待机模式的介绍。 主要操作就是把能关的全都关掉。 只保留几个唤醒的功能。 当然配合RTC和独立开门口的低速。 始终也可以正常工作。 所以待机模式相当于这个人直接下班回家。 睡觉了。 没有指定的这几个事。 他是不会轻易回来工作的。 在省电程度上。 待机模式评级为极为省电好。 以上就是这三种低功耗模式的详细介绍。 以及它们之间的区别。 相信大家对这几种模式。 已经有了大概的了解了吧。 接下来我们对这里的一些细节问题。 再额外补充和总结一下。 首先是模式选择的问题。 刚才这里的表述出现了很多计容器的位。 其中这些模式又有一些更细的划分。 比如睡眠模式由sleep和sleep are exit的区别。 停机模式有电压T2T开启和低功耗的区别。 我们如何配置才能指定某个模式呢。 那看这个图就比较清晰了。 当然这些计算器。 实际上库函数已经帮我们分装好了哈。 不用我们自己配置的。 但是多了解一些。 对我们理解程序还是有很大帮助的。 首先这里有一句。 执行WFI等待中断。 或者WFE等待事件指令后。 SD32进入低功耗模式。 就说这两个指令是最终开启低功耗模式的。 触发条件。 配置其他的计算器都要在这两个指令之前。 看下面这个图。 首先一旦WFA或者WFE执行了芯片。 咋知道他要进入哪种低功耗模式呢。 那它就会按照这个流程来判断。 首先看看sleep deep位是一还是零。 如果sleep deep等于零。 就是浅睡眠。 对应的就是睡眠模式。 如果sleep deep等于一。 表示要进入深度睡眠模式。 对应的是停机或者待机模式。 停机和待机都可以叫做深度睡眠模式啊。 在普通的顺序模式呀。 还有个细分的功能。 通过sleep are exit位来决定。 这位等于零时。 无论程序在哪里。 调用WFI或WFE都会立刻进入睡眠。 这位等于一时执行WFI或WFE之后。 它会等待中断退出。 等所有中断处理完成之后再进入睡眠。 这个可能考虑到中段还有一些紧急的任务啊。 最好不要被睡眠打断了。 所以先等等也无妨。 当然这两个细分模式我们一般可以不用管哈。 只要我们不在中断函数里调用WFI或WFE。 那其实它们的效果是一样的。 我们WFWFE可以放在主程序里。 如果主程序执行到了。 自然也代表中端处理完成了。 如果你想在中断函数里调用WFWFE。 并且想中断结束后再睡眠。 才需要考虑下面这个模式。 然后继续看。 进入深度睡眠模式。 它会继续判断pd d s这一位。 如果PDDS等于零。 就进入的是停机模式。 如果PDDS等于一。 就进入的是待机模式。 在停机模式下。 它会继续判断LPDSV。 如果LPDS等于零。 就是停机模式。 且电压提示器开启。 如果LPDS等于一。 就是停机模式。 且电压提示器低功耗。 电压调压器低功耗的特性就是更省电。 但是唤醒延迟更高。 那这些就是模式选择的一个判断流程。 通过这个图看着应该就比较清晰了。 最后我们再分别总结一些。 这三种模式的一些特性。 首先是睡眠模式。 第一条执行完WFWFE指令后。 STM32进入睡眠模式。 程序暂停运行。 唤醒后程序从暂停的地方继续运行。 一般我们可以在主循环的最后执行一下。 WFWFE主循环执行一遍就睡眠。 然后唤醒之后主循环又会执行一遍。 再睡眠。 每唤醒一次主循环执行一遍。 然后第二条sleep on it。 为决定STM2执行完WF或WF1后。 是立刻进入睡眠。 还是等STX2。 从最低优先级的中断处理程序中退出时。 进入睡眠。 这个刚才说过啊。 第三点。 在睡眠模式下。 所有的IO引脚。 都保持它们在运行模式时的状态。 比如如果你在程序里进行点灯。 灯点亮了。 再进入睡眠灯子。 那是亮的。 GPU引脚的高低电平在睡眠时是维持原样的。 最后两条WFI指令进入睡眠模式。 可被任意一个NVC响应的中断唤醒。 WFE指令进入睡眠模式。 可被唤醒事件唤醒。 这个唤醒事件还是有些复杂的哈。 可以看下手。 这在手册上。 睡眠模式这一节有对睡眠模式的唤醒事件描述。 节目说了。 唤醒事件可以通过下述方式产生。 第一种在外设控制净水器中使能一个中断。 而不在NVC中使人。 并且还要在内核的系统控制计算器中使人。 S e v on pv。 这样才能产生唤醒事件。 并且唤醒后要及时清除挂几位才行。 下面第二种就是配置ex ti为事件模式。 这个职业配置即可。 所以看到这个事件唤醒还是有点麻烦的。 你要是觉得麻烦。 直接使用中断唤醒的方式也是可以的。 还简单一些就是事件唤醒的一些描述。 那睡眠模式总结的一些知识点就这么多。 接下来看停止模式。 第一条和睡眠模式一样。 执行完WFWFE指令后。 STM32进入停止模式。 程序暂停运行。 唤醒后程序从暂停的地方继续运行。 因为睡眠模式和停止模式。 存储器和计时器的内容都可以维持。 所以唤醒后。 程序可以直接在暂停的地方继续运行。 下一条1.8伏供电区域的所有时钟都被禁止。 PLLHSI和HS被禁止。 SRAM和静期内容被保留下来。 这个刚才那个音量表介绍过。 还CPU和外设的始终都停止。 但是没有断电。 SRAM和计算器的数据还可以维持。 然后下一角在停止模式下。 所有的L引脚都保持它们在运行模式时的状态。 这个和睡眠模式一样。 GPL在进入睡眠或者停止模式时暂停。 并且高低电平维持暂停前一刻的状态。 最后下一条。 当一个中断或唤醒事件导致退出停止模式时。 HSI被选为系统时钟。 这条是设计编程的注意事项哈。 我们的程序默认在system1的函数里的配置。 是使用的HSE外部高速时钟。 通过PLL倍频得到72兆赫兹主频。 但是进入停止模式后。 PLL和HS都停止了。 而现在退出停止模式是。 它并不会在自动版本开启PLL和HS。 而是默认用HSI的八兆赫兹直接作为主屏。 所以如果你忽略了这个问题。 那么就会出现一个现象。 你程序刚上电是72兆赫兹的主频。 但是进入停止模式。 在唤醒之后就变成八兆赫兹的主频了。 这是一个问题。 所以我们一般在停止模式唤醒后。 第一时间就是重新启动HISE。 配置主频为72兆赫兹。 这个操作也不麻烦。 配置的函数他都帮我们写好了。 我们只需要在电话下system elite就行。 这是这个问题。 然后就看当电压调压器处于低功耗模式下。 系统从停止模式退出时。 会有一段额外的启动延时。 这个就是刚才电压调节器开启。 和低功耗模式的区别了。 电压调节器低功耗更省电。 但是从停止模式退出时。 会有一段额外的启动延时。 最后两条是WFI和WF的区别。 WFI指令进入停止模式。 可被任意一个ex di中断唤醒。 WFE指令进入停车模式。 可被任意一个EXTI事件唤醒。 停止模式只能通过EFGI唤醒中断模式。 唤醒WFI自建模式唤醒WFE。 那以上就是停止模式的相关知识点。 最后我们看一下待机模式。 第一条执行完WFWFE指令后。 STM32进入待机模式。 唤醒后程序从头开始运行。 这个和上面两个模式就有些区别了哈。 待机模式下唤醒程序是从头开始运行的。 因为待机模式。 把内部大部分电路的电源直接断了。 数据都丢失了。 唤醒之后程序也无法继续。 只能从头开始。 看一下第二条的操作。 待机模式下。 整个1.8伏供电区域被断电。 PLLH3和HSE也被断电。 SRAM和计算器内容丢失。 只有备份的计算器和待机电路维持供电。 能断的都断流。 不过备份计算器和待机电路。 还是可以维持供电的哈。 下一条在待机模式下。 所有的L引脚变为高阻态。 对于输出来说。 既不输出高电平。 也不输出低电平。 呈现高阻态。 对于输入来说不上拉也不下来。 呈现浮空输入状态。 实际上GPU的配置里啊。 没有高阻态。 这个配置它其实就是浮空输入配置哈。 浮空输入对于输出而言就是高阻态。 所以说如果你提前点个灯。 进入待机模式后。 无论这个灯是高电平点亮还是低电平点亮。 它都会熄灭。 GPL对外不输出高低电平。 也不流过电流。 最后最后一题了。 wake up引脚的上升眼。 ITC闹钟事件的上升眼。 NI4T引脚上外部复位。 IWDG复位。 退出待机模式。 这四个是待机模式的换取条件。 刚才也说过啊。 那这些就是待机模式的一些描述。 那这里我们这个PPT的知识点就讲完了。 最后我们分别看一下数据手册和参考手册啊。 首先看一下数据手势。 刚才我们说了。 睡眠模式是一般省电。 停止模式是非常省电。 待机模式是极为省电。 说了这么多。 省电到底有多省呢。 我们看一下数据手册。 用数据说话。 在手册这里5.3.5供电电流特征有介绍。 这里测试条件比较多啊。 表现比较多。 我就没往PPT里放。 另外耗电量在不同工作条件下都是不同的。 做产品的话具体值还是以实测为准。 现在我们就大概看一下官方给的一些测试表哈。 看一下各个模式的耗电范围。 首先这个表是从flash运行。 正常运行模式下的供电电流条件是外部时钟。 使能所有外设和关闭所有外设。 然后各个主频下的电流信号。 在右边可以看到耗电电流区间是几到几十。 单位是毫安。 最高是50ma左右。 最低是7ma左右。 上下对比。 使人所有外设比关闭所有外设更耗电。 所以为了省电。 不需要的外设。 我们可以把他的时钟关掉。 另外对于频率来说。 降低主频对于省电也是很划算的。 降低主频后耗电电流下降也很明显。 所以如果你需要设备连续性。 并且对于主频和性能没那么高要求的话。 降低主频也是一个不错的选择。 就是这个表的数据。 然后下面这个是从ram运行的核电数据啊。 整体上来看比上面这个表低一些。 但差别不大。 然后这个图里可以看出主频温度和耗电的关系。 主屏和耗电大概上是一个正比的关系啊。 72兆耗电40ma左右。 频率降低一半。 36兆耗电大概也降低一半。 二次毫安左右。 36兆再降低一半是18兆。 可以看下这个相近的16兆哈。 差不多电流也降低了一半。 16兆再降低180兆。 电流继续降低一半。 所以主频越低。 耗电越低。 主频每降低一半。 耗电大概就也降低一半。 单只是大概一半的关系。 并不是严格对应的。 然后再看温度。 温度升高。 耗电量也是升高的。 但影响并不是很大。 这就是这个图可以看出来特征。 接下继续我们看睡眠模式。 这是睡眠模式下的供应电流。 它的耗电也是毫安级别的。 从几毫安到几10ma不等。 但是整体上来看。 比正常运行的耗电是低一些的。 比如正常运行的情况下。 最大刚才看的是50ma左右。 在睡眠模式下。 这个最大电流降低到了30ma左右。 会省一些电。 但是耗电也是毫安级别的。 只能算是一般省电。 最后继续我们看这个表。 这是停机模式下的供应电流。 和待机模式下的供应电流。 这些是测试条件哈。 大家可以仔细看看。 那看右边的数据呢。 首先这个电流的单位是微安级别。 在停机模式下3.3伏供电时。 耗电电流典型值是14~24V安。 这个就非常省电了。 在待机模式下。 电流会进一步降低。 典型值是2~3。 未按左右。 可以算是极卫生间了。 举个例子呢。 为了方便计算或近似取个值。 假设正常运行电流是30ma。 停机模式电流是30微安。 待机模式是3VR。 那么对于一个300ma时的电池来说。 正常运行能用十个小时。 停机模式能用1万个小时。 待机模式能用10万个小时。 这个对比差别就比较大了吧。 所以如果你的产品使用了电池供电。 低功耗模式还是要考虑用一下的。 最后我们看到备份区域的供电电流也非常低。 RTC开启的情况下也只需要1.4微安。 所以备用电池接上一个基本不用担心没电的。 那有关STM32各个状态下的电流消耗。 我们就看到这里。 剩下的一些表格和数据。 大家可以自己看看。 最后我们还是照例看一下参考手势。 我们本节讲的内容位于参考手册。 第四节电源控制PWR看一下。 首先是这个整体的电源框图。 内部电源有哪些区域。 通过哪些引脚供电。 这个了解一下。 下面有一些详细的解释。 比如独立的AD转换器供电和参考电压。 这也是VDDA和VR眼护相关硬件的介绍。 100角和144角分装有单独的VREF。 六四角或更少的分装没有VREF。 他们在芯片内部与ADC的电源相连。 最下面是电池备份区域。 这里有一些警告和建议哈。 这个我们上一节讲RTC电路的时候说过。 当然这里还有一个注写的是。 因为模拟开关只能通过少量的电流3ma。 在输出模式下使用。 PC13是PC15的L口功能是有限制的。 速度必须限制在两兆赫兹以下。 最大负载为30平方。 而且这些LQ绝对不能当做电流源。 如驱动led。 他这里特意强调了。 PC13到PC15端口绝对不能驱动LED。 但有意思的是。 我们这个最小系统板。 它上面有两个led。 一个是电源指示灯。 另一个是接待GPL口的测试等。 并且这个接待GPL的测试灯。 它就正好位于PC13。 所以说我们这个最小系统板的电路设计。 违背了这条注意事项。 不过好在这个贴片的小LD电流并不是很大。 目前也没有什么问题啊。 但是他要是真的导致GPU损坏。 你也不能怪他没提醒你。 所以我们在做产品之前还是要仔细阅读手册哈。 知道的越多就越不容易犯错。 然后继续。 下面是电压调节器。 有三种模式。 正常运转。 低功耗和停止供电。 再看下面这是上电复位和掉电复位的介绍。 这个图和功能我们也讲过哈。 下面是可编程电压监测器。 大家可以看一下。 之后就是低功耗模式的介绍了。 低功耗一览表。 总共有睡眠停机待机三种模式。 下面是一些省电建议哈。 首先就是降低系统时钟。 降频后功耗会明显降低。 刚才通过那个数据手册也看过啊。 然后是外部始终的控制。 不需要的外设。 我们可以把时钟给关掉。 以减少功耗。 另外在睡眠之前也可以关闭所有外设的时钟。 来省电。 不过这样睡眠模式下的外设就干不了活了。 然后下面是睡眠模式。 执行WFI或WFE进入睡眠模式。 可以选择立刻睡眠。 或者等中断结束后再睡眠。 退出睡眠呢在这里也有介绍。 和我们pp讲的一样哈。 第二是停止模式。 如何进入。 如何退出。 以及一些注意事项。 大家可以自己再看看。 然后是待机模式再介绍。 也可以再看看。 最后这里有个低功耗模式下的自动唤醒。 这里的意思就是使用IDC。 可以在停止模式或待机模式下定期唤醒芯片。 也就是我们第四个实例代码演示的现象啊。 然后下面就是一些计算器描述了。 控制计算器里面是一些控制位。 比如DBP为取消后备区域协保护。 PLS选择PVD电平。 PDD选择是停止模式还是待机模式。 LPTS选择停止模式下。 电压提示器是开启还是低功耗。 这价位就在这里定义的。 然后控制状态。 计算器里面是一些控制位和标志位啊。 比如使人wake up引脚和一些标志位。 最后就是计数器总表了。 计容器不多。 总共就两个好了。 到这里。 本节PWW的知识点我就讲完了。 我们下小节来学习低功耗模式的相关代码。
45. 大家好。 欢迎回来。 本小节我们来学习低功耗模式的代码部分啊。 首先看一下经验图。 本节代码都在之前代码的基础上修改而来的。 所以接线基本是和之前对应代码的一样。 来看一下13杠一修改主频。 这个代码不需要接其他的模块。 所以只接个显示屏显示一下即可。 非常简单。 然后后面几个代码的接线我们一起看一下吧。 13杠二睡眠模式加串口发送加接收。 这个和串口那一截的接线一样啊。 拿出一个C区340USB转串口模块。 GND和STM32共地XD接待PA9。 对应STM32的TX硬件TXT接待P10。 对应STM32的2X硬件。 发送和接收交叉连接。 别搞错了。 这是第二个代码的极限。 之后第三个代码13杠三停止模式加对。 设置红外传感器计次。 这个和外部中断那一节的接线一样。 我们拿出对射红外模块VCC和精力。 接上供电DO输出。 接到STM32的PB14引脚。 这是第三个代码的接线。 最后第四个代码13杠四待机模式加实时时钟。 首先是右下角接上OLED显示屏。 然后PA0。 这里我引出来了一根线啊。 这个线的意思就是。 我们可以手动把pa0接到3.3伏或者断开。 因为PA0还有一个功能。 wake up可以唤醒待机模式。 wake up引脚上升也有效。 但是这个地方也不好接按键的。 所以我们可以直接用一根线短接到3.3伏。 来手动产生一个上升沿。 测试wake up引脚是不是有效果。 然后实时时钟还有一个备用电源VBAT。 这个接不接都行啊。 因为我们需要在待机模式下唤醒。 唤醒之后没有主电源程序运行不了。 所以主电源是不能断电的。 那组电源不断电。 备用电源接不接就都是一样的现象了。 好这就是这几个代码的接线。 那看一下面包板。 这几个代码的接线我都已经事先接好了哈。 因为之前都演示过。 所以这里就不再过多演示接线部分了。 那接下来回到工程文件夹来开始本节的代码。 首先第一个代码。 我们还是复制OID显示屏的工程。 改个名字叫13杠一。 修改主屏。 打开工程。 这些删掉编译一下。 在这个过程里。 我们主要的任务就是研究一下这个system s t m。 32F10X点C和点去这两个文件。 这两个文件之前也介绍过一点哈。 这里呢我们就再更进一步研究一下。 看一看这些代码是怎么运作的。 顺便我们再利用它里面给我们提供的宏。 完成修改主频的任务。 降低主频可以用来降低功耗。 也算是契合本节的主题啦。 那我们来看一下。 首先这两个system文件是用来配置系统时钟的。 也就是配置RCC时钟速。 这个RCC时钟速啊。 我们可以看一下PPT。 在这里这个图就是RJC时钟速的全部电路。 左边是四个时钟圆。 HSIHSELSELS用于提供时钟。 右边就是各个外设。 就是使用时钟的地方。 我们用的最多的就是AHB时钟。 app1时钟和APP2时钟。 另外还有一些时钟。 它们的来源不是HB和APB。 比如IPHONE4的时钟直接来源于system clock。 USB的时钟。 直接来源于PLL。 当然这些特例我们就不过多关心了。 我们主要关心的就是这个外部的八兆赫兹晶振。 它如何进行选择。 如何被屏。 才能得到这个72兆赫兹的csm clock。 系统主频。 然后系统主题如何去分配。 才能得到AHB。 APB1和APB2的时钟频率。 在我们之前的课程里。 我们一直保持着默认的配置。 就是金正接的是八兆。 主频是72兆。 AHB和APB2是72兆。 APP1是36兆。 但其实这些都不是绝对的哈。 可以根据自己的需求进行更改。 当然我建议一般还是不要改吧。 毕竟目前绝大多数程序。 都是按照默认的配置来写的。 随意更改可能会造成一些问题。 回到程序。 我们来看一下它这里是怎么配置。 这个RJC时钟数字。 那这个点C文件最开始写了一堆注释啊。 这个注释就是对这个system文件的介绍。 读懂这些注释就差不多能理解这个文件了。 所以注释我们还是得好好看一看的。 英文不好的话。 用用翻译软件就行。 难得他写了这么多注释。 不看白不看。 那这里注释我已经提前看过了哈。 给大家简单说一下。 第一条的意思就是。 system这两个文件提供的两个外部可调用的函数。 和一个外部可调用的变量。 两个函数是system it和system call clock update。 一个变量是system call clock。 这一点我们可以看一下头文件哈。 这里是一个外部可调用的变量。 这里是两个外部可调用的函数头文件。 总共就这么多东西啊。 那正好和我们这里注释是对应的。 然后这三个东西的用途呢。 右边解释system dat这个函数是用来配置使用数的。 也是这整个文件最主要的东西。 使用HS配置主频为72兆。 就是这个函数干的活。 并且这个函数在复位后执行main函数之前。 在启动文件里自动调用了。 所以main函数一进来始终就配置好了。 不用我们操心。 最下面这个变量。 system call LCK表示主频频率的值。 我们想知道目前的主频是多少。 直接显示一下这个变量就行。 最后一个函数system call LCK update。 这个是用来更新上面这个变量的。 因为这个变量只有最开始的一次赋值之后。 如果我们改变了主频频率。 这个值不会自动跟着变换。 所以我们就需要调用一下这个函数。 根据当前时钟数的配置。 更新一下上面这个变量好。 这就是这个文件对外提供的一些函数和变量。 然后后面这几条大家自己看一下哈。 我们接着往后看。 下面这一块儿就是用来更改主频的宏定义的。 这里写的是解除对应的注释。 来选择想要的系统主频。 重要提示大家自己看。 下面这里是配置的地方。 如果你使用的是VL。 这些设备也是超值系列。 那可选主频只有两个HS的八兆和24兆。 否则的话可以选择这么多主频。 八兆。 24兆。 36兆。 48兆。 56兆和72兆。 当前解除注释的是72兆。 所以主频默认就是72兆。 这个井号的if啊叫做预编译。 主要是用来兼容不同型号的设备。 意思就是如果我们define了这些东西。 那整个文件就是if这里有效。 下面这些代码相当于没写。 不用看。 否则井号ELS的话。 就是下面这些代码有效。 上面的这些相当于没写。 所以在看这里带有预编译的代码时。 我们一定要清楚当前我们的设备是啥。 F103C8T六是MD中容量非超值系列。 所以我们就看下面这一块儿。 在这里可以修改主频频率。 如果你想改成36兆。 那把72兆的红注释掉。 再把36兆的红解除注释。 但目前这个文件是只读的哈。 它提示我无法更改。 在这个文件列表里。 这些文件的图标带了个钥匙符号。 就代表它是只读的。 解除只读的方法。 我们打开工程文件夹。 或者在选项卡这里右键点打开包含的文件夹。 这样他就可以直接打开文件夹。 并定位到这个文件。 在这里我们右键属性把这个只读的勾去掉。 确定。 如果你想要整个文件夹。 或者整个工程的文件都取消只读。 那要在外面对整个文件夹操作。 然后把这个只读去掉就行了。 好。 我们回到Q。 可以看到这个文件的钥匙图标已经没有了。 这时候我们就可以修改代码了。 当然现在先不改哈。 等会再改。 那我们简单的修改一个宏定义。 它是如何作用电路的配置的呢。 我们继续往后看。 首先我们要找的这个system net。 这是最先调用的函数。 它里面的代码。 这些都是直接操作计算器的写法。 看不懂没关系哈。 他这里都有注释的嘛。 可以看到第一步是开启HSI。 你要是默认使用的是内部的八兆晶振之后。 这些操作啊可以看到都是各种reset。 各种disable。 重要的就是恢复确认配置啊。 最后恢复完之后调用set c4clock函数。 那我们转到这个函数。 继续挖掘这个函数里。 我们就能知道为什么改变宏定义。 就可以修改主屏了。 可以看到这个函数实际上就是一个分配函数。 根据你定义的不同宏定义。 选择执行不同的配置函数。 比如你前面解除了这个72兆的红。 那他就执行设置时钟到72兆这个函数。 如果你解除了36兆的红。 那就执行设置时钟到36兆的函数。 根据你所选的红执行不同的函数。 我们当年解除的是默认的72兆。 这个那就继续挖掘这个函数。 转到第一好到这里。 这才是正式的时钟配置部分配置。 第一步是使人HSE外部高速始终。 第二步是一个循环哈。 等待hs ready或者超时退出。 接下来根据hs ready标志位给hs state置一或零。 如果hs state等于一。 表示真正启动成功。 进入if配置。 第一步是设置flash的等待啊。 这个不用多管这个配置。 HCLKPCLK2和PCLK1的分屏器。 HCLK就是AHB的时钟。 PCLK就是APB的时钟。 可以看到这里的分屏分别是112。 对应这个时钟数就是啊这里一分屏。 这里一分屏。 这里二分屏。 如果C4clock是72兆的话。 那这样HB和APB2就是72兆。 APP1是36兆。 那继续往后。 这里是井号。 if define cl是互联型。 我们这个是MD。 所以if define里面不看。 我们看else里的。 可以看到这里配置的是锁相环。 HSE是八兆所向环。 选择九倍频。 最终所向环输出就是72兆。 这就是齿轮锁相环。 等待锁相环准备就绪。 选择锁相环的输出作为系统时钟。 最后等待锁相环成为系统时钟。 对于时钟树的图案。 刚才执行的配置就是选择外部的八兆晶振。 作为锁相环。 输入锁相环执行九倍频输出的72兆。 选择为system clock。 这是库函数默认的时钟配置。 这个csm elite函数干的就是这些活。 然后代码最后还有个else写的是。 如果HSE启动失败。 应用程序会有错误的时钟。 用户可以在这里加一些代码解决这个错误。 同时我们也可以看出啊。 如果HSE没接。 或者HSE坏了。 那么上面代码都不执行。 程序。 默认会使用最开始启动HSI内部八兆时钟。 作为系统主屏。 所以如果你发现你的主屏变成了八兆。 那可能是外部晶振有问题了。 你可以在这个else里加一些代码。 如果确实执行到了else里面。 那就说明确实是HSE有问题啊。 好这就是这个C文件里代码的作用。 然后往上看看。 除了有这个set to72的。 还有cf56的。 这里面的执行流程几乎是一样的哈。 主要区别就是这里所相反的倍频是七倍。 HSE乘七等于56兆之后继续。 这是HS乘六等于48兆。 再往上。 hs 1÷2。 说明这个HS进来之后啊。 走的是下面这一路除二的对吧。 然后再往上。 HS12乘六等于24的。 最后这个是直接使用HS作为系统时钟了。 没有通过锁相环倍频主频就是八兆对应时钟数。 HS1进来就是走的这一路。 那最后画个图总结一下哈。 首先是CSM1D函数进来。 首先启动HSI之后就是各种恢复确认配置啊。 最后调用set c4clock。 SC4clock是一个分配函数。 根据我们前面解除注释的宏定义。 选择执行不同的配置函数。 比如set six clock to72to。 56to48等等。 只有在two72等这一函数里才真正的配置。 比如突72的配置是选择HS作为锁相环。 输入之后。 锁相环仅九倍频。 再选择锁相环输出作为主屏。 这样主频就是72兆了。 就是配置时钟的整个流程。 好了。 流程说完了。 接下来我们就来完成代码吧。 首先我们刚才说了。 有个变量可以表示当前主频。 那我们显示一下。 看看先来个字符串哈。 OID修string。 一行一列显示cs LCK。 之后oled show number1行八列。 显示刚才那个变量在这里啊。 system call LCK放到这里。 数字长度给八。 这样就行了。 然后这个C的头文件不需要再包含了哈。 因为这个头文件里面已经包含过了。 那目前我们来测试看一下编译下载。 看一下目前显示的主频确实就是72兆。 没问题。 然后我们继续测试。 首先我们在主循环里加个delay。 表示一下当前代码运行的速度哈。 比如o i d show string。 在二行一列显示个running delay。 毫秒给个500。 复制一下。 再显示个空格。 把running擦掉。 就相当于闪烁running字符串对吧。 闪烁周期是一秒。 下载看一下。 可以看到目前现象已接近成行。 running闪烁的周期是一秒。 接下来我们就来开始修改主题了。 那修改主屏呢。 我们就到system点C这个文件的最开始。 比如修改成36兆。 36兆是72兆的一半哈。 这个方便观察。 这样就行了。 下载看一下。 可以看到第一行的主频频率。 显示的就是36兆。 第二行running闪烁也变慢了。 目前闪烁周期是两秒。 说明主频确实降低了一半。 这就完成了。 修改主频还是非常简单的吧。 那其他的频率大家都可以自己再尝试一下。 然后还有一个问题说一下。 就修改主屏后。 有很多涉及计时的计算都要重新匹配一下。 比如这个delay函数。 我代码默认使用的是72招数。 平台转到定义。 看一下这里delay微秒时默认是72。 所以在72兆主频下。 delay的时间是正确的。 降低主频后。 delay的时间不能自适应变化。 如果你想在任何主频下delay的时间都是正确的。 那我们程序就别写死了对吧。 可以用这个system call LCK变量来做自适应。 把这个变量也带入计算就行。 另外从这里我们也可以看出来。 修改主屏是一个牵一发而动全身的事情。 改完之后。 很多涉及精准计时的计算都要做好匹配的工作。 所以一般条件下我是不推荐随便修改主频的哈。 除非你是真的有需求。 并且可以协调好每个需要计算的地方。 好到这里。 我们第一个代码就完成了。 主要是学习一下system这两个文件的工作流程。 另外再用它提供给我们的宏定义修改一下主屏。 那第一个代码就是这样。 接下来我们来学习第二个代码。 回到工程文件夹。 复制一下九杠二的工程。 改个名字。 叫13杠二睡眠模式加串口发送加接收。 打开工程。 编译一下。 在这个工程的基础上。 我们要为他加入低功耗的代码。 那假设我们目前要用这个STF32。 做个下位机。 下位机接收电脑串口发过来的指令。 然后执行相应的功能。 电脑随时都有可能通过串口发送指令。 当然也可以几个小时。 几天都不发指令。 为啥随时能响应指令。 STM32就得时刻准备着对吧。 比如我这里主循环就一直在不断的检查标志位。 但是你如果一直不发指令。 我这些操作都没啥意义。 还比较费电。 当然你可能说把这段代码放在中断里就行啦。 但是即使主循环是空的。 它CPU也是在不断耗电的。 所以对于这种靠中断触发。 没有中断的时候就没什么事了。 代码我们就可以给它加入低功耗模式。 没事的时候就低功耗中断奶了。 再醒来干活就行了。 那对于当前这个代码。 我们可以加入哪一种低功耗模式呢。 看看PPT。 首先睡眠模式这是可以的。 CPU始终关程序不再执行。 但是外设的始终不会关。 USART硬件电路还是可以接受数据的。 USART收到数据后产生中断唤醒CPU。 所以睡眠模式可以之后停机模式。 这个叫停机模式或者叫停止模式。 都是一个意思哈。 我手册里一会儿写的是停机模式。 一会儿写的是停止模式。 我在PPT里也是停机模式。 停止模式都有出现过哈。 大家知道是一个东西就行。 来继续看停止模式行不行呢。 这个模式下所有1.8伏区域的时钟都关了。 CPU和外设都不能运行。 那自然USART也搜不到数据。 产生不了中断了。 并且USART的中断也不能唤醒停止模式。 所以当前这个程序功能啊用不了停止模式。 最后待机模式自然也不行了。 所以目前这个程序功能只能加上睡眠模式。 一般省电的那开始写代码。 在睡眠模式之前呢。 我们先加一个running的指示。 看一下不加睡眠的情况。 在这里来个ORE修string2行一列。 显示running之后。 delay100毫秒。 复制一下。 再显示空格。 把running清除掉。 这是正常的情况。 我们先看一下。 可以看到。 即使我们现在并没有发送数据。 主循环也是在不断运行的。 那我们打开串口助手。 随便发送一个数据。 可以看到数据收发是没问题的。 但是没有数据发动时。 主循环还在不断运行。 这是耗电操作。 我们可以用睡眠模式来优化这部分损耗。 那怎么使用睡眠模式呢。 很简单。 我们在主循环的最后加上一个WI。 FI指令即可。 WFI指令的格式是两个下划线WIFI。 再加个括号。 分号就是WFI指令格式。 就按照这个来当睡眠模式。 还有一个指令是WFE。 它俩的区别就是唤醒方式不同。 WIFI是中断唤醒。 WFE是事件环境。 但我推荐是使用WFI中断唤醒啊。 因为试驾模式的配置可能比较麻烦。 并且中断模式唤醒。 正好可以在带有中断的程序修改比较方便。 所以我们工程就只显示WFI了。 那转到第一看下。 它对应的就是一个CPU的汇编指令。 再往下就看不到定义了。 所以这个指令格式记住就行。 那我们的睡眠模式。 其实简单的加上这一句就完成了。 当然通过PPT这里的流程图哈。 这里其实还涉及两个计算器的位。 一个是sleep deep。 另一个是sleep on exit。 这两个位。 其实库函数并没有给我们提供一个。 比较方便的配置方法。 所以我们暂时就不配了。 直接使用默认值零。 他进入的就是默认的睡眠模式。 立刻睡眠。 如果确实想配置的话。 得使用操作计算器的方式完成啊。 这两个位位于内核的系统控制块。 我们需要打开参考文档。 打开cortex跟M3编程手势。 然后打开第四章内核外设4.4。 系统控制快SAB。 这里有个系统控制计算器SCR。 可以看到这里就是和低功耗相关的三个位。 第一个s EV on pd。 是事件唤醒睡眠模式需要设置的位。 第二个史蒂夫deep。 决定是进入睡眠模式还是深度睡眠模式。 第三个sleep on exit。 决定是立刻睡眠还是等中断结束再睡。 如果你想配置这三个V的话。 得在程序中用操作计算器的方式实现。 比如在WIFI上面写个SCB。 外设的SCR进气等于0X什么什么什么。 这个值你得对照着计算器的未来给。 当然我们不要求这么多。 进入睡眠模式的话。 只要位暂时就不配了。 保持默认为零就行。 那睡眠模式的代码就是这样。 我们编译下载看一下。 可以看到这里第二行就不再闪烁running了。 这说明主循环目前是停下来了。 CPU正在睡眠。 那我们用串口助手发送一个数据试试。 可以看到每发送一次让你闪烁一次。 接收区回传一次数据。 这说明程序在收到数据之后。 可以唤醒工作一次对吧。 在不影响程序功能的前提下。 CPU能在空闲时睡眠及用电就是睡眠模式的作用。 那回到程序分析一下程序的执行流程。 首先程序开始初始化。 把串口配置好之后。 进入主循环。 检查一下标志位。 让你闪烁一次。 在主循环的最后执行WFI。 这时CPU会立刻睡眠。 程序是不是就停在了WFI指令这里了。 这是CPU睡眠。 但是各个外设比如USRT还是工作状态。 等到我们用串口助手发送数据时。 UICIT外设收到数据产生中断。 唤醒CPU睡眠模式唤醒之后。 程序在暂停的地方继续运行。 所以程序会运行到WFI之后。 但是幻影之后中断也是会立刻申请的。 所以程序在跳回到while循环开头之前。 先进入UCIT的中断函数。 在中断函数这里读取数据。 然后回到while循环的开头。 这时rx flag刚刚置一。 所以if成立执行数据回传和显示的功能。 唤醒的功能执行完之后。 running闪烁一次。 最后程序又来到WIFI的位置。 这是一个新的睡眠指令。 所以到这里CPU再次进入睡眠。 正好我们需要它唤醒后执行的功能也执行完了。 这时再进入睡眠。 那就是恰到好处了之后。 等待下一个数据发过来时。 程序再重新执行一遍这个流程。 这样就指着整个程序的执行步骤。 所以睡眠模式。 我们一般可以。 在while循环的最后加一个WFI指令。 每来一个中断先进终端函数。 再执行一遍程序功能。 这样就能实现我们想要的功能了。 那这些就是睡眠模式的代码。 我们就讲完了。 接下来我们继续看下一个代码。 回到工程文件夹。 下一个代码我们要学习停止模式。 停止模式只能通过外部中断触发。 所以和停止模式相关的代码肯定得用外部中断。 那么复制五杠一的代码。 改个名字叫13杠三。 停止模式加对设置红外传感器机制。 打开工程。 先编译一下。 那对于这个代码呢。 其实思路和上一个睡眠模式是非常像的。 你看这个counter sense总是get。 但是如果外部一直没有中断信号的话。 那这个get就是没有意义的耗电操作。 如果几个小时几天都没有外部中断触发技术。 那我这个while循环也没必要一直刷新对吧。 所以对于这个代码在空闲的时候。 我们可以让他进入低功耗。 因为这个代码可以使用外部中断触发唤醒。 所以我们可以让它进入更为省电的停止模式。 在停止模式下1.8伏区域的始终关闭。 CPU和外设都没有时中断。 但是外部中断的工作是不需要时钟的。 这一点从代码里也可以看出来。 你看初始化的时候。 根本就没有开启EXTI时钟的参数。 这也是EXTI能在时钟关闭的情况下。 工作的原因。 因为它不需要时钟。 那确定好用停止模式之后。 我们来开始写代码。 写代码之前我们还是得看一下库函数啊。 刚才讲的睡眠模式其实都只是内核的操作。 睡眠模式涉及的几个计算器也都是在内核里。 跟PW外设关系不大。 所以刚才我们都没用到PWR的库数。 不过现在停止模式涉及到内核之外的电路操作。 这就需要用到PW外设了。 我们看一下扩展数。 打开PWR点去看一下函数啊。 这些就是PW外设的相关函数。 看着也不是很多。 我们一一看一下。 第一个第一data恢复全损配置。 这个不用多说。 第二个backup access command。 使人后背区域的访问。 这个上节用过哈。 最后两个pvd command和pvd level config。 这两个是跟PVD相关的函数。 level configure就是配置PVD的阈值电压。 CMD就是死人PVD功能。 如果你需要用PVD的话。 就先指定阈值。 然后CMD死人一下即可。 这是PVD的功能。 接下一个wake up pin command。 使人位于pa0位置的wake up银角。 这个配合待机模式使用哈。 待机模式可以用wake up引脚的上升眼唤醒。 当然用不用这个功能是有一个开关的。 如果你需要开启wake up引脚唤醒功能的话。 那就得调用这个函数使人一下。 然后下一个enter stop mode进入停止模式。 调用这个函数就可以进入停止模式了。 这是我们一会儿要用到的。 然后enter standby m进入待机模式。 调用这个函数进入待机模式。 这是我们下一个代码要用到的。 最后两个是获取标志位和清除标志位的函数。 这个不用多说吧。 好过数我们就清楚了。 接下来我们来开始写代码。 首先加入停止模式之前。 我们还是加一个running的指示。 在主循环下面加一个OOD修string。 二行一列显示running。 delay100毫秒复制一下。 再把running清除。 当然这些代码并不是必须的哈。 加它主要是用来指示主循环。 是不是在不断运行的。 方便我们观察实验现象。 那目前我们先看一下当前代码的现象编译。 然后下载的步骤注意一下。 按住复位键不放下载松手看一下。 遮挡一下这个传感器。 可以看到数值是在技术。 但是在没有中断信号的时候。 它还是在不断的装。 你这个耗电操作。 我们可以用停止模式来优化一下。 所以回到程序我们来加入停止模式的代码。 停止模式和待机模式都需要PW外设干活。 所以首先我们要开启PWR的。 始终在这上面来个RCCAPPE外设。 始终控制RCCAPP1外设p w w be。 这个时钟一定不要忘了开哈。 如果外设没开时钟。 那么写入计算器是无效的。 读取计算器也全都是零。 这个现象大家可以自己试一下。 然后始终开启之后。 我们想让它在主循环的最后进入停止模式。 那可以直接调用这个函数。 P w w enter stop mode。 放到这里。 这个函数有两个参数。 转到定义看一下。 第一个参数是指定电压调节器。 在停止模式里的状态开启或者低功耗。 这个就随意了哈。 目前我选择开启放到这里之后。 第二个参数是停止模式的入口。 参数是选择WFI指令进入停止模式。 还是选择WFE指令进入停止模式。 这里我就选择WFI指令进入放到这里。 这样进入停止模式的代码就完成了。 那这一句代码里面干了什么呢。 可以转到定义。 看一下函数内部。 看一下。 第一步读取PWCR计数器放在临时变量里。 第二步清除PDDS和LPDS位。 其中清除PDD就是代表选择停止模式以后是PPT。 在这里哈PDDS等于零。 那在这一步的判断会执行上面的操作。 进入停止模式。 然后第三步根据我们指定的参数。 设置LPDS位。 如果你这个参数选择调压器开启。 那这里LPDS就等于零。 如果选择调压器低功耗。 那这里LPDS就等于一。 这一步就对应PPT这里的判断。 LPDS等于零。 T压器开启LPDS等于1T加T低功耗。 最后下一步把014变量写入到PWCR进器。 参数生效。 最后设置内核里的sleep deep way。 这里或等于sleep deep的掩码。 就是把sleep deep之一。 那对于这里在这个判断它就会执行下面的流程。 至此。 史蒂夫蒂普PDDS和LPDS都已配置好。 最后我们就可以调用WFI或者WFE指令了。 可以看到程序最后就是一个if。 如果你第二个参数给的是WF。 那他就执行WFI指令。 否则执行WFE指令。 那执行到这个位置。 芯片就会进入停止模式。 程序暂停运行。 然后最后还有一行。 这一行就是停止模式唤醒之后才能执行到啊。 可以看到在退出停止模式后。 他很贴心的帮我们把史蒂夫蒂部位就清零了。 好这些就是进入停止模式。 这个函数执行的内容。 配置各种计算器和调用指令。 在这一个函数里就都完成了。 那在主函数里我们调用这个函数就可以了。 现在测试看下程序现象。 按住复位键下载。 松手看一下。 现在可以看到在空闲时装零是没有闪烁的。 这说明主循环是停止运行的。 我们遮挡试下呢。 可以看到每遮挡一次让你闪烁一下。 不过我们还注意到一个现象啊。 比如现在我按下复位键。 可以看到复位之后的第一次running闪烁很快。 是正常的时间。 而我们遮挡之后。 running闪烁就变得很慢了。 这是什么原因呢。 那在PPT这里我提到过哈。 原因就在这里。 退出停止模式时。 HSI被选为系统时钟。 要是在我们首次复位后。 system elite函数里配置的是HSE乘九倍频的。 72兆主频。 所以复活后第一次抓你闪烁很快。 而之后进入停止模式。 在退出时默认时钟就变成HSI了。 HSI是八兆。 所以唤醒之后的程序运行就会明显变慢。 这是刚才现象的原因。 那找到原因了。 解决方法也很简单。 我们只需要在退出停止模式之后。 重新调用system1。 重新启动HS。 配置72兆的主频就行了。 所以在这里我们简单的来一个system elite就可以了。 先来试一下。 看看编译下载啊。 不能直接下载啊。 复位下载看一下再试试看。 可以看到这时遮挡之后。 running的闪烁仍然是正常的。 那这样我们就解决了停止模式退出后。 主频变为八兆的问题了。 好这就是停止模式的代码。 然后这个代码的执行流程。 和上一个睡眠模式也是非常类似的。 首先复位后。 初始化之后进入主循环。 然后进入这个函数。 只听到这一句WFI指令后。 程序立刻暂停。 等外部中断发生时。 芯片唤醒。 这时芯片先进用到外部中断函数里执行一遍。 中断函数退出后。 程序再到这里继续运行。 然后函数退出执行system elite配置始终之后。 while循环回到开头执行一遍这个内容。 最后就是在执行这个函数进入停止模式的。 这是程序执行流程。 那到这里我们第三个程序也写完了。 最后我们来看第四个程序。 回到工程文件夹。 复制12杠二实施时钟的程序。 改个名字叫13杠四。 待机模式加实时时钟。 打开工程。 先编一下。 好在这个过程里。 我们的主要任务就是第一设置RTC闹钟。 第二进入待机模式。 第三使用闹钟信号唤醒待机模式。 那在开始代码之前呢。 我们先把目前的显示布局重新规划一下。 目前OID上已经没有位置的。 那么第一行就用来显示CNT。 这个是秒计数器啊。 第二行用来显示ALR。 这个是闹钟子。 第三行显示个ALRF。 这个是闹钟标志位。 第三行删掉最下面年月日时分秒就不显示了。 CNT的位置放在一行六列。 div也不一样了。 现在看一下现象。 按复位键下载松手。 不健康的。 现在第一行显示秒数。 后面的还没有东西。 回到代码。 目前我们先实现第一个任务。 设定闹钟。 我们可以在while循环上面。 这里设定在每次复活后设定闹钟值。 闹钟值也不用特别去记得哈。 我们直接设置为当前秒数加十。 这样每次复位后闹钟就都是十秒后了。 怎么设定闹钟呢。 我们到RTC点距离看一下库函数。 很明显我们调用这个slam就行了。 那放到这里设定闹钟。 闹钟值也是一个32位的值。 我们直接给他一个r DC get counter。 这是当前的秒数。 然后加十就是设定闹钟为十秒后。 这样闹钟就设置好了之后。 在下面我们还计划显示一下这个值对吧。 但这里有个问题。 就这个闹钟计算器它是只写的。 写进入之后就读不出来了。 怎么看出禁用器是只写还是只读呢。 我们可以看一下手册的禁用器描述部分。 打开RTC的计算器。 描述这个闹钟计算器。 可以看到这个进度条下面有一排字母W。 这个就是对应位的读写特征啊。 只有个字母W就代表对应的位只能写入。 不能读出。 然后上面比如这个CNT计算器。 对应的V都是2W。 这个就代表可读可写。 再往上。 比如这个div余数定器。 这里写的是二。 就代表只能读不能写。 这是最常见的几种读写特性。 那有关这些独有特性的字母意思哈。 可以看一下文档的第一章。 这里有个表。 里面各种缩写和对应的意思。 大家可以自行看一下。 那回到代码。 因为这个闹钟定器是只写的库函数。 也没有rtc get拉姆这样的函数。 所以为了避免写进去就不知道是啥了。 我们可以在写之前给他存下来。 就这样先定义一个变量。 UINT32杠七拉姆。 它等于我们要写入的那种子。 之后把这个alarm变量写入进去。 最后显示的话就直接显示这个变量就行了。 所以是o r i d show number。 二行六列显示alarm长度为十。 那这样我们闹钟设定和显示的代码就完成了。 之后随着CNT的增大。 CNT会和AR相等。 然后触发闹钟标志位置一。 如果开启了闹钟中断。 那还会进一步进入中断函数。 在这个代码我们暂时就不开中断了。 直接显示下闹钟标志位。 看看闹钟响的时候会不会自一。 所以在主循环里复制一下。 在三行六列我们不断刷新。 显示rtc get flag status。 获取标志位。 标志位是rtc flag a l r绕桩标志位。 显示长度为一。 这样绕中标志位我们就能看到了。 然后主循环后面我们也还是加个running的指示。 看一下OID修string4行一列显示running。 delay100毫秒复制一下。 再把running清除。 那现在我们看一下程序现象。 编译下载看一下。 目前看到第一行的CNT不断自增。 第二行的ALI是复位后十秒。 第三行是闹钟标志位。 然后等一下CNT等于LRLRF之一。 并且发现它是CNT等于ALR的最后时刻。 ALRF才是一好。 这样我们的闹钟测试是没问题的。 回到代码。 我们现在就可以加入待机模式来测试了。 要想进入待机模式呢。 我们需要使用PWR外设。 使用PW外设之前还是别忘了开启时钟。 虽然在这个代码里啊。 RT c初始化里面已经开启过了PWR的时钟。 但是我们使用待机模式的话。 最好还是再开一次。 保持每部分代码的独立性。 所以可以复制这一条放到这里。 开启PWR的时钟。 时钟已经开启了。 再开一遍不会有任何问题。 但始终没开启外设就不会工作。 如果你认为在RTC初始化里面已经看过了。 外面这条代码我就省掉。 那么待机模式的代码。 就会对RTC代码具有依赖性。 增大了代码之间的耦合性。 没有RTC待机模式就不能正常工作。 现在有RTC代码没问题。 但如果你只有改编程序。 我不用RTC了。 一旦把RTC的代码去掉。 就很可能会引起很隐蔽的bug。 所以该写的代码我们最好还是要写完整。 这是这个注意事项之后进入待机模式。 还是同样的操作。 我们在主循环的最后调用函数。 到PWR点区里找一下。 显然调用这个enter stand by mod就行了。 放到这里参数没有。 那这个函数干了什么活呢。 我们转到定义看一下。 可以看到第一步是清除wake up标志位。 第二步是选择stand by模式。 实际上就是把PDD之1PDDS为一。 表示进入待机模式对吧。 第三步是sleep deep之一。 进入深度睡眠。 然后这个不用看。 最后一步调用WFI指令进入待机模式。 可以看到对于待机模式。 其实并没有区分WFI和WFE跨入。 这里也不能选择统一。 都调用的是WFI。 这一点也不难理解啊。 WFI和WF1的区别就是唤醒方式的不同。 看一下PPT。 对于待机模式。 它的唤醒条件是指定的四个信号。 没有对中断唤醒和事件唤醒做出区分。 所以我们就也不用区分了哈。 直接理解为调用WIFI进入待机。 然后这四个信号都能唤醒就行了。 好这里函数内部的功能我们就清楚了。 接下来我们进行测试下载看一下。 复位可以看到复位后让你闪烁一次进入待机。 但这时CNT也不会刷新了哈。 然后等一等。 过一会闹钟触发待机模式。 唤醒身体和闹钟值刷新一下。 让你闪烁一次。 这是目前程序的现象。 并且每次唤醒之后。 闹钟值都重新设定。 通过这一现象。 我们可以确定待机模式唤醒后。 程序是从头开始执行的。 因为我们闹钟设定的代码在while循环之前。 如果程序不是从头开始的。 那闹钟值也不会更新对吧。 然后再进入待机模式之后。 高速时钟也都会关闭。 在退出待机模式时。 程序从头开始执行。 在程序刚开始的时候自动调用system it初始化时钟。 所以代理模式我们就不用像停止模式那样。 自己调用CSAMGTA。 另外在执行完这个函数进入待机模式之后。 这个函数之后的代码就再也执行不到了。 因为待机模式退出程序从头开始执行到这里。 它就会代理下次继续从头开始。 所以待机模式之后的代码执行不到。 并且这个while循环。 实际上也只有执行一遍的机会啊。 把这个while循环去掉也是可以的。 那最后待机模式对标的是极度省电。 光STM32自己一个省电。 那也不行。 所以一般在进入待机模式之前。 我们都要尽可能的把外部挂载模块都关掉。 你要说我STM32代机的外面。 还有个显示屏在显示。 或者外面还有一个电机在嗡嗡的转。 外挂模块的耗电远超SM3本身。 这时再给STM32代机不管外部模块的话。 那不就是捡了芝麻丢了西瓜了吗。 所以STF12进入待机模式之前。 一定要把外部接的模块。 能停的都停掉。 能锻炼的都断掉。 这样才能最大化省电。 这个功能需要精心设计硬件电路啊。 可以选一个带有使能端的稳压器来实现。 或者自己设计电路。 把其他模块的供电加个开关。 那程序这里我就简单模拟一下了。 在进入待机模式之前。 来个o r d clear清屏表示一下啊。 当然为了看的清晰一点。 我们再闪烁一个字符串吧。 放在四行九列。 显示个单by显示停留时间给长点哈。 来个一秒。 这样看一下。 复位下载中轴看一下。 敷一下。 最开始显示一些信息。 进入待机ORD清屏。 等待一会儿。 闹钟出发之后唤醒一次。 这是目前程序的现象。 那之后我们还可以测试一下。 wake up引脚唤醒的功能。 这个其实非常简单哈。 我们看一下库函数。 调用这个wake up pin command的。 放到初始化这里参数给个label。 就这一条代码就行了。 那你可能会问目前使用到的GPU。 INTEL需不需要GPU初始化呀。 这个是不需要的哈。 看一下手册。 PWR的计算器描述。 这里写了使人wake up引脚后。 wake up引脚被强制为输入下拉的配置。 所以不用在GPO初始化了。 好这样我们试一下wake up的上升沿能不能唤醒。 待机。 复位下载。 松手看一下we cp引脚默认是下拉的。 引脚悬空就是低电平。 然后我们把这个线插到高电平试一下。 可以看到wake up接高电平的时刻。 待机模式被唤醒了。 当然wake up引脚也不局限于手动。 给DMI外部的模块或者别的传感器信号。 也都可以接过来。 用于唤醒STM32。 就是wake up引脚的唤醒功能。 好到这里。 我们本节的代码就全部演示完成了。 最后的最后我还进行了一个小实验。 就是验证一下待机模式到底。 是不是像手册里说的那样省电。 手册里说待机模式的电流只有三微安左右。 这个是不是真的呢。 为此我进行了测试。 这里我单独找了个板子。 把这个电源供电线正极给剪断。 串联一个万用表测电流。 当然最开始我直接测试哈。 待机模式的电流高达一点多毫安。 远超手册里说的三维啊。 但首先很明显这个电源指示灯肯定是耗电的。 所以我先把这个电源指示灯去掉了。 再测试电流仍然有几百微安。 那说明还有别的东西。 耗电之后。 我就把板子背面的这个LDO稳压器去掉了。 这个LDO虽然我们并没有用到哈。 但这样它就会有电流损耗。 最后去掉电源指示灯和LDO之后。 待机模式的电流就下降了三位元了。 接下来我这里给大家演示一下最后现象。 大家自己就不用再拆板子了。 首先我们改一下程序。 在程序中为了方便测试。 我们把这个时间延长一点。 stand by显示时间给个十秒。 待机号中设置大点100秒。 这样测试一下。 我们先把这个板子下载一下程序啊。 先换到下载程序的t link。 然后复位下载。 松手之后再把这个板子换到测试电路上实验。 加供电看一下。 首先万用表拨到200ma电流档。 可以看到最开始是正常工作的电流。 目前显示是20多毫安。 敷一下。 看看正常工作就是20多毫安。 之后。 等一会等他进入待机。 好这时可以看到供电电流瞬间变为零了。 换到更小的200微安档。 可以看到目前待机的供电电流是3.3。 单位是微安。 这个和手册上的数据基本是一致的了。 这样我们从硬件上也验证了待机模式。 代码的正确性。 另外从这个实验中我们也可以看出。 使用待机模式省电。 一定要想方设法把外部能关的一切。 耗电电路都关掉。 否则你的待机模式就无法做到真正的极度省电。 就是这个实验好。 来到这里。 我们本节课的内容也就全部结束了。 我们下期再见。
46. Hello。 大家好。 欢迎继续观看STM32入门教程。 这一节我们要学习的内容是。 STM32里的看门狗。 S332内置两个看门狗啊。 分别是独立看门狗IWDG和。 窗口看门狗WWDG两者的作用基本相同。 只是侧重点不一样。 那看门狗。 简单来说就是程序运行的一个保障措施。 我们得在程序中定期的喂狗。 如果程序出问题卡死了。 没有在规定的时间里喂狗。 那么看门狗硬件电路就会自动帮我们复位一下。 防止程序长时间卡死啊。 就像是我们写了个程序。 然后突然没动静了。 我们就会习惯性的去按一下复位。 或者说手机啊。 电脑啊卡死不动了。 我们也会习惯性的重启来解决。 那看门狗就是完成这样一个操作的硬件电路。 在程序卡死的情况下。 自动帮我们复位一下好。 然后我们还是先看一下本节程序的现象。 本节一共两个程序。 14杠一独立看门狗和14杠二窗口看门狗。 先看一下独立看门狗的程序啊。 简单看一下程序内容。 程序进来。 首先执行判断。 看一下这个程序。 是因为看门狗复位而从头执行的。 还是因为刚上电或者按复位键而从头执行的。 如果是开门口复位OID。 第二行显示独立开门口RST的字符串。 如果是正常复位OOD。 第三行显示正常IST的字符串。 就这一块是独立开门口初始化设定的。 最大喂狗时间是1000ms。 这样我们在总群管理就得不断的调用这个函数。 执行喂狗。 且胃口的间隔不能超过上面配置的1000ms。 目前喂狗的间隔是200+600=800毫秒。 这样主循环不断运行起来。 独立看门狗就不会自行复位。 最后在这个位置我加入了一个按键获取件码。 在这个函数里面。 我们采用的是主摄氏写法。 由此按键按下不放的话。 程序就会卡死在这个函数。 所以我们把这个函数放到这里。 按下按键不放。 模拟程序卡死的状况。 返回值按键键码暂时不需要。 这样喂狗程序无法及时执行。 独立开门口就会复位。 让程序从头开始执行啊。 那我们下载看一下现象。 复位一下。 这是正常复位。 所以第三行显示正常复位的IST字符串之后。 主循环不断执行。 并在第四行显示fade表示喂狗。 然后我们按上面的按键按住不放。 这时主循环卡死。 第二行就会显示独立开门口。 IST这个复位就是独立看门狗产生的吧。 那这就是独立开门口的程序现象。 简单来说就是如果不及时喂狗程序就会复位。 接着我们来看看第二个程序。 窗口看门狗。 这个窗口看门狗和独立看门狗类似啊。 都是不喂狗就复位。 但是窗口看门狗对喂狗时间要求更严格一些。 它给喂狗时间的窗口。 必须在这个时间窗口内喂狗。 喂狗晚了复位。 喂狗早了也复位。 看一下程序进来。 首先还是判断复位来源是窗口。 看门狗导致的复位。 还是正常上电和复位键的复位之后。 窗口看门狗初始化。 这里设置的喂狗时间窗口是30到50ms。 喂狗的间隔必须在30到50ms之间。 未找未晚都不行。 然后看主训环里这一条是胃口。 程序上面delay的时间间隔是2020。 等于40ms。 目前的间隔位于时间窗口内。 然后获取件码还是模拟程序。 卡死啊。 这个程序下载看一下。 首先还是正常复位。 第三行显示正常的IST。 之后主循环第三行一直闪烁。 fade表示喂狗。 然后按上面的按键程序开始没有及时喂狗。 这样第二行就会显示窗口。 看门狗产生复围栏。 当然按按键只能模拟晚喂狗哈。 找尾狗也会复位。 这个现象我们写程序的时候再来演示吧。 好程序现象就演示到这里。 看完这两个代码的演示。 希望大家对开门口已经了解的大差不差了吧。 其实看门狗也不是很复杂。 就是个自动复位电路对吧。 那接下来看一下PPT。 先看一下看门狗的简介。 首先看门狗。 英文是watch dog。 简称WDG。 它的作用顾名思义就是看大门。 不过这里的大门表示的是程序。 所以第二条看门狗可以监视程序的运行状态。 当程序因为设计漏洞。 硬件故障。 电磁干扰等原因出现卡死或跑回现象时。 看门狗能及时复位程序。 避免程序陷入长时间的罢工状态。 保证系统的可靠性和安全性。 那写过程序代码的都知道哈。 程序的设计是非常讲究逻辑的。 每一种可能。 每一种状态都要在写程序的时候预先注意到。 否则一旦出现了程序没有预料到的情况。 程序经常就会出现卡死跑飞胡乱运行的状况。 这一点在我们当前这些简单的测试程序中。 还很少出现啊。 因为这些程序其实并不复杂。 任务也很简单。 但是对于一些大型项目。 各种状态和可能都是非常非常多的。 在写程序的时候。 一不小心就会留下bug。 或者说在大型项目中。 bug根本无法避免。 因为可能的状态太多了。 总有那么些意想不到的情况发生。 让你的程序卡死或崩溃。 那解决办法呢。 第一就是我们程序员要有丰富的经验。 避免一些常见的bug。 第二就是程序要经常迭代。 发现bug后及时修补。 第三就是我们的看门狗了。 出现卡死崩溃现象后。 帮我们按下复位。 虽然说不能解决bug本身吧。 但是也可以极大的提高程序的健壮性。 因为很多bug都是偶然发生的。 简单的复位一下。 就会有很大概率让程序走向正轨啊。 那在我这里写的除了程序本身的设计漏洞呢。 还会有硬件故障。 电磁干扰等原因让程序出问题。 比如硬件故障。 我们想读取传感器的数据。 结果传感器坏了总是死等。 那程序不就卡死了吗。 电磁干扰这个一般出现在恶劣的环境中啊。 我们都知道很强的电磁干扰。 可能会让这些电子元件失灵。 由是程序跑飞的现象。 程序不知道跑到哪个奇怪的地方了。 那假设你的设备遇到了一阵强电磁干扰。 有看门狗的话。 干扰过后。 程序复位回到正轨。 没有看门狗的话可能受到干扰。 程序就永远卡死在某个地方了对吧。 所以出现状况时。 我们需要看门狗及时复位程序。 避免程序陷入长时间的罢工状态。 最后再说两点啊。 一个是对于硬件故障。 如果是关键的设备故障。 复位也没用的话。 那开门口也无法力挽狂澜。 因为开门口就是简单的复位一下。 第二个是对于程序设计漏洞。 这里主要针对的是无法预料的漏洞。 而不是说我有看门狗了。 我就在程序中写大量的死循环或者不规划程序。 到处跳来跳去。 然后卡死了。 就用看门狗来托底。 这样空白不太好啊。 合理规划程序是第一。 然后可以预料的漏洞。 尽量直接写好处理方法。 最后才是看门狗托底。 这样才是比较好的思路。 接着看下一条。 看门狗本质上是一个定时器。 当指定时间范围内程序没有执行喂狗操作时。 喂狗就是重置记录器啊。 看门狗硬件电路就自动产生复位信号。 这里说的就是看门狗的工作逻辑了。 看门狗其实就是定时器。 看一下结构。 它的结构和定时器是非常相似的哈。 只不过是定时器溢出产生中断。 而看门狗定时器溢出直接产生复位信号。 然后喂狗操作其实也就是重置这个计数器。 这是一个递减计数器。 减到零之后就复位。 那程序正常运行时。 为了避免复位。 就得在这个计数器减到零之前。 及时把记录值加大点对吧。 这个操作就是喂狗。 如果你程序卡死了。 没有及时加大这个机器。 那减到零之后就自动复位了。 就是看门狗的工作逻辑是不是也不难啊。 就这一条。 就刚才说过的STM32内置有两个看门狗。 一个是独立看门狗。 它的特点就是独立运行。 对时间精度要求较低。 独立运行就是独立开门口的时钟是专用的。 LSI内部低速时钟。 即使主食中出现问题了。 看门狗也能正常工作。 这也是独立开门口独立的得名原因。 对时间精度要求较低。 就是独立开门口只有一个最晚时间界限。 你胃口间隔只要不超过这个最晚接线就行了。 你说很快的喂。 疯狂的喂。 连续不断的喂。 那都没问题。 之后另一个是窗口看门狗。 它相比较独立看门狗就严格一些了。 要求看门狗在精确计时窗口起作用。 意思就是喂狗的时间有个最晚的界限。 也有个最早的界限。 必须在这个界限的窗口内喂狗。 这是窗口开门口窗口的得名原因。 因为对于独立看门狗来说。 可能程序就卡死在喂狗的部分了。 或者程序跑飞。 但是喂狗代码也意外执行了。 或者程序有时候很快喂狗。 有时候又比较慢喂狗。 那这些状态独立看门狗就检测不到了。 但是窗口看门狗是可以检测到这些问题的。 因为它对喂狗的时间窗口可以卡的很死。 快了慢了都不行。 最后窗口开门口使用的是APP1的时钟。 它没有专用的时钟。 所以不算是独立好。 这些就是看门狗的基本介绍了。 接下来先看一下独立看门狗。 看下光图案。 这个框图大家可以类比定时器的实际单元来看。 我们看一下定时器。 这一块是实际单元。 实际单元由预分频器。 计数器和重装载进容器组成。 左边是舒适中。 比如这里是72兆。 首先用过分屏。 比如现在二分屏。 那么计数器的驱动时钟就是72兆。 除二等于36兆。 这个计数器可以自增。 也可以自检。 看门狗使用的是质检运行啊。 那质检到零后。 定时器产生更新事件和中断。 而看门狗是直接产生复位。 另外重装纸啊。 定时器是在更新事件重装。 而看门狗需要我们在质检到零之前手动重装。 因为减到零就复位了对吧。 正常运行情况下。 肯定是不能让他减到零的。 那这个手动重装进游戏的操作就是喂狗。 看完了定时器。 接着来看这个独立看门狗。 这一块是预分频器。 这一块是计数器。 这一块是重装机容器。 这基本就是一样的结构哈。 那预分频器之前数时钟是LSI内部低速时钟。 时钟频率为四十千赫兹。 之后时钟进入预分频器进行分屏。 这个预分频器只有八位。 所以它最大只能进行256分屏啊。 上面这个预分频进行器。 IWDGPR可以配置分频系数。 这个pr和定时器的PSC是一个意思。 他们都是PRESCOTT的缩写。 可能不是一个人设计的。 所以这手册里很多缩写都不太一样。 不过大家要知道他们其实是一个意思。 这后面经过预分配器分屏之后。 时钟驱动递减。 旧器每来一个时钟只减一个数。 另外这个旧器是12位的。 所以最大值是二的12次方。 减一等于4095。 然后当质检到零之后。 产生IW gt复位。 正常运行时。 为了避免复位呢。 我们可以提前在重装进容器写个值。 IWDGIR和定时器的ARR是一样的。 ILR是reload。 AR是auto reload。 那当我们预先写好值之后。 在运行过程中。 我们在这个间接容器里写个特定数据控制电路。 进行喂狗。 这时重装值就会复制到当前的旧武器中。 这样接收器就会回到重装值。 重新自检运行了。 然后这里有个状态进器。 SR就是标志电路运行的状态了。 其实这个SR里没什么东西。 就只有两个更新。 同部位基本不用看。 最后上面这些计算器位于1.8伏供电区。 下面主要的工作电路都位于VDD供电区。 所以这下面写了看门狗功能处于v dd供电区。 即在停机和待机模式时仍能正常工作。 上届我们也说过哈。 独立开门口也是唤醒待机模式的四个条件之一。 这个还有影响吧。 那有关独立开门口的框图。 我们就看到这里。 接下来我们再介绍这个间接用器。 这个东西我们之前没见过啊。 它有什么用呢。 看一下下一页。 第一条。 间接控器本质上是控制进器。 用于控制硬件电路的工作。 比如我们刚才说的喂狗操作。 就是通过在键接容器写入0XAAAA完成的。 那为什么要用间接容器呢。 我直接定义一个控制就容器。 其中再定义一个位。 这一位写入一就喂狗。 这样不也行吗。 我们继续看第二条。 在可能存在干扰的情况下。 一般通过在整个间接容器写入特定值来代替。 控制电容器写入移位的功能。 以降低硬件电路受到干扰的概率。 为什么能降低干扰呢。 你看独立看门狗工作的环境是什么啊。 是程序可能跑飞。 可能受到电磁干扰。 程序做出任何操作都是有可能的。 如果你只在计算器中设置一个V。 那这一位就有可能在误操作中变成一。 或者变成零。 这个概率是比较大的。 所以单独设置移位就来执行控制。 在这里比较危险。 这时我们就可以通过。 在整个计算器写入一个特定值来代替。 写入一个位的操作。 比如这里间接容器是16位的。 只有在间接容器写入0XAAA这个特定的数。 才会执行未构的操作。 这样就会降低误操作的概率。 比如这次程序跑飞胡乱地设置各个机用器件。 接用器也受到了影响。 它可能会变成000。 0FFFF1234等等等等。 它可以随机变为任何数。 但是它恰好变为零。 XAAA这个数概率是非常小的。 就像是个密码一样。 只有输对密码才能执行功能。 所以下次一般是试不出来的。 另外我们也可以看出来。 这些密码都设置的很标准。 cc cc是1100110010011。 零。 零是101010101010。 10105555401。 0101010101。 0101都是一零交替混合的键值。 那看一下键值和作用呢。 在建计算器写入0XCC。 CC表示启用独立开门口。 写入NEXA表示I2中的值重新加载了计数器。 就是喂狗。 写入0X55表示解除pr和2R的写保护。 然后写入五五之外的值。 就启用pr和LR的写保护。 最后两条是写保护的逻辑啊。 意思就是执行指令必须写入指定的键值。 所以指令抗干扰能力是很强的。 但这里还有pr sr和RLR3个净水器。 他们也要有防止误操作的功能。 SIS组图的这个不用保护。 剩下的对pr和RLR的写操作。 可以设置一个写保护措施。 然后只有在间接用系写入5555。 才能解除写保护。 一旦写出其他值。 pr和RRR再次被保护。 这样pr和RLR就跟随舰接容器一起。 被保护了起来。 防止误操作。 这是间接器设计的用途。 接着看一下独立开门口的超时时间啊。 由是定时期的一书时间。 这里有个公式。 超时时间T等于TLSI乘pr。 预分频系数乘2L加一。 其中TLSI等于fl si分之一。 这个公式用的是时间计算啊。 你用频率计算也是一样的。 超市频率就等于LOSI的频率。 除以分屏除重装值。 对应定时器的话就是72兆。 除PSC加一除A21。 这是异曲同工对吧。 那这里通过时间计算呢。 就这样来理解。 LSI是输入时钟四十千赫兹。 FLOSI就是40K。 TLSI就是周期等于40K分之一。 计算器算一下哈。 140K等于0.025ms。 所以这里是0.025ms。 每隔0.025ms来一个输入时钟。 最后输入时钟进行分屏。 相当于计数时间加倍加多少倍呢。 下面一个pr定器和分频系数的对应关系。 这里并不是pr写几就是几加一分屏啊。 它只有这几个固定的分频系数。 比如pr写作二。 那就是16分屏。 对应这里计数时间就要乘16。 最后L就是L啊。 技术目标乘个2L加一就是最终的超时时间了。 比如IL给个99。 那这样式子里的各部分值都确定好了对吧。 计算一下0.025ms乘16100值。 大家自己算一下。 这是当前这些参数下的超时时间。 那下面这个表里。 各个参数的最短时间和最长时间。 为什么是这样子。 大家就知道了吧。 比如第一行pr先用临时一分平为四。 这里是4TLSI是固定的0.025ms。 这段时间2L给零。 这里2L加一是一零点025ms。 乘4×1=0.1毫秒。 对应表里的这个0.1ms。 最长时间2L给最大的0XFFFG4095。 这里RL加一是4096。 0.02ms乘44096。 等于409.6ms。 对应表里的这个409.6ms之后的。 都是类似的计算方法。 比如pr给一一分明系数为八。 那整体上来看。 最短时间和最长时间都是上面的二倍对吧。 下面分频系数每次变为二倍。 时间也都逐渐二倍递增。 这是独立看门狗超时时间的计算。 简单来说和定时器定时时间的计算是一样的哈。 好那到这里我们独立开门口的内容就讲完了。 其中包括硬件电路如何工作啊。 如何通过建接容器去控制电路运行。 和如何写入pr和RL计算器来确定超时时间。 就是独立看门狗。 那接下来我们就进入窗口看门狗的学习窗口。 看门狗从功能上来说。 和独立看门狗还是比较像的。 大体上来看只是比独立看门狗多。 那个最早喂狗时间的限制。 但是等会儿学的时候。 你就会发现啊。 这个窗口看门狗。 无论是框图的设计。 还是计容器的分布和命名规则。 或者程序的操作流程。 和独立看门狗都不是一个思路。 可能是两个看门狗侧重点不一样吧。 当然我感觉应该还是。 因为这两个外设不是同一个人设计的。 所以设计的思路有所不同。 这个大家先有个准备啊。 那我们看一下框图。 这是窗口开门口的结构。 左下角是时钟源部分。 这个时钟源是PCLK1。 右边这个是预分频器。 它这个预分频器名字又变了哈。 叫WDGTB。 实际上和独立开门口的PRD时期的PSC。 都是一个东西。 上面这个是六位地点注入器。 CNT这个计数器是位于控制计算器CR里的。 计数器和控制计算器合二为一了。 然后窗户开门口没有桶装净水器。 那如何重装计数器进喂狗呢。 这个我们直接在CNT写个数据就行了。 想写多少就写多少。 这上面这一块是窗口值。 由此喂狗的最早时间界限就写到这里存起来。 最后左边就是输出信号的操作逻辑的。 什么情况下会产生复位。 就这几个逻辑门来确定好。 在这个框图的大体结构可以分为这几部分之后。 我们来详细看一下它的工作流程。 首先还是从左下角开始看。 时钟来源是PCLK1。 由是app1的时钟。 这个始终默认是36兆赫兹啊。 所以就是36兆的时钟进来进来之后。 还是先经过一个音分频器进分屏。 这个和独立开幕的预分频器。 定时器的预分频器都是一个作用。 就是灵活的调节后面计数器的时钟频率。 同时预分频系数也是计算计数器溢出时间。 的重要参数啊。 那接着分屏之后的。 始终驱动这个计数器进行计数。 这个计数器和独立看门狗一样。 也是一个递减计数器。 每来一个时钟自检一次。 不过这个计数器比较特殊哈。 从图上来看。 这里写了T6到T0。 总共是七个位。 但下面却写的是六位递减计数器。 这是为什么呢。 那这其实是因为这个计数器只有T5到T0。 这六位是有效的。 就值最高位T6。 这里用来当做溢出标志位。 第六位等于一时。 表示计数器每溢出T6位等于零时。 表示计数器溢出。 不过对于硬件电路来说。 T6位其实也是旧系的一部分。 只不过是T6位被单独拎出来。 当做标志位了而已。 举个例子啊。 比这个计数器初始值。 我们给1111111。 那么来一个技术脉冲。 只减一变为1111110。 再来一个变为1111101。 以此类推啊。 不断自检。 直到减为1000000。 好讲到这个数值是一个关键节点。 此时包括T6位在内的数是1000000。 转为16进制是0X40。 连个四零要特别记一下。 等会儿还会用到。 也就是说。 此时如果把T6位也当做计数器的一部分。 那计数器的值实际上才减一半对吧。 但是如果我们把T6位剥离出去。 当作溢出标志位。 第六位当作直有器。 那此时的状态就是标志位为一。 就气为零。 00000已经减到零了。 再点一次。 下一个值是什么呢。 就是0111111。 这时最高位T6由一变为零。 即代表救济溢出。 这时最高位T6就会通过这个线路。 产生复位信号。 就是这个计数器的工作流程和溢出条件。 总结一下。 就是如果你把T6尾看作是计数器的一部分。 那要是整个计数器只减到0X40之后移出。 而如果你把T6位当成溢出标志位。 第六位当做旧器。 那就是第六位的旧值减到零之后溢出。 这一点尤其要搞清楚啊。 因为我们后面还会多次提到。 并且它的描述。 有时候是把T6V和旧游戏当做一个整体。 有时候又是把T6位给拎出来的。 所以这里一定要理解清楚。 要不然等会儿就搞迷糊了。 好计数器的部分我就讲完了。 这要看左边的复位信号输出部分。 首先这个WDGA是窗口看门狗的激活位。 由是使人WDGA写入一启用窗口看门狗。 使人为作用于这个语文啊。 语文的这种连接方式。 我们之前遇到很多次了吧。 它的作用就类似于一个开关。 左边是控制信号。 右边是输入。 右边是输出。 控制信号给一则输出等于输入开关。 导通控制信号给零。 则输出等于零。 与输入无关。 开关断开。 那开关右边就是一星二的来源了。 这里有两个来源。 用后面连接优势的两个来源。 任意一个都可以复位。 请问下面这一路来源于一除标志位T6。 但就是一初始T6等于零。 然后输入进来。 这里输入有个小圆圈。 二代表输入取反。 所以零变为一或能有效输出一。 到最后这个死人位给一开启开门口后。 这个一出信号就直接通向复位了。 所以下面这一路意思就是T6位一旦等于零。 就代表就由器一出就产生复位信号。 那叫程序正常运行状态下。 我们必须始终保证T6位为一。 这样才能避免复位好。 至此。 下面这一块实现的功能和独立开门口。 基本是一样的。 如果不及时喂狗。 六位的计数器减到零后就产生复位。 接下来未稿的时间的最早接线。 由上面这一块来实现。 首先我们要计算一个最早接线的计数值。 写到这里的W6到W0中再值。 写入之后是固定不变的。 在这里一旦我们执行写入CR操作时。 这个语门开关就会打开。 写入C啊。 其实就是写入计数器。 也就是胃口。 在胃口时。 这个比较器开始工作。 一旦它比较我们当前的计数器。 T6到零大于窗口值W6到零。 比较结果就等于一。 这个一通过或门也可以去申请复位。 这是喂狗最早时间窗口的实现流程。 就是喂狗的时候。 我把当前记录值和预设的窗口值进行比较。 如果发现你的狗鱼粮还非常充足。 你喂的这么频繁。 那肯定是有问题啊。 我要给你敷一下。 不让你喂太早了。 那这就是窗户开门口的全部内容了。 胃口太晚。 六位旧器减到零了。 复位胃口太早。 就气的值超过窗口值的复位。 这是窗口看门狗那结构。 看完我们继续看下一页。 这是窗口看门狗的工作特性。 通过刚才的讲解。 这应该就很好理解了。 第一条递减就系T6到零的值小于零。 注意这里写的是T6到零。 包含T6尾。 所以是只减到零。 X40之后再减一次就负A。 第二条递减接收器T6到零。 在窗口W6到零Y被重新装载时。 WWDG才能复位。 就是不能过早位。 置完就下一条。 这是一个新的知识点。 D减周期T6到零等于零。 X40时可以产生早期唤醒中断。 EWI用于桶装机器。 以避免WWD复位。 注意这里是等于零。 X0时可以产生一个早期中断。 上面是小于零。 X0时产生复位040。 这时T6还是一还没有移除。 再减一个数变为0X3F了。 才是一出。 所以说这里的意思就是。 减到0X40时产生中断。 然后再减一个数到0X3F时产生负A。 那这样这个中断其实就是在溢出的前一刻发生。 对吧。 所以这个中断也可以称作史前中断。 马上就要溢出复位了。 再提醒一下你要不要干点啥。 所以在这个早期唤醒中那里。 我们一般可以用来执行一些紧急操作。 比如保存重要数据。 关闭危险设备等等。 或者还有一种写法。 就虽然超时喂狗了。 但是我们可以在中断里执行一些代码。 经解决。 或者这个任务不是很危险。 测试呢我就只想做一些提示。 不想让他复位了。 这样的话我们就可以在这个早期唤醒中断里。 直接执行喂狗。 阻止系统复位。 然后提示一下信息就完事儿了。 这样也是一种思路。 然后最后一条定期写入CR计数器进喂狗。 以避免WWDG复位。 这个刚才也说过。 最后看一下下面这个工作示意图。 纵轴是T6到零。 包含T6位的CNTD卷轴器。 喂狗之后。 在这个数值往下递减。 如果这个技术值还很大。 高于这个W6到零窗口值了。 你又不能急着喂狗。 也是在这一块是不允许刷新的。 之后当几乎值小于窗口值啦。 进入的刷新窗口可以喂狗。 当然喂狗也不能太晚啊。 要再减到3F之前位。 sf这个值就是T6位刚等于零的时刻。 所以下面这里T6位在这个时刻变为零。 同时-1200也在这个时刻产生。 就是这个示意图展示的内容我们就清楚了。 大家看下面一页。 我们来看一下窗口。 看门口的超市时间计算。 这里有两个公式。 超时时间就是喂狗的最晚时间。 窗口时间就是喂狗的最早时间。 先看一下超时时间。 这个和刚才独立开门口的基本一样。 超时时间。 TWWDG等于TPC2K14096。 乘WDGTB预分频系数乘T5到01。 其中TPC2K一等于FPC2K11。 这里要多乘一个4096。 是因为这里PCLK1进来之后。 其实是先执行了一个固定的4096分屏。 这里框图没画出来啊。 实际上是有的。 因为36兆的频率还是太快了。 先来个固定分屏给降一降。 所以到这里公式计算。 我们直接多乘一个4096就行了。 然后w dd tb1分明系数。 这里我直接写的是分明系数啊。 w d d tb的值和分配系数之间的关系。 看下面图里的这个公式。 就是分频系数等于二的WDGTB次方。 在对应这个表。 当WDGTB等于零时。 就是一分屏。 WDGTB等于一。 就是二分米。 WDGTB等于二。 就是四分米。 WDGTB等于三。 就是八分米。 分配系数只有这四种选择。 如果在表里左边补上这么一列分别系数。 那这个表是不是就和刚才独立开门口。 这里是一样的啦。 这是金属性的值和分配系数的对应关系。 最后再看计数器。 这里写的是T5到零。 这个一定要注意。 刚才我们写的都是T6到零。 包含T6位。 而这里计算公式里是T5到零。 是不包含T6V的。 这样的话T5到零就是减到零后溢出。 所以超时时间的公式。 直接把T5到零拿来计算就行了。 这是超时时间的公式。 之后再看窗口时间。 这个公式手册里并没有给出啊。 不过在这里我要给大家总结出来。 就是t window等于TPC2K14。 096乘WDGTB与分泌系数乘T5到零。 减去W5到零。 这个和上面差不多。 主要区别就是后面这里。 上面这个超时时间是计数器减到零的时间。 而这个是计数器减了窗口指的时间。 所以我们拿T5到零。 减W5到零就可以算出创作时间了。 同时也要注意。 这个W5到零也是不包含W6这一位的。 然后上面这里从这里可以看出。 旧器等于窗口值时就已经可以喂狗了。 所以这里公式后面就不用再加一了。 这是窗口时间的公式。 最后看下面这个图。 其中超时时间的公式和上面这个一样。 拿下面这个表的时间怎么得到的。 和上面独立开门口哪里类似啊。 比如WDGTB等于零。 分明系数为一。 概率公式。 这里就是一。 然后TP上2K1是36兆分之一。 当计数器给最小值零时。 得到下面这个最小超时时间。 当计数器给最大值时。 六位的计数器最大值是二的六次方。 减一等于六三。 这样计算得到下面这个最大超时时间。 用计算器演示一下。 先1÷36000。 得到周期是这个数单位是毫秒啊。 然后乘4096。 再乘一。 得到这个时间。 当T等于零时。 T加一等于一。 再乘一。 最小时间就是这个0.13ms。 和比亚迪的一样。 当T等于六三十。 T加一等于64。 再乘六四。 最大时间就这个7.28ms。 和表里的这个一样。 这是表里数据的计算方法。 然后下面都是同样的。 也有规律。 分别系数逐渐二倍递增。 最小时间和最大时间也都是二倍递增。 就是这个表里的操作时间。 然后窗口时间手册里并没有给表和数值。 但按照这个公式套进去计算就行。 一般我们先确定超时时间。 确定T的值。 然后再计算窗口时间。 就很划算了。 对吧好。 这是窗口camera的全部内容。 最后我们总结一下这两个看门狗的差别。 看这个表。 第一位方面独立开门口就由器减到零后。 复位窗口开门口就由器T5到零。 减到零后和过载重装机器。 第二中单方面独立看门狗没有窗口。 开门口有一个早期唤醒中断。 第三时钟源独立看门狗使用40K的LSI窗口。 看门狗使用36兆的PCLK1。 第四一分米系数的选择。 独立看门狗从4~256。 总共六种选择。 窗口看门狗12484种选择。 第五计数器的位数。 独立看门狗12位比较多。 窗口看门狗有效进入的只有六位。 比较少啊。 第六超时时间的范围独立。 他们狗时终又慢。 分屏又大。 就气位数越多。 自然时间就大一些。 是0.1ms到26秒多。 窗口看门狗时钟快。 分屏小。 救器位数少。 所以时间就比较小。 是113微秒到58.5ms。 第七胃口方式。 独立看门狗是在建接收器写入喂狗指令。 然后LR的固定值重装到计数器窗户。 chemical是直接写入接收器。 写多少。 重装多少。 第八防护操作方面。 独立看门狗有鉴定器和谐保护。 基本很难受到干扰。 窗口ram go并没有这个设计。 最后一个用途还是我们最开始写的。 独立开门口一般用于独立工作。 对时间精度要求较低的场合。 窗口看门狗一般用于要求开门口。 在精确技术窗口起重的场合。 对于用途来说。 我觉得大多数场景用独立看门狗就已经足够了。 因为大部分情况下。 我们想要的功能就简单的程序卡死或跑飞了。 帮我敷一下就行。 当你有更高的需求时。 再考虑用窗口m go好到这里。 我们PPP的内容就讲完了。 接下来我们还是过一遍手册。 本节的内容主要涉及手册里的第17章。 独立看门狗和第18章窗口看门狗。 依次看一下。 独立看门狗。 上面是一些简介。 主要性能和功能描述。 这些我们刚才都介绍过啊。 然后这个硬件看门狗。 如果用户在选择字节中。 就选项字节启用了硬件看门狗功能。 在系统上电复位后。 看门狗会自动开始运行。 意思就是上电自启动。 可以防止你程序在开启开门口之前就失效了。 会更加安全一些。 那这个配置需要在选项字节里进行再进器保护。 写作。 555进行保护。 防止误操作。 这是独立开门口的框图和这个超时时间表。 这个我刚才详细分析过来。 然后这里有个注意思。 就是这个内部的事实可以。 时钟它其实并不是很精确。 会在30K到60K之间变化。 所以我们在计算这个超时时间时。 不要卡的太死。 要给这些变化多留一些余量。 最后就是计算器描述建计容器。 这里是一些键值和它对应的指令。 另外可以看到啊。 这里只有启动看门狗的指令。 没有关闭看门狗的。 实际上无论是独立看门狗还是窗口。 看门狗一旦启用就无法关闭了。 这样可以防止误操作。 就给它关了。 更安全一些。 既然养狗了。 怎么会让你随便弃养呢是吧。 这是这个设计。 然后预分频计数器重装载机容器状态寄存器。 这样看着都比较简单了吧。 然后计算器就完了。 另外可以注意到这个开门口的CNT计数器。 他并没有提供给我们进行读写啊。 所以开门口运行的时候。 内部就系寄到哪个值。 我们是不知道的。 这个对于调试和观察实验现象来说。 可能不太友好。 不过影响也不大。 这是独立看门狗的部分。 接下来看窗口看门狗简介。 主要特性大家自己看这个框图。 我们也详细分析过。 最后是一些介绍。 这里也有一句话。 在系统复位后。 看门狗总是处于关闭状态。 设置WWDGCR进器的WDGA位能够开启。 看门狗。 随后他不能再被关闭。 除非发生复位窗口。 开门口也是开大。 就不能随便关了。 除非复位。 然后下面递减制由器。 递减机由器处于自由运行状态。 即使开门口被禁止递减接收器仍继续递减计数。 当开门口被启用时。 提列位必须被设置。 以防止立即产生一个复位。 也是我们在开启的时候。 一定要首次给个重装值。 并且提留位给一。 以。 防止开的时候立刻就复位了。 然后下面还有一些描述。 大家自己看都是这个图和这个表计算公式。 我们也都见过。 最后就是计算器描述了。 第一个是控制计算器。 WDGA是激活位。 后面T6到零。 他这里写的是七位及器。 但实际上T6位是标志位。 第六位才是有效及物质。 然后这里为什么这个计数器。 非要和控制计算器挤在一起呢。 个人推测可能是未来战开启。 看门狗和重装机容器能同时进行吧。 这个配置容器里面是中断配置。 预算比配置和窗口值。 最后是状态计算器。 然后就是计算器总表了。 整体上来看。 手册里对chemical的描述都不是很多啊。 大家可以再仔细看一遍。 好本。 下节课到这里就结束了。
47. 大家好。 欢迎回来。 这一小节我们来学习看门狗的代码部分。 那还是先看一下经验图。 打开14杠一的图片。 这两个看门狗代码的接线都非常简单哈。 这里右下角接个ORD用于显示。 然后上面PB1口接一个按键。 用于阻塞喂狗。 这样就行了。 然后下一个窗口开门口的接线也是一样的。 就是经验图。 然后看一下面包板。 这里我已经提前接好了。 右下角是OID显示屏。 然后再在PB1口接个按键就行了。 就是硬件接线部分好之后。 回到工程文件夹。 复制一下OLED显示屏的工程。 改个名字叫14杠。 一独立看门狗。 打开工程。 再删掉。 然后编译一下。 那接下来我们就在这个工程的基础上。 来测试独立看门狗的功能。 对于看门狗的部分代码也不是很多啊。 所以我们也不单独建模块了。 直接在转述里写就行。 然后回到PPT。 根据我们上小节的知识点。 我们总结一下独立看门狗的配置流程。 首先看一下这个框图。 从左到右。 第一步应该就是开启时钟了吧。 只有这个LSI始终开启了独立看门狗才能运行。 所以初始化独立开门口之前。 LSI必须得开启。 但是这个开启LOSI的代码。 并不需要我们来写。 为什么呢。 我们看一下手册。 在第六章6.2时钟。 6.2.9。 看门狗时钟这个地方隐藏比较深啊。 在这里有一句话写的是。 如果独立看门狗已经由硬件选项或软件启动。 并且不能被关闭。 始终供应给IWDG。 这个意思就是说如果我们开启了独立看门狗。 那么LRSI就会跟随强制打开。 等LSI稳定后。 就可以自动为独立看门狗提供时钟了。 所以我们这里的第一步开启LSI的。 始终就不需要我们再写代码来执行了。 那接着我们直接进入下一步。 继续往右。 下一步我们就是写入密封容器和重装进容器了。 当然在写入这两个计数器之前啊。 不要忘了这里的写保护。 首先写出这个键值。 解除写保护。 然后再写入一分屏和重装值。 所以这里的第二步就是解除写保护。 随后第三步是写入预分屏和重装值。 预分频和中高值具体写入多少呢。 我们可以通过这里的超时时间公式来计算。 最后当这些配置工作做完之后。 我们就可以执行这条指令来启动独立看门狗了。 然后在主循环里。 我们可以不断执行这条指令来进行喂狗。 这是独立看门狗的配置流程。 接下来我们回到代码。 看一下。 我们这些操作都对应库函数里的哪些函数吧。 那我们找到IWDG点。 去看一下最后面的函数声明。 独立看门狗总共有这么些函数。 啊啊这是非常简单的。 第一个IW d g write access command。 就是写死难控制。 可以转到第一看一下。 可以看到写死人的操作。 就是在间接容器写入这个参数。 这个参数可以是enable或disable。 再转的定义可以看到你label就是0X555。 disable就是0X0000。 这一点是不是对应我们PPT的。 这里间接用器写入555就是解除写保护。 写势能。 写入其他值。 比如0000就是启用写保护写诗能。 所以这里第一个函数我们就清楚了。 第二继续看IW d g set precode。 写预分频器。 I w d g set reload。 写重装值。 这两个也非常简单简单。 第一看一下。 写预分频器就写pr定器。 写重装值就写入RLR进器。 对应PPT就写入这两个计数器。 最后继续IW d g reload counter。 重新装载自容器。 就是WI狗。 专家定义它的操作就是在间接容器写入这个值。 这个值转到定义。 可以看到就是0XAA。 正好也是对应我们PPT里的这条喂狗的操作。 然后继续看IW d g e label。 启动独立cam go这个函数执行了什么操作。 想必大家不用看就已经知道吧。 转到第一看一下。 他就是在间接容器写入这个值。 这个值就是0XCCCC。 对应我们PPT的这个地方。 然后函数最后一个获取标志位状态。 这个就不用多说了。 好以上就是独立看门狗的全部函数。 整体上来看都是非常简单的吧。 然后除了这里的函数。 我们还要看一个RCC里的函数。 就之前示例代码解释的。 我们想知道程序复位的时候。 它是看门狗导致的复位。 还是上电或复位键导致的复位呀。 这个判断可以通过SC里的一个标志位来实现。 那么打开cc点去看一下函数。 我们需要用到这个查看标志位的函数。 然后查看完标志位。 不要忘了再调用下面这个函数清除一下。 那转到这个的定义。 看一下这个ICC标志位可以查看哪些事件呢。 看一下参数。 ISA标志位对应的事件主要分为两种。 一种是HSIHSE等等啊。 这些时钟的ready就是判断时钟是不是准备好了。 这个功能我们在RTC大姐开启时钟的时候。 是不是就用过。 接着另一种就是各种reset标注为。 其中P1reset就是按复位键复位的时候。 会质疑PORPDI。 就是上一节讲的上电复位和掉电复位。 software是软件复位。 Independent。 watchdog是独立看门狗复位。 window watchdog是窗口chemical复位。 最后一个是低功耗的复位。 那我们本节主要会查看这两个。 独立开门口和窗口看门狗的复位标志位。 以此来判断这个复位到底是不是看门狗引起的。 所以这个函数大家先了解一下。 好到这里库函数我们就看完了。 接下来开始写代码。 那在初始化独立开门口之前。 我们先把前面的准备工作完成一下。 首先先来个2D修string。 一行一列显示IW dj test这条代码就写的完了。 指示一下。 这是独立看门狗的测试程序。 然后我们使用一下i cc查看标注位的函数。 区分一下独立看门口的复位和普通的复位啊。 方便观察现象。 这里我们可以调用刚才说的ACC。 获取标志位的函数放在这里。 只有一个参数啊。 转到第一看一下。 我们需要使用这个参数。 Acc flag i w d g i s t。 查看一下独立开门口复位的标志位。 参数放在这里。 返回值是set或者set。 所以我们套个if。 如果查看独立看门狗复位标志位等于等于set。 那说明本次复位是独立开门口导致的。 否则else那说明这只是一次普通的辅音。 然后标志位置一之后。 在if里面别忘了再清除一下标志位啊。 所以我们调用刚才说的这个clear flag。 放到这里。 参数没有啊。 这里必须要清除标志位。 因为根据实测。 这个标志位即使按下复位键也不会自动清零。 如果你质疑之后不给他清零。 那下次即使是正常的复位键复位。 他也会判断为看门狗复位啊。 这样时间现象就错了。 然后接下来我们就在if和L式里写下。 开门口复位和正常复位执行的代码。 如果是camera的复位。 我们想说一个字符串。 来个o i d show string。 二行一列显示IWDGRST。 随后delay500毫秒。 复制一下。 再显示空格。 把这个字符串清除。 最后底内100mm。 当然最后这个底也可以不要哈。 营养不大。 这是独立开门口复位时候的现象。 就在第二行闪烁一下这个IWDG。 IST字符串。 然后L10里的代码复制一下这段代码。 我们在第三行显示一个RST字符串之后。 把它清除。 这正常复位时候的现象。 就在第三行闪烁2ST字符串。 好。 现在先看一下目前的实验现象啊。 编译下载看一下。 目前这里第一行显示IW d g test。 按下复位。 第三行显示正常的IST。 这是目前的现象。 然后回到代码。 我们继续来写。 接下来我们就要初始化独立看门狗了。 策划第一步。 开启LSI的时钟。 这个刚才说过啊。 不需要我们手动开启代码也不用写。 然后第二步解除写保护。 显然我们需要调用这个函数复制放到这里。 参数转到定义。 我们需要使用这个label。 写死人就解除写保护对吧。 那放到这里。 这样第二步就完成了。 接下来第三步配置预分频和重装值。 配置预分频。 我们调用这个函数放到这里。 然后配置重装值。 我们需要调用真函数。 放到这里好。 现在我们来计算一下这两个参数的值啊。 看一下PPT。 看一下这里的计算公式和表格。 在计算之前。 我们需要确定一下我们想要设定的操作事件。 这个测试时间具体是多少。 需要根据你的项目要求了哈。 如果你没有特别的要求。 开始后过个一两秒再复位也不影响的话。 那这个超市时间可以设置的稍微大一些。 比如现在设置超时时间为1000ms。 也是一秒啊。 那就是要求喂狗时间间隔不能超过1000ms。 所以公式这里是1000ms。 TLS是四十千赫兹。 分之一等于0.025ms。 然后pr和RL都是待定的数值。 并且它们的值可以有多种组合啊。 并不是固定的。 随着一分比系数的不同。 IL也对应的有不同的选择。 我们可以看一下下面这个表。 目前我们要设置1000ms。 可以看到这里前两个预分屏是不能选择的。 因为这两个预分频系数太小。 以至于计数器计数的最长时间。 都达不到1000ms。 所以对于1000ms的操作时间。 前两个预分频系数不能选择。 然后剩下的这些分明都可以选择。 因为他们技术的最短时间和最长时间。 都包含了1000ms。 当然在这些可选项中啊。 我们应该优先选择预分频系数小的。 这样可以最大化利用计数器的值。 来减少时间误差。 因为有的时候代入这个公式计算。 得到的IL值是一个小数。 但只能给整数。 所以四舍五入取整就会造成误差。 这时如果余分比小时钟快。 那么取整后造成的误差就比较小。 这个误差大家可以自己带入几个值。 算一下就知道了。 所以目前对于1000ms的操作时间。 这个16分屏就最佳选择。 但如果你不介意这点误差。 下面这些也都是可以选择的话。 影响不大。 毕竟我们这个独立看门狗对其中要求也不严格。 而且IOS中也会有很大误差的对吧。 那这里pr运动系数我们选择16分屏。 最后就只剩一个2L的。 简单算一下。 IL就等于1000除0.0.5除16再减一了。 用计算器算一下。 1000÷0.025除16等于2500。 再减12499。 就是要写入的重装值。 当然这里计算结果直接是一个整数啊。 不会因为取证造成误差。 那回到程序这里的配置。 我们就计算好了。 一分屏转到定义。 我们选择这个16分屏放到这里。 重装值转到定义。 这个值必须在0~3个F之间。 即0~4096。 我们计算的结果2499处于这个范围啊。 所以这里直接写2499。 这样操作时间就确定好了。 是1000ms。 接着进入下一步。 我们就可以调用这个函数。 直接启动看门狗来。 当然在启动之前我们可以先喂一次狗啊。 这样启动之后的第一个喂狗周期就是1000ms。 这样严谨一些。 所以在这里我们先喂一次狗。 参数没有这样。 CNT的初始值就是重装值2499。 那最后我们再调用这个ILLEL启动cam go。 这样开门口的初始化就完成了。 同时这里喂狗或死人的时候。 会在鉴定器写入555之外的值。 这时就顺便给自容器写保护了。 所以写完计算器之后。 我们就不用再手动执行写保护了。 好这就是独立开门口的初始化。 接下来我们来测试喂狗的逻辑。 首先复制喂狗的代码。 在主循环里不断喂狗。 喂狗的时间间隔。 我们先提了一个800ms。 这样看一下现象。 编译下载看一下。 按一下复位键。 可以看到除了第一次复位之后都不会再复位的。 因为目前我们的未购时间满足要求。 接着修改程序。 我们把喂狗时间改成1200ms。 再看一下下载。 可以看到这时会不断地显示独立看门狗复位。 因为目前我们的喂狗时间不满足要求。 那再改一下时间。 我们看一下零件时间是不是我们设定的。 1000ms。 直接改成1000ms。 看一下。 可以看到对于1000ms它是不复位的。 然后加大点1010试一下。 可以看到这样就不行了。 所以胃口的连接时间大概就是1000ms左右啊。 因为这个LSI可能有些误差。 并且代码执行也需要一些时间。 所以如果你实测的时间和这个不太一样。 这也是正常的。 只要这个时间是在1000ms左右就行。 我们一般需要多留一些时间。 余量不会卡的这么死好。 那程序现象我们就验证完成了。 接下来我们来完善一下最终的程序吧。 首先我们把按键功能拿过来。 在这最上面包含K点H初始化那个K你。 在主群管理我们可以直接调用k get la。 按住按键不放主循环就会阻塞。 主循环阻塞不能及时喂狗。 独立看门狗就复位。 然后下面再来个闪烁字符串。 这样看的更清楚一点。 O o d show string。 四行一列显示肺的。 复制一下。 再把肺的清除。 delete的时间先给200ms。 再给600ms。 加起来。 主循环执行的时间大概就是800多毫秒。 距离1000ms的操作时间。 还有大概200ms的余量。 就是最终的程序代码。 我们测试一下下载。 可以看到正常情况下OIDD4行不断显示。 喂狗程序不会复位。 然后按住PP1的按键不放。 程序阻塞。 就会引起独立看门狗复位。 就是独立开门口的程序现象。 好第一个代码到这里我们就讲完了。 接下来我们来学习下一个代码窗口看门狗。 回到公开文件夹。 我们复制一下独立看门狗的工程啊。 在这个工程的基础上修改。 改个名字叫14杠二窗口看门狗。 打开工程。 其实这两个camera的代码结构都差不多哈。 我们直接在这里改一下。 首先初始化这里还是这个流程显示的字符串。 我们改成w w d g test。 下面获取标志位的也是一样。 不过标志位的改下转到第一看一下。 这里选择WWTG窗口。 看门狗的复位标志位替换。 这里参数下面显示的字符串也改一下。 这样复位的显示就改好了。 最后独立开门口的初始化我们全部删掉。 待会在这里我们对应写上窗口。 开门口的初始化即可。 最后主循环里的独立看门狗喂狗删掉。 待会写上窗口看门狗的喂狗好。 那窗口看门口的测试框架我们就改好了。 先编译一下。 没问题。 接着我们回到PPT看一下初始化流程。 先看一下窗口。 看门口的框图。 这里因为窗户开门口的始终来源是PCLK1。 所以第一步我们需要开启窗户。 chemical a p p1的时钟。 这个第一步需要我们自己来执行。 不会像独立看门狗来讲自动开启啊。 最后第二步就是配置各个系统器了。 比如预分屏和窗口值。 窗口看门狗没有写保护啊。 所以第二步就可以直接写这些寄存器了。 最后第三步写入控制性器。 CR控制净水器包含chemical死人位。 机器溢出标志位和机器有效为。 这些东西需要一起设置。 放在第三步统一执行之后。 在运营过程中。 我们不断向接收器写入想要的重装值。 这样就可以进行喂狗了。 这是窗口看门狗的操作流程。 那流程看完我们再看一下库函数。 这两个标签先关掉。 找一下关注。 我们打开WWDG点去看一下函数。 这些是窗口看不够的扩展数。 看一下。 第一个是恢复缺省配置。 第二个set press skirt写入预分频器。 第三个set window value写入窗口值。 初始化配置就用这两个函数啊。 第四个enable i t使能中断。 因为它只有一个中断。 所以不需要指定参数了。 拿下面set counter写作计数器。 V口就用这个函数。 最后ELIABLE使能窗口看不懂。 出发之后启动CLAMGO就用这个函数。 因为这个函数还有一个参数啊。 并且和上面这个set counter参数是一样的。 为什么这么设置呢。 看一下手册。 这个上小节的最后说过啊。 在这里18.3。 因为递减接收器是自由运行状态。 你在死人的时候。 就由器可能是任何值。 为了避免刚一死人就立马复位。 所以我们在死人的时候需要顺便同时喂一下狗。 那在快书里的体现就是死人函数里也有个参数。 需要指定死人的时候喂狗多少。 然后最后两个就是。 获取标志位和清除标志位的函数了。 这就是窗口开门口的库数。 接下来我们就可以开始写代码了。 回到这里。 我们来初始化窗口看门狗策划。 第一步。 开启时钟。 这里需要调用CCAPP1外设。 时钟控制参数是cc app1外设WWD1类。 不这样我们就开启了窗口。 开门口的PCLK1时钟接到第二步。 设置预分屏和窗口值设置与分屏。 我们调用这个函数放到这里。 参数待会再算设置窗口值。 我们调用这个函数放到这里弹出来放着。 最后第三步就死人了。 我们调用这个函数放到这里。 参数也放着。 最后主循环里。 我们调用这个函数不断写入计数器进行喂狗。 参数也放着。 好流程。 就是这些。 现在我们有这几个待定的参数。 这个参数决定了喂狗的最晚时间和最早时间。 怎么计算呢。 我们看一下PT。 这里是计算公式。 在计算之前。 我们需要根据项目要求。 确定想要设定的超时时间和窗口时间。 这里测试的话我就自己随便定了。 比如我想设定的超时时间是50ms。 窗口时间是30ms。 那么首先需要代入第一个公式。 确定一下预分频和喂狗要给的计数器值。 看一下下面的表。 我想要设置的操作时间是50ms。 所以这里只能选择最后一个分屏吸入。 因为只有最后一个的时间范围包含50ms。 前面三个都记不了这么久。 那你说我想设置60ms的设置时间。 怎么办呢。 从这个表来看。 窗户开门口是记不到60ms这么久的。 它最大只能G58.25毫秒。 除非你改变PC2K一的时钟频率。 不过并不建议这样做啊。 那余分明我们就确定好了。 WDGTB选择三预分频系数。 就是二的三次方等于八。 这里是8TPC2K14316兆分之一。 超时时间我们设定为50ms。 这样算一下T就非常简单了吧。 我们打开计算器。 首先1÷36兆。 36兆只给三个零啊。 这样算的是这个结果。 单位是毫秒。 我们记一下。 然后50ms除记忆值除4096。 除八等于54.9。 取整为55。 这里取整就会有一点点误差了。 那所以这里T加一等于55。 最终得到T5到零应该设定为54。 这样超时间的参数就确定下来了。 预分频系数给八。 T5到零。 给54。 对应的超时时间就是50ms。 回到程序预分频转到定义。 我们需要选择这个八放到这里。 最后的T5到零应该是重装值对吧。 但是窗户开门口并没有重装进容器。 它通过直接写入计数器来实现重装的。 在死人的时候。 我们需要首次写入重装值。 这胃口的时候。 我们也需要不断的写入重装值。 所以我们把计算的54写入到这里来。 但现在还需要做一个步骤。 就这个54只是T5到零的值。 看PPT在这里。 T5到零是这里。 到这里还有一个T6尾也是必须要设置为一的。 所以在54的基础上。 我们需要或上0X40。 也就是把计容器次高位的T6位设置为一。 所以代码这里加上一个或0X40。 这里用按位或或者用加号都可以。 因为五四这个值比较小。 没有触及到次高位。 所以这时或和加效果是一样的。 另外这里控制计算器还有一个最高位。 WDGA死人位。 我们看一下这两个函数内部。 对死人位是怎么操作的呢。 首先使能函数这个参数进来货场w d g a set。 这个w d g a set可以看到它是0X80。 由是把最高位设置为一了。 所以这样CR最高位为一死人。 最后看一下喂狗的set counter。 插入进来后。 先与上bat mask。 再写入CR进容器。 Beat mask。 可以看到是0X7F也是最高位七零。 所以这里写入的最高位是零。 最高位是死人。 喂。 喂狗的时候会给死人喂显灵。 那这样我们在喂狗的时候。 会不会又同时把看门狗给关闭了呢。 这个不用担心啊。 因为上一小节这里我们也说过。 启动开门口之后。 开门口是不能再被关闭的。 所以即使喂狗的时候。 最高位写入量零。 这个操作也是无效的。 同样在代码这里连个注释啊。 意思是写入G6到零来配置路由器。 不需要再做读改写这样的操作了。 这个读改写的操作在库函数里面经常出现。 可以跟大家介绍一下。 比如上面这里就是一个典型的读改写操作。 第一步先把计算器读到临时变量里。 第二步。 用或等于余等余的操作。 改变临时变量的指定几位。 第三步把临时变量写回到金融机里。 这样做的好处就是。 一可以单独改变进气的某几位。 而不影响其他位的值。 二如果连续更改多次不同的胃。 这样的操作效率比较高。 三所有更改的V在最终写回到进气时同时生效。 就是读改写这个操作。 来看上面这里是不是也是类似的操作啊。 其他地方大家可以自己再看看好。 回到这里。 这里不用再读改写了。 因为对最高位的WDGA写零没有任何作用。 所以你就可以直接写入计数值。 不用考虑这个操作会影响到最高位的。 就是这两个函数对控制进入器的操作。 那回到主程序。 我们继续计算这个窗口值。 看一下PPT这里的公式。 计算窗口值之前。 我们一定要先把超时间算出来。 算好超时时间了。 一分明系数和T就确定好了。 下面再算窗口时间就易如反掌了。 那刚才我们算出预分频系数为八。 T为54TPC2K一是36兆分之一。 超过时间我们将指定为30ms。 再算充过值。 那就简单了。 所以打开计算器30ms。 除刚才保存的G值。 除409658等于32.9。 取整到33。 所以这一块T减W等于33。 W等于T减33。 等于54-33=21。 最终计算得到窗口值W5到零需要给21。 回到程序这里我们要给21。 同理这个窗口值也是只有W5到零D6位W6。 这一位我们也需要或上0X40给它治一。 这样窗口值就决定好了。 那在这里我们的各个参数就配置完成了。 目前的参数超时时间是50ms。 穿过时间是30ms。 也是我们主循环的。 喂狗周期要在32秒到50秒的范围内。 我们把这两个延时都改成20ms。 目前延时加起来是40ms啊。 当然其他代码的执行也需要花一些时间。 目前应该是40多毫秒。 只要不超过50ms就行。 这是目前的程序。 不过目前的程序这样写其实是有问题的。 大家能看出来问题在哪吗。 我们先看一下实验现象啊。 编译下载看一下。 可以看到目前一直都在触发窗户看门狗的复位。 这是为什么呢。 我们组循环一直都是40多毫秒的循环。 喂狗啊。 是处于这个范围的。 为什么会一直触发窗口看门狗负A呢。 那么问题在哪里呢。 答案就是这两条语句。 他们离得太近了。 你看程序初始化执行到这里时。 只能看门狗同时执行第一次喂狗。 然后执行执行执行执行到这里很快就又执行了。 第二次喂狗。 这里到这里的时间间隔肯定是小于30ms的。 属于是喂狗太快了。 所以can go会立刻复位。 下次执行到这里的时候。 它就会复位。 所以就陷入到了循环复位卡死的促进。 解决方法呢。 就是把喂狗的代码放在延时之后就行了。 第一次喂狗。 在这里先经过40ms的延时再执行。 第二次喂狗。 这样就能避免第一次和第二次喂狗。 时间过短的问题了。 如果你觉得这个死人第一次喂狗和下面这里。 第二次喂狗中间的时间不好把握的话。 也可以把死人的代码和下面的放在一起。 并且加个if判断和标注位判断。 如果是第一次执行。 就执行上面这条使人顺便为作者程序。 如果不是第一次执行。 就执行下面这条单独的位构程序。 这样也行啊。 那么先回复这样的代码。 在测试看一下下载。 可以看到现在程序就没有复位了。 并且第四行在很快的闪烁。 fade表示喂狗X10胃口会导致复位。 然后过快外狗呢这里不太好模拟。 我们直接改程序吧。 目前是40ms。 当然OID显示的函数其实也是比较耗时的。 我们先注释掉delay。 直接改成30ms。 这是最快的窗口值。 下载试试看。 现在在不断复位。 说明30ms是过宽。 位够了。 我们加大到31ms再试试看。 可以看到它已经不复位了。 说明31ms是没问题的。 这说明我们最快。 胃口的窗口值确实是30ms左右。 然后测试一下50ms的操作时间了。 delay改成50试一下。 可以看到目前已经在复位了。 然后改小点四九再试一下。 可以看到目前就不复位了。 这说明超时时间确实是50ms左右。 通过实测大概验证了我们计算参数的正确性啊。 其他时间的参数大家可以在自行计算。 然后验证一下好。 目前窗户开门口的程序到这里也有讲完了。 我们看过的知识点到这里也就结束了。 那我们下期再见。
48. Hello。 大家好。 欢迎继续观看STM32入门教程。 本节我们学习的内容是STM32的flash闪存。 当然闪存是一个通用的名词啊。 表示的是一种非意识性。 也就是掉电不丢失的存储器。 比如我们之前学习SPI的时候。 用的W5Q64芯片。 就是一种闪存存储器芯片。 而本节我们所说的闪存啊。 则特指STM32的内部闪存。 也是我们下载程序的时候。 这个程序所存储的地方。 我们下载的程序掉电后肯定不会消失对吧。 这说明程序存储在了一个非易失性存储器中。 这个存储器也是一种闪存。 那我们本节就来学习一下如何利用程序来读写。 存储程序的这个存储器。 在开始本节之前。 我们还是看一下本节代码的现象。 本节课主要有两个代码。 第一个是15杠一读写内部flash。 第二个是15杠二读写芯片id。 先看一下第一个。 这个代码的目的。 就是利用内部flash程序存储器的剩余空间。 来存储一些掉电不丢失的参数。 如果你有一些配置参数需要掉电不丢失的保存。 再外挂一个存储器芯片的话。 显然会增加硬件成本。 那XT32本身不就是有掉电。 不丢失的程序存储器吗。 我们直接把参数存在这里。 是不是就又方便又节省成本啊。 所以这里的程序是按下K1变换一下测试数据。 然后存储到内部FLACD。 按下K2把所有参数清零。 最后OID显示一下。 我们下载看一下。 这里OLED显示了flag和data flag当做标志位啊。 内容随便定义。 这里我定义的是A5。 A5。 flag的作用。 就是判断一下之前是不是存储过程序。 如果存储过程序就直接读取。 如果没存储过。 就先初始化一下。 这个思路和之前RTC的那一节的代码是一样的。 然后下面的data就是要掉电存储的数据了。 我们按下K1可以变换一下测试数据啊。 每变换一次。 这个数据就更新存储到flash里了。 比如现在四个数据分别是5AF14。 我们直接把整个芯片断电。 再重新上电。 可以看到数据仍然存在。 和之前保存的一样。 继续变换几次呢。 再断电重启。 可以看到数据也还是存在的。 继续测试。 按复位键可以看到这个数据也不会丢失。 那为了能清零这个数据呢。 我们可以按K2按键。 这样就把所有参数归零了。 就是利用内部flash存储掉电。 不丢失数据的现象。 可以看到整个电路我不需要外挂任何存储芯片。 在电路上也不需要有任何新增设备。 所以利用内部flash实现这个功能。 是一个非常灵活和节省的方案。 这是第一个代码的选项。 然后继续看第二个代码。 读取芯片ID这个代码非常简单啊。 这节就顺便讲一下。 那在STM32里指定的这些地址下存储的。 有原厂写入的id号。 我们直接使用指针的操作方式读取。 就可以得大家列号了。 那下载看一下现象。 可以看到这里有两个id号。 第一个是f size表示芯片flash的容量。 0040表示flash容量单位是KB。 换成十进制就是64KB。 但有的芯片flash容量会大于64KB。 这个数据有些不一样。 也是正常的。 然后第二个是UID是96位的芯片唯一id号。 每个芯片的唯一id号都不一样。 目前我这个芯片读取出来是这个数据。 大家可以自己读取看看。 肯定和我这个是不一样的。 好这是本节程序的现象。 接下来我们回到PPT看一下本节课的内容。 首先看一下简介。 DETASTM32F一系列的flash包含程序存储器。 系统存储器和选项字节三个部分。 通过闪存存储器接口外设。 可以对程序存储器和选项字节进行擦除和编程。 那首先flash包含程序存储器。 系统存储器和选项之间这三个部分。 这个我们之前介绍过。 还有印象吧。 我们回顾一下。 在DMA这一节。 这里我们讲过存储器印象。 SM32内部的存储空间主要有这些部分。 其中ROM区就是掉电不丢失的存储介质是flash闪存。 ram区掉电丢失存储介质是SRAM。 闪存。 主要有程序存储器。 系统存储器和选项字节三个部分。 这是我们本节要学习的内容。 其中程序存储器是这三者之中空间最大。 最主要的部分。 所以也称作主存储器。 起始地址是0800。 开头的用途是存储程序代码。 系统存储器起始地址是1FFF000。 用途是存储BOOTLOADER。 用于串口下载。 选项字节起始地址是1FFF800。 用途是存储一些独立的配置参数。 然后下面的地址也看一下。 运行内存的起始地址是2000开头的。 外设计算器的起始地址是4000。 内核外设兼容器的起始地址是1000。 这样其实地址要记一下要多少。 当你看到一个存储器的地址时。 一眼就能知道它位于什么区域。 有什么特性。 大概是做什么的。 这是这一块内容。 我们再回顾一下。 等会儿还会用到的。 接着回到这里继续看flash。 包括这三部分。 我们本节的任务就是对这些存储器进行读写。 那我们怎么操作这些存储器呢。 这需要用到这个闪存存储器接口的。 闪存存储器接口是一个外设。 是这个闪存的管理员。 毕竟闪存的操作很麻烦。 涉及到擦除编程。 等待码解锁等等操作。 所以这里我们需要把我们的指令和数据。 写入到这个外设的相应进容器。 然后这个外设就会自动去操作对应的存储空间。 那后面写的是这个外设。 可以对程序存储器和选项字节。 这两部分进行擦除和编程。 对比。 上面的三个部分呢少了系统存储器这个区域。 因为系统处理器是原厂写入的BOOTLOADER程序。 这个是不允许我们修改的。 接着往下看读写flash的用途。 这里我列了两个用途。 第一个是利用程序存储器的剩余空间。 来保存掉电不流失的用户数据。 像我们刚才演示的代码就是这个用法。 对于我们这个C8T6芯片来说。 它的程序存储器容量是64K。 一般我们写个简单的程序。 可能就只占前面的很小一部分空间。 剩下的大片空余空间我们就可以加以利用。 比如存储一些我们自定义的数据。 这样就非常方便。 而且可以充分利用资源对吧。 不过这里要注意我们在选取存储区域时。 一定不要覆盖了原有的程序。 要不然程序自己把自己给破坏了之后。 程序就运行不了了。 一般存储少量的参数。 我们就选最后几页存储就行了。 关于如何查看程序所占用空间的大小。 这个我们下小节也会介绍。 那这就是第一个用途。 然后第二个用途就是通过在程序中编程IP。 实现程序的自我更新。 刚才说了。 我们在存储用户数据时要避开程序本身。 以免破坏程序。 但如果我们就非要修改程序本身。 这会发生什么呢。 那这就是第二点提到的功能。 在程序中编程。 利用程序来修改程序本身。 实现程序的自我更新。 这个在程序中编程就是IP。 在数码圈也有个可能大家更熟悉的技术叫OTA。 这俩是类似的东西。 都是用来实现程序升级的。 但这个IP升级程序的功能比较复杂。 我们本课程暂时就不涉及了。 之后有缘再说吧。 然后看一下下面的介绍。 这有两个概念。 首先在线升级英文是INCIRCUITPROGRAMING。 缩写sap。 但英文直译过来也可以叫在电路中编程。 意思就是下载程序。 你只需要留几个引脚就行。 不用拆芯片了。 就叫在电路中进行编程。 这个sap的作用是用于更新程序。 存储器的全部内容。 它通过JTAGSWD协议或系统加载程序。 BOOTLOADER下载程序。 这个JTAGSWD就是仿真器下载程序。 就是我们目前用的s t link。 使用SWD下载程序。 每次下载都是把整个程序完全更新掉。 那系统加载程序就是系统存储器的不错。 road由是串口下载。 串口下载也是更新整个程序。 这是我们一直在用的sap下载方式之后。 更高级的下载方式就是在程序中编程。 英文是in application program。 简称IP。 它可以使用微控制器支持的任意一种通信接口。 下载程序怎么实现呢。 那比如这是整个程序存储器。 我们首先需要自己写一个BOOTTO的程序。 并且存放在程序更新时不会覆盖的地方。 比如我们放在最后面。 然后需要更新程序时。 我们控制程序跳转到这个自己写的不透漏。 这里来。 在这里面我们就可以接收任意一种通讯接口。 传过来的数据。 比如串口。 USB蓝牙转串口。 WIFI转串口等等。 这个传过来的数据就是待更新的程序。 然后我们控制flash读写。 把收到的程序写入到前面程序正常运行的地方。 写完之后再控制程序跳转回正常运行的地方。 或者直接复位。 这样程序就完成了自我升级。 这个过程其实就是和系统存储器。 这个的bot load一样。 因为程序要实现自我升级。 在升级过程中。 肯定需要布置一个辅助的小机器人来临时干活。 只不过是系统中速器的BOOTLOAD写死了。 只能用串口下载到指定位置。 启动方式也不方便。 只能配置boot intel触发启动。 而我们自己写BOOTLOADER的话。 就可以想怎么搜怎么搜。 想写到哪就写到哪。 想怎么启动就怎么启动。 并且在整个升级过程。 程序都可以自主完成。 实现在程序中编程更进一步。 就可以直接实现远程升级了对吧。 非常灵活方便。 那有关IP的内容。 我就讲这么多。 更进一步的内容。 大家在自己研究啊。 接下来的内容。 我们就只涉及最基本的对flash进行读写。 这也是实现IP的基础。 好简介就是这些。 接着我们继续看一下这个闪存模块的组织。 这个表是重量产品的闪存分配情况。 我们C8T6芯片的闪存容量是64K。 属于重容量产品。 对于小容量产品和大容量产品。 闪存的分配方式有些区别。 这个可以参考一下手册。 那首先提醒一下闪存这一章的内容。 在手册里是单独列出来的。 并不在之前的参考手册里。 我们需要打开这个闪存编程参考手册。 打开之后可以看到这个文档也不是很多啊。 其实就是单独一章的内容。 这个注意一下。 别找错位置。 那我们打开1.2这一节。 这里就是闪存模块组织。 首先是小量产品。 这个页数少一些。 总共32页。 每页1K。 然后中文电产品页数多一些。 总共128页。 每页1K。 最后大容量产品页数更多。 总共256页。 并且每页容量也更大。 是2K。 这是小中大容量产品。 闪存分配方式的不同。 其他地方基本都是一样的。 那回到BD这里。 以重量产品为例来讲解。 首先看一下第一列的几个块。 这里分为了三个块。 第一个是主存储器。 也是我们刚才说的程序存储器。 用来存放程序代码的。 这是最主要也是容量最大的一块。 下面第二个是信息框。 里面又可以分为启动程序代码和用户选择字节。 其中启动程序代码就是刚才说的系统存储器。 存放的是原厂写入的BOOTLOADER。 用于串口下载。 这个手册的名称经常会有不同的表述方式啊。 但大家要知道某些名称描述的其实是一个东西。 然后下面这个用户选择字节。 就是刚才说的选项字节存放一些独立的参数。 这个选项字节在手册里一直都称作选择字节。 可能是翻译的问题啊。 英文是option bts。 我们一般都叫选项字节。 大家也知道是一个东西就行。 然后最后一块是闪存存储器接口。 接收器这一块的存储器实际上并不属于闪存。 你看那个地址就知道地址都是四零开头的。 说明什么啊。 说明这个存储器接口。 净水器就是一个普通的外设。 和之前讲的GPIO定时器。 串口等等都是一个性质的东西。 这些存储器它们的存储介质也都是s ram。 这个闪存存储器接口就上面这些闪存的管理员。 这些计算器就是用来控制擦除和编程。 这个过程的。 那到这里这个表的整体我们就清楚了。 上面这里到这里是真正的闪存。 分为三部分。 主存储器就程序存储器。 启动程序代码。 就系统存储器。 用户选择字节。 就选项字节。 其中系统存储器和选项字节。 又可以合称为信息块。 这一点和刚才这里讲的是对应的。 闪存分为这三部分。 没问题。 然后下面这一部分是闪存的管理员。 我们擦除和编程就通过读写这些接触器来完成。 这点和刚才讲的。 这里是对应的闪存存储器接口。 可以对闪存进行擦除和编程。 当然这里只有参数和编程。 并没有读取啊。 这是因为读取指定存储器直接使用指针读即可。 用不到这个外设好。 那我们继续看这个表。 对于主服务器。 这里对它进行了分页。 分页是为了更好的管理闪存。 擦除和写保护都是以E为单位的。 这点和之前W5Q64代接的闪存一样。 同为闪存。 它们的特性基本一样。 写入前必须擦除啊。 擦除必须以最小单位进行。 擦除后数据位全变为一啊。 数据只能一写零。 不能零写一啊。 擦除和写入之后都需要等待毛啊。 这些都是一样的。 学习这节之前。 大家可以再复习一下W5K64来接。 相信你学过WQ64之后。 再学这一节就会非常轻松了。 那W5K64的分配方式是先分为块block。 再分为扇区。 sector比较复杂。 这里就比较简单了。 它只有一个基本单位。 就是页。 每一页的大小都是以K0到127。 总共128页。 总量就是128K。 对于C8T6来说。 它只有64K。 所以C8T6的页只有一半0~63。 总共64页。 共64K。 然后看一下页的地址范围。 第一个页的起始地址就程序存储器的起始地址。 0x08000000。 之后就是一个字节。 一个地址依次线性分配的。 看一下每页起始地址的规律。 首先是0000。 然后040008000400。 再之后1000。 后面按照规律就是14001800。 1400。 2000240028002400等等等等。 最后一直到1FC00。 所以地址只要以000400800400。 结尾的。 都一定是E的起始地址对吧。 这个稍微记一下之后。 如果想要给一个页的起始地址。 就需要用到这个规律。 然后继续系统总武器。 它的起始地址是零X一FFF000。 这个之前介绍过的。 它的容量是2K这个就不用多说了。 在下面选项。 字节起始地址是零X一FFF800。 容量是16个字节。 里面只有几个字节的配置参数啊。 这个后面还会继续说的。 那这里还可以发现我们平时说的芯片。 闪存容量是64K128K。 它指的只是主存储器的容量。 下面信息快的这两个东西虽然也是闪存。 但是并不统计在这个容量里。 这是闪存的分配方式。 那最后就是这个闪存接口接容器了。 里面包括K2键进容器。 SR状态进入器。 CR控制进入器等等。 外设的起始地址是0X40022000。 每个计算器都是四个字节。 也是32位。 就是这个外设的计算器好。 那这个表就看到这里。 接下来看一下我总结的这个基本结构图啊。 整个闪存分为程序存储器。 系统容器和选项字节三部分。 这里程序存储器为以C8T6为例。 它是64K的。 所以总共只有64页。 最后一页的起始地址是0800FC00。 左边这里是闪存存储器接口。 手册里还有个名称。 闪存编程和擦除控制器。 L p e c。 大家也知道这两个名称其实是一个东西就行。 然后这个控制器就闪存的管理员。 他可以对程序中器进行擦除和编程。 也可以对选项字节进行擦除和编程。 当系统容器是不能擦除和编程的。 这个选项字节里面有很大一部分配置位。 其实配置主程序存储器的读写保护的。 所以右边画的写入选项字节。 可以配置程序存储器的读写保护。 当然选项之前还有几个别的配置参数啊。 这个待会再讲。 那这就是整个闪存的基本结构大概就是这样。 接下来我们来看一下细节问题。 如何操作这个控制器。 F p e c。 来对程序存储器和选项字节进行擦除和编程。 首先第一步是flash解锁。 这和之前W5K641样。 W5K64操作之前需要写死人。 这个flash操作之前需要解锁。 目的都是为了防止误操作。 那这里解锁的方式和之前独立看门狗一样。 都是通过在鉴定器写入指定的键值来实现。 使用间接容器的好处就是更能防止误操作。 每一个指令必须输密码才能完成。 通过经文名称也能看出来剑的英文是KK。 直译是不是钥匙的意思。 所以这个更形象的翻译。 我们可以把它叫做钥匙禁用器。 密钥计算器。 那看一下。 首先LPEC共有三个键值。 也是三把开锁的钥匙。 RDPRT键是解除毒保护的密钥。 只是0XA5K。 一键则是0X45670123K。 二键则是0XCDEF8角ab。 为什么是这些子呢。 通过它的子也可以看出来。 实际上是随便定义的。 只要你定义的不是很简单。 不是随便就能把这个锁撬了就行。 继续看怎么解锁呢。 第一个是复位后FFEC被保护。 不能写入flash cr。 你要是复位后。 flash默认是锁着的。 然后在flash kr键进入其中。 先写入K1。 再写入K2解锁。 我们找到了锁。 这个锁是KR进器。 怎么解呢。 要先用K1钥匙解。 再用K2钥匙解。 最终才能解锁成功。 所以这个锁的安全性非常高。 有两道锁。 即使李程序跑飞了。 歪打正着正好写入了K1。 那也难以保证下一次又歪打正着写入了K2。 所以非人为情况下基本不可能结束。 然后第三条还有进一步的保护措施。 就是错误的操作序列。 会在下次复位前锁死FPC和flash cr。 于是他发现有程序在尝试撬锁时。 一旦没有先写入K1。 再写入K2。 整个模块就会完全锁死。 除非复位。 这是整个解锁操作。 可以看到安全性非常高。 接着继续看。 解锁之后如何加锁呢。 我们操作完成之后。 要尽快把flash重新加锁。 以防止意外情况。 加速的操作是设置flash cr中的lock位。 锁住FEC和flash cr。 这个比较简单。 就是控制计数器里面有个lock位。 我们在这一位写一就能重新锁住闪存的好。 这就是解锁和加锁。 我们操作闪存的第一步就解锁。 操作完成后就加锁。 这个我们就清楚了。 接着看下一个知识点。 这个地方我们要学习的是。 如何使用指针访问存储器。 因为SM3内部的存储器是直接挂在总线上的。 所以这时在读写某个存储器就非常简单了。 直接使用C语言的指针来访问即可。 指针的这个用途。 在我之前发布的指针教程里也介绍过。 来看一下这里的操作。 首先使用指针读指定地址下的存储器。 我们需要用到这样一个格式的语句。 这个代码什么意思呢。 我们来一一分析。 第一步我们需要给定要读取存储器的地址。 比如我这里以08000000为例。 我想读取这个地址下的数据。 然后把这个地址写到这里。 因为这个括号因为目前里面只有一个数。 所以也可以不写。 但是如果你要对这个地址进行加减。 那就必须加上括号。 并在括号里面进行加减。 否则运算的优先级会有问题。 总之如果你不敢肯定各个运算符的优先级。 那就多加点括号肯定是最保险的好。 这是第一步。 把地址写到这里。 接着第二步这个地址前面加上强制类型转换。 这里我把这个变量强制转换为了。 unit16杠T的指针类型。 如果你想以16位的方式读出指定地址的数据。 那转换成unit16杠七新。 如果你想以八位的方式读出来了。 就转换成unit t8杠梯形。 像32位就转为unit t32杠梯形。 像浮点类型就转为float型或者double型。 这个根据你的读取形式的啊。 然后这个指针类型前面还加了个两个下划线。 IO在STM32库函数中。 这是一个宏定义。 下面写了这个宏定义对应C语言的关键字。 Volatile。 volatile直译就是异变的数据。 在这个数据类型前面加上volatile。 是一个安全保障措施。 在程序逻辑上没有作用。 加上这个关键字的目的。 用一句话来说就是防止编译器优化。 首先说一下。 Q编译器默认情况下是最低优化等级。 这时加不加这个VTR都没有影响。 如果你要提高编译优化等级。 这时就会有这个问题了。 那编译器优化有什么用呢。 用途就是可以去除无用的繁杂代码。 降低代码空间。 提升运行效率。 但优化之后。 编译器在某些地方可能会弄巧成拙。 比如你想用变量计数。 空中管的方式实现延时函数。 那编译器优化的时候可能会说。 你这段延时函数好像没用啊。 还白白浪费时间。 我直接给你优化掉。 不让你浪费时间了。 这就弄巧成拙了。 因为我们的本意就是靠浪费时间来延时。 这时我们就可以在延时的变量定义前面。 加上涡轮tile。 告诉编译器。 我无论对这个变量干什么。 你都原封不动的去执行。 别给我优化掉了。 另外编译器还会利用缓存的加速代码。 比如如果你要频繁读写内存的某个变量。 那最常见的优化方式。 就先把变量转移到高速缓存里来。 在STM3内核里有个类似缓存的工作主机用器。 这个定时器的访问速度最快。 我先把变量放在缓存里。 需要读写的时候直接返回缓存就行了。 用完之后再写回内存。 这是一个优化方案。 但是如果你的程序有多个线程。 比如中断函数。 在中断函数里你改变了这个原始变量。 那可能缓存并不知道你更改了下次程序。 还看缓冲的变量。 就会造成数据更改不同步的问题。 这时我们的做法也是读取变量定义的。 前面加上一个涡轮。 太告诉编译器。 这个变量是异变的。 每次读取你都得执行到位。 要直接从内存里找。 不要再用缓存优化。 所以总结一下。 就是如果开启了编译器优化。 在无意义加减变量。 多线程更改变量。 读写与硬件相关的存储器时。 都需要加上volatile。 防止被编译器优化。 如果你默认不开启编译器优化。 那就无所谓了。 加不加都一样。 所以这里我们要直接读取存储器。 为了严谨。 可以加上volatile。 告诉编译器。 我要直截了当地读取指定存储器。 不要给我优化或者绕弯子好。 第二步完成之后。 这里面的部分就是一个指针变量。 并且这个指针已经指向了。 0X08000000这个位置。 然后最后一步就使用星号指针取内容。 把这个指针指向的存储器取出来了。 这个值就是指定存储器的值。 取出来之后。 我们可以把它赋值给自定义的变量data。 这样就完成了指定地址读的任务了。 另外说一下。 对于闪存的读取来说。 是不需要进行解锁的。 因为读取只看看存储器。 不对存储器进行更改。 所需权限很低。 不用解锁。 直接就能读。 那接下来继续看。 使用指针写指定机制下的存储器。 这个语句的意思就很明显了。 左边和上面一样。 先给定地址。 再强壮为指针。 最后指针取内容。 这样就是指定地址的值。 我们直接对它赋值。 比如0X1234。 这样就能完成指定地址写的功能了。 另外这里也有注意事项。 因为这个语句是写入数据。 并且指定的是闪存的地址。 闪存在程序运行时是只读的。 不能轻易更改。 而我们本节需要对闪存进行更改。 这个所需的权限就比较高。 需要提前解锁。 并且还要套个后面这里的流程。 这个待会再说啊。 那如果你这个地址写的是SRAM的地址。 比如0X20000000。 那可以直接写入了。 因为SRAM在程序运行时是可读可写的好。 这是使用指针访问存储器的C语言代码。 其中读取可以直接读。 写入需要解锁。 并且执行后面的流程。 那么接下来就来看一下下面这三个流程图。 第一个是编程。 也是写入。 第二个是夜叉除HTML的闪存也是写入前必须擦除。 擦除之后所谓的数据位变为一。 擦除的最小单位就一页1K1024字节。 第三个是全删除。 把所有页都给擦除掉。 那首先说一下这个详细的流程啊。 库函数已经帮我们都写好了。 我们直接调用一个整体的函数就行。 非常简单。 这里我们只大概的了解一下详细步骤。 研究得越深。 操作越得心应手对吧。 那么从下往上看。 先看擦除。 再看编程。 首先看一下全擦除。 第一步是读取lock位。 看一下芯片锁没锁。 下面如果lock位等于一锁住了。 就执行解锁过程。 解锁过程就是在KR计算器先写K1。 再写K2。 这里如果他当天没锁住。 就不用解锁了。 这是流程图里给的解锁步骤。 如果锁住了就解锁。 如果没锁住就不用解锁。 但是在库函数中并没有这个判断。 快速是直接执行截图过程。 管理锁没锁都执行解锁。 这个比较简单直接啊。 不过效果都一样。 然后继续解锁之后。 首先自控制计算器里的MERV为一。 然后再自start为为一。 其中start为一是触发条件。 start为一之后芯片开始干活。 然后现在看到MERV是一。 他就知道接下来要干的活就是全删除。 这样内部电路就会自动执行全插锁的过程。 然后继续拆除也是需要花一段时间的。 所以拆除过程开始后。 程序要执行等待判断状态。 进入器的B站位是否为一。 b z way表示芯片是否处于盲状态。 B站为一表示新片盲。 所以这里如果判断BZ等于一。 就跳转回来继续循环判断。 直到BZ等于零跳出循环。 这样穿插组过程就结束了。 最后一步这里写的是读出并验证所有页的数据。 这个是测试程序才要做的。 正常情况下全删除完成的。 我们默认就成功了。 如果还要在全读出来验证一下。 这个工作量太大了。 所以这里的最后一步我们就不管了。 这是全擦除的流程。 然后我们看一下夜叉除。 这个也是类似的过程。 第一步这一块一样的是解锁的流程。 第二步。 这个方框里的自控制禁用器的PERV为一。 然后在R地址禁用器中选择要查组的页。 最后自控制用期的start为为1~10。 start为一。 也是触发条件大为一。 芯片开始干活。 然后前面看到PR等于一。 他就知道接下来要执行一叉出。 然后三层不止一二。 夜叉除芯片就要知道要具体查哪一页。 所以它会继续看AR进气的数据。 AR进去我们要提前写入一个页的起始地址。 这样芯片就会把我们指定的一页给擦除掉。 然后擦除开始之后。 我们也要等待BZV最后读出并验证数据。 这个就不用看了。 这是夜叉组的过程。 最后看一下闪存的写入。 拆除之后我们就可以执行写入的流程了。 另外说明一下。 SDF2的闪存。 在写入之前会检查指定地址有没有拆除。 如果没有参数就写入SDX2则不执行写入操作。 除非写入的全是零。 这个数据是例外。 因为不插足就写入。 可能会写入错误。 但全写入零的话。 写入肯定是没问题的。 来看一下流程图。 写入的第一步也是解锁。 然后第二步我们需要自控制运算。 P机位为一。 表示我们即将写入数据之后。 第三步就在指定的地址写入半只。 这一步我们需要用到刚才说的这句代码。 使用指针在指定地址写入数据。 想写入什么数据。 在这里指定即可。 另外这里注意一下。 写入操作只能以半字的形式写入。 在STM32中有几个术语字半字和字节集中字。 word就是32位数据。 半字half word就是16位数据字节。 bat就是八位数据。 这个了解一下。 那这里只能以半字写入。 意思就是只能以16位的形式写入。 一次性写入两个字节。 如果你要写入32位。 就分两次完成。 如果你只要写入八位。 这个就比较麻烦了。 如果你想单独写入一个字节。 还要保留另一个字节的原始数据的话。 那只能把整页数据都读到SRAM。 再随意修改SRAM数据修改全部完成之后。 再把整页都擦除。 最后再把整页都写回去。 所以如果你想像SRAM一样随心所欲的读写。 那最好的办法就先把闪存的一页读到SRAM中。 读写完成后再擦除一页。 整体写回去。 那回到流程图这里写入数据。 这个代码就触发开始的条件。 不需要像擦除一样是start we的。 写了半子之后。 芯片会处于盲状态。 我们等待一下B得清零。 这样写入数据的过程就完成了。 那每执行这样一个流程。 只能写入一个半字。 如果要写出很多数据。 要不断循环调用这个流程就可以了。 跑到这里。 内存的解锁指针读写数据。 擦除和编程的流程我们就学完了。 接下来我们再介绍一下选项字节这块内容。 大概了解一下就行了。 首先这里是选项字节的组织和用途。 图里的提示地址。 就是我们刚才说的选项字节的起始地址。 1FFF800这块的这些数据。 就前面这里这个表的这一行里面。 总共只有16个字节。 把这些存储器给展开。 就这个图这里是对应的16个字节。 其中有一半的名称前面都带了个N。 比如RDP和n r DP user和NUSER等等。 这个意思就是你在写入RDP数据时。 要同时在NRDP写入数据的砝码。 其他的这些都是一样。 写这个存储器时。 要在带N的对应的存储器写砝码。 这样写入操作才是有效的。 如果芯片检测到这两个存储器不是反马的关系。 那就代表数据无效。 有错误。 对应的功能就不执行。 这是一个安全保障措施。 但这个写入砝码的过程。 硬件会自动计算并写入。 不需要我们操心。 使用库函数的话。 那就更简单了。 函数都给我们分装好了。 直接调用函数就行。 那然后看一下每个存储器的功能。 去掉所有戴安的就剩下八个字节存储器了。 第一个RDP是独保护配置位。 下面有解释。 在RDP存储器写入RDPRT键。 就刚才说的A5。 然后解除毒保护。 如果IDP不是义务。 那闪存就是读保护状态。 无法通过调节器读取程序。 避免程序被别人窃取。 接着看第二个字节优势。 这个是一些零碎的配置位啊。 可以配置硬件。 看门狗和进入停机待机模式是否产生复位。 这个了解即可。 然后第三个和第四个字节data0和data1。 这个在芯片中没有定义功能。 用户可自定义使用最后四个字节。 WP0123这四个字节配置的是鞋保护。 在重量产品里是每一个位对应保护四个存储页。 四个字节总共32位。 一位对应保护四页。 总共保护32×4。 等于128页。 正好对应总用量的最大128页。 那对于小容量和大容量产品呢。 可以看一下手册2.5选项字节说明。 这里。 对于小容量产品。 也是每一位对应保护四个存储液。 但小容量产品最大只有32K。 所以只需要一个字节WP0就行。 4×8=32。 其他三个字节没用到。 然而对于大容量产品。 每一个位只能保护两个纯乳液。 这样的话四个字节就不够用了。 所以这里规定WRP3的最高位。 这一位直接把剩下的所有页一起都保护了。 这是写保护的定义。 这样选项之前有哪些东西都是干啥的。 我们就清出来。 然后看一下如何去写入这些位呢。 这里两页PPT展示的就是选项字节的擦除和编程。 因为选项字节本身也是闪存。 所以它也得擦除。 这里参考手册并没有给流程图啊。 我们看一下这个文字流程。 这个文字流程和流程图细节上有些出入啊。 我们知道关键部分就行。 先看一下选项字节擦除。 第一步其实也是解锁闪存。 这里文字并没有写。 然后第二步这里文字版的流程多了一步。 检查SR的B站位。 已确认没有其他正在进行的闪存操作。 这个实际上就是事前等待对吧。 如果当前已经在忙了。 我先等一下。 这一步在刚才的流程图里并没有体现。 然后下一步解锁CR的OPTWREV。 这一步是选项之间的解锁。 选项字节里面还有一个单独的锁啊。 在解锁闪存后。 还需要再解锁选项字节的锁之后。 才能操作选项字节解锁选项。 自己的话看一下前面的均衡器。 整个闪存的锁是K2。 里面选项自己的小锁是下面的OTK解锁。 这个小组也是类似的流程。 我们需要在OPTKR里先写入K1。 再写入K2。 这样就能解锁选项自己的小锁了。 然后继续解除小锁之后和之前的擦除类似。 监测者CROPDERV为一。 表示即将拆除选项字节之后。 设置CR的大V为一。 触发芯片开始干活。 这样芯片就会启动插手选项字节的工作之后。 等待BC位变为零。 擦除选项字节就完成了。 拆除之后就可以看写入了。 和普通的闪存协助也差不多。 先检测busy。 然后解除小锁之后。 设置CR的OPTPT位为一。 表示即将写入选项字节。 再之后写入要编程的半字到指定的地址。 这个是指针写入操作。 最后等待毛这样写作选项字节就完成了好了。 一款选项字节的内容我就讲这么多。 至此闪存的整个PPT的介绍我们就讲完了。 最后我们花几分钟学一下器件电子签名。 这个非常简单啊。 既然讲到闪存了。 就顺便学习一下吧。 看一下电子签名。 存放在闪存存储器模块的系统存储区域。 包含的芯片识别信息在出厂时编写不可更改。 使用指针读指定地址下的存储器。 可获取电子签名。 电子签名其实就是STM32的id号。 它的存放区域是系统存储器。 就这里系统中系它不仅有BOOTLOADER程序。 还有几个字节的id号。 系统中系起始地址是1FF000。 看下这里。 这里有两段数据。 第一个是闪存容量。 存储器基地址是1FFF7E零。 通过地址也可以确定它的位置。 就是系统存储器对吧。 这个存储器的大小是16位。 它的值就是闪存的容量单位是KB。 然后第二个是产品唯一身份标识计算器。 由是每个芯片的身份证号。 这个数据存放的基地址是1FFF7E八。 大小是96位。 每一个芯片的这96位数据都是不一样的。 使用这个唯一id号可以做一些加密的操作。 比如你想写入电程序。 只能在指定设备运行。 那也可以在程序的多处加入id号判断。 如果不是指定设备的id号。 就不执行程序功能。 这样即使你的程序被盗。 在别的设备上也难以运行。 这是STM32的电子签名。 总共就是这么多。 内容非常简单啊。 我们也顺便学一下。 好到这里。 我们本节课的内容差不多就讲完了。 最后还是大概看一下手册。 首先看一下这个闪存编程手势。 最开始这里是sap和IP的一些介绍。 对闪存编程。 实现IP在做产品时还是一个非常方便的功能。 有利于便捷地进行程序升级。 然后往后看。 这里有些术语。 小容量重量大容量是什么意思。 字半字字节的定义等等名词在这里有介绍。 然后是概述。 这里闪存模块组织是一个比较重要的内容。 要读写闪存。 首先你得知道它是怎么分配的。 这里小容量总容量。 大容量的分配方式都带这个表体现出来了。 然后下面是一些说明文字。 比如正在执行写或擦除操作的时候。 不能同时进行读取。 然后写或擦除时必须打开HSIS中。 这个CSM1第一步就已经打开了。 不要去动它就行。 然后下面这里这一页是涉及内核和CPU运行的内。 容连体的。 还是有点抽象的。 大家可以不用过多关心。 也不需要我们自己干什么的。 比如这个预取缓冲器可以提前读取程序。 来加快代码执行。 还有主频比较低的时候。 可以开启伴奏及访问。 加快代码执行。 这东西随便看看。 不用过多了解。 然后就是闪存编程和擦除控制器。 LPECI键值和解锁。 这些我们都介绍过。 然后主产从编程里面有些说明。 比如一次只能写入一个半字。 任何非半字的数据都会产生总结错误。 还有一个比较重要的注意事项。 就是在编程过程中。 任何读写闪存的操作都会使CPU暂停。 直到此时闪存编程结束。 这其实是读写内部闪存存储数据的一个弊端。 就删除。 忙的时候代码执行会暂停。 因为执行代码需要读闪存。 闪子粘毛没法读。 所以CPU也就没法运行了。 程序就会暂停。 这会导致什么问题呢。 假如你使用内部闪存存储数据。 同时你的中断代码又在频繁执行的。 这样读写缓存的时候。 中断代码就无法执行了。 这可能会导致中断无法及时响应。 比我之前做的一个项目SM32驱动一个点阵屏。 这个点阵屏需要用定时器中断。 不断的去扫描刷新。 否则屏幕就不会亮。 同时程序里我又使用了内部闪存。 来存储一些配置参数。 然后测试的时候就会出现一个问题。 就是一旦内部闪存进行读写。 整个屏幕就会快速的闪一下。 这个虽然不是大问题。 但非常影响用户体验。 目前的原因就是读写闪存会导致中断。 扫描点阵的代码暂停。 扫描暂停屏幕就会闪一下。 所以最终只能放弃内部闪存存储数据啊。 这是闪存存储的一大弊端。 如果你的程序里有需要频繁执行。 且对时间要求严格的中断函数。 那就要慎用这个内部闪存来存储用户数据。 这是这个注意事项。 然后继续看。 这是编程过程。 流程也讲过啊。 有个注意事项。 就是如果指定地址没有拆除。 那不会执行。 变成同时提出警告。 唯一的例外是写入0000。 这个没问题。 然后如果指定地址为写保护。 也是不执行编程。 并提出警告。 之后是文字版的流程。 然后闪存页擦除文字版的流程和下面的流程图。 整片擦除文字版的流程和流程图。 这样我们也叫过。 其中有个说明是整片查询信息。 快的内容不受影响。 接下来就是选项字节的编程。 选项字节在FPC解锁后。 还要再在OPTKR写入K1和K2。 解锁单独的小锁。 然后这里写的是LPEC。 会自动计算高字节的砝码。 所以砝码不用我们操心。 然后编程文字版的流程我们介绍过。 这里有个说明是当闪存由保护变为未保护时。 会自动执行整片擦除。 防止代码被盗。 这个探索过程我们介绍过。 再之后就是保护相关的内容了。 写保护和读保护可以在自己看看。 这说明。 然后选项之间的数值和每个字节的定义。 这一块可以详细看看。 我们也讲过。 但有个注意事项。 就是这里的V都使用的是反逻辑。 一表示无效。 零表示有效。 因为闪存擦除之后都是一。 所以一会用来作为默认情况。 比如这里的写保护。 一是默认的不实时写保护。 而零才是实时写保护。 这个注意一下。 最后就是计算题。 说明了第一个闪存访问控制禁用题。 这个是和内核执行代码有关的东西。 不用了解之后。 FBEC渐进器和OPT键禁用期。 分别是闪存锁和选项之间的小锁。 小K1再写K2解锁状态。 监控器表示电路的工作状态。 重点了解的就是这个B类盲标志为控制器。 用于控制电路运行。 重点了解这个knock加锁start。 开始opt e r选择自己的擦除opt pg。 选择自己的编程。 MER全擦除PERE叉除pg变成这些位。 我们之前都见过。 最后地址运气。 这个是配合页参数指定参数来一页的。 然后选项字节进器。 这些进器会把闪存里的选项字节的内容。 加载进来。 里面的内容和选项字节是对应的。 这个也是一样。 最后就是计算器总表了。 好这是闪存的手册内容。 大家可以在自己仔细看看。 然后还有一小点内容是器件电子签名。 再看一下参考手册。 第28章。 器件电子签名。 这个内容非常少。 上面这里写的电影签名是出厂编写的。 包含芯片识别信息之后直接是计算器闪存容量。 计算器基地址也是起始地址。 只是在这个数据存在什么地方了。 里面有16个子图位表示闪存容量。 然后产品唯一身份标识禁用器有什么用呢。 比如作为序列号。 作为密码。 用来激活带安全机制的制取过程。 这96位可以以字节为单位读取。 也可以半字或全制来读取。 然后基地址是这个下面就是所有V的内容了。 就是一串id号数据。 就是器件电子签名的内容。 那到这里。 本小节课的内容就全部结束了。 我们下小节来学习闪存的代码部分。 那么下一小节再见。
49. 大家好。 欢迎回来。 本小节。 我们来学习一下读写内部闪存的代码部分。 先看一下本节的经验图。 打开15杠一的图片。 本节的接线也是非常的简单。 右下角是OLED。 然后左上角在PB1和PB十一两个硬件。 插上两个按键用于控制。 这样就行了。 之后下一个代码15杠二读取芯片2D。 这个也是接上一个ORD。 能显示测试数据就可以了。 然后看下面包板。 这里我已经接好了。 右下角OID。 左上角两个按键就是接线部分。 那接下来我们回到工程文件夹。 复制一下OID的工程。 改个名字叫15杠一读写内部flash。 打开工程。 这也删掉。 先编译一下。 好那现在开始代码之前。 我们先规划一下工程结构啊。 这个工程我计划是建两个底层模块。 最底层计划叫my flash。 在这里面我们要实现闪存最基本的三个功能。 也就是读取擦除和编程之后。 在此模块之上。 我计划再建一个模块叫store。 主要实现参数数据的读写和存储管理。 因为我们最终应用层想要实现的功能。 是任意读写参数。 并且这些参数是掉电不丢失的。 至于你存在什么地方。 怎么擦除。 采用什么读写策略。 这并不是应用层所关心的。 所以在store这一层。 我们会定义一个s ram。 宿主需要掉电不丢失的参数就写到SRAM数组里。 之后调用保存的函数。 这个s ram数组就自动备份到闪存里。 上天后。 store初始化会自动再把闪存里的数据。 读回到s ram数组里。 这是闪存管理策略。 这部分主要就在store这一层实现。 那最后就是main点C里面的应用层部分了。 想要保存参数就写到12层的数组。 再调用保存函数备份的闪存。 这样就能实现最终功能了。 那这就是这个代码的整体规划。 待会我们就来一步步的实现。 然后本节的代码调试。 我们还有一个非常强大的辅助软件可以使用。 就这个STM32st link utility。 这个软件在之前九杠六那个视频里也讲过啊。 他的获取和安装方法可以参考一下视频。 九杠六拿安装好之后。 在桌面有这样的图标。 我们打开它。 在使用之前我们需要用stink把steam3连接好。 然后我们点击这个按钮连接。 可以看到下面这个窗口里显示的。 就是闪存里面存储的数据了。 也就是说闪存里面每个地址下到底存储了啥。 我们通过这个软件就能直接清晰的看到。 这个非常方便调试的对吧。 像之前W5K64的三重芯片。 芯片里面存了啥。 我们看不到。 这样我们就只能先写入再读取。 整个过程都没问题才算测试成功。 那一旦读取的数据和写入的不同。 其实我们也不清楚到底是写入错了。 还是读取错了对吧。 这对调试来说就不友好。 而我们本节有了这个软件辅助芯片里存了啥。 我们一目了然。 这样就可以单独设置读取。 擦除和编程验证程序功能也非常方便。 所以我们本节要充分利用好这个方面的软件。 看一下。 首先这个地方我们可以指定想要查看的。 起始地址。 目前是08000000。 又是整个闪存的起始地址。 所以下面的界面就从08000000开始的。 这里存的就是我们的程序代码之后。 第二个size就是从起始地址开始。 总共查看多少个字节。 目前0X10000就查看64KB的字节数。 0x10000。 为什么是64KB。 计算方法就是0X10000先转为十进制。 再除1024就是64KB。 这是基础的计算。 然后第三个框是数据宽度。 可以指定是以32位的形式显示。 还是以16位或八位的形式显示。 这个就分别对应的是字半字和字节。 现在是32位。 所以下面是32位。 四个字节在一个框里。 如果改成16位。 那个是16位。 两个字节。 一个框改成八位。 那是一个字节。 一个框。 就是显示模式也好理解吧。 然后还有一个更强大的功能是。 这个软件可以直接任意修改闪存的数据。 比如我看这个数据不爽。 可以先选中再单击一下。 这样就可以直接更改数据。 比如改成66enter。 这样这个数据就直接变成六六了。 当然目前我改的是程序文件啊。 正常的程序大家不要随便改。 要不然破坏了程序可能运行就会出问题。 那这里从效果上来看。 它可以任意更改数据啊。 但是也可以想到。 底层其实也是有线擦除再写入的过程。 这闪存的基本特性好。 这是这个读取闪存和写入闪存的操作。 通过这个软件不用写代码就能实现。 然后还有一个功能就是选项字节的东西。 打开target option batch。 这里就是选项字节配置界面。 读保护。 用户配置部分自定义的两个字节和谐保护。 这四个部分的配置。 也是在这里随便点就能配置的。 另外你看这里写保护。 点一下就四页同时打勾。 是不是对应选项字节里的一个位。 配置四个闪存页。 那配置完之后点apply。 这样选择字节就自动配置好了。 也不用写任何代码。 非常方便好。 就是这个软件闪存的读写。 选用字节的读写。 都可以在这里进行可视化的操作。 待会程序的功能实际上实现的就是这个效果。 测试的时候也可以在这里对照验证一下。 那然后我们看一下PPT。 梳理一下流程啊。 闪存的基础代码呢其实也不难。 首先闪存并不需要初始化。 直接操作即可。 然后第一个读取数据。 我们直接把这一句代码封装一下就完事了。 之后第二个擦除我们要使用这个步骤。 全擦除或者夜叉除。 这两个功能分别对应一个库函数都封装好了。 想要流程不用我们写。 当然要记得执行之前手动调用一下解锁。 执行之后一般要再加锁一下。 就第三个编程也是有对应的函数。 调用函数就行。 当然解锁和枷锁也不要忘了。 这是闪存的三个操作。 读取擦除和编程之后。 选项之间的差除。 和编程和主产权的擦除和编程类似。 也都对应的有函数。 当然选项自己的操作我们不做要求啊。 如果你有少量的需要。 那么这个软件配置不是更方便快捷吗。 而且用代码配置读写保护的话。 容易造成芯片自锁。 比如你把闪存给写保护了。 但程序里并没有预留解除写保护的代码。 这样锁住之后芯片就没法下载程序了。 这时靠芯片自己肯定是救不活芯片的。 但是我们还可以用这个软件来配置。 在这个选项字节的配置里。 把读写保护都去掉。 再apply就能救活芯片了。 所以如果你的芯片因读写保护而无法下载程序。 那就记得到这里来救他。 好。 流程清楚了。 我们再看一下库函数。 打开library。 本节用到的库是flash。 点C和flash点去打开flash点。 去看一下最下面这里就flash的所有函数了。 那我们观察到这里的函数被分为了三个部分。 第一部分注释写的是。 这些是所有F10X设备都可以使用的函数。 第二部分是所有设备都可以使用的新的函数。 最后第三部分是只有XL加大容量的设备。 才可以使用的新的函数。 并且第三部分的函数有个预编译。 只有定义了XL这个宏。 这些函数才是有效的。 首先说一下。 本节我们只需要使用上面第一部分的函数。 下面两部分都用不到。 那为什么要再加下面这两部分呢。 新的函数是什么意思呢。 这个在C文件的前面。 这里也有说明。 大家可以自己翻译看看。 简单来说就是因为在最开始的时候。 这个系列只有小容量LD重量。 MD和大容量LD之后加大中奖XL才推出。 XL直接又加了一块新的独立的闪存。 所以XL产品总共有两块闪存。 为了区分它们。 设计者命名。 新加的这一块叫做半壳二。 与之对应。 原来小中大容量的这一块叫做bk1。 所以我们就知道了。 Bk1。 bk2是加大容量产品才有的概念。 加大容量产品推出后。 这些函数又对XL系列进行了适配更新。 至于每个函数做出了哪些更改。 可以看这个表。 后面还新增了一些函数啊。 这函数里都带了半个一和bk2的指定。 是加大容量才会用到的好。 这就是这三部分函数的解释。 大家不要被这个bank所迷惑了。 然后我们依次来看一下函数。 首先前面三个函数。 这些是和内核运行代码有关的。 不用我们过多了解。 也不需要我们调用。 所以不用看。 最后下一个flash unlock。 显然是用来解锁的。 转到定义。 看一下是不是在K2计算器先写个K1。 再写个K2啊。 这是解锁流程。 对应PPT的这里对吧。 然后继续下一个flash lock加锁。 它是把CR计算器的lock位设置为一。 然后对应PPT这里的枷锁操作非常的直观。 接下来继续。 下面这里到这里。 就对主闪存和选项字节。 进行擦除和编程的函数了。 第一个flash与睿智配置闪存。 擦除某一页参数。 给一个页的起始地址。 函数执行完后。 指定的一页就被删除了。 返回值是这个操作的完成状态。 可以看到下面这些操作都有返回值来告知状态。 转到定义看一下。 这是一个枚举。 在执行完后会返回执行状态。 如果执行完全没问题。 则返回这个complete表示完成。 如果返回第一个表示芯片当前盲。 返回第二个表示编程错误。 返回第三个表示写保护错误。 返回第五个表示等待超时。 这是函数返回状态的功能。 如果你调用完成之后。 想看看这个操作到底有没有落实到位。 就可以接收一下这个返回值。 但如果你不想知道状态的话。 也可以不用管。 就是夜叉除可以转到定义。 看看内部。 首先XL的不看。 我们看L4D的。 可以看到第一步是等待码参数。 可以指定等待的超时时间。 最后这三步PR之1AR写入指定地址。 Start。 自一开始。 是不是就对应PPT这里夜叉数的这三步啊。 之后start开始后继续等待忙。 所以库函数这里是事前事后都有等待。 最保险的策略。 最后等待结束后。 他还把P2给清零了。 这是为了方便后续操作的执行。 这是夜叉除的过程。 然后继续下一个flash与raise or pages。 这个就是全擦除了。 看一下这里的操作。 第一步事前等待。 第二步MER之1start之一开始传查除。 第三步。 事后等待最后MER归位。 防止影响后续操作。 这是不是对应我们PPT这里这个全删除的流程啊。 这是全参数的函数。 然后下一个flash raise option bats。 这个是擦除选项。 自己看一下。 第一步事前等待。 第二步。 解除选项字节的小锁。 第三步自OPTER。 然后start开始。 第四步。 事后等待。 这是关键的步骤。 下面还有一段这个简单说一下。 下面的这段程序的目的。 是维持读保护的原始状态。 这个大概了解一下就行了。 之后继续看下面两个flash program word和program half word。 就分别是在指定地址写入字。 可写入半字了。 先看一下。 写了半字的菜儿都不干。 这里关键的步骤。 第一步事先等待。 第二步。 pg位置一。 第三步address强转为指针。 在指针取内容赋值为data。 由是在指定地址address下写入指定数据data。 第四步事后等待最后pg位恢复为零。 这边是不是就对应PPT这里这个编程的过程。 仅用这个写入半字的操作。 就上面这里的使用指针写入。 看是不是就和这里是一样的。 这是写入半字之后。 看写入全字呢。 这里可以看到它是写两字啊。 首先在address下写入data的低石流为。 然后address加二。 再写入data的高斯六维。 这个我们就清楚了。 之后继续下面四个就是选项字节的。 写入了选项字节的四个部分。 自定义的data0和data1。 写保护读保护用户选项的三个配置位。 就分别用这四个函数来写入。 这个了解一下函数内部。 感兴趣的话自己看看。 最后下面这三个读取的函数就是获取选项。 自己当前的状态。 获取用户选项的三个配置位。 获取斜保护状态。 获取读保护状态。 当然还有一个获取自定义的data0和data1。 这个没给函数使用指针访问就行了。 将下一个获取预取缓冲区状态。 这个是对应上面这个函数的。 不用了解。 最后it configure中断死人。 获取标志位和清除标志位。 最后两个是获取状态和等待上一次操作。 这个函数就是等待忙。 等待必得为零。 但是刚才我们看上面这些函数。 在执行耗时操作时。 这些函数内部就已经调用了等待王的函数了。 所以最后这个函数并不需要我们单独调用好。 这是闪存的库函数介绍。 接下来我们就可以开始写代码了。 首先在system目录下快速新建一个模块。 模块名叫my flash。 模块建好。 我们要实现最开始规划的三个功能。 就是读取擦除编程flash不需要初始化。 所以我们直接开始写读取的部分。 先来个读取32位的字。 返回值是读取的数据肯定是UINT32杠T了。 函数名叫my flash read word。 参数需要指定一个地址。 在STM32中。 所有的地址都是32位宽度的。 所以参数是UINT32杠t address。 在这里面我们只需要写一句代码就可以了。 看一下PPT。 我们把这个使用指针访问存储器的格式。 复制下来。 放到这里。 指定的地址我们就用形参的address来指定。 然后目前这个函数。 我们想以32位字的形式读取。 所以指针要强转为unit32杠T型。 前面这个IO转到定义啊。 可以看到是volatile。 上面还有O也是volatile。 I如果定义了C加加也是volatile。 否则是volatile const。 这些是为了严谨加的东西啊。 并且也可以表现出来变量的读写特性对吧。 你看看下面的计算器也都指定了IOO或者I。 当然在这里我们加不加都行啊。 那这样指定地址的内容。 就以32位的形式访问到了。 我们直接return就完事了。 之后我们再复制两份。 如果我们想以半指16位的形式读出来呢。 就来个read half wor。 形参的地址必须还是32位的。 访问时强转类型改成16位的指针。 返回值对应也改成16位。 这是读取半字。 最后一个我们先以字节八位的形式读取。 就是read bt。 强调为八位指针返回八位数据。 就是读取字节也挺简单吧。 但这个要求你对指针的操作非常熟悉啊。 要不然不好理解。 解释一个可能会有疑惑的点。 就这个地址必须都是32位的。 这个32位与指针的类型是32位。 16位还是八位无关。 因为地址是门牌号。 比如flash的起始地址08000000。 只有32位的变量才足够。 存得下这么大的门牌号。 好目前读取的功能我们就实现了。 接下来可以进行测试。 我们把这三个函数放在头文件声明。 编一下没问题。 接下来到主函数测试。 先include my flash。 点去。 最后直接OD修hax number。 一行一列直接显示my flash read word地址。 先给个0X08000000。 读取一下闪存的起始地址。 显示长度为八。 只复制两份。 分别在二行和三行试一下。 Read half wor。 长度为四和REBT长度为二。 我们都从08000000开始读。 看一下以不同形式读出来有什么区别。 那测试程序就是这样。 目前这个测试程序也非常有意思啊。 就是用程序把程序代码本身给读出来。 我读我自己是吧。 那编译下载这个注意一下。 使用完s t link这个软件。 要及时点这个按钮给断开连接。 要不然设备占用了QQ下载就会出错。 断开之后再下载看一下。 可以看到ORD第一行读取字。 显示20000660。 第二行读取半只显示0660。 第三行读取字节显示六零。 这个数据对不对呢。 我们就可以用这个软件来验证了。 先连接起始地址。 从08000000开始。 大小0X10000。 查看64K的全部内容。 数据宽度。 先看一下32位的。 可以看到这个软件清晰地显示了。 08000000起始地址下。 第一个32位的质数据是20000660。 是不是和OID显示的一样。 这说明字的读取没问题。 然后数据宽度设置16位。 这样就是半字读取的效果。 可以看到第一个08000000。 起始的第一个半径是0660URD。 第二行一致。 这个等八位自己的形式呢。 第一个是六零。 与ORD第三行一致。 同时我们发现这个数据是以小端模式存储的。 也就是低位字节存储在低位地址。 如果以字节读取。 第一个就是六零。 以半字读取前两个字节组合到一起。 由高位到低位是06601字。 读取前四个字节组合到一起。 由高位到低位是20000660。 这个是反着来的。 就是小端冲突。 那回到代码。 我们换个地址再测试一下。 比如08000010试一下看看。 当然这里先断开连接。 然后下载。 可以看到08000010起始的数据。 一致的方式读取是08000351。 按照字节存储的顺序就反过来。 51030008对吧。 大家这个软件验证一下连接。 可以看到08000010起始的数据。 按照自己的顺序是51030008。 没问题。 以16位读取就是03510800。 以32位读取就是08000351。 这个可以理解吧。 这是读取的功能。 我们就验证通过了。 接下来我们回到代码继续来写下一个功能擦除。 首先我们先实现一个全插图的功能。 所以来个word my flash。 Raise our pages。 word参数返回值都不需要。 在这里面。 我们要执行全擦除的过程。 第一步我们要对flash进行解锁。 所以调用这个unlock函数放到这里。 参数没有。 第二步我们就直接调库。 调用库里的erise our page放到这里。 参数没有。 这函数执行完后。 flash全删除就完成了。 之后第三步执行完后。 我们最好再给flash锁上。 所以第二用log函数放在这里拆除没有。 这样就完成了。 还是非常简单的吧。 得益于库函数的封装实施的具体流程。 比如自控制位置。 Start。 等待忙等等。 这些具体操作在这一个函数里已经写好了。 但这个函数里并不包含解锁和加锁。 所以解锁和加锁需要我们另外调用函数实现。 然后这个参数函数也有个返回值。 表示执行的状态。 如果你要严谨一些。 就可以判断一下范围值。 如果执行出错了。 可以进行一个提醒。 那这里我们就先不管返回值。 这是全擦除的流程。 然后我们再实现一下夜叉除。 来个word my flash raise page。 参数需要给定指定页的地址。 所以是new int32gt page address。 在这里面类似的。 第一步执行解锁。 第二步看一下。 我们调用配置这个函数放到这里。 参数是pg address液体值。 那么把这个pg address传过来之后。 第三步同样的加速。 这样夜叉主函数就完成了。 接下来我们进行测试。 把这两个函数放到头文件。 声明一下。 编译看看没问题。 然后到转速执行测试。 首先我们先把按键的功能拿过来。 按下按键再进行查处啊。 所以先按include k点去。 有你的八杠1K number。 k elite初始化。 key等于k get number。 获取件码之后。 if k number等于等于1K1按下。 那我们就执行my flash raise or pages。 把整个闪存都擦除。 再if k number等于等于2K2按下。 那我们就执行my flash EZ page页。 查询指定页地址。 给个0X0800000。 有时候把闪存的第一页。 前1K1024个字节擦掉。 好程序就这样测试一下看看。 下载看一下。 目前显示的是读取测试的数字。 按下复位键。 可以看到每次复位ORD都刷新了一次。 目前没什么问题。 接下来我们试一下。 按下K1我已经按下了哈。 好像没有任何反应。 但是我们再按复位键。 可以看到OID没有刷新了。 实际上刚才按下K1的时候。 整个闪存都已经拆除了。 程序文件已经不复存在了。 当前led显示的数值并没有消失。 是因为OID里面有显存。 可以保存最后一次显示的内容。 那么断电重新上电。 可以看到2D没有任何显示。 无论按什么按键都没有反应。 这是闪存全擦除的现象。 直线下全大图就相当于程序做了个自我了结。 现在整个芯片是空白的。 没有任何程序。 我们用这个软件验证一下。 看看连接。 可以看到闪存里面全都是FF是空白的。 就是穿插组的现象。 全擦除一般不要随便调用啊。 要不然整个程序都没有了。 还得重新下载程序。 但是如果你想设计一个安全保障措施。 在设备被拆时可以触发全大图。 这样程序肯定就不会被盗了。 像读保护是把程序放在保险箱里全擦除。 那就直接把程序销毁了。 销毁肯定比放保险箱还要安全对吧。 不过这个要根据你的使用场景来选择。 毕竟全叉之后程序是没法恢复的。 之后我们继续测试试下页参数。 先重新下载程序。 然后我们按下K2键擦除第一页。 插完了FA可以看到OID也不刷新。 因为程序的第一页没了。 现在程序是损坏的。 没法运行。 那用这个软件验证一下呢。 连接可以看到前面都是FF。 然后往后翻。 可以看到到第二页的时候。 数据还是存在的。 并且这个起始地址正好是第二页的起始地址。 08000400E地址的分布规律。 我们上学期研究过啊。 地址以000400800400结尾的。 都是夜骑士地址。 这里也看到08000400就是一一。 也是第二页的起始地址。 所以这里执行这个函数。 它只会把第一页擦掉。 其他页不受影响。 然后继续测试。 我们如果想让它插第二页呢。 就把这个地址改成0400。 这是擦除第二页。 试一下。 下载按下K2之后到这个软件看看。 可以看到第一页没有被擦。 往下翻。 0400开始的第二页被查出了之后。 继续。 0800开始。 第三页没有被查。 这是夜叉处的现象。 我们就玩明白了。 那回到程序。 我们继续完成下一个任务。 编程下两个函数。 Word my flash。 Program word。 写入一个字参数要有两个。 第一个指令我们要在哪里写。 是32位的地址。 第二个指令我们要写什么。 是32位的数据。 在这里面还是类似的过程。 第一步解锁。 第二步找一下函数。 复制program word放到这里。 参数一样。 我们分别把地址和数据传进去。 最后第三步再加锁就完成了。 其实可以看出这函数我们就是再包装一下。 并没有太多的操作。 因为库函数已经集成的很完善了。 那继续我们再来个编程半子word。 My flash program half wor。 参数。 第一个指定义32位的address删除。 第二个。 因为只需要写作半字。 所以指定16位的data即可在这里面。 第一步解锁。 第二步。 我们使用这个program half word放到这里。 参数把address和data传进去。 第三步枷锁。 这样就完事了。 但对于编程来说。 我们就只能写到这儿了。 只有写入字和写入半字的函数。 暂时就没有写入字节的了。 因为写入字节比较麻烦。 最好用缓冲区的方式来实现。 所以函数就没有写入字节的好。 那我们来测试一下。 把这两个函数放在头文件声明。 编一下。 接下来指定测试。 那我们在写入的时候。 尽量就不要再破坏程序本身了。 所以我们可以在闪存的最后一页写入测试数据。 这样不会影响程序。 来看一下PPT。 对于64K的闪存。 最后一页的起始地址就是0800FC00。 所以我们就在FC00的位置写一点测试数据。 看看在这里测试写之前一定要先执行擦除。 所以我们先调用夜叉除页地址。 指定最后一页0800。 FC00之后就可以写入了。 比如my flash program word。 写入32位的字。 在最后一页的起始地址FC00下。 随便写个32位数据。 比如0X12345678。 最后再来个my flash program harvard。 写入16位的半字地址。 往后加点。 在零X0800FC一零的位置。 随便写个16位数据。 比如0XABCD。 这样测试程序就写好了。 我们现在擦除最后一页。 然后在FC00写字。 在FC10写半字来试试看。 下载看一下。 打开这个软件连接。 往后滑。 找到0800FC00的位置。 可以看到FZ00的位置。 写了12345678。 FZ10的位置写了ABCD。 但现在是32位一个格子。 所以高位有四个负。 然后换个位置试看。 比如FC20写字。 FC30写半字再试试。 连接找一下。 可以看到FC20和FC30的写入没问题。 但也可以看到。 之前FC00和FZ10的数据没有了。 这是因为我们在写入新数据之前。 又执行了夜叉除。 所以原来的数据就丢失了。 那这就是写入数据的测试。 好支持flash的底层代码读取擦除编程。 我们就写完了。 接下来我们就来完成更上层的业务代码。 现在我想实现的功能是参数掉电不丢失的存储。 那基于这个my flash层。 我们就可以再来建立一个store模块。 所以在c storm右键快速新建一个storm模块。 那在十大模块。 我们要用SRAM缓存数组来管理flash的最后一页。 实现参数的任意读写和保存。 因为闪存每次都是擦除再写入。 擦除之后还容易丢失数据。 所以要想灵活管理数据。 还是得靠SRAM速度。 需要备份的时候。 我们再统一转到闪存里。 这才是一个比较好的方案。 所以在storm模块里。 我们先定义一个s RM数组。 数组类型可以定义为八位。 但为了方便我们还是跟闪存的半字统一下。 所以来个unit16杠t star data。 数组的数量可以给个512。 512个数据。 每个数据16位两字节。 正好对应闪存的一页1024字节。 然后这个代码继承于my flash。 所以不要忘了include一下my flash。 点进去之后。 我们来个初始化函数。 Void stelite void。 首先我们要把闪存初始化一下。 比如你第一次使用这个代码。 那闪存默认全是FF。 而参数和SRAM一般都默认零。 所以对于第一次使用。 我们要给闪存的各个参数都是零。 怎么判断是不是第一次使用的。 我们就定义一个标志位。 把三成最后一页的第一个半字当做标志位判断。 If my flash read half wor。 地址是零X0800FC零零。 读取第一个半字。 如果它不等于零。 XA5A五A5A5。 是自己随便规定的一个标志位。 如果第一个半字不是av5。 就说明是第一次使用。 这我们要干啥。 第一步先买flash energe。 Pg。 把最后一页给擦掉。 第二步。 My flash program havard。 在这个起始地址也是第一个半字的位置。 写入规定的标志位。 0XA为五。 第三步。 把剩余的存储空间全都置为默认值。 零来个for循环。 for your int16杠TI等于一。 A小于512A加加注意。 这里I要从一开始。 而不是零。 因为第一个半字是标志位。 剩下的才是有效数据。 在这里面。 My flash program half word。 剩下的每一个半字的地址是什么呢。 首先要从这个地址开始。 然后每个循环加上I。 因为一个半字占用两个地址。 所以I要乘二。 这是后续每个半字的起始地址。 写的半字。 我们给0X0000就是初始化闪存过程。 没初始化的时候。 闪存最后一页应该全是FF。 初始化之后。 删除最后一页的第一个半径是标志位A为五。 剩下的数据全是零。 那这就是十大一利特的第一大步。 第一次使用的时候对闪存进行初始化。 接着还有第二大步。 就上电的时候。 把闪存的数据全都转存到SRAM数组里。 转到数组里。 这个过程就上电的时候恢复数据。 实现数据掉电不丢失。 所以这里同样来个for循环复制一下这个方向。 YI要从零开始。 标志位也要转到数组里。 要不然后续备份数据的时候。 标志位就丢失了。 那在这里面我们调用my flash read half word。 地址。 依次是这个歧视地址加I乘二。 读出来之后。 我们就依次放到10store data的第二个位置。 这个第二部分就在上电的时候。 把闪存备份的数据恢复到S2数组里之后。 我们向存储掉电不丢失的参数的时候。 就先任意更改这个数组。 除了标志位的其他数据。 更改好之后。 我们把这个数组整体备份到闪存的最后一页。 所以下面我们来个函数。 Word star save word。 备份保存在这里面。 两个步骤。 第一步擦除最后一页。 也是这句代码。 第二步把数组完全备份。 保存到闪存。 同样哪个for循环。 但这次存储方向就变了。 My flash program half world。 每个数据的地址分别是起始地址加I乘二。 存储的内容是每个数组的数据。 这样就是把SRAM的所有内容。 备份到闪存的最后一页。 到这里我们这个模块实现的就差不多了。 画个图给大家再梳理一下。 比如这是闪存的最后一页。 直接对它进行读写的话。 那肯定不方便。 效率低。 还容易丢失数据。 所以我们在SRAM里定义一个数组。 它就是闪存的分身。 我们在读写任何数据。 就直接对SRAM操作。 这样就非常方便了。 但是SRAM掉电丢失。 所以我们需要闪存来配合SM。 每次更改的时候都把数组整体备份到闪存里。 而在商店的时候。 我们再把闪存里的数据初始化加载回到SRAM里。 这样SM数组是不是就相当于掉电不丢失了。 另外为了判断这个闪存是不是之前保存过数据。 我们还需要一个标志位来配合。 如果标注为4AV5。 就说明闪存已经保存过了。 我们上面就直接加载回备份的数据。 如果标注位不是A5A5。 就说明闪存是第一次使用。 我们就先初始化一下。 再加载数据。 就是这个参数保存整体的思路。 但这个思路是我自己想的啊。 并不是固定的。 如果你有别的可以说得通的思路。 那都可以实践试一下。 最后这个模块我们再加一个可变函数。 因为这个数组实现了掉电不丢失。 正常情况下不太方便把所有数据清零。 所以为了方便使用。 我们来个word star clear y。 在这里来个for循环。 注意二。 要从一开始不要把标志位清零了。 之后我们把数组的每一个用户数据都归零。 规定之后一定要记住调用save。 把这个更改更新到闪存里。 我们每次修改完数组后都要save一下。 保证数组和闪存数据一样。 如果你不save。 那下次商店加载的就是以前保存的数据了。 好到这里。 我们这个模块就写完了。 接下来进行测试。 现在头文件声明一下函数。 另外这个数组我们也直接声明为外部可调用。 加个X数组数量可以不写。 编一下没问题。 然后到主函数进行测试。 现在我们有了更上层的十大模块。 就不再需要直接操作闪存了。 所以我们可以直接把my flash点去改成十道点去。 下面有关闪存的操作全都删掉。 之后上天后先来个star it。 这个函数的作用是第一次使用的时候。 初始化闪存。 然后把闪存备份的数据加载回SM数组。 实现SM数组的掉电不丢失之后。 比如你有一些按键配置的参数。 在按键按下后就可以存储来存放的位置。 先放到store data里。 数组第零个是标志位。 千万不要使用啊。 我们放到数组第一个点。 比如放个0X1234。 然后再来个数组。 第二个放个0XABCD。 这样想怎么放参数都可以呀。 放完之后一定要记得来个star save。 把SRAM数据备份到闪存。 如果现在断电。 那数组内容丢失。 但闪存已经保存好了。 在下次上电的时候。 store就会读回掉电前保存的数据。 那现在我们测试一下。 看看下载看一下。 当然现在ORD还没有显示啊。 我们先看一下闪存里的内容是不是符合预期。 翻到最后一页。 可以看到第一个数据是A5A5标志位。 其他数据都初始化为零了。 那断开。 现在按下K1按键备份了两个数据对吧。 看一下闪存里有没有链接。 翻一下可以看到第一个半字A55。 第二个半字1234。 第三个半子ABCD完全符合预期。 这是没问题的。 接下来我们就可以实现最终程序的现象了。 首先OID显示两个字符串。 O id show string。 一行一列显示flag。 冒号。 复制一下。 二行一列显示data之后。 如果可以按一下。 我们就要保存参数数据。 这个数据可以根据你的实际需求来。 这里。 我就用自身来随便变换一下了。 比如D1加加DA2加等于二。 再来两个德三加等于三。 D4加等于四。 随便变换一下。 最后变化好之后。 C5保存。 这样就行了。 之后如果K2按下。 我们就把所有参数清零一下。 直接调用store clear就行了。 好最后我们用OLED显示一下所有数据。 OID修hex number。 一行六列显示star data。 零长度为四。 这个是显示标志位。 复制几份。 三行一列显示data1。 三行六列显示data2。 四行一列显示D3。 四行六列显示DA4。 那这样最终的测试程序就写好了。 下载试试看。 看一下id第一个显示标志位。 这个一直都是A5A5。 不要去改它。 剩下的现在已经显示了1234和ABCD。 这之前保存的对吧。 按下K2可以清零所有参数。 按下K1给变换测试数据之后。 我们断电再重新上电。 数据仍然保持原样。 按FA键数据也不会丢失。 这是最终程序的现象。 那回到程序这里。 这边还有几个问题可以说说。 首先程序可以提取一下参数。 比如这里的液体是地址出现了非常多次对吧。 如果你想换一页存储。 那就得改很多地方。 所以对于这种出现很多次有可能修改的数据。 那最好就用宏定义替换一下。 比如在这里我们定义define star start address。 是0X0800。 FC00之后的所有这个数据。 就可以用这个宏代替了。 这样在改参数的话就方便了。 然后这个数量也可以修改。 这里最大是512。 如果你没那么多参数。 也可以改小的十几20个都可以。 这样程序效率会高一些。 所以我们把这个数据也提取成红零一。 def star count为512。 下面所有的五百十二用这个宏来替换。 就是这个代码优化的部分。 宏定义大家也要学会使用啊。 一般大量出现的可配置参数。 或者为了强调某个数据的特殊意。 就可以用宏定义替换一下。 就这一点。 然后下一个问题就是目前来闪存。 前面一部分存储的是程序文件。 最后一页存储的是用户数据。 目前我们的假设是程序文件比较小。 最后一页肯定是没有用到的。 所以我们放心的使用最后一页。 但是如果程序比较大。 触及到了最后一页。 那程序和用户数据存储的位置就冲突了对吧。 或者说如果你参数非常多。 最后实验很大一部分都是留着存储用户数据的。 这样如果前面的程序文件长一些。 那样非常容易和用户数据冲突。 并且这种冲突如果没发现。 就会产生非常隐蔽的bug。 那如何解决这个问题呢。 这时我们可以给程序文件限定一个存储范围。 不让它分配到后面我们用户数据的空间来。 我们打开工程选项。 再下面就是编译器给各个数据分配的空间。 地址和范围了。 比如片上的ROM起始地址是08000000。 注意这个最高位的零省略了。 别看成8000开头的了。 这是0800开头。 然后它的size是0X10000。 默认全部的64K闪存。 都是程序代码分配的空间。 如果你想把闪存的尾部空间留着自己用。 那可以把这个程序空间的size改小点。 比如我们改成0XFC00。 这样编译后的代码。 无论如何也不会分配到最后一页了。 如果扇子过小。 那编译的时候也会报错。 所以如果你计划把闪存尾部的很多空间都留着。 自己用。 那就把这个程序代码的空间改小点。 以免冲突。 然后这个下载程序的提示地址也可以改。 比如你想写个BOOTLOADER程序放在闪存尾部。 那可以在这里修改下载到闪存的起始位置。 最右边这里是片上ram的起始地址和大小。 2000开始大小5000对应就是20K。 就是这个问题。 下一个问题是这里debug settings。 Flash download。 在这里是配置下载选项。 其中这个选项我们要选择第二个擦除扇区。 由是夜叉除。 第一个是每次下载代码都全擦除再下载。 第二个是用到多少页。 就差多少页。 这个下载速度更快一些。 如果你想在闪存尾部存储数据。 那也最好选择夜叉组的下载。 要不然每次下载程序芯片都全擦除了这个问题。 然后再下一个问题是。 我们想知道目前这个程序编译之后。 到底占用了多大的空间。 这个怎么看呢。 我们可以全部编一下。 在下面有一行信息就显示了program size。 程序大小。 其中有四个数。 这四个数分别是什么意思。 时间关系这里就不细说了。 感兴趣的话可以网上搜索。 这里大家只需要记住。 前三个数相加得到的就是程序占用闪存的大小。 后两个数相加得到的是占用SRAM的大小。 这个程序大小我们也可以在target1这里双击。 会打开一个点map文件。 这就是详细的编译信息。 感兴趣的话可以研究一下。 我们就看最后面这里也有写程序的大小。 并且有计算结果。 倒数第二行是占用SRAM的大小。 这里结果是2664之间。 2.6kb。 最后一行是占用闪存的大小。 这里是4576之间。 4.47kb。 那对不对呢。 我们可以验证一下。 目前闪存占用是4576之间。 记一下。 然后这个map文件看完就关掉。 要不然每次编译后都会弹出个窗口。 问你是不是要重新加载。 非常烦人。 那么下载到SM32里。 之后用这个软件验证一下。 这是程序文件。 一直往后翻。 可以看到程序在这个位置终止。 这个地方的地址是1110。 我们用计算器转换一下16进制。 压压一零对应十进制。 就是我们刚才看的4576。 我们观察的数据和编译结果相符。 没问题。 好到这里。 我们这个读写内部flash的程序和几点注意事项。 我就全部讲完了。 接下来我们来写第二个程序。 第二个程序非常简单啊。 回到工程文件夹。 复制一下OID的工程。 改个名字叫15杠二。 读取CPID。 打开工程。 直接删掉。 编译一下。 在这里我们知道这些数据的存储位置。 那非常简单的。 直接用这个指针读指定地址下的数据。 就可以获取id号了。 看一下手册二。 这里画出了各个存储器。 我们先读一下这个f size闪存存储器容量。 所以程序这里先显示一下字符串。 o i d show string1行一列显示f size冒号。 然后直接来个ord show。 HX蓝一行八列显示什么呢。 我复制一下PPT这里的读取格式。 这里要给这个数据的起始地址复制。 这个放到这里。 然后以多少V的形式读取了。 我们看到这个存储器就是16位的。 所以我们以16位的形式读出。 最后显示长度为四。 这样就行了。 我们测试看一下。 下载。 可以看到目前显示闪存容量为0040。 也是64K。 有的芯片容量可能会更大一些啊。 这个数可能会更大。 也就是正常的。 那回到程序继续来写。 接下来我们来显示这个UID。 在程序里先显示字符串。 在二行一列。 显示UID之后显示16进制读取的地址。 我们使用这个基地址对吧。 放到这里。 然后读取的形式。 这里写了可以字节半指或者全字读出。 想怎么读都可以。 那我看到这里计数器画的是16位啊。 所以就先16位读。 这第一个16位显示在二行六列。 然后复制继续在二行11列看一下。 第二个16位是基地址。 加上0X02的地址偏移。 这个也可以想到的。 所以第二次读地址是基地址加0X02。 这里注意一下这个地址有加减。 就一定得加括号在括号里进行了。 否则运算优先级会出问题。 这是第二个16位之后。 继续在三行一列下一个存储器。 地址偏移是0X04。 并且手册这里是32位画在一起的。 所以我们也就按32位读去吧。 但实际上并不一定要32位读八位。 16位也都可以。 这里就多演示几种方式啊。 作为示例。 那这里地址偏移是0X04。 我们以32位的方式读出。 显示长度是八。 最后再复制一下。 在四行一列看一下。 最后30位id号地址偏移。 40X08也以32位的方式读出版。 所以这里地址偏移给0X08以上。 车位形式突出。 那这样读取f size和UD的程序实际上就写完了。 就是指针读内容的一个实践对吧。 编译下载试一下。 可以看到下面显示的UID是这些数。 那id号到底对不对呢。 我们还可以用这个软件来验证连接。 查看的起始地址。 我们直接给UID的起始地址。 这里复制一下。 放到这里enter可以看到这些就是UID了。 当然要以小端模式来看。 第一个16位FF32对照一下没问题。 第二个16位066E没问题。 第三个32位34355234没问题。 第四个32位57133559没问题。 这说明我们的UID读取是没问题的。 然后可以看到这个ID2后面还有一些数据。 目前手册里我暂时没找到他们的描述。 可能是有别的作用啊。 这个我们就不用管了。 好那我们第二个程序到这里也就写完了。 本节课程到这里就全部结束了。